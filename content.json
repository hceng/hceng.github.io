[{"title":"Tiny4412——Android灯光系统","date":"2019-05-04T10:09:05.000Z","path":"2019/05/04/Tiny4412——Android灯光系统/","text":"继续学习Android驱动，Android灯光系统。 https://github.com/weidongshan/DRV_0001_LEDS/blob/v2/leds_4412.c hardware/libhardware/include/hardware/lights.h (未完待续) 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Android驱动","slug":"Android驱动","permalink":"http://yoursite.com/tags/Android驱动/"},{"name":"灯光系统","slug":"灯光系统","permalink":"http://yoursite.com/tags/灯光系统/"}]},{"title":"黑群晖","date":"2019-04-22T08:39:05.000Z","path":"2019/04/22/黑群晖/","text":"黑群晖折腾记录。最近，权游第八季上映，下载好的资源，如何在众多播放设备：IPad、小米盒子、Android手机以及多台电脑之间共享成了一个问题。想到之前折腾过树莓派做过NAS，实现过文件共享，但受制性能，导致实用性不高，这次准备弄个X86迷你主机折腾黑群晖。 出于实际需求和学习，运用所学知识开始折腾之旅。 1.硬件篇先说说黑群晖的概念，黑群晖就是在普通主机上运行Synology DSM系统，对应的白群晖就是使用官方提供的主机运行Synology DSM系统，因此售卖主机成了Synology的主要收入来源。Synology两个盘位的服务器主机价格在1000元以上，只从硬件成本角度看，价格太高了，但Synology还有系统、软件成本，这个价位也可以理解。Synology对待盗版的举措有点像微软，用盗版先培养用户使用习惯，等市场占有率提高，用户成长起来，体会到存储安全的重要性，了解群晖正版产品的便利性后，逐步转为白群晖。 1.1 硬件成本在淘宝逛了一圈黑群晖主机后，发现价格都普遍300左右，且体积都比较肥大。我的要求是：在性能基本够用的情况下，主机体积一定要小，最好双盘位，CPU要64位以便升级DSM 6.2，还要考虑功耗、散热、噪音等。 最后花费364.14元，其中主机220元、两个500G西数绿盘141.6元、20个1N5408二极管2.54元。 主机配置： CPU: Intel Celeron 1037U @ 双核 1.80GHz RAM: 2G DDR3 1600笔记本内存(单卡槽) ROM: 32G msata接口SSD 硬盘位: 可放两个3.5寸硬盘或2.5寸硬盘 网卡: 千兆网卡 USB: 4个USB 2.0 显示接口: VGA、HDMI 主板尺寸：17 X 17CM 机箱尺寸：20 X 22.5 X 6.5CM 电源：12V直流供电(配送12v/5A适配器) 功耗：20W(负载两个3.5寸硬盘) 拿到主机和硬盘后，就可以装机了，过程比较简单，插上两个硬盘，拧好固定螺丝： 1.2 改善噪音上电后，发现CPU上的散热风扇噪声有点大，整机温度不算高，因此使用二极管降低风扇的电压，从而降低转速减少噪音，这里串联了四个1N5408二极管： 修改后，噪声明显降低，已经比室内空调声音还小，几乎可以忽略不计，此时主机温度也可以接受。 2.系统篇2.1 装机思路先回顾一下普通的Windows/Linux电脑，如何U盘装系统。 - 正常启动：上电后，首先运行的是BIOS，在进行硬件自检后，会根据BOOT里设置的启动顺序（此时装有系统的硬盘在第一顺序），将硬盘里的系统加载到RAM，从而启动系统。- U盘重装：首先将U盘制作为启动盘（实质就是装一个精简版的Windows系统），然后插在电脑上，进入BIOS，在BOOT里将U盘设置为第一启动盘。重新上电后，仍然先运行BIOS，此时U盘作为第一启动盘，将U盘的精简系统加载到RAM里，进入该精简系统后，可以操作读写其它硬盘，此时再将完整的系统写入到硬盘里。最后拔掉U盘，将硬盘设置为第一启动盘。再来看看群辉的Synology DSM系统(实质是一个Linux系统)： 正常启动：上电后，首先运行的是BIOS，在进行硬件自检后，会根据BOOT里设置的启动顺序（此时装有引导系统的硬盘1在第一顺序），将硬盘1里的引导系统加载到RAM，运行引导系统，在加载硬盘2里的DSM系统（硬盘2、3都有DSM系统，优先使用第一个分区的DSM系统）。 U盘重装：首先将U盘制作为启动盘（实质就是装一个精简版的Windows系统），然后插在电脑上，进入BIOS，在BOOT里将U盘设置为第一启动盘。重新上电后，仍然先运行BIOS，此时U盘作为第一启动盘，将U盘的精简系统加载到RAM里，进入该精简系统后，可以操作读写任意硬盘，接着将引导系统写入到硬盘1里，然后拔掉U盘，将硬盘1设置为第一启动盘，进入系统盘的引导系统，再根据提示安装DSM系统到硬盘2、3里面。 上述重装DSM系统的方法是由装Windows类比过来的，对于黑群辉，还有一个更简便的方法，在Windows上使用win32diskimager等工具，直接将引导系统写到U盘上，将U盘设置为第一启动顺序，上电后直接进入引导系统，然后安装、启动DSM系统。但这样有个缺点，每次启动都需要插U盘进行引导。因为主机送了一个32G的SSD，于是把这个作为引导盘，使用U盘的PE将引导系统烧写到SSD上，这样每次启动就自动引导，不在需要额外U盘。 2.2 装机准备系统安装过程，需要准备： 一个VGA/HDMI接口的显示器 键盘、鼠标 可用网络、网线 一个做好PE的U盘 查看SSD的信息MPALL_V3.63或ChipEasy.exe 写IMG工具Roadkil’s Disk Image V1.6 引导系统synoboot.img DSM系统DSM_DS3617xs_23739.pat 将MPALL_V3.63、synoboot.img和Roadkil&#39;s Disk Image拷贝到U盘里。连接好显示器、键盘、鼠标，插上U盘，启动电源，跳按Delete(一般就F2、F10、Delete中某一个)进入BIOS。在BOOT选项卡里将U盘设置为第一启动顺序，保存，重启。 2.3 安装引导系统进入PE后，打开DiskGenius查看分区情况，可以看到四个盘：两个500G的机械硬盘，一个32G的固态硬盘，一个16G的U盘。 使用DiskGenius先将SSD格式化，再运行MPALL_V3.63，输入对应的盘符，记录下SSD的VID和PID： 在DiskGenius里选择硬盘-&gt;打开虚拟磁盘文件，选择synoboot.img，点击grub文件夹，选择grub.cfg，右键选择复制到&quot;桌面&quot;。 打开grub.cfg，找到：1234set vid=0x058fset pid=0x6387set sn=A8ODN02468set mac1=0011322CA603 set vid=0x058f 改为U盘的VID：0x13feset pid=0x6387 改为U盘的PID：0x5500set sn=A8ODN02468 序列号，用于洗白，现在不好洗白，不用修改set mac1=0011322CA603 MAC地址，用于洗白，现在不好洗白，不用修改 改完之后，在DiskGenius里，右键复制文件到当前分区，覆盖掉原来的grub.cfg，退出DiskGenius。 接着打开Roadkil&#39;s Disk Image，在映像写入选项卡里，选择要写入的SSD，再选中前面修改过的synoboot.img，点击开始，待写入完成后退出程序。 重启PE，进入BIOS，将SSD设置为第一启动顺序，拔掉U盘，再次重启。 2.4 安装DSM系统插上网线，SSD作为引导盘，启动后显示屏上显示：1Screen will stop updating shortly, please open http://find.synology.com to continue. 此时，使用在同一局域网的笔记本，浏览器打开http://find.synology.com搜索设备，或者安装SynologyAssistant搜索设备。搜出设备后，根据提示点击设置，上传DSM_DS3617xs_23739.pat安装，待安装完成后，自动重启即可。 重启后，进入系统初始化设置界面，根据提示进行设置，因为是黑群晖，没有洗白的缘故，不能使用QuickConnect，在该设置界面直接跳过即可。 3.必要设置3.1 配置存储空间刚装好的DSM系统，没有设置存储空间，需要自己根据硬盘情况组建存储空间。比如，我这有两个HDD，一个SSD，SSD作为引导盘，自然不能使用，两个HDD可以组建RAUD1。具体的操作步骤，当时没有截图，现在已经在使用中，又不好重新删除演示一遍，下次重装再补教程。网上也有很多教程，直接参考群晖无存储空间怎么设置。 3.2 内网穿透白群晖用户，可以登陆账户，使用Quickconnect功能，在外面通过Quickconnect就可以操作群晖，访问文件。黑群晖用户，不能登陆也就不能使用该功能，就算洗白后可以使用，占用群晖的服务器资源也不厚道，况且还有许多其它方法实现外网访问群晖。 之前嵌入式Linux网络编程——TCP/UDP里提到了使用端口号和网络地址的组合可以唯一的确定整个网络中的一个网络进程。 比如访问百度，可以直接在浏览器输入119.75.217.109:80访问。这里的119.75.217.109是百度的固定IP，80是http网页服务端口，用于普通网页浏览，该端口是默认端口，可不写。可以看到，如果我们有一个固定IP，便可直接通过固定IP访问到群晖，对于个人用户，拥有一个固定IP用于家庭网络，是一件不太现实的事情。目前个人用户都是从运营商那里购买宽带服务，运营商提供的大部分都是内网IP，即便申请到公网IP，也不是固定IP。 另外，我们不容易记住类似119.75.217.109的固定IP，一般都是在浏览器输入www.baidu.com，也可以打开百度。这里是运用了DNS(Domain Name System)，将域名自动解析成了相应的IP地址。 没有固定IP，要想通过外网访问黑群晖，也就是内网穿透，还有两个方法：动态域名和反向代理。 3.2.1 动态域名DDNS动态域名服务(Dynamic Domain Name Server)，简称DDNS。DDNS将用户的动态IP地址映射到一个固定的域名解析服务上，用户每次连接网络的时候客户端程序就会把该主机的动态IP地址传送给位于服务商主机上的服务器程序，而服务器程序负责提供DNS服务并实现动态域名解析。 通俗一点的解释：首先向宽带运营商申请公网IP，找个DDNS服务商(比如花生壳)，注册账号，添加内网IP、端口、访问域名等信息。打开群晖/路由器的DDNS服务客户端，选择同一DDNS服务商，输入账号，再设置端口转发等。内网设备，每次连接网络，群晖/路由器的DDNS客户端将本机的公网IP发送给DDNS服务器端。外网用户，输入域名+端口，DNS先解析域名找到DDNS服务商，DDNS服务器端找到对应公网IP，返回给用户，实现访问。就算以后设备的公网IP发生了变化，仍然可以访问内网设备。 优点：配置简单，成本低；缺点：需要公网IP，公网IP发生变化时可能半小时无法访问； 3.2.2 反向代理frp如果没有公网IP，就只能进行反向代理，反向代理的常见工具有ngrok和frp，其中frp简单一点，这里使用frp。frp的原理就是，利用有固定IP的VPS(Virtual Private Server)虚拟专用服务器做中转。在外网VPS上搭建服务端frps，在内网服务器上启动客户端frpc，以后访问外网VPS的某个端口，就可以反向代理转发到内网的对应端口上。 之前在搬瓦工上购买了一个VPS搭建SSR用于”科学上网”，理论上完全可以在上面搭建服务端frps，但因为是和朋友合购的，怕影响性能，就没在VPS上搭建，直接使用现成免费的VPS，以后有机会再补上VPS搭建服务端frps。 1.frp服务器首先找到一个免费frp服务器，比如在外网门里选择一个适合自己的服务器。 这个截图里有服务器的很多信息，后面慢慢会用到。 使用其提供的工具或者自己新建frpc.ini文件，生成文件内容如下：12345678910111213141516# frps信息[common]server_addr = aliyunsz2.waiwang.men #服务器地址server_port = 6666 #服务器端口token = waiwang.men #连接凭证protocol= tcp #协议类型# frpc信息[hceng.nas] #名字，同一类型的名字不能一样type = http #类型privilege_mode = true #开启特权模式local_ip = 192.168.123.123 #群晖本地IP地址local_port = 5000 #群晖控制界面端口号use_encryption = true #开启加密use_compression = true #开启压缩custom_domains = nas.hceng.cn #绑定的域名 然后将该文件上传到群晖，比如放在docker/frpc/里。 2.安装docker和frp客户端在群晖里打开“套件中心”，在“所有套件”中找到docker，点击“安装套件”。 安装完后，启动docker，在“注册表”选项卡的搜索框输入oldiy，找到oldiy/frpc，双击它弹出“选择标签”，这里选择0.24.1版本即可。 注意，随着frp版本的更新，出现了配置文件不兼容的情况，大致可以分为三个版本：0.93以前的版本、0.93-0.17.0版本、0.17.0-0.26.0版本。因为前面选择的frp服务器版本为0.20.0，这里选择0.17-0.26.0都行。 待其下载完后，切换到“映像”选项卡，双击oldiy/frpc:0.24.1，在弹出的“创建容器”窗口里，设置“容器名称”、勾选“使用高权限执行容器”，点击“高级设置”。 在弹出的“高级设置”窗口里，切换到“卷”选项卡，点击“添加文件”，选择前面新建的docker/frpc/frpc.ini，“装载路径”里填写/frp/frpc.ini。 这样设置后，docker里的frpc在启动时，执行/bash/sh -c /frpc -c /frp/frpc.ini，就使用的是前面编写的frpc.ini。 接着切换到“网络”选项卡，勾选“使用与 Docker Host 相同的网络”，再点击“应用”。 切换到“容器”选项卡，可以看到frpc已经启动了。 3.查看连接打开frp服务器的Dashboard监控界面aliyunsz2.waiwang.men:7777，输入账号、密码(监控端口，账号密码等信息都在前面frp服务器截图里面)，在Overview选项卡界面可以看到frp服务器信息，其中http端口是88。 切换到Proxies选项卡，选择HTTP，可以看到hceng.nas的状态是online，说明连接成功。 4.设置DNS最后还要域名解析，我们希望通过nas.hceng.cn的方式来访问，虽然在frpc.ini里设置了该域名，还需要找个DNS解析服务商，将nas.hceng.cn解析到aliyunsz2.waiwang.men。参考之前GitHub+Hexo博客搭建及优化——4.2绑定域名，在DNSPod里添加一条记录。主机记录：nas记录类型：CNAME线路类型：默认记录值：aliyunsz2.waiwang.men （frp服务器域名） 优点：相对稳定，无需公网IP；缺点：需要VPS搭建frps，配置相对复杂； 参考资料：DDNS简单教程How DDNS Works内网穿透：在公网访问你家的 NAS群晖 Docker版的frp客户端配置详解+免费服务器分享 4.扩展设置后面这些设置就不是必须的了，以后遇到什么有趣的，就记录下来，不断更新。 4.1 自动修改登陆壁纸实现每日抓取bing美图作为登陆界面壁纸，并替换欢迎信息为美图简介。 设置教程 脚本源码 效果： 4.2 将NAS入口添加到博客实现将群晖登陆接口添加到博客左下方图标位置。 1、使用FontCreator修改博客主题下的ttf文件。比如我使用的yilia主题ttf路径为：blog\\themes\\yilia\\source\\fonts\\iconfont.16acc2.ttf。 使用FontCreator打开iconfont.16acc2.ttf后，选择一个合适图标，或者修改一个没有图标，这里直接选择原来home图标作为nas图标。选中图标，右键选择“字形属性”，在弹出的窗口里，将名称home改为nas。 然后点击“文件”-&gt;“导出字体”-&gt;“导出TrueType/OpenType字体”，覆盖掉原来的iconfont.16acc2.ttf。 2、将iconfont.16acc2.ttf上传到网站fontke，勾选eot、woff、svg，点击“立即转换”，将生成的iconfont.16acc2.eot、iconfont.16acc2.svg和iconfont.16acc2.woff，覆盖掉原来的这几个文件。 3、打开blog\\themes\\yilia\\source\\main.0cf68a.css，搜索里面的home，全改为nas。改完后，找到a.nas{background:#6ea3ff;border:1px solid #6ea3ff}，可以修改图标背景颜色。 4、打开blog\\themes\\yilia\\_config.yml，在subnav下添加：1nas: &quot;http://nas.hceng.cn:88/&quot; 效果： 4.3 安装浏览器访问内网通过外网访问群晖里的浏览器，实现科学上网或访问内网路由器，并设置访问密码 之前有个需求：在不能使用SSR的特殊情况下，想科学上网访问Google，并且下载文件资料。家里的路由器搭了ShadowSocks，可以访问外网，只要能够访问家里的内网，就能科学上网。群辉的docker就像一个大宝盒，由它可以扩展出许多意想不到的功能，chrome也是通过它实现的。 1、安装chrome参考前面安装frpc的过程。打开docker，在“注册表”选项卡搜索框里输入oldiy，找到oldiy/chrome-novnc，并双击下载。下载完成后，在“映像”选项卡里双击oldiy/chrome-novnc:latest，在弹出的“创建容器”窗口里设置“容器名字”，再点击“高级设置”。在弹出的“编辑”窗口里，选择“常规设置”选项卡，勾选“创建桌面快捷方式”，选择“网页”，输入自定义域名或本地IP+端口号+vnc.html。因为想后面通过外网访问，所以这里填写自定义域名，frps提供的http端口为88。 接着切换到“卷”选项卡，因为要通过chrome下载文件，默认的下载路径在docker里的/root/Downloads，这里将其映射到本地文件路径，后面通过chrome下载的文件放在默认路径，就可以在群辉的public/download里找到。 再切换到“端口设置”选项卡，右边的容器端口5900和8083不要修改，左边的本地端口，根据自己需求，自行设置。需要考虑frps中是否被占用，设置的端口是否在开放范围以内。 最后点击“应用”即可。 2、设置frpc要想通过外网访问，还要配置frpc进行反向代理，因为chrome用到了两个端口，这里也需要配置两个，修改frpc.ini如下： 123456789101112131415161718192021# frps信息[common]server_addr = aliyunsz2.waiwang.men #服务器地址server_port = 6666 #服务器端口token = waiwang.men #连接凭证protocol= tcp #协议类型# frpc信息[hceng.web] #名字，同一类型的名字不能一样type = tcp #类型local_ip = 192.168.123.123 #群晖本地IP地址local_port = 12140 #chrome端口号remote_port = 12140 #反向代理后的端口号[hceng.web] #名字，同一类型的名字不能一样type = http #类型local_ip = 192.168.123.123 #群晖本地IP地址local_port = 12141 #chrome端口号use_encryption = true #开启加密use_compression = true #开启压缩custom_domains = web.hceng.cn #绑定的域名 修改完后，重新启动frpc。 3、设置DNS在DNSPod里添加一条记录。主机记录：web记录类型：CNAME线路类型：默认记录值：aliyunsz2.waiwang.men 此时，访问web.hceng.cn:88/vnc.html就可以访问chrome。但这样任何人都可以访问，导致一些安全隐患，因此还需设置密码。 4、设置密码在docker的“容器”选项卡里选中正在运行的chrome，点击上方“详情”，在弹出的窗口里切换到“终端”选项卡，点击“新增”，再点击刚才出现的bash，此时右边就会出现终端。 在终端输入:1x11vnc -storepasswd 然后输入密码，确认再输入一次，然后会有提示，问你是否保存到/root/.vnc/passwd，按y回车。接着还要改下启动命令，让x11启动时候加载密码文件。先安装vim以便后面修改文件，输入：1apt install -y vim 安装完成后，输入：1vim /etc/supervisor/conf.d/supervisord.conf 在第9行后面添加：1-rfbauth /root/.vnc/passwd 这里会用到vim编辑器的基本操作，自行百度。随后重启chrome容器即可。以后，通过群晖桌面的快捷方式或者输入web.hceng.cn:88/vnc.html就可以打开noVNC，再输入密码即可打开chrome。 建议把缩放模式改为“本地缩放”，这样就可以全屏显示chrome。 参考文章：在群晖里使用浏览器，通过Docker安装火狐/Chrome浏览器+Enpass，可以外网访问群晖所在内网路由等！给Docker镜像运行的chrome镜像添加访问密码 4.4 加快群晖自带下载器速度加快群晖自带Download Station下载种子的速度。 群辉自带的下载工具Download Station下载效果还是可以，如果遇到下载比较慢的任务，可以添加tracker服务器。打开trackerslist，选择trackers_best_ip.txt，复制里面所有的内容。 再打开Download Station，选中下载慢的种子，切换到“Tracker服务器”选项卡，点击“加入”，粘贴前面复制的内容，最后点击“确定”。 参考链接：自己添加tracker服务器，加快群晖下载速度 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Linux驱动、应用调试技巧","date":"2019-04-08T01:39:03.000Z","path":"2019/04/08/Linux驱动、应用调试技巧/","text":"记录几个Linux驱动、应用调试技巧。 1.printkprintk都比较熟悉了，在日常中用得最多的一个。 示例：1printk(KERN_DEBUG \"Passed %s %d \\n\",__FUNCTION__,__LINE__); 其中KERN_DEBUG表示log的级别，参考kern_levels.h:12345678#define KERN_EMERG KERN_SOH \"0\" /* system is unusable 紧急事件，一般是系统崩溃之前的提示消息 */#define KERN_ALERT KERN_SOH \"1\" /* action must be taken immediately 必须立即采取行动 */#define KERN_CRIT KERN_SOH \"2\" /* critical conditions 临界状态，通常涉及严重的硬件或者软件操作失败 */#define KERN_ERR KERN_SOH \"3\" /* error conditions 报告错误状态，经常用来报告硬件错误 */#define KERN_WARNING KERN_SOH \"4\" /* warning conditions 对可能出现问题的情况进行警告，通常不会对系统造成严重问题 */#define KERN_NOTICE KERN_SOH \"5\" /* normal but significant condition 有必要的提示，通常用于安全相关的状况汇报 */#define KERN_INFO KERN_SOH \"6\" /* informational 提示信息，驱动程序常用来打印硬件信息 */#define KERN_DEBUG KERN_SOH \"7\" /* debug-level messages 用于调试信息 */ 一个有8个等级，从0到7，优先级依次降低。通常通过修改/proc/sys/kernel/printk来设置printk打印。1234567cat /proc/sys/kernel/printk7 4 1 7echo 8 &gt; /proc/sys/kernel/printkcat /proc/sys/kernel/printk8 4 1 7 4个值的含义依次如下：console_loglevel：当前console的log级别，只有更高优先级的log才被允许打印到console；default_message_loglevel：当不指定log级别时，printk默认使用的log级别；minimum_console_loglevel：console能设定的最高log级别；default_console_loglevel：默认的console的log级别。 另外，关于printk格式化字符串形式，参考printk-formats.txt。 使用dmesg命令，可以显示之前所有的打印信息，常配合grep来查找历史纪录。 2.dump_stack在分析驱动源码的调用关系时，常遇到分支结构、回调函数，往往要多次添加打印来追溯调用过程。这时，可以使用内核提供的dump_stack();函数来一次性打印调用过程，将该函数加在要调试位置，当运行到该函数时，就会打印出之前的调用关系。 加入dump_stack：123456static int spidevx_drv_init(void)&#123; …… dump_stack(); ……&#125; 效果：1234567891011121314151617181920# insmod spidev.koCPU: 0 PID: 198 Comm: insmod Tainted: G O 4.1.18-g4b7863b4-dirty #32Hardware name: Generic AM33XX (Flattened Device Tree)Backtrace:[&lt;c0012b48&gt;] (dump_backtrace) from [&lt;c0012d68&gt;] (show_stack+0x18/0x1c) r7:ddfb6100 r6:c0910960 r5:bf0012cc r4:c0910960[&lt;c0012d50&gt;] (show_stack) from [&lt;c06833d8&gt;] (dump_stack+0x20/0x28)[&lt;c06833b8&gt;] (dump_stack) from [&lt;bf000fd4&gt;] (spidevx_drv_init+0x18/0xe8 [spidev])[&lt;bf000fbc&gt;] (spidevx_drv_init [spidev]) from [&lt;c0009694&gt;] (do_one_initcall+0x88/0x1e0) r5:bf000fbc r4:c0910960[&lt;c000960c&gt;] (do_one_initcall) from [&lt;c068142c&gt;] (do_init_module+0x60/0x1b0) r10:bf001488 r9:00000001 r8:dddd5f40 r7:bf0014d0 r6:ddfb6040 r5:00000001 r4:bf001488[&lt;c06813cc&gt;] (do_init_module) from [&lt;c008f634&gt;] (load_module+0x1bec/0x1e54) r6:dddd5f48 r5:00000001 r4:ddcc3f48[&lt;c008da48&gt;] (load_module) from [&lt;c008fa74&gt;] (SyS_finit_module+0x84/0x98) r10:00000000 r9:ddcc2000 r8:c000f9c4 r7:0000017b r6:0002541e r5:00000003 r4:00000000[&lt;c008f9f0&gt;] (SyS_finit_module) from [&lt;c000f820&gt;] (ret_fast_syscall+0x0/0x3c) r6:00038d08 r5:00000000 r4:00000000 可以看到调用关系为：ret_fast_syscall-&gt;SyS_finit_module-&gt;load_module-&gt;do_init_module-&gt;do_one_initcall-&gt;spidevx_drv_init。 3.stracestrace是个功能强大的Linux调试分析诊断工具，可用于跟踪程序执行时进程系统调用(system call)和所接收的信号，尤其是针对源码不可读或源码无法再编译的程序。在Linux系统中，用户程序运行在一个沙箱(sandbox)里，用户进程不能直接访问计算机硬件设备。当进程需要访问硬件设备(如读取磁盘文件或接收网络数据等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可跟踪进程产生的系统调用，包括参数、返回值和执行所消耗的时间。strace常用参数：123456strace: -p &lt;pid&gt;: 跟踪一个PID进程 -f: 继续子进程的跟踪 -T: 打印出每次调用所花费的时间，单位：秒 -c: 统计和报告每个系统调用所执行的时间、调用次数和出错次数等 -o &lt;outfile&gt;: 指定保存strace输出信息的文件 示例，执行：1strace -o log.txt date 查看log.txt：12345678910……open(\"/etc/localtime\", O_RDONLY|O_CLOEXEC) = 3fstat64(3, &#123;st_mode=S_IFREG|0644, st_size=127, ...&#125;) = 0fstat64(3, &#123;st_mode=S_IFREG|0644, st_size=127, ...&#125;) = 0 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb6f9f000read(3, \"TZif2\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\1\\0\\0\\0\\1\\0\\0\\0\\0\"..., 1024) = 127_llseek(3, -6, [121], SEEK_CUR) = 0read(3, \"\\nUTC0\\n\", 1024) = 6close(3) = 0……可以清楚的看到date先打开/etc/localtime，得到文件描述符为3，再去read文件，最后close文件。 4.应用层读写寄存器在判断某个硬件是否按期望正常工作，最简单粗暴的就是直接读取对应寄存器值来分析。Linux内核提供了一个/dev/mem节点来访问硬件寄存器，可以通过devmem或devmem2等应用程序来读写寄存器。一些嵌入式的BusyBox包含了devmem，一些发行版的Linux，可以通过sudo apt install devmem2等方式安装，或者手动编译源码： [devmem2.c]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/* * http://sources.buildroot.net/devmem2.c * * devmem2.c: Simple program to read/write from/to any location in memory. * * Copyright (C) 2000, Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl) * * * This software has been developed for the LART computing board * (http://www.lart.tudelft.nl/). The development has been sponsored by * the Mobile MultiMedia Communications (http://www.mmc.tudelft.nl/) * and Ubiquitous Communications (http://www.ubicom.tudelft.nl/) * projects. * * The author can be reached at: * * Jan-Derk Bakker * Information and Communication Theory Group * Faculty of Information Technology and Systems * Delft University of Technology * P.O. Box 5031 * 2600 GA Delft * The Netherlands * * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA * */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;fcntl.h&gt;#include &lt;ctype.h&gt;#include &lt;termios.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/mman.h&gt; #define FATAL do &#123; fprintf(stderr, \"Error at line %d, file %s (%d) [%s]\\n\", \\ __LINE__, __FILE__, errno, strerror(errno)); exit(1); &#125; while(0) #define MAP_SIZE 4096UL#define MAP_MASK (MAP_SIZE - 1)int main(int argc, char **argv) &#123; int fd; void *map_base, *virt_addr; unsigned long read_result, writeval; long int target; int access_type = 'w'; /* usage: ./devmem &#123; address &#125; [ type [ data ] ] */ if(argc &lt; 2) &#123; fprintf(stderr, \"\\nUsage:\\t%s &#123; address &#125; [ type [ data ] ]\\n\" \"\\taddress : memory address to act upon\\n\" \"\\ttype : access operation type : [b]yte, [h]alfword, [w]ord\\n\" \"\\tdata : data to be written\\n\\n\", argv[0]); exit(1); &#125; target = strtoul(argv[1], 0, 0); if(argc &gt; 2) access_type = tolower(argv[2][0]); if((fd = open(\"/dev/mem\", O_RDWR | O_SYNC)) == -1) FATAL; printf(\"/dev/mem opened.\\n\"); fflush(stdout); /* Map one page */ map_base = mmap(0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, target &amp; ~MAP_MASK); if(map_base == (void *) -1) FATAL; printf(\"Memory mapped at address %p.\\n\", map_base); fflush(stdout); virt_addr = map_base + (target &amp; MAP_MASK); switch(access_type) &#123; case 'b': read_result = *((unsigned char *) virt_addr); break; case 'h': read_result = *((unsigned short *) virt_addr); break; case 'w': read_result = *((unsigned long *) virt_addr); break; default: fprintf(stderr, \"Illegal data type '%c'.\\n\", access_type); exit(2); &#125; printf(\"Value at address 0x%X (%p): 0x%X\\n\", target, virt_addr, read_result); fflush(stdout); if(argc &gt; 3) &#123; writeval = strtoul(argv[3], 0, 0); switch(access_type) &#123; case 'b': *((unsigned char *) virt_addr) = writeval; read_result = *((unsigned char *) virt_addr); break; case 'h': *((unsigned short *) virt_addr) = writeval; read_result = *((unsigned short *) virt_addr); break; case 'w': *((unsigned long *) virt_addr) = writeval; read_result = *((unsigned long *) virt_addr); break; &#125; printf(\"Written 0x%X; readback 0x%X\\n\", writeval, read_result); fflush(stdout); &#125; if(munmap(map_base, MAP_SIZE) == -1) FATAL; close(fd); return 0;&#125; 以操作一个LED为例，GPIO1_18的寄存器基地址为0x4804C000，数据输出寄存器偏移为0x13C。 值得注意的是，这里使用的是AM335X，测试中发现不能直接操作数据输出寄存器，需要先操作GPIO控制寄存器，这里先通过GPIO子系统完成GPIO寄存器前期工作，也许换个SOC不会出现该情况，可以直接操作任意寄存器：1234echo 50 &gt; /sys/class/gpio/exportecho out &gt; /sys/class/gpio/gpio50/directioncat /sys/class/gpio/gpio50/value0 可以看到，现在数据输出寄存器0x4804C13C的值为0，使用devmem2查看：1234./devmem2 0x4804c13c w/dev/mem opened.Memory mapped at address 0xb6f86000.Value at address 0x4804C13C (0xb6f8613c): 0x0 读取到的值和前面使用GPIO子系统的结果一致。 继续写操作测试：12345678./devmem2 0x4804c13c w 0x40000/dev/mem opened.Memory mapped at address 0xb6fcc000.Value at address 0x4804C13C (0xb6fcc13c): 0x0Written 0x40000; readback 0x40000cat /sys/class/gpio/gpio50/value1 使用devmem2操作寄存器，使用GPIO子系统查看发现确实被改变了。 使用devmem2还存在几个问题：一是需要保证/dev/mem节点存在；二是不能同时读取多个寄存器值；三是必须依赖应用程序，不能直接echo或cat读写寄存器； 因此，编写一个新的驱动和应用程序，独立的实现读写寄存器的功能，以解决前面可能出现的情况。 驱动程序如下:[ker_rw.c]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;asm/io.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/types.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/ioport.h&gt;#define MAX_LEN 1000#define REG_IOC_MAGIC 'r'#define REG_IOC_R8 _IOWR(REG_IOC_MAGIC, 0, void *)#define REG_IOC_R16 _IOWR(REG_IOC_MAGIC, 1, void *)#define REG_IOC_R32 _IOWR(REG_IOC_MAGIC, 2, void *)#define REG_IOC_W8 _IOWR(REG_IOC_MAGIC, 3, void *)#define REG_IOC_W16 _IOWR(REG_IOC_MAGIC, 4, void *)#define REG_IOC_W32 _IOWR(REG_IOC_MAGIC, 5, void *)#define REG_ATTR(_name, _mode, _show, _store, _index) \\ &#123; .dev_attr = __ATTR(_name, _mode, _show, _store), \\ .index = _index &#125;static int reg_major;static struct cdev reg_cdev;static struct class *reg_class;struct device* reg_device = NULL;struct ker_rw_msg &#123; unsigned int val; unsigned int addr; unsigned int width; unsigned int num; struct mutex lock; &#125;; static struct ker_rw_msg rw_msg;struct reg_device_attribute&#123; struct device_attribute dev_attr; int index;&#125;;static ssize_t reg_num_show(struct device *dev, struct device_attribute *devattr, char *buf)&#123; return sprintf(buf, \"%u\\n\", rw_msg.num);&#125;static ssize_t reg_num_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)&#123; unsigned int num; num = simple_strtoul(buf, NULL, 10); if ((num &gt; MAX_LEN) || (num == 0)) printk(KERN_ERR \"%s: num range is 0~%d\\n\",__FUNCTION__, MAX_LEN); else rw_msg.num = num; return count;&#125;static ssize_t reg_width_show(struct device *dev, struct device_attribute *devattr, char *buf)&#123; return sprintf(buf, \"%u\\n\", rw_msg.width);&#125;static ssize_t reg_width_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)&#123; unsigned int width = 0; width = simple_strtoul(buf, NULL, 10); if ((width != 8) &amp;&amp; (width != 16) &amp;&amp; (width != 32)) printk(KERN_WARNING \"Address width can only be 8 or 16 or 32.\\n\"); else rw_msg.width = width; return count;&#125;static ssize_t reg_addr_show(struct device *dev, struct device_attribute *devattr, char *buf)&#123; return sprintf(buf, \"0x%08x\\n\", rw_msg.addr);&#125;static ssize_t reg_addr_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)&#123; rw_msg.addr = simple_strtoul(buf, NULL, 16); return count;&#125;static ssize_t reg_val_show(struct device *dev, struct device_attribute *devattr, char *buf)&#123; int i; void __iomem *virtbase; unsigned int addr; unsigned int phy_addr[rw_msg.num]; unsigned int vir_addr[rw_msg.num]; unsigned int val[rw_msg.num]; volatile unsigned char *p8; volatile unsigned short *p16; volatile unsigned int *p32; //if (!request_mem_region(rw_msg.addr, 4, \"ker_rw\")) //return -EBUSY; mutex_lock(&amp;rw_msg.lock); addr = rw_msg.addr; virtbase = ioremap(addr, 4); if (virtbase == NULL) return -ENOMEM; p8 = (volatile unsigned char *)virtbase; p16 = (volatile unsigned short *)virtbase; p32 = (volatile unsigned int *)virtbase; for (i=0; i&lt;rw_msg.num; i++) &#123; if (rw_msg.width == 8) &#123; phy_addr[i] = addr; vir_addr[i] = (volatile unsigned int)p8; val[i] = readb(p8); //val[i] = *p8; p8++; addr = addr + 1; &#125; else if (rw_msg.width == 16) &#123; phy_addr[i] = addr; vir_addr[i] = (volatile unsigned int)p16; val[i] = readw(p16); //val[i] = *p16; p16++; addr = addr + 2; &#125; else if (rw_msg.width == 32) &#123; phy_addr[i] = addr; vir_addr[i] = (volatile unsigned int)p32; val[i] = readl(p32); //val[i] = *p32; p32++; addr = addr + 4; &#125; else printk(KERN_WARNING \"Please check the address width.\\n\"); sprintf(buf + strlen(buf), \"phy_addr:0x%08x vir_addr:0x%08x val:0x%08x\\n\", phy_addr[i], vir_addr[i], val[i]); &#125; iounmap(virtbase); mutex_unlock(&amp;rw_msg.lock); return strlen(buf);&#125;static ssize_t reg_val_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)&#123; void __iomem *virtbase; mutex_lock(&amp;rw_msg.lock); rw_msg.val = simple_strtoul(buf, NULL, 16); virtbase = ioremap(rw_msg.addr, 4); if (virtbase == NULL) return -ENOMEM; if (rw_msg.width == 8) writeb(rw_msg.val, virtbase); else if (rw_msg.width == 16) writew(rw_msg.val, virtbase); else if (rw_msg.width == 32) writel(rw_msg.val, virtbase); else printk(KERN_WARNING \"Please check the address width.\\n\"); iounmap(virtbase); mutex_unlock(&amp;rw_msg.lock); return count;&#125;static struct reg_device_attribute reg_attribute[] = &#123; REG_ATTR(val, S_IRUGO | S_IWUSR, reg_val_show, reg_val_store, 1), REG_ATTR(addr, S_IRUGO | S_IWUSR, reg_addr_show, reg_addr_store, 2), REG_ATTR(width, S_IRUGO | S_IWUSR, reg_width_show, reg_width_store, 3), REG_ATTR(num, S_IRUGO | S_IWUSR, reg_num_show, reg_num_store, 4),&#125;;static long ker_rw_ioctl(struct file *file, unsigned int cmd, unsigned long arg)&#123; volatile unsigned char *p8; volatile unsigned short *p16; volatile unsigned int *p32; unsigned int val; unsigned int addr; unsigned int buf[2]; mutex_lock(&amp;rw_msg.lock); if (copy_from_user(buf, (const void __user *)arg, 8)) printk(KERN_ERR \"%s: copy_from_user error in the %d \\n\",__FUNCTION__,__LINE__); addr = buf[0]; val = buf[1]; p8 = (volatile unsigned char *)ioremap(addr, 4); if (p8 == NULL) return -ENOMEM; p16 = (volatile unsigned short *)p8; p32 = (volatile unsigned int *)p8; switch (cmd) &#123; case REG_IOC_R8: &#123; val = *p8; if (copy_to_user((void __user *)(arg+4), &amp;val, 4)) &#123; printk(KERN_ERR \"%s: copy_to_user error in the %d \\n\",__FUNCTION__,__LINE__); return -EINVAL; &#125; break; &#125; case REG_IOC_R16: &#123; val = *p16; if (copy_to_user((void __user *)(arg+4), &amp;val, 4)) &#123; printk(KERN_ERR \"%s: copy_to_user error in the %d \\n\",__FUNCTION__,__LINE__); return -EINVAL; &#125; break; &#125; case REG_IOC_R32: &#123; val = *p32; if (copy_to_user((void __user *)(arg+4), &amp;val, 4)) &#123; printk(KERN_ERR \"%s: copy_to_user error in the %d \\n\",__FUNCTION__,__LINE__); return -EINVAL; &#125; break; &#125; case REG_IOC_W8: &#123; *p8 = val; break; &#125; case REG_IOC_W16: &#123; *p16 = val; break; &#125; case REG_IOC_W32: &#123; *p32 = val; break; &#125; &#125; iounmap(p8); mutex_unlock(&amp;rw_msg.lock); return 0;&#125;static struct file_operations ker_rw_ops = &#123; .owner = THIS_MODULE, .unlocked_ioctl = ker_rw_ioctl,&#125;;static int ker_rw_init(void)&#123; int i = 0; int ret = 0; dev_t reg_devid = 0; mutex_init(&amp;rw_msg.lock); mutex_lock(&amp;rw_msg.lock); if(alloc_chrdev_region(&amp;reg_devid, 0, 1, \"ker_rw\") &lt; 0) &#123; printk(KERN_ERR \"%s: alloc_chrdev_region error in the %d \\n\",__FUNCTION__,__LINE__); return -EINVAL; &#125; reg_major = MAJOR(reg_devid); cdev_init(&amp;reg_cdev, &amp;ker_rw_ops); ret = cdev_add(&amp;reg_cdev, reg_devid, 1); if (ret &lt; 0) &#123; printk(KERN_ALERT \"%s: cdev_add error in the %d \\n\",__FUNCTION__,__LINE__); goto error1; &#125; reg_class = class_create(THIS_MODULE, \"ker_rw\"); if (IS_ERR(reg_class)) &#123; printk(KERN_ALERT \"%s: device_create error in the %d \\n\",__FUNCTION__,__LINE__); goto error2; &#125; reg_device = device_create(reg_class, NULL, MKDEV(reg_major, 0), NULL, \"ker_rw\"); if (IS_ERR(reg_device)) &#123; printk(KERN_ALERT \"%s: device_create error in the %d \\n\",__FUNCTION__,__LINE__); goto error3; &#125; for (i=0; i&lt;4; i++) &#123; ret = device_create_file(reg_device, &amp;reg_attribute[i].dev_attr); if (ret) &#123; printk(KERN_ALERT \"%s: device_create_file error in the %d \\n\",__FUNCTION__,__LINE__); goto error4; &#125; &#125; //Defaults rw_msg.num = 1; rw_msg.width = 32; mutex_unlock(&amp;rw_msg.lock); return 0; error4: device_destroy(reg_class, MKDEV(reg_major, 0));error3: class_destroy(reg_class);error2: cdev_del(&amp;reg_cdev);error1: unregister_chrdev_region(MKDEV(reg_major, 0), 1); mutex_unlock(&amp;rw_msg.lock); return -EINVAL;&#125;static void ker_rw_exit(void)&#123; int i; mutex_lock(&amp;rw_msg.lock); for (i=0; i&lt;4; i++) device_remove_file(reg_device, &amp;reg_attribute[i].dev_attr); device_destroy(reg_class, MKDEV(reg_major, 0)); class_destroy(reg_class); unregister_chrdev_region(MKDEV(reg_major, 0), 1); cdev_del(&amp;reg_cdev); mutex_unlock(&amp;rw_msg.lock);&#125;module_init(ker_rw_init);module_exit(ker_rw_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"Read and write register.\");MODULE_VERSION(\"v1.0\"); 该驱动程序向用户层提供了两个接口：sysfs文件系统接口和devfs文件系统接口。对于sysfs文件系统接口，加载驱动后，会在/sys/class/ker_rw/ker_rw/生成如下节点：12addr num subsystem valdev power uevent width 其中，num用于设置一次读取的寄存器数量，范围为1~MAX_LEN(1000)；witdh用于设置每次读/写寄存器的宽度，支持8、16、32；addr用于设置每次读/写寄存器的地址(16进制)；val用于设置每次读/写寄存器的值(16进制)； 因此，查看操作前面的GPIO可执行：12345678910111213141516# echo 0x4804c13c &gt; addr# cat valphy_addr:0x4804c13c vir_addr:0xfa04c13c val:0x00000000# echo 0x40000 &gt; val# cat valphy_addr:0x4804c13c vir_addr:0xfa04c13c val:0x00040000# echo 4 &gt; num# cat valphy_addr:0x4804c13c vir_addr:0xfa04c13c val:0x00040000phy_addr:0x4804c140 vir_addr:0xfa04c140 val:0x00000000phy_addr:0x4804c144 vir_addr:0xfa04c144 val:0x00000000phy_addr:0x4804c148 vir_addr:0xfa04c148 val:0x00000000 这里仍然保留了传统的devfs文件系统接口，需要编写应用程序访问： [app_rw.c]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/ioctl.h&gt;#define REG_IOC_MAGIC 'r'#define REG_IOC_R8 _IOWR(REG_IOC_MAGIC, 0, void *)#define REG_IOC_R16 _IOWR(REG_IOC_MAGIC, 1, void *)#define REG_IOC_R32 _IOWR(REG_IOC_MAGIC, 2, void *)#define REG_IOC_W8 _IOWR(REG_IOC_MAGIC, 3, void *)#define REG_IOC_W16 _IOWR(REG_IOC_MAGIC, 4, void *)#define REG_IOC_W32 _IOWR(REG_IOC_MAGIC, 5, void *)/* Usage: * ./regeditor r8 addr [num] * ./regeditor r16 addr [num] * ./regeditor r32 addr [num] * * ./regeditor w8 addr val * ./regeditor w16 addr val * ./regeditor w32 addr val */void print_usage(char *file)&#123; printf(\"Usage:\\n\"); printf(\"%s &lt;r8 | r16 | r32&gt; &lt;phy addr&gt; [num]\\n\", file); printf(\"%s &lt;w8 | w16 | w32&gt; &lt;phy addr&gt; &lt;val&gt;\\n\", file);&#125;int main(int argc, char **argv)&#123; int fd; unsigned int buf[2]; unsigned int i; unsigned int num; int ret; if ((argc != 3) &amp;&amp; (argc != 4)) &#123; print_usage(argv[0]); return -1; &#125; fd = open(\"/dev/ker_rw\", O_RDWR); if (fd &lt; 0) &#123; printf(\"can't open /dev/ker_rw\\n\"); return -2; &#125; /* addr */ buf[0] = strtoul(argv[2], NULL, 0); if (argc == 4) &#123; buf[1] = strtoul(argv[3], NULL, 0); num = buf[1]; &#125; else &#123; num = 1; &#125; if (strcmp(argv[1], \"r8\") == 0) &#123; for ( i = 0; i &lt; num; i++) &#123; ioctl(fd, REG_IOC_R8, buf); /* val = buf[1] */ printf(\"%02d. [%08x] = %02x\\n\", i, buf[0], (unsigned char)buf[1]); buf[0] += 1; &#125; &#125; else if (strcmp(argv[1], \"r16\") == 0) &#123; for ( i = 0; i &lt; num; i++) &#123; ioctl(fd, REG_IOC_R16, buf); /* val = buf[1] */ printf(\"%02d. [%08x] = %04x\\n\", i, buf[0], (unsigned short)buf[1]); buf[0] += 2; &#125; &#125; else if (strcmp(argv[1], \"r32\") == 0) &#123; for ( i = 0; i &lt; num; i++) &#123; ret = ioctl(fd, REG_IOC_R32, buf); /* val = buf[1] */ if (ret == -1) &#123; printf(\"errno = %d\\n\", errno); &#125; printf(\"%02d. [%08x] = %08x\\n\", i, buf[0], (unsigned int)buf[1]); buf[0] += 4; &#125; &#125; else if (strcmp(argv[1], \"w8\") == 0) &#123; ioctl(fd, REG_IOC_W8, buf); /* val = buf[1] */ &#125; else if (strcmp(argv[1], \"w16\") == 0) &#123; ioctl(fd, REG_IOC_W16, buf); /* val = buf[1] */ &#125; else if (strcmp(argv[1], \"w32\") == 0) &#123; ioctl(fd, REG_IOC_W32, buf); /* val = buf[1] */ &#125; else &#123; printf(argv[0]); return -1; &#125; return 0; &#125; 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"Linux应用","slug":"Linux应用","permalink":"http://yoursite.com/tags/Linux应用/"}]},{"title":"Tiny4412——Android访问硬件的方法","date":"2019-03-15T08:46:28.000Z","path":"2019/03/15/Tiny4412——Android访问硬件的方法/","text":"2019年，正式学习Android驱动。以LED为切入点，学习Android访问硬件的方法。 之前写第一个Linux下的LED驱动时候，提到：Linux驱动 = 裸机 + 框架这个思维在写Linux驱动的过程中，得到了充分验证。如今，学习Android驱动，开始验证：Android驱动 = Linux驱动 + 框架 1. 环境搭建开发环境主要包含：1.一个Linux主机(虚拟机)，在该主机里编译Linux内核和Android源码等；2.一个Windows主机，在该主机里编写Android APP，并连接开发板调试； 1.1 搭建Ubuntu虚拟机前面在学习Java时，已经安装了Ubuntu18.04的虚拟机，这里继续使用该虚拟机。 值得一提的是，虚拟机的内存给多一点，虚拟机参考配置：内存6G，硬盘100G，CPU 8核。在编译内核源码的过程中，发现编译太慢，一般挂一晚上都能编译好，之前内存给小了，编译了一天一夜也没好，后来改大了内存后，一会就编译完了。 1.2 编译Kernel和Android以下所有安装包都是从百问网云盘下载。 1、安装交叉编译工具链下载arm-linux-gcc-4.5.1-v6-vfp-20120301.tgz并解压。修改/etc/environment，将解压的交叉编译工具链加在末尾：1PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/work/tools/toolschain/4.5.1/bin&quot; 执行source /etc/environment更新环境变量。此时执行arm-linux-gcc -v，打印出gcc version 4.5.1 (ctng-1.8.1-FA)即OK。 2、编译Kernel下载linux-3.0.86-20150324.tgz并解压。进入内核源码根目录执行：12cp tiny4412_android_defconfig .configmake zImage 最后生成/work/linux_source/linux-3.0.86/arch/arm/boot/zImage。 3、编译Android下载android-5.0.2-fs-20150325.tar.gz并解压。进入Android源码根目录执行：12. setenvlunch 在选择界面：12345678910111213141516171819202122232425262728You&apos;re building on LinuxLunch menu... pick a combo: 1. aosp_arm-eng 2. aosp_arm64-eng 3. aosp_mips-eng 4. aosp_mips64-eng 5. aosp_x86-eng 6. aosp_x86_64-eng 7. mini_emulator_x86-userdebug 8. m_e_arm-userdebug 9. mini_emulator_arm64-userdebug 10. mini_emulator_mips-userdebug 11. mini_emulator_x86_64-userdebug 12. aosp_hammerhead-userdebug 13. aosp_mako-userdebug 14. full_tiny4412-userdebug 15. full_tiny4412-eng 16. aosp_shamu-userdebug 17. aosp_deb-userdebug 18. aosp_flo-userdebug 19. aosp_grouper-userdebug 20. full_fugu-userdebug 21. aosp_fugu-userdebug 22. aosp_tilapia-userdebug 23. aosp_manta-userdebugWhich would you like? [aosp_arm-eng] 输入15，即选择full_tiny4412-eng。再执行make –j8，等待几个小时，编译完成后执行./gen-img.sh生成/work/android_source/android-5.0.2/system.img. 当然编译过程不可能是那么一帆风顺的，实际编译Android源码过程中遇到的问题有：①JDK版本过高，重新安装openjdk-7-jdk，参考解决链接。②编译报错aidl_language_l，参考解决链接。③编译报错error: unsupported reloc 43，参考解决链接。④制作映像文件出错mkimage: command not found，执行sudo apt-get install u-boot-tools安装即可。 4、烧写使用厂家提供的MiniTools。将zImage和system.img分别烧写到Android Kernel和Android RooFs/System Image。 1.3 安装JDK(Windows)因为要在Windows上使用Android Studio编写APP，所以在Windows上也需要安装Java JDK(Java Development Kit)。通过Oracle官网下载最新的JDK： 安装好后，将JDK安装路径加入Windows的环境变量： 最后在CMD里验证： 1.4 安装Android Studio首先从官网下载Android Studio。 点击安装，会弹出首次运行没有Android SDK，点击“Cancel”。 然后选择”Custom”以自定义SDK安装路径。在弹出的界面勾选上”Android Virtual Device”，再指定SDK的安装路径。 此时会下载Android SDK和AVD，两个文件都很大，为了C盘节省空间，应用界面只指定了SDK的安装路径在D盘，还需手动指定AVD的安装路径，这个需要修改环境变量设置。 然后，等待一段时间就安装完了。 1.5 Android Studio的常用快捷键参考博客：Android Studio2.0 教程从入门到精通MAC版 - 提高篇 2. Android应用程序我的目的是写一个Android应用程序，通过该应用程序控制开发板上的LED灯。因此首先得设计一个APP，该APP有一个总开关控制所有灯的亮灭，每个灯又有单独的开关控制亮灭。 2.1 创建APP工程打开Android Studio，选择”Start a new Android Studio project”创建一个新APP工程。然后选择”Empty Activity”空主界面，最后设置APP信息、保存路径、兼容API版本。 等待自动创建完成后，会自动生成工程文件，其中有两个文件后面常用： app\\src\\main\\res\\layout\\activity_main.xml，界面控件布局文件，既可通过图形界面设计控件，也可直接编辑xml； app\\src\\main\\java\\cn\\hceng\\led\\MainActivity.java，实现控件各种具体功能，逻辑关系。 2.2 常用控件介绍2.2.1 TextViewTextView是文本视图，用来显示文字的。 xml创建：123456789&lt;TextView android:id=\"@+id/TEXT\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:text=\"hceng first APP!\" android:textColor=\"#008577\" android:textSize=\"25sp\" android:textStyle=\"bold\" /&gt; 1.标签&lt;TextView /&gt;代表着要在Activity中添加一个TextView，标签中可以设置一些属性；2.android:id代表TextView的ID，也就是TextView的唯一标识；在java代码中我们可以通过findViewById()方法来通过ID获取控件；上述控件的唯一ID为TEXT；3.android:layout_width代表控件的宽度，该属性的值是match_parent，表示该控件的宽度与父视图的宽度相同；4.android:layout_height代表控件的高度，该属性的值是wrap_content，表示控件的高度根据内容的高度进行改变；5.android:gravity代表文字对齐方式，该属性的值是center，表示居中显示；6.android:text代表文字内容，该属性的值是hceng first APP!，表示显示这串字符；7.android:textColor代表文字的颜色，该属性的值是#008577，表示16进制色值的绿色；7.android:textSize代表文字的大小，该属性的值是25sp，长度宽度的数值用dp，字体的大小用sp；7.android:textStyle代表文字的样，normal、bold、italic分别为正常，加粗、斜体，默认为normal； 代码控制：12345import android.widget.TextView; TextView myTextView = (TextView) findViewById(R.id.TEXT); String myText = myTextView.getText().toString(); myTextView.setText(myText+\" Add String\"); 2.2.2 ButtonButton是按钮，用来控制某个目的的开关。 xml创建：123456&lt;Button android:id=\"@+id/BUTTON\" android:layout_width=\"50pt\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:text=\"ALL ON\" /&gt; 1.Button标签里面的属性和前面TextView基本类似，这里就不赘述了； 代码控制：在Activity的类中也是使用findViewById()来通过ID获取该按钮。获取按钮后需要给按钮绑定点击事件，也就是点击按钮要做的事情，常用的方法有四种：布局文件指定响应函数、直接匿名内部类、新建子类实现、在当前类实现接口。 布局文件指定响应函数： 在布局文件的&lt;Button /&gt;标签里，添加android:onClick=&quot;onClick&quot;，MainActivity.java里就只需要实现onClick()方法即可。 12345678910111213141516import android.view.View;import android.widget.Button;public class MainActivity extends AppCompatActivity &#123; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.BUTTON); &#125; public void onClick(View v) &#123; //Todo &#125;&#125; 直接匿名内部类: 123456789101112131415161718import android.view.View;import android.widget.Button;public class MainActivity extends AppCompatActivity &#123; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.BUTTON); button.setOnClickListener(new View.OnClickListener() &#123; public void onClick (View v)&#123; //Todo &#125; &#125;); &#125;&#125; 新建子类实现: 1234567891011121314151617181920import android.view.View;import android.widget.Button;public class MainActivity extends AppCompatActivity &#123; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.BUTTON); button.setOnClickListener(new MyButtonListener()); &#125; class MyButtonListener implements View.OnClickListener &#123; @Override public void onClick(View v) &#123; //Todo &#125; &#125;&#125; 在当前类实现接口： 12345678910111213141516171819import android.view.View;import android.widget.Button;import android.view.View.OnClickListener;public class MainActivity extends AppCompatActivity implements OnClickListener &#123; //注意这里实现接口 protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.BUTTON); button.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; //Todo &#125;&#125; 参考博客：Android代码规范—-按钮单击事件的四种写法 2.2.3 CheckBoxCheckBox是复选框，用来多项选择。 xml创建： 123456&lt;CheckBox android:id=\"@+id/LED1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"onCheckboxClicked\" android:text=\"LED1\" /&gt; 分析： 1.CheckBox标签里面的属性和前面也基本类似；2.android:onClick代表控件的响应函数，该属性的值是onCheckboxClicked，表示操作该控件将调用onCheckboxClicked()方法； 代码控制： 123456789101112131415161718192021import android.widget.CheckBox;import android.widget.Toast; CheckBox checkBoxLed1 = (CheckBox) findViewById(R.id.LED1); public void onCheckboxClicked(View v) &#123; boolean checked = ((CheckBox) v).isChecked(); switch (v.getId()) &#123; case R.id.LED1: if (checked) &#123; Toast.makeText(getApplicationContext(), \"LED1 on\", Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(getApplicationContext(), \"LED1 off\", Toast.LENGTH_SHORT).show(); &#125; break; case R.id.LED2: //Todo break; &#125; &#125; 在XML里，多个CheckBox的android:onClick都是onCheckboxClicked，也就是任意一个CheckBox被点击，都会调用到onCheckboxClicked()方法。因此，需要使用getId()获取是按的哪一个CheckBox，再根据isChecked()的状态，进行相应操作。 2.2.4 EditTextEditText是输入框，用来接收用户输入的数据。 xml创建：123456&lt;EditText android:id=\"@+id/EDIT_TEXT\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"Please input the text \" android:maxLines=\"1\" /&gt; 1.android:hint代表占提示字符串，用来提示用户输入内容；2.android:macLines表示显示的最多行数； 代码控制：123456import android.widget.EditText;import android.widget.Toast; EditText myEditText = (EditText) findViewById(R.id.EDIT_TEXT); String inputText = myEditText.getText().toString(); Toast.makeText(MainActivity.this, inputText, Toast.LENGTH_SHORT).show(); 一般EditText还需要监控键盘回车键，或者和Button搭配，从而判断用户输完了数据，再获取数据。 2.2.5 ImageViewImageView是图片显示框，用来在界面上显示贴图。 xml创建：12345&lt;ImageView android:id=\"@+id/IMAGEVIEW\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:src=\"@drawable/p1\" /&gt; 1.android:src代表图片资源的，使用@xx来引用，图片一般放在res/drawable里面； 代码控制：1234import android.widget.ImageView; ImageView imageView = (ImageView) findViewById(R.id.IMAGEVIEW); imageView.setImageResource(R.drawable.p2); 2.2.6 ProgressBarProgressBar是进度条，用来展示当前进度。 xml创建：12345678&lt;ProgressBar android:id=\"@+id/PROGRESSBAR\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" style=\"@style/Widget.AppCompat.ProgressBar.Horizontal\" android:max=\"100\" android:visibility=\"visible\" android:progress=\"60\"/&gt; 1.style用来指定进度条样式，默认是转动的圆，这里是水平的一根横线表示进度条；2.android:max表示进度条的最大值；3.android:visibility表示是否可见进度条，visible是可见，invisible是不可见，gone是隐藏，即不保留控件所占空间；4.android:progress表示进度条的当前值(初始值)； 代码控制：1234567891011import android.widget.ProgressBar; ProgressBar myProgressBar = (ProgressBar) findViewById(R.id.PROGRESSBAR); myProgressBar.setProgress(myProgressBar.getProgress()+10); if (myProgressBar.getProgress() == myProgressBar.getMax()) &#123; //myProgressBar.setVisibility(View.GONE); myProgressBar.setProgress(0); &#125; else &#123; myProgressBar.setVisibility(View.VISIBLE); &#125; 1、通过findViewById()方法找到指定ProgressBar；2、通过getProgress()方法获取当前进度值，setProgress()方法设置当前进度值；3、通过getMax()方法获取xml设置的最大值；4、通过setVisibility()方法设置进度条是否可见，VISIBLE、INVISIBLE、GONE含义同上； 2.2.7 AlterDialogAlterDialog是警告对话框，用来展示警告信息和简单的交互。 代码创建：1234567891011121314151617181920212223import android.widget.Toast;import android.app.AlertDialog;import android.content.DialogInterface; AlertDialog.Builder alterDialog = new AlertDialog.Builder(MainActivity.this); alterDialog.setTitle(\"Warning\"); alterDialog.setMessage(\"Warning content\"); alterDialog.setCancelable(false); alterDialog.setPositiveButton(\"YES\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(MainActivity.this, \"yes\", Toast.LENGTH_SHORT).show(); &#125; &#125;); alterDialog.setNegativeButton(\"NO\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(MainActivity.this, \"no\", Toast.LENGTH_SHORT).show(); &#125; &#125;); alterDialog.show(); 1、AlterDialog是通过Builder进行创建，在创建的时候会指定该AlterDialog在那个Activity上进行显示；2、通过setTitle()方法设置标题，通过setMessage()设置内容；3、setCancelable()方法，表示弹出的AlterDialog在用户点击返回键是否消失，默认是true，这里设置为false，表示点击返回键不消失；4、setPositiveButton()方法是设置点击“确定”按钮时的事件，setNegativeButton是设置点击“取消”按钮的事件；5、show()方法弹出AlterDialog； 2.2.8 ProgressDialogProgressDialog是进度提示框，即在AlterDialog上添加Progress。 代码创建：123456789import android.app.ProgressDialog; ProgressDialog myProgressDialog = new ProgressDialog(MainActivity.this); myProgressDialog.setTitle(\"ProgressDialog\"); myProgressDialog.setMessage(\"Loading……\"); myProgressDialog.setCancelable(true); myProgressDialog.show(); 2.3 四种布局介绍Android中的布局方式有四种：线性布局(LinearLayout)、相对布局(RelativeLayout)、帧布局(FrameLayout)、表格布局(TableLayout)。 2.3.1 线性布局线性布局是最常用的布局之一，如名字一样，将控件在线性方向上依次排列。既然是线性，那么就可能是水平线性horizontal，也可以是垂直线性vertical。 xml示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;LinearLayout &lt;!--LinearLayout 1--&gt; android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" &gt; &lt;LinearLayout &lt;!--LinearLayout 1.1--&gt; android:layout_width=\"match_parent\" android:layout_height=\"960px\" android:background=\"#005A5B\" &gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"A\" android:textSize=\"100dp\"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout &lt;!--LinearLayout 1.2--&gt; android:layout_width=\"match_parent\" android:layout_height=\"960px\" android:orientation=\"horizontal\" &gt; &lt;LinearLayout &lt;!--LinearLayout 1.2.1--&gt; android:layout_width=\"540px\" android:layout_height=\"match_parent\" android:background=\"#008C72\" &gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"B\" android:textSize=\"100dp\"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout &lt;!--LinearLayout 1.2.2--&gt; android:layout_width=\"540px\" android:layout_height=\"match_parent\" android:background=\"#02A676\" &gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"C\" android:textSize=\"100dp\"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 效果： 示例实现了三个色块，最外层的LinearLayout 1是整个区域，它指定内部按垂直排列。然后里面的两个LinearLayout 1.1和LinearLayout 1.2就按垂直的上下排列。再在LinearLayout 1.2里又指定水平排列，里面的LinearLayout 1.2.1和LinearLayout 1.2.2就左右排列。 2.3.2 相对布局相对布局可以根据已经固定的控件来确定其它新加控件的位置。 xml示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;Button android:id=\"@+id/button_center\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerInParent=\"true\" android:text=\"center\" /&gt; &lt;Button android:id=\"@+id/button_above\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_above=\"@+id/button_center\" android:layout_centerInParent=\"true\" android:text=\"above\" /&gt; &lt;Button android:id=\"@+id/button_below\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/button_center\" android:layout_centerInParent=\"true\" android:text=\"below\" /&gt; &lt;Button android:id=\"@+id/button_left\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerVertical=\"true\" android:layout_toLeftOf=\"@+id/button_center\" android:text=\"left\" /&gt; &lt;Button android:id=\"@+id/button_right\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerVertical=\"true\" android:layout_toRightOf=\"@+id/button_center\" android:text=\"right\" /&gt;&lt;/RelativeLayout&gt; 效果： 示例实现了五个按键，先确定最中间button_center。然后使用layout_above、layout_below、layout_toLeftOf、layout_toRightOf分别在其上下左右。其中layout_centerVertical作用是将控件置于父控件的中心位置。 2.3.3 帧布局帧布局就是以屏幕左上角为坐标原点，指定每个控件的大小，后加进来的控件覆盖前面的控件。 xml示例： 1234567891011121314151617181920212223242526272829&lt;FrameLayout android:layout_width=\"120pt\" android:layout_height=\"120pt\" android:background=\"#00BF80\"&gt;&lt;/FrameLayout&gt;&lt;FrameLayout android:layout_width=\"100pt\" android:layout_height=\"100pt\" android:background=\"#298A6A\"&gt;&lt;/FrameLayout&gt;&lt;FrameLayout android:layout_width=\"80pt\" android:layout_height=\"80pt\" android:background=\"#00734D\"&gt;&lt;/FrameLayout&gt;&lt;FrameLayout android:layout_width=\"60pt\" android:layout_height=\"60pt\" android:background=\"#39BF93\"&gt;&lt;/FrameLayout&gt;&lt;FrameLayout android:layout_width=\"40pt\" android:layout_height=\"40pt\" android:background=\"#00402B\"&gt;&lt;/FrameLayout&gt; 效果： 示例实现了五个色块，都以左上角为原点，设置不同的大小，实现层级覆盖的效果。 2.3.4 表格布局在表格布局中，整个页面就相当于一张大的表格，控件就放在每个表格中。 xml示例： 1234567891011121314151617181920212223242526272829 &lt;TableLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:stretchColumns=\"0\"&gt; &lt;TableRow&gt; &lt;LinearLayout android:layout_width=\"75pt\" android:layout_height=\"75pt\" android:background=\"#00BF80\"&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"75pt\" android:layout_height=\"75pt\" android:background=\"#298A6A\"&gt; &lt;/LinearLayout&gt; &lt;/TableRow&gt; &lt;TableRow&gt; &lt;LinearLayout android:layout_width=\"75pt\" android:layout_height=\"75pt\" android:background=\"#00734D\" android:layout_span=\"2\"&gt; &lt;/LinearLayout&gt; &lt;/TableRow&gt;&lt;/TableLayout&gt; 效果： 示例实现了三个色块，先用TableLayout圈出整个表格，stretchColumns表示第N列自动扩充，可以看到上面的两个色块虽然设置的大小一样，但第0列的比第1列的大，就是因为第0列的自动扩充占据了两个剩余的部分。TableRow代表一行，在标签里可以根据需求设置多个控件，再用TableRow，表示继续下一行，layout_span属性表示该控件占两个表格。 参考博客：Android开发之基本控件和详解四种布局方式 2.4 设计的APP有了上面的基础知识，基本就可以编写APP了。 2.4.1 布局设计布局比较简单，采用线性布局，里面有6个控件：1个TextView显示字符、1个Button作为所有LED总开关、4个CheckBox分别控制每一个LED。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/TEXT\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:layout_marginTop=\"30dp\" android:text=\"Android access hardware\" android:textColor=\"#008577\" android:textSize=\"25sp\" android:textStyle=\"bold\" /&gt; &lt;Button android:id=\"@+id/BUTTON\" android:layout_width=\"50pt\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"30dp\" android:layout_gravity=\"center\" android:text=\"ALL ON\" /&gt; &lt;CheckBox android:id=\"@+id/LED1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"onCheckboxClicked\" android:text=\"LED1\" /&gt; &lt;CheckBox android:id=\"@+id/LED2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"onCheckboxClicked\" android:text=\"LED2\" /&gt; &lt;CheckBox android:id=\"@+id/LED3\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"onCheckboxClicked\" android:text=\"LED3\" /&gt; &lt;CheckBox android:id=\"@+id/LED4\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"onCheckboxClicked\" android:text=\"LED4\" /&gt; &lt;/LinearLayout&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 2.4.2 代码操作代码的操作逻辑也很简单，先是获取每个按键的ID，然后绑定button按键监听和chekbox按键监听。在监听的函数里，进行相应的逻辑控制。这里展示屏蔽了所有的硬件操作，硬件操作在后面再添加。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package cn.hceng.led;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.Button;import android.view.View;import android.widget.CheckBox;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; private boolean ledStatus = false; private Button button = null; private CheckBox checkBoxLed1 = null; private CheckBox checkBoxLed2 = null; private CheckBox checkBoxLed3 = null; private CheckBox checkBoxLed4 = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); &#125; private void initView() &#123; checkBoxLed1 = (CheckBox) findViewById(R.id.LED1); checkBoxLed2 = (CheckBox) findViewById(R.id.LED2); checkBoxLed3 = (CheckBox) findViewById(R.id.LED3); checkBoxLed4 = (CheckBox) findViewById(R.id.LED4); button = (Button) findViewById(R.id.BUTTON); button.setOnClickListener(new MyButtonListener()); &#125; class MyButtonListener implements View.OnClickListener &#123; @Override public void onClick(View v) &#123; ledStatus = !ledStatus; if (ledStatus) &#123; button.setText(\"ALL OFF\"); checkBoxLed1.setChecked(true); checkBoxLed2.setChecked(true); checkBoxLed3.setChecked(true); checkBoxLed4.setChecked(true); &#125; else &#123; button.setText(\"ALL ON\"); checkBoxLed1.setChecked(false); checkBoxLed2.setChecked(false); checkBoxLed3.setChecked(false); checkBoxLed4.setChecked(false); &#125; &#125; &#125; public void onCheckboxClicked(View view) &#123; boolean checked = ((CheckBox) view).isChecked(); switch (view.getId()) &#123; case R.id.LED1: if (checked) &#123; Toast.makeText(getApplicationContext(), \"LED1 on\", Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(getApplicationContext(), \"LED1 off\", Toast.LENGTH_SHORT).show(); &#125; break; case R.id.LED2: if (checked) &#123; Toast.makeText(getApplicationContext(), \"LED2 on\", Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(getApplicationContext(), \"LED2 off\", Toast.LENGTH_SHORT).show(); &#125; break; case R.id.LED3: if (checked) &#123; Toast.makeText(getApplicationContext(), \"LED3 on\", Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(getApplicationContext(), \"LED3 off\", Toast.LENGTH_SHORT).show(); &#125; break; case R.id.LED4: if (checked) &#123; Toast.makeText(getApplicationContext(), \"LED4 on\", Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(getApplicationContext(), \"LED4 off\", Toast.LENGTH_SHORT).show(); &#125; break; default: break; &#125; &#125;&#125; 3. Android访问硬件的方法Android APP采用Java编写的，Java不能直接访问硬件，因此Android APP访问硬件只能两种方式：通过JNI直接访问和Android硬件访问服务。 3.1 通过JNI直接访问 驱动层：和Linux驱动完全一样，编写驱动，向上提供/dev/leds节点；C库：使用C/C++操作/dev/leds，将C库函数名和Java函数名建立映射关系，注册java本地方法；应用层：APP加载C库(so文件)，加载后便可以调用C库提供的java本地方法：open()、ioctl()、close()实现对硬件的操作； 3.1.1 编写LED驱动LED的驱动很简单，就不多废话了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/miscdevice.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/types.h&gt;#include &lt;linux/moduleparam.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/ioctl.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/delay.h&gt; #include &lt;linux/gpio.h&gt;#include &lt;mach/gpio.h&gt;#include &lt;plat/gpio-cfg.h&gt;static int led_gpios[] = &#123; EXYNOS4212_GPM4(0), EXYNOS4212_GPM4(1), EXYNOS4212_GPM4(2), EXYNOS4212_GPM4(3),&#125;;static int led_open(struct inode *inode, struct file *file)&#123; int i; for (i = 0; i &lt; 4; i++) s3c_gpio_cfgpin(led_gpios[i], S3C_GPIO_OUTPUT); return 0;&#125;/* app : ioctl(fd, cmd, arg) */static long led_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; /* cmd : 0-off, 1-on */ /* arg : 0-3, which led */ if ((cmd != 0) &amp;&amp; (cmd != 1)) return -EINVAL; if (arg &gt; 4) return -EINVAL; gpio_set_value(led_gpios[arg], !cmd); return 0;&#125;static struct file_operations leds_ops = &#123; .owner = THIS_MODULE, .open = led_open, .unlocked_ioctl = led_ioctl, &#125;;static int major;static struct class *cls;int leds_init(void)&#123; major = register_chrdev(0, \"leds\", &amp;leds_ops); cls = class_create(THIS_MODULE, \"leds\"); device_create(cls, NULL, MKDEV(major, 0), NULL, \"leds\"); /* /dev/leds */ return 0;&#125;void leds_exit(void)&#123; device_destroy(cls, MKDEV(major, 0)); class_destroy(cls); unregister_chrdev(major, \"leds\");&#125;module_init(leds_init);module_exit(leds_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"Tiny4412 leds driver.\");MODULE_VERSION(\"v1.0\"); 编写好后，放在内核目录drivers/char/里，并在Makefile里添加obj-y += leds_drv.o。重新编译make zImage，将内核重新烧写到开发板里。 3.1.2 编写C库文件参考前面Java的JNI，编写hardcontrol.c，生成libhardcontrol.so。在hardcontrol.c里，操作/dev/leds，将操作函数与Java方法绑定，并注册。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;stdio.h&gt;#include &lt;jni.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;android/log.h&gt;#define DEBUG 1#if(DEBUG==1)#define LOG_TAG \"JNI\"#define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE,TAG,__VA_ARGS__)#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)#else#define LOGV(...) NULL#define LOGD(...) NULL#define LOGI(...) NULL#define LOGE(...) NULL#endifstatic jint fd;jint ledOpen(JNIEnv *env, jobject cls)&#123; LOGD(\"hardcontrol ledOpen\\n\"); fd = open(\"/dev/leds\", O_RDWR); if (fd &gt;= 0) return 0; else return -1;&#125;void ledClose(JNIEnv *env, jobject cls)&#123; LOGD(\"hardcontrol ledClose\\n\"); close(fd); return;&#125;jint ledCtrl(JNIEnv *env, jobject cls, jint number, jint status)&#123; LOGD(\"hardcontrol ledCtrl number=%d status=%d\\n\", number, status); int ret = ioctl(fd, status, number); return ret;&#125;static const JNINativeMethod methods[] = &#123; &#123;\"ledOpen\", \"()I\", (void *)ledOpen&#125;, &#123;\"ledClose\", \"()V\", (void *)ledClose&#125;, &#123;\"ledCtrl\", \"(II)I\", (void *)ledCtrl&#125;, &#125;;JNIEXPORT jint JNICALLJNI_OnLoad(JavaVM *jvm, void *reserved)&#123; JNIEnv *env; jclass cls; if ((*jvm)-&gt;GetEnv(jvm, (void **)&amp;env, JNI_VERSION_1_4)) return JNI_ERR; cls = (*env)-&gt;FindClass(env, \"cn/hceng/hardlibrary/HardControl\"); if (cls == NULL) return JNI_ERR; if ((*env)-&gt;RegisterNatives(env, cls, methods, sizeof(methods)/sizeof(methods[0])) &lt; 0) return JNI_ERR; return JNI_VERSION_1_4;&#125; 编译：1arm-linux-gcc -fPIC -shared hardcontrol.c -o libhardcontrol.so -I /usr/lib/jvm/java-1.7.0-openjdk-amd64/include/ -nostdlib /work/android_source/android-5.0.2/prebuilts/ndk/9/platforms/android-19/arch-arm/usr/lib/libc.so 这里的-I指定头文件jni.h的路径；-nostdlib是为了不使用标准的libc库，因为后面libhardcontrol.so依赖libc.so.6，需要重新构建系统得到libc.so.6，但源码中有很多libc.so也能用，为了方便找了一个版本较高的libc.so。 最后把生成的libhardcontrol.so放在APP的D:\\Android\\APP\\LED\\app\\libs\\armeabi\\路径下。 如何在C语言中打印log到android控制台：1.修改app\\build.gradle，在Android里添加ndk：1234567//hceng add for c language printingndk &#123; moduleName &quot;printing&quot; abiFilters &quot;armeabi&quot;,&quot;armeabi-v7a&quot;,&quot;x86&quot; ldLibs &quot;log&quot;&#125; 2.C文件中添加：123456789101112131415#include &lt;android/log.h&gt;#define DEBUG 1 #if(DEBUG==1)#define LOG_TAG &quot;JNI&quot;#define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE,TAG,__VA_ARGS__)#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)#else#define LOGV(...) NULL#define LOGD(...) NULL#define LOGI(...) NULL#define LOGE(...) NULL#endif 3.和printf一样使用：12//打印logcatLOGD(&quot;name=%s age=%f\\n&quot;,name,age); 4.编译C文件，需指定android/log.h路径和添加liblog.so库:1arm-linux-gcc -fPIC -shared hardcontrol.c -o libhardcontrol.so -I /usr/lib/jvm/java-1.7.0-openjdk-amd64/include/ -I /work/android_source/android-5.0.2/prebuilts/ndk/9/platforms/android-19/arch-arm/usr/include/ -nostdlib /work/android_source/android-5.0.2/prebuilts/ndk/9/platforms/android-19/arch-arm/usr/lib/libc.so /work/android_source/android-5.0.2/prebuilts/ndk/9/platforms/android-19/arch-arm/usr/lib/liblog.so 参考博客：C语言中打印log到android控制台 3.1.2 修改APP文件在APP目录app\\src\\main\\java\\cn\\hceng\\hardlibrary\\下创建HardControl.java来加载C库和声明Native方法：12345678910111213141516package cn.hceng.hardlibrary;public class HardControl &#123; //1.load static &#123; try &#123; System.loadLibrary(\"hardcontrol\"); //Call libhardcontrol.so from C. &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //2.Function declaration public static native int ledCtrl(int number, int status); public static native int ledOpen(); public static native void ledClose();&#125; 在APP里，即可通过JNI调用本地方法：12345import cn.hceng.hardlibrary.*; //硬件库 HardControl.ledOpen(); //硬件初始化 HardControl.ledCtrl(0, 1); //硬件操作 HardControl.ledCtrl(0, 0); //硬件操作在APP的适当位置，根据操作逻辑，调用本地方法。 最后还要修改app\\build.gradle，在Android里添加：123456//hceng add for ledsourceSets &#123; main &#123; jniLibs.srcDirs = [&apos;libs&apos;]; &#125;&#125; 此时修改后，将不能在AVD里仿真了，必须在开发板上测试。 最后，编译APP，插上USB线，连接开发板，运行测试，通过APP实现对LED的控制。 3.2 Android硬件访问服务前面直接通过JNI访问硬件，操作比较简单，同时也存在一些问题。比如，当多个APP同时访问某个硬件时，就可能发生硬件冲突。为了解决这个问题，Android提供了硬件访问服务，APP不能直接访问硬件，而是都给System Server申请操作硬件，System Server决策后，再去访问硬件，解决多个APP同时访问硬件冲突的问题。 驱动层：和Linux驱动完全一样，编写驱动，向上提供/dev/leds节点；C库：HAL层操作/dev/leds，JNI层加载HAL文件和向上注册java本地方法；系统服务：通过注册android服务的方式加载C库，再将服务加入service_manager里面。应用层：从service_manager里获取相关服务，再通过接口调用，接口里实现对本地方法的调用。 3.2.1 编写AIDLAIDL(Android Interface Definition Language)，即Android接口定义语言，顾名思义就是定义接口，提供给APP使用。LED对APP而言，就一个控制方法，因此ILedService.aidl如下：12345package android.os;interface ILedService &#123; int ledCtrl(int number, int status);&#125; ILedService.aidl并不能直接被APP调用，需要生成ILedService.java才能被APP使用。将ILedService.aidl放在frameworks/base/core/java/android/os/里，修改frameworks/base/Android.mk，添加：1core/java/android/os/ILedService.aidl \\ 然后执行mmm frameworks/base/，将自动生成out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/core/java/android/os/ILedService.java。 3.2.2 编写LedService.java前面生成了ILedService.java，需要实现ILedService接口的成员函数。123456789101112131415161718192021package com.android.server;import android.os.ILedService;public class LedService extends ILedService.Stub &#123; private static final String TAG = \"ILedService\"; //Call native c function to access hardware public int ledCtrl(int number, int status) throws android.os.RemoteException &#123; return native_ledCtrl(number, status); &#125; public LedService() &#123; native_ledOpen(); &#125; //Function declaration public static native int native_ledCtrl(int number, int status); public static native int native_ledOpen(); public static native void native_ledClose();&#125; 将其放在frameworks/base/services/core/java/com/android/server/路径下。 可以看到LedService.java继承于ILedService，并调用本地方法实现了成员函数。并在构造函数里调用native_ledOpen()。 3.2.3 修改SystemServer.javaSystemServer.java主要做两件事，一是加载C库，二是使用addService将LED服务加入service_manager里面。加载C库这个是调用onload.cpp，这个后面只修改onload.cpp，这里就不需要改了。修改frameworks/base/services/java/com/android/server/SystemServer.java，添加：12Slog.i(TAG, \"Led Service\");ServiceManager.addService(\"led\", new LedService()); 3.2.4 修改onload.cppSystemServer.java会加载C库，调用到onload.cpp，需要在onload.cpp注册LED服务。修改frameworks/base/services/core/jni/onload.cpp，添加：12345int register_android_server_LedService(JNIEnv* env);……register_android_server_LedService(env); 3.2.5 编写com_android_server_LedService.cpp前面用到了register_android_server_LedService()，是在com_android_server_LedService.cpp里实现的。com_android_server_LedService.cpp理论上可以直接操作节点/dev/leds，但一般不这样做。通常的做法是，向上提供本地方法(native_ledOpen)，向下加载hal文件(led_hal.c)，并调用HAL的函数。这样操作有两个好处：1.方便修改；如果需要修改硬件部分的操作，只需要修改led_hal.c，生成so文件，放入系统即可，而不需要编译整个Android系统；2.保密代码；因为Linux的GPL协议，一旦使用的内核代码，自己的代码也得开源出去，硬件厂商为了保密硬件的具体细节，只在内核实现操作寄存器的接口，具体的操作逻辑放在HAL文件里，而Android采用Apache协议，修改了代码而无需开源，这样就实现了保密代码； Google的这一”骚”操作就不评论了，积极的看确实加快的Linux的传播，但也伤害了Linux的开源社区。 编写步骤如下：1、定义JNINativeMethod，建立Java本地方法与C库函数名的映射关系；2、使用jniRegisterNativeMethods注册本地方法，将在onload.cpp被调用；3、在open()里： 3.1、使用hw_get_module获得hw_module_t结构体； 3.2、使用module-&gt;methods-&gt;open获得hw_device_t结构体； 3.3、将hw_device_t转换为led_device_t，调用对应open；4、完成其它函数ctrl、close的调用； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#define LOG_TAG \"LedService\"#include \"jni.h\"#include \"JNIHelp.h\"#include \"android_runtime/AndroidRuntime.h\"#include &lt;utils/misc.h&gt;#include &lt;utils/Log.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;hardware/led_hal.h&gt;namespace android&#123; static led_device_t* led_device; jint ledOpen(JNIEnv *env, jobject cls) &#123; jint err; hw_module_t* module; hw_device_t* device; ALOGI(\"native ledOpen\"); //1. hw_get_module for get module err = hw_get_module(\"led\", (hw_module_t const**)&amp;module); if (err == 0) &#123; //2. module-&gt;methods-&gt;open for get device err = module-&gt;methods-&gt;open(module, NULL, &amp;device); if (err == 0) &#123; //3. conversion, call led_open led_device = (led_device_t *)device; return led_device-&gt;led_open(led_device); &#125; else &#123; return -1; &#125; &#125; return -1; &#125; void ledClose(JNIEnv *env, jobject cls) &#123; ALOGI(\"nativeled Close\"); return; &#125; jint ledCtrl(JNIEnv *env, jobject cls, jint number, jint status) &#123; ALOGI(\"native ledCtrl %d, %d\", number, status); return led_device-&gt;led_ctrl(led_device, number, status); &#125; static const JNINativeMethod method_table[] = &#123; &#123;\"native_ledOpen\", \"()I\", (void *)ledOpen&#125;, &#123;\"native_ledClose\", \"()V\", (void *)ledClose&#125;, &#123;\"native_ledCtrl\", \"(II)I\", (void *)ledCtrl&#125;, &#125;; int register_android_server_LedService(JNIEnv *env) &#123; return jniRegisterNativeMethods(env, \"com/android/server/LedService\", method_table, NELEM(method_table)); &#125;&#125;; 将其放到./frameworks/base/services/core/jni/路径下。 3.2.6 编写HAL文件led_hal.c接着前面，HAL负责访问驱动程序执行硬件操作。 编写步骤如下：1、创建一个名为HMI(HAL_MODULE_INFO_SYM)的hw_module_t结构体；2、创建一个open函数, 它返回led_device_t结构体；3、创建led_device_t结构体，里面包含hw_device_t结构体和提供的函数；4、操作设备节点实现提供的函数； [led_hal.h]123456789101112131415161718192021#ifndef ANDROID_LED_INTERFACE_H #define ANDROID_LED_INTERFACE_H #include &lt;stdint.h&gt; #include &lt;sys/cdefs.h&gt; #include &lt;sys/types.h&gt; #include &lt;hardware/hardware.h&gt; __BEGIN_DECLS struct led_device_t &#123; struct hw_device_t common; int (*led_open) (struct led_device_t* dev); int (*led_ctrl) (struct led_device_t* dev, int number, int status);&#125;; __END_DECLS #endif [led_hal.c]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;hardware/hardware.h&gt;#include &lt;cutils/log.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;utils/Log.h&gt;#include &lt;hardware/led_hal.h&gt;#define LOG_TAG \"LED_HAL\"static int fd;static int led_open(struct led_device_t* dev __unused)&#123; fd = open(\"/dev/leds\", O_RDWR); ALOGI(\"led_open : %d\", fd); if (fd &gt;= 0) return 0; else return -1;&#125;static int led_ctrl(struct led_device_t* dev __unused, int number, int status)&#123; int ret = ioctl(fd, status, number); ALOGI(\"led_ctrl : %d, %d, %d\", number, status, ret); return ret;&#125;static int led_close(struct hw_device_t* device __unused)&#123; ALOGI(\"led_close : %d\", fd); close(fd); return 0;&#125;static struct led_device_t led_dev = &#123; .common = &#123; .tag = HARDWARE_DEVICE_TAG, .close = led_close, &#125;, .led_open = led_open, .led_ctrl = led_ctrl,&#125;;static int led_device_open(const struct hw_module_t* module __unused, const char* id __unused, struct hw_device_t** device)&#123; //return by id *device = &amp;led_dev; return 0;&#125;static struct hw_module_methods_t led_module_methods = &#123; .open = led_device_open,&#125;;struct hw_module_t HAL_MODULE_INFO_SYM = &#123; .tag = HARDWARE_MODULE_TAG, .id = \"led\", .methods = &amp;led_module_methods,&#125;; 将led_hal.h放在./hardware/libhardware/include/hardware/目录下；将led_hal.c上放在./hardware/libhardware/modules/led/目录下； 3.2.7 编译和重新烧写system.img前面添加了LedService.java，其Android.mk自动包含了所有java文件，不需要修改Android.mk。前面添加了com_android_server_LedService.cpp，不会自动包含cpp文件，其Android.mk需要修改。打开frameworks/base/services/core/jni/Android.mk，添加：1$(LOCAL_REL_DIR)/com_android_server_LedService.cpp \\ 前面添加了led_hal.c，需要创建hardware/libhardware/modules/led/Android.mk，内容如下：12345678910111213LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := led.defaultLOCAL_MODULE_RELATIVE_PATH := hwLOCAL_C_INCLUDES := hardware/libhardwareLOCAL_SRC_FILES := led_hal.cLOCAL_SHARED_LIBRARIES := liblogLOCAL_MODULE_TAGS := enginclude $(BUILD_SHARED_LIBRARY) 然后执行：1234mmm ./frameworks/base/services/ //保证com_android_server_LedService.cpp和onload.cpp都重新编译mmm ./hardware/libhardware/modules/led/ //保证led_hal.c编译make snod //重新生成./out/target/product/tiny4412/system.img./gen-img.sh //脚本，生成system.img并移动到源码根目录，且生成其他用户数据镜像等 将生成的system.img重新烧写，重新启动后界面卡在Android logo，串口一直打印request_suspend_state: wakeup (0-&gt;0)。解决方法：修改android源码的./device/friendly-arm/tiny4412/conf/init.rc将mount rootfs rootfs / ro remount改为mount rootfs rootfs / rw remount，重新编译，烧写即可。 3.2.8 修改APP文件在APP里，会用到ILedService类，这个类是我们自己定义的，直接在APP里使用，连编译都过不了。因此，就需要把包含ILedService类的文件导入工程，或者使用JAVA的反射机制。 1、使用导入的方法①首先还是修改MainActivity.java，修改其中对硬件的调用，参考如下：1234567import android.os.ILedService;import android.os.ServiceManager;import static android.os.ServiceManager.getService; …… ILedService iLedService = ILedService.Stub.asInterface(ServiceManager.getService(\"led\")); …… iLedService.ledCtrl(0, 1);注意getService()的名字和SystemServer.java里addServer添加的名字要一致。 ②将out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes.jar放在Windows里。在Android Studio里，选择File-&gt;Project Structure，此时弹出配置界面，点击左上角的+，选择Import .JAR/.AAR Package，选择刚才的classes.jar。再选中app，切换到Dependencies选项卡，点击右边的+号，选择3 Module dependency，在弹出的界面选择刚才添加的classes，最后点击OK。 以上操作后，会在APP工程根目录下生成classes文件夹，里面就包含了classes.jar。为了减小生成的APP体积，还需要设置JAR包只在编译时使用，而不打包到APP里面。如下图，选中classes，在右边的选项卡选择Compile only。 ③此时，再次编译可能遇到INSTALL_FAILED_NO_MATCHING_ABIS: Failed to extract native libraries, res=-113等错误，在app\\build.gradle添加：123456789//hceng add for solved:INSTALL_FAILED_NO_MATCHING_ABIS: Failed to extract native libraries, res=-113.splits &#123; abi &#123; enable true reset() include &apos;x86&apos;, &apos;armeabi-v7a&apos;, &apos;x86_64&apos; universalApk true &#125;&#125; 2、使用反射机制 JAVA的反射机制原理参考之前的JAVA学习笔记——4.2反射。 使用放射机制就不用导入classes.jar，通过Class.forName()获取类、getMethod()获取方法，最终得到ledCtrl()方法。123456789101112131415161718192021Object proxy = null;Method ledCtrl = null;……try &#123; //iLedService = ILedService.Stub.asInterface(ServiceManager.getService(\"led\")); Method getService = Class.forName(\"android.os.ServiceManager\").getMethod(\"getService\", String.class); Object ledService = getService.invoke(null, \"led\"); Method asInterface = Class.forName(\"android.os.ILedService$Stub\").getMethod(\"asInterface\", IBinder.class); proxy = asInterface.invoke(null, ledService); ledCtrl = Class.forName(\"android.os.ILedService$Stub$Proxy\").getMethod(\"ledCtrl\", int.class, int.class);&#125; catch (NoSuchMethodException e) &#123; e.printStackTrace();&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; catch (IllegalAccessException e) &#123; e.printStackTrace();&#125; catch (InvocationTargetException e) &#123; e.printStackTrace();&#125; 使用：1234567try &#123; ledCtrl.invoke(proxy, i, 1);&#125; catch (IllegalAccessException e) &#123; e.printStackTrace();&#125; catch (InvocationTargetException e) &#123; e.printStackTrace();&#125; 4.总结如何实现一个硬件访问服务:①编写Linux驱动led_drv.c，操作硬件；②编写HAL层led_hal.c，访问Linux设备节点；③编写JNI层com_android_server_LedService.cpp，调用HAL层，注册本地方法；④修改onload.cpp注册服务，修改SystemServer.java加入服务；⑤编写LedService.java调用本地方法；⑥编写ILedService.aidl生成ILedService.java，提供接口；⑦编写APP，实现UI、操作逻辑，调用接口访问硬件； 参考资料：韦东山第四期Android驱动_Android系统Android系统源代码情景分析_罗升阳 第一行代码：Android 涉及示例源码:Github 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Android驱动","slug":"Android驱动","permalink":"http://yoursite.com/tags/Android驱动/"},{"name":"Android应用","slug":"Android应用","permalink":"http://yoursite.com/tags/Android应用/"}]},{"title":"博客两周年","date":"2019-03-01T08:58:00.000Z","path":"2019/03/01/博客两周年/","text":"2018-2019，博客一年统计。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"AM335X——1-Wire和IrDA驱动","date":"2019-02-15T06:38:22.000Z","path":"2019/02/15/AM335X——1-Wire和IrDA驱动/","text":"记录DS18B20温度传感器、DH11温湿度传感器、红外遥控驱动。1-wire(单总线协议)就是只使用一条线(GPIO)实现时钟/数据的双向传输。DS18B20是比较标准的1-wire协议，可以通过逻辑分析仪显示出含义，DH11不是很标准(专利原因？)，需要自己参考芯片手册理解含义。但它们原理都差不多，且都对时序要求比较高(us级的延时)。 IrDA也是一根线，原理也差不多，因此也把它放在一起记录。AM335X没有1-wire的控制器，因此使用GPIO模拟。 1. DS18B201.1 基础知识1.1.1 性能参数分辨率：9~12位可编程(上电默认12位)精度：±0.5℃(在-10~+85℃)量程：-55°C ~ 125°C转换时间：750ms(12位分辨率) 1.1.2 温度数据格式一次返回的温度数据为16位，前五位表示正负，中间七位表示整数部分，最低四位为小数部分；温度传感器的分辨率为用户可编程的9、10、11或12位, 分别对应0.5℃、0.25℃、0.125℃和 0.0625℃｡因此温度计算结果为：(正负)整数部分+小数部分*分辨率 以0000 0000 1010 0010为例，前五位为0，即温度为零上；中间七位0001010，即温度整数部分为10；最后四位0010，即温度小数部分为2*0.625=0.125，因此温度为+10.125。 1.1.3 64Bits只读数据低八位用于CRC校验，中间48位是DS18B20唯一序列号，高八位是产品系列号(为28h) 1.1.4 操作步骤每次对DS18B20操作，都必须严格按照以下步骤：1、初始化；2、ROM指令；3、功能指令； 1.1.5 ROM指令和功能指令ROM指令指令名称指令代码指令功能读ROM33H读ROM中64Bits的只读数据ROM匹配55H发出此命令后接着发64Bits的ROM编码，使单总线上与编码匹配的DS18B3做出响应搜索ROMF0H用于确定挂在总线上的DS18B20的个数和识别64Bits的ROM地址跳过ROMCCH忽略64BitsROM只读数据，接着发出功能指令，进行温度转换或读取温度警报搜索ECH只有温度超过设定上限或下限的DS18B20才做出响应 功能指令指令名称指令代码指令功能温度转换44H启动温度转换，结果将保存在内部RAM中读取温度BEH读取内部RAM中的温度数据设置报警温度4EH设置上或下限报警温度指令，接着应发送两字节数据保存报警温度48H将RAM中的报警温度数据，复制到EEPROM中保存恢复RAMB8H将EEPROM中的报警温度数据恢复到RAM读供电方式B4H寄生供电返回0，外界电源供电返回1 1.1.5 初始化时序 初始化DS18B20的时序如上，先拉低480us，然后拉高释放总线，随后在60-240us内，DS18B20将会拉低总线进行响应。此时检测总线释放被拉低既可判断出DS18B20是否初始化成功。 1.1.6 读写时序 上面的图是写0或1的时序：如果写0，拉低至少60us(写周期为60-120us)即可；如果写1，先拉低至少1us，然后拉高，整个写周期至少为60us即可。 下面的图是读0或1的时序：先拉低至少1us，随后读取电平，如果为0，即读到的数据是0，如果为1，即可读到的数据是1。整个过程必须在15us内完成，15us后引脚都会被拉高。 1.2 内核驱动内核中自带1-Wire和DS18B20的驱动。drivers/w1/masters/w1-gpio.c是单总线的IO操作方法,用于模拟单总线时序；drivers/w1/slaves/w1_therm.c是DS18B20的寄存器操作方法，和IO时序无关； 1.2.1 加入内核1234567Device Drivers ---&gt; &lt;*&gt; Dallas's 1-wire support ---&gt; [*] Userspace communication over connector 1-wire Bus Masters ---&gt; &lt;*&gt; GPIO 1-wire busmaster 1-wire Slaves ---&gt; &lt;*&gt; Thermal family implementation 1.2.2 修改设备树12345onewire@0 &#123; compatible = \"w1-gpio\"; gpios = &lt;&amp;gpio0 13 0&gt;; //pinctrl-0 = &lt;&amp;ds18b20_dq_pin&gt;;&#125;; 1.2.3 应用测试cat /sys/bus/w1/drivers/w1_slave_driver/28-01d58c07010c/w1_slave 1.3 自己驱动这次驱动，吸取了前面AM335X——hwmon和input子系统的经验。 1.3.1 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306//cat /sys/class/hwmon/hwmon0/device/temperature#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;linux/of_gpio.h&gt;#include &lt;linux/platform_device.h&gt; #include &lt;linux/hwmon.h&gt;#include &lt;linux/hwmon-sysfs.h&gt;#include &lt;linux/irqflags.h&gt;struct ds18b20 &#123; struct device *hwmon_dev; struct mutex lock; int dq_pin; u8 value[2]; u8 family_code; u8 serial_num[6]; u8 crc;&#125;;static struct ds18b20 ds;static int ds18b20_init(void)&#123; int ret = 1; mutex_lock(&amp;ds.lock); gpio_direction_output(ds.dq_pin, 1); udelay(2); gpio_direction_output(ds.dq_pin, 0); //Low level 480us for reset udelay(480); gpio_direction_output(ds.dq_pin, 1); //Pull high release bus udelay(60); gpio_direction_input(ds.dq_pin); //Read response pulse ret = gpio_get_value(ds.dq_pin); udelay(240); //Waiting for the corresponding end mutex_unlock(&amp;ds.lock); return ret;&#125;static void write_byte(unsigned char data)&#123; int i = 0; unsigned long flags; mutex_lock(&amp;ds.lock); local_irq_save(flags); //Save interrupt //local_irq_disable(); //Close all interrupts gpio_direction_output(ds.dq_pin, 1); for (i = 0; i &lt; 8; i ++) &#123; gpio_direction_output(ds.dq_pin, 1); udelay(2); gpio_direction_output(ds.dq_pin, 0); //Start at a low level greater than 1us udelay(5); gpio_direction_output(ds.dq_pin, data &amp; 0x01); udelay(60); //Write cycle is greater than 60us data &gt;&gt;= 1; &#125; local_irq_restore(flags); //Recovery interrupt //local_irq_enable(); //Open all interrupts mutex_unlock(&amp;ds.lock); &#125;static unsigned char read_byte(void) &#123; int i; unsigned long flags; unsigned char data = 0; mutex_lock(&amp;ds.lock); local_irq_save(flags); //local_irq_disable(); for (i = 0; i &lt; 8; i++) &#123; gpio_direction_output(ds.dq_pin, 1); udelay(2); gpio_direction_output(ds.dq_pin, 0); //Start at a low level greater than 1us udelay(5); gpio_direction_output(ds.dq_pin, 1); //Pull high release bus udelay(1); data &gt;&gt;= 1; gpio_direction_input(ds.dq_pin); if (gpio_get_value(ds.dq_pin)) //Must be read within 15us after being pulled low data |= 0x80; udelay(60); //Read cycle is greater than 60us; &#125; local_irq_restore(flags); //local_irq_enable(); mutex_unlock(&amp;ds.lock); return data; &#125; static ssize_t ds18b20_get_sensor_value(struct device *dev, struct device_attribute *devattr, char *buf)&#123; int ret = -1; unsigned int m, n; ret = ds18b20_init(); //Reset initialization of the DS18B20 before each read and write if(0 != ret) &#123; printk(KERN_ERR\"%s ds18b20_init error.\\n\",__func__); return -1; &#125; write_byte(0xCC); //Skip commands for ROM operations write_byte(0x44); //Start the DS18B20 acquisition temperature ret = ds18b20_init(); if(0 != ret) &#123; printk(KERN_ERR\"%s ds18b20_init error.\\n\",__func__); return -1; &#125; write_byte(0xCC); //Skip commands for ROM operations write_byte(0xBE); //Read the data in the DS18B20 register ds.value[0] = read_byte(); //Low byte ds.value[1] = read_byte(); //High byte m = ((ds.value[1] &amp; 0x07)&lt;&lt;4) + ((ds.value[0] &amp; 0xF0)&gt;&gt;4); //Integer part(7 bits in the middle) n = ds.value[0] &amp; 0x0F; //Fractional part(lower 4 bits) if(ds.value[1] &amp; 0xF8)//The high 5 bits indicate positive and negative ret = sprintf(buf, \"TEMP: -%d.%02d\\n\", m, n*625); else ret = sprintf(buf, \"TEMP: %d.%02d\\n\", m, n*625);; return ret;&#125;static ssize_t ds18b20_get_sensor_info(struct device *dev, struct device_attribute *devattr, char *buf)&#123; int i, ret = -1; struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr); ret = ds18b20_init(); if(0 != ret) &#123; printk(KERN_ERR\"%s ds18b20_init error.\\n\",__func__); return -1; &#125; write_byte(0x33); //Read ROM command ds.family_code = read_byte(); //The lower 8 bits is the family code(28h) for (i=0; i&lt;6; i++) //The middle 48 bits are the unique serial number ds.serial_num[i] = read_byte(); ds.crc = read_byte(); //The high 8 bits are the CRC check data. switch(attr-&gt;index) &#123; case 1: ret = sprintf(buf, \"0x%x\\n\", ds.family_code); break; case 2: ret = sprintf(buf, \"%02d%02d%02d%02d%02d%02d\\n\", ds.serial_num[0],ds.serial_num[1], \\ ds.serial_num[2], ds.serial_num[3],ds.serial_num[4],ds.serial_num[5]); break; case 3: ret = sprintf(buf, \"%d\\n\", ds.crc); break; default: break; &#125; return ret;&#125;static struct sensor_device_attribute ds18b20_temp_attr[] = &#123; SENSOR_ATTR(temperature, S_IRUGO, ds18b20_get_sensor_value, NULL, 0), SENSOR_ATTR(family_code, S_IRUGO, ds18b20_get_sensor_info, NULL, 1), SENSOR_ATTR(serial_num, S_IRUGO, ds18b20_get_sensor_info, NULL, 2), SENSOR_ATTR(crc, S_IRUGO, ds18b20_get_sensor_info, NULL, 3),&#125;; static int ds18b20_probe(struct platform_device *pdev)&#123; int status, i; //printk(KERN_INFO\"%s OK.\\n\",__func__); ds.dq_pin = of_get_named_gpio(pdev-&gt;dev.of_node, \"dq-gpio\", 0); status = gpio_request(ds.dq_pin, \"ds18b20_dq_pin\"); if (status) &#123; dev_err(&amp;pdev-&gt;dev, \"gpio_request() fail.\\n\"); return -EBUSY; &#125; mutex_init(&amp;ds.lock); mutex_lock(&amp;ds.lock); dev_set_drvdata(&amp;pdev-&gt;dev, &amp;ds); for (i=0; i&lt;(sizeof(ds18b20_temp_attr)/sizeof(struct sensor_device_attribute)); i++) &#123; status = device_create_file(&amp;pdev-&gt;dev, &amp;ds18b20_temp_attr[i].dev_attr); if (status) &#123; dev_err(&amp;pdev-&gt;dev, \"device_create_file() failed.\\n\"); goto fail_crete_file; &#125; &#125; ds.hwmon_dev = hwmon_device_register(&amp;pdev-&gt;dev); if (IS_ERR(ds.hwmon_dev)) &#123; dev_err(&amp;pdev-&gt;dev, \"hwmon_device_register() fail.\\n\"); status = PTR_ERR(ds.hwmon_dev); goto fail_device_register; &#125; mutex_unlock(&amp;ds.lock); return 0; fail_device_register: hwmon_device_unregister(ds.hwmon_dev);fail_crete_file: for (i--; i&gt;=0; i--) device_remove_file(&amp;pdev-&gt;dev, &amp;ds18b20_temp_attr[i].dev_attr); dev_set_drvdata(&amp;pdev-&gt;dev, NULL); gpio_free(ds.dq_pin); mutex_unlock(&amp;ds.lock); return status;&#125; static int ds18b20_remove(struct platform_device *pdev)&#123; int i; mutex_lock(&amp;ds.lock); hwmon_device_unregister(ds.hwmon_dev); for (i=0; i&lt;(sizeof(ds18b20_temp_attr)/sizeof(struct sensor_device_attribute)); i++) device_remove_file(&amp;pdev-&gt;dev, &amp;ds18b20_temp_attr[i].dev_attr); dev_set_drvdata(&amp;pdev-&gt;dev, NULL); gpio_free(ds.dq_pin); mutex_unlock(&amp;ds.lock); return 0;&#125;static const struct of_device_id ds18b20_of_match[] = &#123; &#123; .compatible = \"maxim,ds18b20\", .data = NULL &#125;, &#123; /* sentinel */ &#125;&#125;;static struct platform_driver ds18b20_drv = &#123; .probe = ds18b20_probe, .remove = ds18b20_remove, .driver = &#123; .name = \"ds18b20_drv\", .owner = THIS_MODULE, .of_match_table = of_match_ptr(ds18b20_of_match), &#125;,&#125;;static int ds18b20_drv_init(void) &#123; //printk(KERN_INFO\"%s OK.\\n\",__func__); return platform_driver_register(&amp;ds18b20_drv); &#125; static void ds18b20_drv_exit(void) &#123; //printk(KERN_INFO\"%s OK.\\n\",__func__); platform_driver_unregister(&amp;ds18b20_drv); &#125; module_init(ds18b20_drv_init);module_exit(ds18b20_drv_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am335x board ds18b20 driver.\");MODULE_VERSION(\"v1.0\"); 驱动内容比较简单，严格按照前面的时序操作即可。值得一提的是，因为时序是us级的，如果在发送时序过程中，产生中断就可能导致时序出错，因此在读写函数里加入local_irq_save(flags);、local_irq_restore(flags);临时开/关中断。 1.3.2 设备树123456789101112131415 ds18b20 &#123; compatible = \"maxim,ds18b20\"; dq-gpio = &lt;&amp;gpio0 13 0&gt;; pinctrl-0 = &lt;&amp;ds18b20_dq_pin&gt;; &#125;; ……&amp;am33xx_pinmux &#123; ds18b20_dq_pin: ds18b20_dq_pin0 &#123; pinctrl-single,pins = &lt; 0x17C (PIN_INPUT_PULLDOWN | MUX_MODE7) /* conf_uart1_rtsn.gpio0_13 */ &gt;; &#125;;&#125;; 1.3.3 应用测试 2. DH112.1 基础知识2.1.1 性能参数 温度分辨率：1°C精度：±2℃检测范围：-20°C ~ 60°C 湿度分辨率：1%RH精度：±5%RH (0~50°C)检测范围：5%RH ~ 95%RH (25°C) 采样周期间隔不得低于1秒钟。 可以看到无论是测量温度的精度还是范围、采样周期，都比较烂。。 2.1.2 数据格式一次返回的数据长度为40Bits，高位在前。8bit湿度整数数据+8bit湿度小数数据+8bit温度整数数据+8bit温度小数数据+8bit校验和可以看到数据分小数部分和整数部分，当前小数部分用于以后扩展，现读出为零。 另外还有数据校验，如果”8bit湿度整数数据+8bit湿度小数数据+8bi温度整数数据+8bit温度小数数据”所得结果的末8位，等于”8bit校验和”即数据正确。 2.1.3 开始时序 开始时，主机拉低至少18ms，随后拉高20-40us，然后释放总线，完成开始信号。DH11随后拉低80us，再拉高80us，最后发送40Bits数据。 2.1.4 读时序 先读到50us的低电平，随后如果是26-28us的高电平即收到的是数据0，如果是70us的高电平即收到的数据是1。 2.2 内核驱动本来以为内核不含DH11驱动，后面又看到了，在iio子系统里面，路径为：linux-4.1.18/drivers/iio/humidity/dht11.c。 2.2.1 内核代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306/* * DHT11/DHT22 bit banging GPIO driver * * Copyright (c) Harald Geyer &lt;harald@ccbib.org&gt; * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. */#include &lt;linux/err.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/printk.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_device.h&gt;#include &lt;linux/sysfs.h&gt;#include &lt;linux/io.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/wait.h&gt;#include &lt;linux/bitops.h&gt;#include &lt;linux/completion.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;linux/of_gpio.h&gt;#include &lt;linux/iio/iio.h&gt;#define DRIVER_NAME \"dht11\"#define DHT11_DATA_VALID_TIME 2000000000 /* 2s in ns */#define DHT11_EDGES_PREAMBLE 2#define DHT11_BITS_PER_READ 40/* * Note that when reading the sensor actually 84 edges are detected, but * since the last edge is not significant, we only store 83: */#define DHT11_EDGES_PER_READ (2*DHT11_BITS_PER_READ + DHT11_EDGES_PREAMBLE + 1)/* Data transmission timing (nano seconds) */#define DHT11_START_TRANSMISSION 18 /* ms */#define DHT11_SENSOR_RESPONSE 80000#define DHT11_START_BIT 50000#define DHT11_DATA_BIT_LOW 27000#define DHT11_DATA_BIT_HIGH 70000struct dht11 &#123; struct device *dev; int gpio; int irq; struct completion completion; struct mutex lock; s64 timestamp; int temperature; int humidity; /* num_edges: -1 means \"no transmission in progress\" */ int num_edges; struct &#123;s64 ts; int value; &#125; edges[DHT11_EDGES_PER_READ];&#125;;static unsigned char dht11_decode_byte(int *timing, int threshold)&#123; unsigned char ret = 0; int i; for (i = 0; i &lt; 8; ++i) &#123; ret &lt;&lt;= 1; if (timing[i] &gt;= threshold) ++ret; &#125; return ret;&#125;static int dht11_decode(struct dht11 *dht11, int offset)&#123; int i, t, timing[DHT11_BITS_PER_READ], threshold, timeres = DHT11_SENSOR_RESPONSE; unsigned char temp_int, temp_dec, hum_int, hum_dec, checksum; /* Calculate timestamp resolution */ for (i = 1; i &lt; dht11-&gt;num_edges; ++i) &#123; t = dht11-&gt;edges[i].ts - dht11-&gt;edges[i-1].ts; if (t &gt; 0 &amp;&amp; t &lt; timeres) timeres = t; &#125; if (2*timeres &gt; DHT11_DATA_BIT_HIGH) &#123; pr_err(\"dht11: timeresolution %d too bad for decoding\\n\", timeres); return -EIO; &#125; threshold = DHT11_DATA_BIT_HIGH / timeres; if (DHT11_DATA_BIT_LOW/timeres + 1 &gt;= threshold) pr_err(\"dht11: WARNING: decoding ambiguous\\n\"); /* scale down with timeres and check validity */ for (i = 0; i &lt; DHT11_BITS_PER_READ; ++i) &#123; t = dht11-&gt;edges[offset + 2*i + 2].ts - dht11-&gt;edges[offset + 2*i + 1].ts; if (!dht11-&gt;edges[offset + 2*i + 1].value) return -EIO; /* lost synchronisation */ timing[i] = t / timeres; &#125; hum_int = dht11_decode_byte(timing, threshold); hum_dec = dht11_decode_byte(&amp;timing[8], threshold); temp_int = dht11_decode_byte(&amp;timing[16], threshold); temp_dec = dht11_decode_byte(&amp;timing[24], threshold); checksum = dht11_decode_byte(&amp;timing[32], threshold); if (((hum_int + hum_dec + temp_int + temp_dec) &amp; 0xff) != checksum) return -EIO; dht11-&gt;timestamp = iio_get_time_ns(); if (hum_int &lt; 20) &#123; /* DHT22 */ dht11-&gt;temperature = (((temp_int &amp; 0x7f) &lt;&lt; 8) + temp_dec) * ((temp_int &amp; 0x80) ? -100 : 100); dht11-&gt;humidity = ((hum_int &lt;&lt; 8) + hum_dec) * 100; &#125; else if (temp_dec == 0 &amp;&amp; hum_dec == 0) &#123; /* DHT11 */ dht11-&gt;temperature = temp_int * 1000; dht11-&gt;humidity = hum_int * 1000; &#125; else &#123; dev_err(dht11-&gt;dev, \"Don't know how to decode data: %d %d %d %d\\n\", hum_int, hum_dec, temp_int, temp_dec); return -EIO; &#125; return 0;&#125;/* * IRQ handler called on GPIO edges */static irqreturn_t dht11_handle_irq(int irq, void *data)&#123; struct iio_dev *iio = data; struct dht11 *dht11 = iio_priv(iio); /* TODO: Consider making the handler safe for IRQ sharing */ if (dht11-&gt;num_edges &lt; DHT11_EDGES_PER_READ &amp;&amp; dht11-&gt;num_edges &gt;= 0) &#123; dht11-&gt;edges[dht11-&gt;num_edges].ts = iio_get_time_ns(); dht11-&gt;edges[dht11-&gt;num_edges++].value = gpio_get_value(dht11-&gt;gpio); if (dht11-&gt;num_edges &gt;= DHT11_EDGES_PER_READ) complete(&amp;dht11-&gt;completion); &#125; return IRQ_HANDLED;&#125;static int dht11_read_raw(struct iio_dev *iio_dev, const struct iio_chan_spec *chan, int *val, int *val2, long m)&#123; struct dht11 *dht11 = iio_priv(iio_dev); int ret; mutex_lock(&amp;dht11-&gt;lock); if (dht11-&gt;timestamp + DHT11_DATA_VALID_TIME &lt; iio_get_time_ns()) &#123; reinit_completion(&amp;dht11-&gt;completion); dht11-&gt;num_edges = 0; ret = gpio_direction_output(dht11-&gt;gpio, 0); if (ret) goto err; msleep(DHT11_START_TRANSMISSION); ret = gpio_direction_input(dht11-&gt;gpio); if (ret) goto err; ret = request_irq(dht11-&gt;irq, dht11_handle_irq, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, iio_dev-&gt;name, iio_dev); if (ret) goto err; ret = wait_for_completion_killable_timeout(&amp;dht11-&gt;completion, HZ); free_irq(dht11-&gt;irq, iio_dev); if (ret == 0 &amp;&amp; dht11-&gt;num_edges &lt; DHT11_EDGES_PER_READ - 1) &#123; dev_err(&amp;iio_dev-&gt;dev, \"Only %d signal edges detected\\n\", dht11-&gt;num_edges); ret = -ETIMEDOUT; &#125; if (ret &lt; 0) goto err; ret = dht11_decode(dht11, dht11-&gt;num_edges == DHT11_EDGES_PER_READ ? DHT11_EDGES_PREAMBLE : DHT11_EDGES_PREAMBLE - 2); if (ret) goto err; &#125; ret = IIO_VAL_INT; if (chan-&gt;type == IIO_TEMP) *val = dht11-&gt;temperature; else if (chan-&gt;type == IIO_HUMIDITYRELATIVE) *val = dht11-&gt;humidity; else ret = -EINVAL;err: dht11-&gt;num_edges = -1; mutex_unlock(&amp;dht11-&gt;lock); return ret;&#125;static const struct iio_info dht11_iio_info = &#123; .driver_module = THIS_MODULE, .read_raw = dht11_read_raw,&#125;;static const struct iio_chan_spec dht11_chan_spec[] = &#123; &#123; .type = IIO_TEMP, .info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED), &#125;, &#123; .type = IIO_HUMIDITYRELATIVE, .info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED), &#125;&#125;;static const struct of_device_id dht11_dt_ids[] = &#123; &#123; .compatible = \"dht11\", &#125;, &#123; &#125;&#125;;MODULE_DEVICE_TABLE(of, dht11_dt_ids);static int dht11_probe(struct platform_device *pdev)&#123; struct device *dev = &amp;pdev-&gt;dev; struct device_node *node = dev-&gt;of_node; struct dht11 *dht11; struct iio_dev *iio; int ret; iio = devm_iio_device_alloc(dev, sizeof(*dht11)); if (!iio) &#123; dev_err(dev, \"Failed to allocate IIO device\\n\"); return -ENOMEM; &#125; dht11 = iio_priv(iio); dht11-&gt;dev = dev; dht11-&gt;gpio = ret = of_get_gpio(node, 0); if (ret &lt; 0) return ret; ret = devm_gpio_request_one(dev, dht11-&gt;gpio, GPIOF_IN, pdev-&gt;name); if (ret) return ret; dht11-&gt;irq = gpio_to_irq(dht11-&gt;gpio); if (dht11-&gt;irq &lt; 0) &#123; dev_err(dev, \"GPIO %d has no interrupt\\n\", dht11-&gt;gpio); return -EINVAL; &#125; dht11-&gt;timestamp = iio_get_time_ns() - DHT11_DATA_VALID_TIME - 1; dht11-&gt;num_edges = -1; platform_set_drvdata(pdev, iio); init_completion(&amp;dht11-&gt;completion); mutex_init(&amp;dht11-&gt;lock); iio-&gt;name = pdev-&gt;name; iio-&gt;dev.parent = &amp;pdev-&gt;dev; iio-&gt;info = &amp;dht11_iio_info; iio-&gt;modes = INDIO_DIRECT_MODE; iio-&gt;channels = dht11_chan_spec; iio-&gt;num_channels = ARRAY_SIZE(dht11_chan_spec); return devm_iio_device_register(dev, iio);&#125;static struct platform_driver dht11_driver = &#123; .driver = &#123; .name = DRIVER_NAME, .of_match_table = dht11_dt_ids, &#125;, .probe = dht11_probe,&#125;;module_platform_driver(dht11_driver);MODULE_AUTHOR(\"Harald Geyer &lt;harald@ccbib.org&gt;\");MODULE_DESCRIPTION(\"DHT11 humidity/temperature sensor driver\");MODULE_LICENSE(\"GPL v2\"); 2.3 自己驱动2.3.1 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271//cat /sys/class/hwmon/hwmon0/device/temperature#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;linux/of_gpio.h&gt;#include &lt;linux/platform_device.h&gt; #include &lt;linux/hwmon.h&gt;#include &lt;linux/hwmon-sysfs.h&gt;#include &lt;linux/irqflags.h&gt;#include &lt;linux/wait.h&gt;#include &lt;linux/sched.h&gt;struct dh11 &#123; struct device *hwmon_dev; struct mutex lock; int da_pin; u8 value[5]; u8 humdity; u8 temperature; struct timer_list timer; struct work_struct work;&#125;;static struct dh11 dh;static unsigned char read_byte(void) &#123; unsigned char i, count, dat = 0; unsigned long flags; local_irq_save(flags); //Save interrupt for(i=0; i&lt;8; i++) &#123; count = 0; while(0 == gpio_get_value(dh.da_pin)) //Waiting for 50us low level end &#123; udelay(5); count ++; if (count &gt; 20) goto time_out; &#125; udelay(30); //Delay 30us, if it is still high, the data is 1, otherwise it is 0. dat &lt;&lt;= 1; if(gpio_get_value(dh.da_pin)) dat += 1; while(gpio_get_value(dh.da_pin)) //Waiting low level end &#123; udelay(5); count ++; if (count &gt; 20) goto time_out; &#125; &#125; local_irq_restore(flags); return dat; time_out: local_irq_restore(flags); return 0; &#125;//Work queue callback function for read DH11static void dh11_work_callback(struct work_struct *work)&#123; int i, count; mutex_lock(&amp;dh.lock); //Start signal gpio_direction_output(dh.da_pin, 1); udelay(2); gpio_direction_output(dh.da_pin, 0); mdelay(20); //Low level hold time cannot be less than 18ms gpio_direction_output(dh.da_pin, 1); //Pull up 20-40us udelay(40); gpio_direction_input(dh.da_pin); if (0 == gpio_get_value(dh.da_pin)) //Read response signal &#123; count = 0; while(0 == gpio_get_value(dh.da_pin)) //Waiting for the response signal to end(80us) &#123; udelay(5); count ++; if (count &gt; 20) goto time_out; &#125; count = 0; while(1 == gpio_get_value(dh.da_pin)) //Waiting for DH11 to pull up end(80us) &#123; udelay(5); count ++; if (count &gt; 20) goto time_out; &#125; for (i=0; i&lt;5; i++) //Start reading 40 bits of data dh.value[i] = read_byte(); &#125; else printk(KERN_WARNING\"DH11 response error.\\n\"); //checksum if ((dh.value[0] + dh.value[1] + dh.value[2] + dh.value[3]) == dh.value[4]) &#123; dh.humdity = dh.value[0]; dh.temperature = dh.value[2]; &#125; else printk(KERN_WARNING\"DHT11 checksum error.\\n\"); mutex_unlock(&amp;dh.lock); return;time_out: printk(KERN_WARNING\"DH11 timeout error.\\n\"); mutex_unlock(&amp;dh.lock); return;&#125;//Timercallback function for callback work queue static void dh11_timer_callback(unsigned long data)&#123; schedule_work(&amp;dh.work); mod_timer(&amp;dh.timer, jiffies + (1200 * HZ/1000)); //Modify a timer's timeout&#125;static ssize_t dh11_get_sensor_value(struct device *dev, struct device_attribute *devattr, char *buf)&#123; int ret = -1; struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr); switch(attr-&gt;index) &#123; case 0: ret = sprintf(buf, \"%d\\n\", dh.humdity); break; case 1: ret = sprintf(buf, \"%d\\n\", dh.temperature); break; default: break; &#125; return ret;&#125;static struct sensor_device_attribute dh11_temp_attr[] = &#123; SENSOR_ATTR(humdity, S_IRUGO, dh11_get_sensor_value, NULL, 0), SENSOR_ATTR(temperature, S_IRUGO, dh11_get_sensor_value, NULL, 1),&#125;; static int dh11_probe(struct platform_device *pdev)&#123; int status, i; //printk(KERN_INFO\"%s OK.\\n\",__func__); dh.da_pin = of_get_named_gpio(pdev-&gt;dev.of_node, \"da-gpio\", 0); status = gpio_request(dh.da_pin, \"dh11_da_pin\"); if (status) &#123; dev_err(&amp;pdev-&gt;dev, \"gpio_request() fail.\\n\"); return -EBUSY; &#125; mutex_init(&amp;dh.lock); mutex_lock(&amp;dh.lock); dev_set_drvdata(&amp;pdev-&gt;dev, &amp;dh); for (i=0; i&lt;(sizeof(dh11_temp_attr)/sizeof(struct sensor_device_attribute)); i++) &#123; status = device_create_file(&amp;pdev-&gt;dev, &amp;dh11_temp_attr[i].dev_attr); if (status) &#123; dev_err(&amp;pdev-&gt;dev, \"device_create_file() failed.\\n\"); goto fail_crete_file; &#125; &#125; dh.hwmon_dev = hwmon_device_register(&amp;pdev-&gt;dev); if (IS_ERR(dh.hwmon_dev)) &#123; dev_err(&amp;pdev-&gt;dev, \"hwmon_device_register() fail.\\n\"); status = PTR_ERR(dh.hwmon_dev); goto fail_device_register; &#125; //Timer init_timer(&amp;dh.timer); dh.timer.function = dh11_timer_callback; dh.timer.expires = jiffies + (1200 * HZ/1000); //1.2s (must &gt; 1s) dh.timer.data = ((unsigned long)0); add_timer(&amp;dh.timer); //Workqueue INIT_WORK(&amp;dh.work, dh11_work_callback); mutex_unlock(&amp;dh.lock); return 0; fail_device_register: hwmon_device_unregister(dh.hwmon_dev); fail_crete_file: for (i--; i&gt;=0; i--) device_remove_file(&amp;pdev-&gt;dev, &amp;dh11_temp_attr[i].dev_attr); dev_set_drvdata(&amp;pdev-&gt;dev, NULL); gpio_free(dh.da_pin); del_timer(&amp;dh.timer); cancel_work_sync(&amp;dh.work); mutex_unlock(&amp;dh.lock); return status;&#125; static int dh11_remove(struct platform_device *pdev)&#123; int i; mutex_lock(&amp;dh.lock); hwmon_device_unregister(dh.hwmon_dev); for (i=0; i&lt;(sizeof(dh11_temp_attr)/sizeof(struct sensor_device_attribute)); i++) device_remove_file(&amp;pdev-&gt;dev, &amp;dh11_temp_attr[i].dev_attr); dev_set_drvdata(&amp;pdev-&gt;dev, NULL); gpio_free(dh.da_pin); del_timer(&amp;dh.timer); cancel_work_sync(&amp;dh.work); mutex_unlock(&amp;dh.lock); return 0;&#125;static const struct of_device_id dh11_of_match[] = &#123; &#123; .compatible = \"aosong,dh11\", .data = NULL &#125;, &#123; /* sentinel */ &#125;&#125;;static struct platform_driver dh11_drv = &#123; .probe = dh11_probe, .remove = dh11_remove, .driver = &#123; .name = \"dh11_drv\", .owner = THIS_MODULE, .of_match_table = of_match_ptr(dh11_of_match), &#125;,&#125;;module_platform_driver(dh11_drv);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am335x board dh11 driver.\");MODULE_VERSION(\"v1.0\"); 因为DH11的采样周期长达1S，如果应用层稍微读快一点，就会报错比较明显。因此，这里采取的方案是，驱动设置个定时器每隔一定时间，不断读取传感器，保存数据。应用层读取的是不久前驱动才缓存下的数据。 因此在probe()函数里，先设置了一个定时器:123456//Timerinit_timer(&amp;dh.timer);dh.timer.function = dh11_timer_callback;dh.timer.expires = jiffies + (1200 * HZ/1000); //1.2s (must &gt; 1s)dh.timer.data = ((unsigned long)0);add_timer(&amp;dh.timer);定时器每隔1.2s调用dh11_timer_callback()函数。 再设置了一个工作队列：1INIT_WORK(&amp;dh.work, dh11_work_callback);将dh11_work_callback()函数加入到工作队列里。 dh11_timer_callback()里使用schedule_work()读取DH11数据并重新设置定时器周期反复。 定时器、工作队列的补充知识参考博客。 2.3.2 设备树12345678910111213141516 dh11 &#123; compatible = \"aosong,dh11\"; da-gpio = &lt;&amp;gpio0 12 0&gt;; pinctrl-0 = &lt;&amp;dh11_da_pin&gt;; &#125;; ……&amp;am33xx_pinmux &#123; dh11_da_pin: dh11_da_pin0 &#123; pinctrl-single,pins = &lt; 0x178 (PIN_INPUT_PULLDOWN | MUX_MODE7) /* conf_uart1_ctsn.gpio0_12 */ &gt;; &#125;;&#125;; 2.3.3 应用测试 3. IrDA3.1 基础知识3.1.1 红外原理当遥控器按下不同的按键时，遥控器上的红外发射头，会发出人眼看不到(可通过手机摄像头看到)的光波给模块上的红外接收端。红外接收端收到光波后，会在IRD引脚上产生相应的电平，通过对电平解析，就知道是按的遥控器哪一个键。 3.1.2 数据格式按键一次的接收到数据结构如下，可以分解成五部分：引导码/连发码、系统码1、系统码2、数据码、数据反码。 3.1.3 引导码/连发码最开始的一部分是用来判断是否是连按操作和表示信号开始，分为引导码和连发码。如果是第一按下或非连按，就是先9ms低电平，再4.5ms的高电平，后面接32Bits数据；如果一直按着该键不放，下一个周期就发送的是连发码，先9ms低电平，再只有2.25ms的高电平，后面接32Bits数据； 3.1.4 数据电平数据0和1前面都是0.56ms的低电平，那么就是后面的高电平持续时间不同，0为0.56ms，1为1.685ms 3.2 内核驱动内核中自带红外遥控器的驱动，但没有我使用的遥控器布局文件。drivers/medi/rc/gpio-ir-recv.c是GPIO模拟红外遥控驱动。drivers/media/rc/keymaps/下是遥控器键盘布局文件。 3.2.1 加入内核123456Device Drivers ---&gt; &lt;*&gt; Multimedia support ---&gt; [*] Remote Controller support [*] Remote controller decoders (NEW) ---&gt; [*] Remote Controller devices ---&gt; &lt;*&gt; GPIO IR remote control 3.2.2 添加键盘布局[rc-hceng-nec.c]1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;media/rc-map.h&gt;#include &lt;linux/module.h&gt;static struct rc_map_table hceng_nec[] = &#123; &#123; 0x45, KEY_CHANNELDOWN&#125;, &#123; 0x46, KEY_CHANNEL&#125;, &#123; 0x47, KEY_CHANNELUP&#125;, &#123; 0x44, KEY_PREVIOUS&#125;, &#123; 0x40, KEY_NEXT&#125;, &#123; 0x43, KEY_PLAYPAUSE&#125;, // &#123; 0x07, KEY_VOLUMEDOWN&#125;, &#123; 0x15, KEY_VOLUMEUP&#125;, &#123; 0x09, KEY_EQUAL&#125;, &#123; 0x16, KEY_0&#125;, &#123; 0x19, KEY_F1&#125;, &#123; 0x0d, KEY_F2&#125;, &#123; 0x0c, KEY_1&#125;, &#123; 0x18, KEY_2&#125;, &#123; 0x5e, KEY_3&#125;, &#123; 0x08, KEY_4&#125;, &#123; 0x1c, KEY_5&#125;, &#123; 0x5a, KEY_6&#125;, &#123; 0x42, KEY_7&#125;, &#123; 0x52, KEY_8&#125;, // &#123; 0x4a, KEY_9&#125;,&#125;;static struct rc_map_list hceng_nec_map = &#123; .map = &#123; .scan = hceng_nec, .size = ARRAY_SIZE(hceng_nec), .rc_type = RC_TYPE_NEC, //RC_TYPE_UNKNOWN //echo nec &gt; /sys/class/rc/rc0/protocols .name = \"rc-hceng-nec\", &#125;&#125;;static int __init init_rc_map_hceng_nec(void)&#123; return rc_map_register(&amp;hceng_nec_map);&#125;static void __exit exit_rc_map_hceng_nec(void)&#123; rc_map_unregister(&amp;hceng_nec_map);&#125;module_init(init_rc_map_hceng_nec)module_exit(exit_rc_map_hceng_nec)MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng\"); 将rc-hceng-nec.c放在drivers/media/rc/keymaps/下，并修改Makefile，加入rc-hceng-nec.o。 3.2.3 修改设备树12345ir: ir-receiver &#123; compatible = \"gpio-ir-receiver\"; gpios = &lt;&amp;gpio0 12 1&gt;; linux,rc-map-name = \"rc-hceng-nec\";&#125;; 3.2.4 应用测试测试程序：12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;linux/input.h&gt; int main() &#123; int fd; int version; int ret; struct input_event ev; fd = open(\"/dev/input/event0\", O_RDONLY); if (fd &lt; 0) &#123; printf(\"open file failed\\n\"); exit(1); &#125; ioctl(fd, EVIOCGVERSION, &amp;version); printf(\"evdev driver version is 0x%x: %d.%d.%d\\n\", version, version&gt;&gt;16, (version&gt;&gt;8) &amp; 0xff, version &amp; 0xff); while (1) &#123; ret = read(fd, &amp;ev, sizeof(struct input_event)); if (ret &lt; 0) &#123; printf(\"read event error!\\n\"); exit(1); &#125; if (ev.type == EV_KEY) printf(\"type %d,code %d, value %d\\n\", ev.type, ev.code, ev.value); &#125; return 0; &#125; 3.2.5 其它 码值关系遥控器产生一个原始数据码，rc-hceng-nec里，将原始数据码和输入子系统中的按键编号进行对应，最后用户态读到的code是输入子系统中的按键编号值。比如： 12原始数据码 -------&gt; 按键编号 --------&gt;用户层读取0x16 KEY_0/11 11 打印原始数据修改drivers/media/rc/ir-nec-decoder.c，添加打印: 123456183 &#125; else &#123;184 /* Normal NEC */185 scancode = address &lt;&lt; 8 | command;186 //IR_dprintk(1, \"NEC scancode 0x%04x\\n\", scancode);187 printk(\"NEC scancode 0x%04x\\n\", scancode);188 &#125; 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"AM335X","slug":"AM335X","permalink":"http://yoursite.com/tags/AM335X/"},{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"hwmon子系统","slug":"hwmon子系统","permalink":"http://yoursite.com/tags/hwmon子系统/"},{"name":"input子系统","slug":"input子系统","permalink":"http://yoursite.com/tags/input子系统/"}]},{"title":"AM335X——hwmon和input子系统","date":"2019-01-18T13:23:41.000Z","path":"2019/01/18/AM335X——hwmon和input子系统/","text":"记录两个SPI设备分别采用hwmon子系统和input子系统。刚开始学Linux驱动的时候，就看了input子系统，现在都忘得差不多了，不过回忆起来也还快，这里再记录一下。 为什么要用各种子系统框架，就目前的理解，一是为了向应用层提供统一的接口，二是简化了编写驱动的流程。各种子系统它们是通过一层一层的函数传递与封装，实现了设备驱动的注册，定义了file_operations结构体里面的各种函数操作，不需要在单独的设备驱动代码中进行注册、定义，直接调用相应的的子系统即可。 1. hwmon子系统简介hwmon即硬件监控(Hardware monitor)，它是用于检测设备状态的一类传感器设备接口，比如CPU温度、风扇转速、模数转换等。 Hwmon子系统的核心代码是drivers/hwmon/hwmon.c。通过同路径下的Kconfig文件，可以得知它在make menuconfig中的配置名字为Hardware Monitoring support。通过hwmon.c中的EXPORT_SYMBOL_GPL()符号，可知对外提供如下几组接口函数：12345hwmon_device_register_with_groups() / hwmon_device_register()hwmon_device_unregister()devm_hwmon_device_register_with_groups()devm_hwmon_device_unregister() 1.1 AD7705简介AD7705是十六位分辨率的A/D转换器,2个通道全差分模拟输入。内部有8个寄存器，常用的就Communication Register、Setup register、Clock register、Data register。在每次做任何操作前，都要写Communication Register来设置即将操作的是哪一个寄存器、是读还是写操作、操作哪一个通道。其操作流程如下： 拉低复位引脚，硬件复位； 在至少32个时钟周期里连续发送高脉冲，以同步时钟； 配置AD7705时钟(时钟源、分频系数等)； 自校准，并等待就绪引脚拉低； 从数据寄存器里读取数据； 1.2 完整代码及效果 设备树： [am335x-evm.dts]12345spidev@0 &#123; compatible = \"titan,ad7705\"; spi-max-frequency = &lt;2500000&gt;; reg = &lt;2&gt;; &#125;; 驱动代码： [ad7705_drv.c]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;linux/spi/spi.h&gt;#include &lt;linux/hwmon.h&gt;#include &lt;linux/hwmon-sysfs.h&gt;#define CHANNEL_NUM (2) //AD7705 channel number#define DRDY_PIN (12) //AD7705 DRDY Pin(GPIO0_12)#define RESET_PIN (13) //AD7705 RESET Pin(GPIO0_13)//Communication Registerenum &#123; REG_COMM = (0 &lt;&lt; 4), //Communication Register RS2:RS1:RS0 = [0:0:0] REG_SETUP = (1 &lt;&lt; 4), //Setup register RS2:RS1:RS0 = [0:0:1] REG_CLOCK = (2 &lt;&lt; 4), //Clock register RS2:RS1:RS0 = [0:1:0] REG_DATA = (3 &lt;&lt; 4), //Data register RS2:RS1:RS0 = [0:1:1] REG_TEST = (4 &lt;&lt; 4), //Test register RS2:RS1:RS0 = [1:0:0] REG_RESE = (5 &lt;&lt; 4), //No operation RS2:RS1:RS0 = [1:0:1] REG_OFFSET = (6 &lt;&lt; 4), //Offset register RS2:RS1:RS0 = [1:1:0] REG_GAIN = (7 &lt;&lt; 4), //Gain register RS2:RS1:RS0 = [1:1:1] CMD_WRITE = (0 &lt;&lt; 3), //write operation CMD_READ = (1 &lt;&lt; 3), //read operation CH_1 = 0, //Register Pair 0 (AIN1+ AIN1-) CH_2 = 1, //Register Pair 1 (AIN2+ AIN2-) CH_3 = 2, //Register Pair 0 (AIN1- AIN1-) CH_4 = 3 //Register Pair 2 (AIN1- AIN2-)&#125;;//Setup registerenum&#123; MD_NORMAL = (0 &lt;&lt; 6), //Normal Mode. MD_CAL_SELF = (1 &lt;&lt; 6), //Self-Calibration MD_CAL_ZERO = (2 &lt;&lt; 6), //Zero-Scale System Calibration MD_CAL_FULL = (3 &lt;&lt; 6), //Full-Scale System Calibration GAIN_1 = (0 &lt;&lt; 3), //Gain 1 GAIN_2 = (1 &lt;&lt; 3), //Gain 2 GAIN_4 = (2 &lt;&lt; 3), //Gain 4 GAIN_8 = (3 &lt;&lt; 3), //Gain 8 GAIN_16 = (4 &lt;&lt; 3), //Gain 16 GAIN_32 = (5 &lt;&lt; 3), //Gain 32 GAIN_64 = (6 &lt;&lt; 3), //Gain 64 GAIN_128 = (7 &lt;&lt; 3), //Gain 128 BIPOLAR = (0 &lt;&lt; 2), //Bipolar Operation UNIPOLAR = (1 &lt;&lt; 2), //Unipolar Operation BUF_NO = (0 &lt;&lt; 1), //Buffer Control Off BUF_EN = (1 &lt;&lt; 1), //Buffer Control On FSYNC_0 = (0 &lt;&lt; 0), //Filter Synchronization Normal FSYNC_1 = (1 &lt;&lt; 0) //Filter Synchronization Disable&#125;;//Clock registerenum&#123; CLKDIS_0 = (0 &lt;&lt; 4), //Master Clock Enable (Use crystal clock source) CLKDIS_1 = (1 &lt;&lt; 4), //Master Clock Disable(Use an external clock source) CLKDIV_0 = (0 &lt;&lt; 3), //Clock Divider 0 CLKDIV_1 = (1 &lt;&lt; 3), //Clock Divider 2 (4.9152Mhz/2=2.4576Mhz) CLK_0 = (0 &lt;&lt; 2), //Clock Bit(If master clock 1MHz(CLKDIV = 0) or 2MHz(CLKDIV = 1)) CLK_1 = (1 &lt;&lt; 2), //Clock Bit(If master clock 2.4576MHz(CLKDIV = 0) or 4.9152MHz(CLKDIV = 1)) //If Clock Bit = 0 UPDATE_20 = (0 &lt;&lt; 0), //Filter Selection Bits UPDATE_25 = (1 &lt;&lt; 0), UPDATE_100 = (2 &lt;&lt; 0), UPDATE_200 = (3 &lt;&lt; 0), //If Clock Bit = 1 UPDATE_50 = (0 &lt;&lt; 0), //Filter Selection Bits UPDATE_60 = (1 &lt;&lt; 0), UPDATE_250 = (2 &lt;&lt; 0), UPDATE_500 = (3 &lt;&lt; 0)&#125;;struct ad7705 &#123; struct device *hwmon_dev; struct mutex lock; &#125;;//Resetstatic void ad7705_reset(void)&#123; gpio_direction_output(RESET_PIN, 1); msleep(1); gpio_direction_output(RESET_PIN, 0); msleep(2); gpio_direction_output(RESET_PIN, 1); msleep(1);&#125;//Synchronous SPI timingstatic void ad7705_sync_spi(struct spi_device *spi)&#123; u8 tx_buf[6]; //Write logic \"1\" to DIN for at least 32 clocks memset(tx_buf, 0xFF, sizeof(tx_buf)); spi_write(spi, tx_buf, sizeof(tx_buf)); msleep(1);&#125;//Waiting for DRDY pin signalstatic int ad7705_wait_DRDY(void)&#123; int i = 0; int time_cnt = 500*1000; for (i=0; i&lt;time_cnt; i++) &#123; if (0 == gpio_get_value(DRDY_PIN)) break; udelay(1); &#125; if (i &gt;= time_cnt) return -1; else return 0;&#125;//Self-Calibrationstatic void ad7705_calib_self(struct spi_device *spi, u8 channel)&#123; u8 tx_buf[2] = &#123;0&#125;; tx_buf[0] = REG_SETUP | CMD_WRITE | channel; tx_buf[1] = MD_CAL_SELF | GAIN_1 | UNIPOLAR | BUF_EN | FSYNC_0; spi_write(spi, tx_buf, sizeof(tx_buf)); ad7705_wait_DRDY(); //Waiting for the internal operation to complete, the time is long, about 180ms msleep(50);&#125;//Initialize the specified channelstatic void ad7705_config_channel(struct spi_device *spi, u8 channel)&#123; u8 tx_buf[2] = &#123;0&#125;; tx_buf[0] = REG_CLOCK | CMD_WRITE | channel; tx_buf[1] = CLKDIS_0 | CLKDIV_1 | CLK_1 | UPDATE_50; spi_write(spi, tx_buf, sizeof(tx_buf)); ad7705_calib_self(spi, channel); &#125; //Reset and initialize the specified channelstatic void ad7705_reset_and_reconfig(struct spi_device *spi)&#123; ad7705_reset(); msleep(5); ad7705_sync_spi(spi); msleep(5); ad7705_config_channel(spi, CH_1); ad7705_config_channel(spi, CH_2);&#125;//Read the specified channel valuestatic int ad7705_read_channel(struct device *dev, u8 channel, u16 *data)&#123; struct spi_device *spi = to_spi_device(dev); struct ad7705 *adc = spi_get_drvdata(spi); int ret = -1; u16 value = 0; u8 tx_buf[1] = &#123;0&#125;; u8 rx_buf[2] = &#123;0&#125;; if (mutex_lock_interruptible(&amp;adc-&gt;lock)) return -ERESTARTSYS; if (ad7705_wait_DRDY() &lt; 0) &#123; printk(KERN_ERR \"[%s] ad7705_wait_DRDY() time out.\\n\", __FUNCTION__); goto fail; &#125; tx_buf[0] = REG_DATA | CMD_READ | channel; ret = spi_write_then_read(spi, tx_buf, sizeof(tx_buf), rx_buf, sizeof(rx_buf)); //printk(\"channel:%d rx_buf[0]=%d rx_buf[1]=%d \\n\", channel, rx_buf[0], rx_buf[1]); if (0 &gt; ret) &#123; printk(KERN_ERR \"[%s] ad7705_read_channel() fail. ret=%d\\n\", __FUNCTION__, ret); goto fail; &#125; value = (rx_buf[0] &lt;&lt; 8) + rx_buf[1];#if 0 if (0xFFFF == value) &#123; ret = -1; goto fail; &#125; #endif *data = value; fail: mutex_unlock(&amp;adc-&gt;lock); return ret;&#125;//sysfs hook function static ssize_t ad7705_get_sensor_value(struct device *dev, struct device_attribute *devattr, char *buf)&#123; struct spi_device *spi = to_spi_device(dev); struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr); u16 ad = 0; int i, ret = -1; int vol1, vol2; //After switching channels, the value of the other channel is read for the first time. for (i=0; i&lt;2; i++) &#123; ret = ad7705_read_channel(dev, attr-&gt;index, &amp;ad); continue; if (0 &gt; ret) &#123; ad7705_reset_and_reconfig(spi); return ret; &#125; &#125; #if 0 ret = sprintf(buf, \"%u\\n\", ad);#else vol1 = ad*5/65535; //Voltage integral part vol2 = (ad*5*1000/65535) - (vol1*1000);//Voltage fraction part ret = sprintf(buf, \"vol = %d.%dV\\n\",vol1, vol2);#endif return ret;&#125;static struct sensor_device_attribute ad_input[] = &#123; SENSOR_ATTR(ad7705_ch1, S_IRUGO, ad7705_get_sensor_value, NULL, CH_1), SENSOR_ATTR(ad7705_ch2, S_IRUGO, ad7705_get_sensor_value, NULL, CH_2),&#125;; static int ad7705_probe(struct spi_device *spi)&#123; struct ad7705 *adc = NULL; int i, status; adc = kzalloc(sizeof *adc, GFP_KERNEL); if (!adc) return -ENOMEM; mutex_init(&amp;adc-&gt;lock); mutex_lock(&amp;adc-&gt;lock); spi_set_drvdata(spi, adc); for (i=0; i&lt;CHANNEL_NUM; i++) &#123; status = device_create_file(&amp;spi-&gt;dev, &amp;ad_input[i].dev_attr); if (status) &#123; dev_err(&amp;spi-&gt;dev, \"device_create_file() failed.\\n\"); goto fail_crete_file; &#125; &#125; adc-&gt;hwmon_dev = hwmon_device_register(&amp;spi-&gt;dev); if (IS_ERR(adc-&gt;hwmon_dev)) &#123; dev_err(&amp;spi-&gt;dev, \"hwmon_device_register() fail.\\n\"); status = PTR_ERR(adc-&gt;hwmon_dev); goto fail_crete_file; &#125; status = gpio_request(DRDY_PIN, \"ad7705_drdy\"); //ad7705 DRDY Pin if (status) &#123; dev_err(&amp;spi-&gt;dev, \"gpio_request(AD705_DRDY_PIN) fail.\\n\"); goto fail_device_register; &#125; gpio_direction_input(DRDY_PIN); status = gpio_request(RESET_PIN, \"ad7705_reset\"); //ad7705 RESET Pin if (status) &#123; dev_err(&amp;spi-&gt;dev, \"gpio_request(RESET_PIN) fail.\\n\"); goto fail_request_drdy_pin; &#125; gpio_direction_output(RESET_PIN, 1); ad7705_reset_and_reconfig(spi); mutex_unlock(&amp;adc-&gt;lock); return 0; fail_request_drdy_pin: gpio_free(DRDY_PIN);fail_device_register: hwmon_device_unregister(adc-&gt;hwmon_dev);fail_crete_file: for (i--; i&gt;=0; i--) device_remove_file(&amp;spi-&gt;dev, &amp;ad_input[i].dev_attr); spi_set_drvdata(spi, NULL); mutex_unlock(&amp;adc-&gt;lock); kfree(adc); return status;&#125; static int ad7705_remove(struct spi_device *spi)&#123; int i; struct ad7705 *adc = spi_get_drvdata(spi); mutex_lock(&amp;adc-&gt;lock); gpio_free(DRDY_PIN); gpio_free(RESET_PIN); hwmon_device_unregister(adc-&gt;hwmon_dev); for (i=0; i&lt;CHANNEL_NUM; i++) device_remove_file(&amp;spi-&gt;dev, &amp;ad_input[i].dev_attr); spi_set_drvdata(spi, NULL); mutex_unlock(&amp;adc-&gt;lock); kfree(adc); return 0;&#125;static const struct of_device_id of_match_spi[] = &#123; &#123; .compatible = \"titan,ad7705\", .data = NULL &#125;, &#123; /* sentinel */ &#125;&#125;; static struct spi_driver ad7705_driver = &#123; .driver = &#123; .name = \"ad7705\", .owner = THIS_MODULE, .of_match_table = of_match_spi, &#125;, .probe = ad7705_probe, .remove = ad7705_remove,&#125;; module_spi_driver(ad7705_driver);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am335x board spi device: ad7705 driver.\");MODULE_VERSION(\"v1.0\"); 测试代码：因为是子系统的关系，可以在应用层使用cat /sys/class/hwmon/hwmon0/device/ad7705_ch1直接得到结果。这里再使用该节点，写了个应用程序，以便进行连续访问： [ad7705_app.c]1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt; void read_channel(char *dev_file_path)&#123; int fd = 0; int ret = 0; unsigned char buff[128] = &#123;0&#125;; fd = open(dev_file_path, O_RDONLY); if (-1 == fd) &#123; printf(\"Can't open device file fail\\n\"); return ; &#125; memset(buff, 0, 128); ret = read(fd, buff, 128); if (0 &gt; ret) &#123; printf(\"Can't read data\\n\"); &#125; printf(\"%s\", buff); close(fd);&#125; int main(void)&#123; char ch1_path[] = &#123;\"/sys/class/hwmon/hwmon0/device/ad7705_ch1\"&#125;; char ch2_path[] = &#123;\"/sys/class/hwmon/hwmon0/device/ad7705_ch2\"&#125;; //char ch1_path[] = &#123;\"/sys/bus/spi/drivers/ad7705/spi1.2/ad7705_ch1\"&#125;; //char ch2_path[] = &#123;\"/sys/bus/spi/drivers/ad7705/spi1.2/ad7705_ch2\"&#125;; while (1) &#123; read_channel(ch1_path); usleep(1000*1000); read_channel(ch2_path); usleep(1000*1000); &#125;&#125; 值得注意的是，通过read()返回的数据不再是整型数据，而是字符串，且返回的字符串样式，在驱动里定义。 效果：12345678910cat /sys/class/hwmon/hwmon0/device/ad7705_ch1vol = 2.1Vcat /sys/class/hwmon/hwmon0/device/ad7705_ch2vol = 0.0V./ad7705_appvol = 2.1Vvol = 0.0V 1.3 详细分析1.3.1 驱动与设备树匹配ad7705_drv.c和am335x-evm.dts各自中的compatible属性名字相同时，即调用probe()函数，进入一切的开端。 1.3.2 设置结构体这里定义了一个ad7705的结构体，包含设备指针和互斥锁。1234struct ad7705 &#123; struct device *hwmon_dev; struct mutex lock; &#125;;在probe()里定义和分配该结构体：12345struct ad7705 *adc = NULL;adc = kzalloc(sizeof *adc, GFP_KERNEL);if (!adc) return -ENOMEM;补充下内核中内存申请的相关知识：内核中常用的内存申请函数有：kmalloc()、kzalloc()、vmalloc()： void *kmalloc(size_t size, gfp_t flags)； void kfree(const void *objp); kmalloc()申请的内存位于物理内存映射区域，而且在物理上也是连续的，它们与真实的物理地址只有一个固定的偏移，因为存在较简单的转换关系，所以对申请的内存大小有限制，不能超过128KB。 常用的flags： GFP_ATOMIC —— 分配内存的过程是一个原子过程，分配内存的过程不会被（高优先级进程或中断）打断； GFP_KERNEL —— 正常分配内存； GFP_DMA —— 给 DMA 控制器分配内存，需要使用该标志（DMA要求分配虚拟地址和物理地址连续； void *kzalloc(size_t size, gfp_t flags); void kfree(const void *objp); kzalloc()就是调用的kmalloc()，多加了个__GFP_ZERO标志，即分配内存的时候还会将其清零； 常用的flags： 同kmalloc()。 void *vmalloc(unsigned long size); void vfree(const void *addr); vmalloc()会在虚拟内存空间给出一块连续的内存区，但这片连续的虚拟内存在物理内存中并不一定连续。由于vmalloc()没有保证申请到的是连续的物理内存，因此对申请的内存大小没有限制，如果需要申请较大的内存空间就可以用此函数了。vmalloc()和vfree()可以睡眠，因此不能从中断上下文调用。 1.3.3 设置互斥锁为了并发控制，加入互斥锁独占资源。我好像写驱动都没加锁的习惯，以后改正。互斥锁的使用比较简单，先初始化，再加锁，执行要做的内容，最后解锁。1234 mutex_init(&amp;adc-&gt;lock); mutex_lock(&amp;adc-&gt;lock); …… mutex_unlock(&amp;adc-&gt;lock); 1.3.4 设置私有变量将定义的ad7705结构体adc，保存到spi_device:1spi_set_drvdata(spi, adc);后面其它函数就可以通过device得到spi_device，再提取到私有数据：12struct spi_device *spi = to_spi_device(dev);struct ad7705 *adc = spi_get_drvdata(spi); 1.3.5 创建sysfs属性文件首先解释一下sysfs：sysfs是Linux所提供的一种虚拟档案系统；在设备模型中，sysfs文件系统用来表示设备的结构，将设备的层次结构形象的反应到用户空间中，从而可以通过修改sysfs中的文件属性来修改设备的属性值；sysfs被挂载到根目录下的/sys文件夹下。 使用函数device_create_file()将会调用到sysfs_create_file()，将在/sys/class/hwmon/下创建文件夹，并按照hwmon0、hwmon1、hwmon2等顺序编号 第二个参数是struct device_attribute结构体，通过定义的sensor_device_attribute结构体成员传给它。1234static struct sensor_device_attribute ad_input[] = &#123; SENSOR_ATTR(ad7705_ch1, S_IRUGO, ad7705_get_sensor_value, NULL, CH_1), SENSOR_ATTR(ad7705_ch2, S_IRUGO, ad7705_get_sensor_value, NULL, CH_2),&#125;;参数含义分别是节点名字、节点访问权限(S_IRUGO:用户、组、其它成员都可读)、读函数(cat命令时将调用)、写函数(echo命令时将调用)、索引。 1.3.6 实现device_attribute的函数前面的sensor_device_attribute只提供了读函数ad7705_get_sensor_value，并未提供写函数NULL，这里就只实现读函数即可。123456789101112131415161718192021222324252627282930static ssize_t ad7705_get_sensor_value(struct device *dev, struct device_attribute *devattr, char *buf)&#123; struct spi_device *spi = to_spi_device(dev); struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr); u16 ad = 0; int i, ret = -1; int vol1, vol2; //After switching channels, the value of the other channel is read for the first time. for (i=0; i&lt;2; i++) &#123; ret = ad7705_read_channel(dev, attr-&gt;index, &amp;ad); continue; if (0 &gt; ret) &#123; ad7705_reset_and_reconfig(spi); return ret; &#125; &#125; #if 0 ret = sprintf(buf, \"%u\\n\", ad);#else vol1 = ad*5/65535; //Voltage integral part vol2 = (ad*5*1000/65535) - (vol1*1000);//Voltage fraction part ret = sprintf(buf, \"vol = %d.%dV\\n\",vol1, vol2);#endif return ret;&#125;AD7705有两个ADC通道，它们都调用ad7705_get_sensor_value()，但通过sensor_device_attribute结构体中的index成员，将会读指定通道值。sprintf()将指定格式的数据传给用户层。 1.3.7 注册hwmon子系统使用hwmon_device_register注册hwmon设备。 1.3.8 引脚GPIO初始化AD7705除了SPI引脚，还用到了一个就绪引脚和复位引脚。这两个脚的信息可以从设备树中指定，再获取，这里直接写死在驱动里面了。123456789101112131415status = gpio_request(DRDY_PIN, \"ad7705_drdy\"); //ad7705 DRDY Pinif (status)&#123; dev_err(&amp;spi-&gt;dev, \"gpio_request(AD705_DRDY_PIN) fail.\\n\"); goto fail_device_register;&#125;gpio_direction_input(DRDY_PIN);status = gpio_request(RESET_PIN, \"ad7705_reset\"); //ad7705 RESET Pinif (status)&#123; dev_err(&amp;spi-&gt;dev, \"gpio_request(RESET_PIN) fail.\\n\"); goto fail_request_drdy_pin;&#125;gpio_direction_output(RESET_PIN, 1);GPIO常见的操作: 1.判断引脚是否合法 int gpio_is_valid(int number);2.申请该引脚 int gpio_request(unsigned gpio, const char *label);3.设置为输入还是输出 int gpio_direction_input(unsigned gpio); int gpio_direction_output(unsigned gpio, int value);4.获取/设置引脚电平 int gpio_get_value(unsigned gpio); void gpio_set_value(unsigned gpio, int value);5.申请作为中断引脚/释放中断 int gpio_to_irq(unsigned gpio); void free_irq(unsigned int irq, void *dev_id);6.导出到用户态(/sys/class/gpio/gpioN) int gpio_export(unsigned gpio, bool direction_may_change); void gpio_unexport(unsigned gpio); 1.3.9 复位和配置AD7705调用ad7705_reset()硬件复位，调用ad7705_sync_spi()同步下时钟，调用ad7705_config_channel()配置时钟和自校准。 2. input子系统简介输入子系统是对不同类型的输入设备进行统一处理的驱动程序。一个输入事件，如按键，是通过设备驱动层-&gt;系统核心层-&gt;事件处理层-&gt;用户空间的顺序到达用户空间并传给应用程序使用。 Input子系统由设备驱动层、系统核心层、事件处理层三部分组成。事件处理层的驱动程序叫事件驱动程序，它负责和应用程序的接口，其内容是标准的，对所有输入设备都可用，就不需要我们编写了。设备驱动层的驱动程序叫设备驱动程序，它负责和底层输入设备的通信，需要我们自己编写。 2.1 ADXL345简介ADXL345是一款小而薄的超低功耗3轴加速度计，分辨率为13位，测量范围达±16g。数字输出数据为16位二进制补码格式，可通过SPI(3线或4线)或I2C数字接口访问。芯片默认是SPI四线模式，且CPHA=1 CPOL=1，也就是一般SPI的模式3。但我使用的ADXL345模块默认是I2C接口，即把12脚SDO接地了，如果使用SPI接口，需要去掉R4这个0欧电阻。 关于ADXL345的使用目的，目前能想到这几个：1、读取加速度(加速度是矢量，既有大小又有方向)，估计某些场合需要这个参数；2、让ADXL345处于睡眠状态，当被摇动时候，触发最大阈值，从睡眠模式唤醒并从中断引脚输出高电平唤醒主控；3、根据加速度计算得到角度值，进行屏幕翻转判定等； Linux内核中自带ADXL345驱动，路径为：1234drivers/input/misc/adxl34x-i2c.cdrivers/input/misc/adxl34x-spi.cdrivers/input/misc/adxl34x.c ADI的官网有对该驱动使用、测试方法有详细介绍。 2.2 代码框架介绍以SPI接口为例，先理一下代码的框架，图中最左边有是设备驱动模型中的设备，可以由设备树或者C文件提供。它们目的都是向adxl34x-spi.c提供时钟速度、片选引脚、中断引脚、SPI模式等信息。 如果是设备树，就得修改下adxl34x-spi.c和am335x-evm.dts，使各自中的compatible属性匹配，从而调用adxl34x-spi.c中的probe()函数。如果是C文件，就需要自己创建个board_info.c文件，填充spi_board_info内容，并注册。这里注意目前的内核已经没有将注册函数spi_register_board_info()导出，不能使用，可以通过spi_busnum_to_master()、spi_new_device()的方式注册。最后spi_board_info中的.modalias和spi_driver中的.name名字匹配，则调用adxl34x-spi.c中的probe()函数。 12345678910111213141516static int spi_info_init(void)&#123; struct spi_master *master = NULL; struct spi_device *device = NULL; master = spi_busnum_to_master(am335x_spi1_slave_info-&gt;bus_num); if (!master) return -EINVAL; device = spi_new_device(master, am335x_spi1_slave_info); if (!device) return -EINVAL; return 0; //return spi_register_board_info(am335x_spi1_slave_info, ARRAY_SIZE(am335x_spi1_slave_info));&#125; 然后中间的是设备驱动模型中的驱动，它可以看成三部分：1、在probe()中调用adxl34x.c中的adxl34x_probe()；2、提供read()、write()函数；3、调用adxl34x.c的电源管理相关函数，支持电源管理模型；如果使用I2C接口，其目的还是一样的。 最右边的就是ADXL345的具体操作内容，也是后面详细分析的重点。 2.3 完整代码及效果 驱动部分：adxl34x-spi.c和adxl34x.c的完整代码就没必要贴了。这里使用的设备树提供设备信息，只稍微的修改了点adxl34x-spi.c的内容：123456789101112131415static const struct of_device_id of_match_spi[] = &#123; &#123; .compatible = \"adi,adxl34x\", .data = NULL &#125;, &#123; /* sentinel */ &#125;&#125;; static struct spi_driver adxl34x_driver = &#123; .driver = &#123; .name = \"adxl34x\", .owner = THIS_MODULE, .pm = &amp;adxl34x_spi_pm, .of_match_table = of_match_spi, &#125;, .probe = adxl34x_spi_probe, .remove = adxl34x_spi_remove,&#125;; 设备树部分： 12345678910spidev@0 &#123; compatible = \"adi,adxl34x\"; spi-max-frequency = &lt;2500000&gt;; reg = &lt;0&gt;; interrupt-parent = &lt;&amp;gpio0&gt;; interrupts = &lt;12 IRQ_TYPE_LEVEL_HIGH&gt;; spi-cpha = &lt;1&gt;; spi-cpol = &lt;1&gt;;&#125;; AM335X设备树中断的写法有两种，可以参考Documentation/devicetree/bindings/interrupt-controller/interrupts.txt。这里interrupt-parent指定使用那个GPIO中断控制器，interrupts属性第一个值为该组引脚中的引脚号，第二个为中断触发电平。 测试程序：有两个开源的程序可用来读取input event事件的值，evtest与getevent(这个是从android中提取的)。如下是evtest源码，前面的ADI官网链接也使用了该测试程序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412/* * $Id: evtest.c,v 1.23 2005/02/06 13:51:42 vojtech Exp $ * * Copyright (c) 1999-2000 Vojtech Pavlik * * Event device test program *//* * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA * * Should you need to contact me, the author, you can do so either by * e-mail - mail your message to &lt;vojtech@ucw.cz&gt;, or by paper mail: * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic */#include &lt;stdint.h&gt;#include &lt;linux/input.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#ifndef EV_SYN#define EV_SYN 0#endifchar *events[EV_MAX + 1] =&#123; [0 ... EV_MAX] = NULL, [EV_SYN] = \"Sync\", [EV_KEY] = \"Key\", [EV_REL] = \"Relative\", [EV_ABS] = \"Absolute\", [EV_MSC] = \"Misc\", [EV_LED] = \"LED\", [EV_SND] = \"Sound\", [EV_REP] = \"Repeat\", [EV_FF] = \"ForceFeedback\", [EV_PWR] = \"Power\", [EV_FF_STATUS] = \"ForceFeedbackStatus\",&#125;;char *keys[KEY_MAX + 1] =&#123; [0 ... KEY_MAX] = NULL, [KEY_RESERVED] = \"Reserved\", [KEY_ESC] = \"Esc\", [KEY_1] = \"1\", [KEY_2] = \"2\", [KEY_3] = \"3\", [KEY_4] = \"4\", [KEY_5] = \"5\", [KEY_6] = \"6\", [KEY_7] = \"7\", [KEY_8] = \"8\", [KEY_9] = \"9\", [KEY_0] = \"0\", [KEY_MINUS] = \"Minus\", [KEY_EQUAL] = \"Equal\", [KEY_BACKSPACE] = \"Backspace\", [KEY_TAB] = \"Tab\", [KEY_Q] = \"Q\", [KEY_W] = \"W\", [KEY_E] = \"E\", [KEY_R] = \"R\", [KEY_T] = \"T\", [KEY_Y] = \"Y\", [KEY_U] = \"U\", [KEY_I] = \"I\", [KEY_O] = \"O\", [KEY_P] = \"P\", [KEY_LEFTBRACE] = \"LeftBrace\", [KEY_RIGHTBRACE] = \"RightBrace\", [KEY_ENTER] = \"Enter\", [KEY_LEFTCTRL] = \"LeftControl\", [KEY_A] = \"A\", [KEY_S] = \"S\", [KEY_D] = \"D\", [KEY_F] = \"F\", [KEY_G] = \"G\", [KEY_H] = \"H\", [KEY_J] = \"J\", [KEY_K] = \"K\", [KEY_L] = \"L\", [KEY_SEMICOLON] = \"Semicolon\", [KEY_APOSTROPHE] = \"Apostrophe\", [KEY_GRAVE] = \"Grave\", [KEY_LEFTSHIFT] = \"LeftShift\", [KEY_BACKSLASH] = \"BackSlash\", [KEY_Z] = \"Z\", [KEY_X] = \"X\", [KEY_C] = \"C\", [KEY_V] = \"V\", [KEY_B] = \"B\", [KEY_N] = \"N\", [KEY_M] = \"M\", [KEY_COMMA] = \"Comma\", [KEY_DOT] = \"Dot\", [KEY_SLASH] = \"Slash\", [KEY_RIGHTSHIFT] = \"RightShift\", [KEY_KPASTERISK] = \"KPAsterisk\", [KEY_LEFTALT] = \"LeftAlt\", [KEY_SPACE] = \"Space\", [KEY_CAPSLOCK] = \"CapsLock\", [KEY_F1] = \"F1\", [KEY_F2] = \"F2\", [KEY_F3] = \"F3\", [KEY_F4] = \"F4\", [KEY_F5] = \"F5\", [KEY_F6] = \"F6\", [KEY_F7] = \"F7\", [KEY_F8] = \"F8\", [KEY_F9] = \"F9\", [KEY_F10] = \"F10\", [KEY_NUMLOCK] = \"NumLock\", [KEY_SCROLLLOCK] = \"ScrollLock\", [KEY_KP7] = \"KP7\", [KEY_KP8] = \"KP8\", [KEY_KP9] = \"KP9\", [KEY_KPMINUS] = \"KPMinus\", [KEY_KP4] = \"KP4\", [KEY_KP5] = \"KP5\", [KEY_KP6] = \"KP6\", [KEY_KPPLUS] = \"KPPlus\", [KEY_KP1] = \"KP1\", [KEY_KP2] = \"KP2\", [KEY_KP3] = \"KP3\", [KEY_KP0] = \"KP0\", [KEY_KPDOT] = \"KPDot\", [KEY_ZENKAKUHANKAKU] = \"Zenkaku/Hankaku\", [KEY_102ND] = \"102nd\", [KEY_F11] = \"F11\", [KEY_F12] = \"F12\", [KEY_RO] = \"RO\", [KEY_KATAKANA] = \"Katakana\", [KEY_HIRAGANA] = \"HIRAGANA\", [KEY_HENKAN] = \"Henkan\", [KEY_KATAKANAHIRAGANA] = \"Katakana/Hiragana\", [KEY_MUHENKAN] = \"Muhenkan\", [KEY_KPJPCOMMA] = \"KPJpComma\", [KEY_KPENTER] = \"KPEnter\", [KEY_RIGHTCTRL] = \"RightCtrl\", [KEY_KPSLASH] = \"KPSlash\", [KEY_SYSRQ] = \"SysRq\", [KEY_RIGHTALT] = \"RightAlt\", [KEY_LINEFEED] = \"LineFeed\", [KEY_HOME] = \"Home\", [KEY_UP] = \"Up\", [KEY_PAGEUP] = \"PageUp\", [KEY_LEFT] = \"Left\", [KEY_RIGHT] = \"Right\", [KEY_END] = \"End\", [KEY_DOWN] = \"Down\", [KEY_PAGEDOWN] = \"PageDown\", [KEY_INSERT] = \"Insert\", [KEY_DELETE] = \"Delete\", [KEY_MACRO] = \"Macro\", [KEY_MUTE] = \"Mute\", [KEY_VOLUMEDOWN] = \"VolumeDown\", [KEY_VOLUMEUP] = \"VolumeUp\", [KEY_POWER] = \"Power\", [KEY_KPEQUAL] = \"KPEqual\", [KEY_KPPLUSMINUS] = \"KPPlusMinus\", [KEY_PAUSE] = \"Pause\", [KEY_KPCOMMA] = \"KPComma\", [KEY_HANGUEL] = \"Hanguel\", [KEY_HANJA] = \"Hanja\", [KEY_YEN] = \"Yen\", [KEY_LEFTMETA] = \"LeftMeta\", [KEY_RIGHTMETA] = \"RightMeta\", [KEY_COMPOSE] = \"Compose\", [KEY_STOP] = \"Stop\", [KEY_AGAIN] = \"Again\", [KEY_PROPS] = \"Props\", [KEY_UNDO] = \"Undo\", [KEY_FRONT] = \"Front\", [KEY_COPY] = \"Copy\", [KEY_OPEN] = \"Open\", [KEY_PASTE] = \"Paste\", [KEY_FIND] = \"Find\", [KEY_CUT] = \"Cut\", [KEY_HELP] = \"Help\", [KEY_MENU] = \"Menu\", [KEY_CALC] = \"Calc\", [KEY_SETUP] = \"Setup\", [KEY_SLEEP] = \"Sleep\", [KEY_WAKEUP] = \"WakeUp\", [KEY_FILE] = \"File\", [KEY_SENDFILE] = \"SendFile\", [KEY_DELETEFILE] = \"DeleteFile\", [KEY_XFER] = \"X-fer\", [KEY_PROG1] = \"Prog1\", [KEY_PROG2] = \"Prog2\", [KEY_WWW] = \"WWW\", [KEY_MSDOS] = \"MSDOS\", [KEY_COFFEE] = \"Coffee\", [KEY_DIRECTION] = \"Direction\", [KEY_CYCLEWINDOWS] = \"CycleWindows\", [KEY_MAIL] = \"Mail\", [KEY_BOOKMARKS] = \"Bookmarks\", [KEY_COMPUTER] = \"Computer\", [KEY_BACK] = \"Back\", [KEY_FORWARD] = \"Forward\", [KEY_CLOSECD] = \"CloseCD\", [KEY_EJECTCD] = \"EjectCD\", [KEY_EJECTCLOSECD] = \"EjectCloseCD\", [KEY_NEXTSONG] = \"NextSong\", [KEY_PLAYPAUSE] = \"PlayPause\", [KEY_PREVIOUSSONG] = \"PreviousSong\", [KEY_STOPCD] = \"StopCD\", [KEY_RECORD] = \"Record\", [KEY_REWIND] = \"Rewind\", [KEY_PHONE] = \"Phone\", [KEY_ISO] = \"ISOKey\", [KEY_CONFIG] = \"Config\", [KEY_HOMEPAGE] = \"HomePage\", [KEY_REFRESH] = \"Refresh\", [KEY_EXIT] = \"Exit\", [KEY_MOVE] = \"Move\", [KEY_EDIT] = \"Edit\", [KEY_SCROLLUP] = \"ScrollUp\", [KEY_SCROLLDOWN] = \"ScrollDown\", [KEY_KPLEFTPAREN] = \"KPLeftParenthesis\", [KEY_KPRIGHTPAREN] = \"KPRightParenthesis\", [KEY_F13] = \"F13\", [KEY_F14] = \"F14\", [KEY_F15] = \"F15\", [KEY_F16] = \"F16\", [KEY_F17] = \"F17\", [KEY_F18] = \"F18\", [KEY_F19] = \"F19\", [KEY_F20] = \"F20\", [KEY_F21] = \"F21\", [KEY_F22] = \"F22\", [KEY_F23] = \"F23\", [KEY_F24] = \"F24\", [KEY_PLAYCD] = \"PlayCD\", [KEY_PAUSECD] = \"PauseCD\", [KEY_PROG3] = \"Prog3\", [KEY_PROG4] = \"Prog4\", [KEY_SUSPEND] = \"Suspend\", [KEY_CLOSE] = \"Close\", [KEY_PLAY] = \"Play\", [KEY_FASTFORWARD] = \"Fast Forward\", [KEY_BASSBOOST] = \"Bass Boost\", [KEY_PRINT] = \"Print\", [KEY_HP] = \"HP\", [KEY_CAMERA] = \"Camera\", [KEY_SOUND] = \"Sound\", [KEY_QUESTION] = \"Question\", [KEY_EMAIL] = \"Email\", [KEY_CHAT] = \"Chat\", [KEY_SEARCH] = \"Search\", [KEY_CONNECT] = \"Connect\", [KEY_FINANCE] = \"Finance\", [KEY_SPORT] = \"Sport\", [KEY_SHOP] = \"Shop\", [KEY_ALTERASE] = \"Alternate Erase\", [KEY_CANCEL] = \"Cancel\", [KEY_BRIGHTNESSDOWN] = \"Brightness down\", [KEY_BRIGHTNESSUP] = \"Brightness up\", [KEY_MEDIA] = \"Media\", [KEY_UNKNOWN] = \"Unknown\", [BTN_0] = \"Btn0\", [BTN_1] = \"Btn1\", [BTN_2] = \"Btn2\", [BTN_3] = \"Btn3\", [BTN_4] = \"Btn4\", [BTN_5] = \"Btn5\", [BTN_6] = \"Btn6\", [BTN_7] = \"Btn7\", [BTN_8] = \"Btn8\", [BTN_9] = \"Btn9\", [BTN_LEFT] = \"LeftBtn\", [BTN_RIGHT] = \"RightBtn\", [BTN_MIDDLE] = \"MiddleBtn\", [BTN_SIDE] = \"SideBtn\", [BTN_EXTRA] = \"ExtraBtn\", [BTN_FORWARD] = \"ForwardBtn\", [BTN_BACK] = \"BackBtn\", [BTN_TASK] = \"TaskBtn\", [BTN_TRIGGER] = \"Trigger\", [BTN_THUMB] = \"ThumbBtn\", [BTN_THUMB2] = \"ThumbBtn2\", [BTN_TOP] = \"TopBtn\", [BTN_TOP2] = \"TopBtn2\", [BTN_PINKIE] = \"PinkieBtn\", [BTN_BASE] = \"BaseBtn\", [BTN_BASE2] = \"BaseBtn2\", [BTN_BASE3] = \"BaseBtn3\", [BTN_BASE4] = \"BaseBtn4\", [BTN_BASE5] = \"BaseBtn5\", [BTN_BASE6] = \"BaseBtn6\", [BTN_DEAD] = \"BtnDead\", [BTN_A] = \"BtnA\", [BTN_B] = \"BtnB\", [BTN_C] = \"BtnC\", [BTN_X] = \"BtnX\", [BTN_Y] = \"BtnY\", [BTN_Z] = \"BtnZ\", [BTN_TL] = \"BtnTL\", [BTN_TR] = \"BtnTR\", [BTN_TL2] = \"BtnTL2\", [BTN_TR2] = \"BtnTR2\", [BTN_SELECT] = \"BtnSelect\", [BTN_START] = \"BtnStart\", [BTN_MODE] = \"BtnMode\", [BTN_THUMBL] = \"BtnThumbL\", [BTN_THUMBR] = \"BtnThumbR\", [BTN_TOOL_PEN] = \"ToolPen\", [BTN_TOOL_RUBBER] = \"ToolRubber\", [BTN_TOOL_BRUSH] = \"ToolBrush\", [BTN_TOOL_PENCIL] = \"ToolPencil\", [BTN_TOOL_AIRBRUSH] = \"ToolAirbrush\", [BTN_TOOL_FINGER] = \"ToolFinger\", [BTN_TOOL_MOUSE] = \"ToolMouse\", [BTN_TOOL_LENS] = \"ToolLens\", [BTN_TOUCH] = \"Touch\", [BTN_STYLUS] = \"Stylus\", [BTN_STYLUS2] = \"Stylus2\", [BTN_TOOL_DOUBLETAP] = \"Tool Doubletap\", [BTN_TOOL_TRIPLETAP] = \"Tool Tripletap\", [BTN_GEAR_DOWN] = \"WheelBtn\", [BTN_GEAR_UP] = \"Gear up\", [KEY_OK] = \"Ok\", [KEY_SELECT] = \"Select\", [KEY_GOTO] = \"Goto\", [KEY_CLEAR] = \"Clear\", [KEY_POWER2] = \"Power2\", [KEY_OPTION] = \"Option\", [KEY_INFO] = \"Info\", [KEY_TIME] = \"Time\", [KEY_VENDOR] = \"Vendor\", [KEY_ARCHIVE] = \"Archive\", [KEY_PROGRAM] = \"Program\", [KEY_CHANNEL] = \"Channel\", [KEY_FAVORITES] = \"Favorites\", [KEY_EPG] = \"EPG\", [KEY_PVR] = \"PVR\", [KEY_MHP] = \"MHP\", [KEY_LANGUAGE] = \"Language\", [KEY_TITLE] = \"Title\", [KEY_SUBTITLE] = \"Subtitle\", [KEY_ANGLE] = \"Angle\", [KEY_ZOOM] = \"Zoom\", [KEY_MODE] = \"Mode\", [KEY_KEYBOARD] = \"Keyboard\", [KEY_SCREEN] = \"Screen\", [KEY_PC] = \"PC\", [KEY_TV] = \"TV\", [KEY_TV2] = \"TV2\", [KEY_VCR] = \"VCR\", [KEY_VCR2] = \"VCR2\", [KEY_SAT] = \"Sat\", [KEY_SAT2] = \"Sat2\", [KEY_CD] = \"CD\", [KEY_TAPE] = \"Tape\", [KEY_RADIO] = \"Radio\", [KEY_TUNER] = \"Tuner\", [KEY_PLAYER] = \"Player\", [KEY_TEXT] = \"Text\", [KEY_DVD] = \"DVD\", [KEY_AUX] = \"Aux\", [KEY_MP3] = \"MP3\", [KEY_AUDIO] = \"Audio\", [KEY_VIDEO] = \"Video\", [KEY_DIRECTORY] = \"Directory\", [KEY_LIST] = \"List\", [KEY_MEMO] = \"Memo\", [KEY_CALENDAR] = \"Calendar\", [KEY_RED] = \"Red\", [KEY_GREEN] = \"Green\", [KEY_YELLOW] = \"Yellow\", [KEY_BLUE] = \"Blue\", [KEY_CHANNELUP] = \"ChannelUp\", [KEY_CHANNELDOWN] = \"ChannelDown\", [KEY_FIRST] = \"First\", [KEY_LAST] = \"Last\", [KEY_AB] = \"AB\", [KEY_NEXT] = \"Next\", [KEY_RESTART] = \"Restart\", [KEY_SLOW] = \"Slow\", [KEY_SHUFFLE] = \"Shuffle\", [KEY_BREAK] = \"Break\", [KEY_PREVIOUS] = \"Previous\", [KEY_DIGITS] = \"Digits\", [KEY_TEEN] = \"TEEN\", [KEY_TWEN] = \"TWEN\", [KEY_DEL_EOL] = \"Delete EOL\", [KEY_DEL_EOS] = \"Delete EOS\", [KEY_INS_LINE] = \"Insert line\", [KEY_DEL_LINE] = \"Delete line\",&#125;;char *absval[5] = &#123; \"Value\", \"Min \", \"Max \", \"Fuzz \", \"Flat \" &#125;;char *relatives[REL_MAX + 1] =&#123; [0 ... REL_MAX] = NULL, [REL_X] = \"X\", [REL_Y] = \"Y\", [REL_Z] = \"Z\", [REL_HWHEEL] = \"HWheel\", [REL_DIAL] = \"Dial\", [REL_WHEEL] = \"Wheel\", [REL_MISC] = \"Misc\",&#125;;char *absolutes[ABS_MAX + 1] =&#123; [0 ... ABS_MAX] = NULL, [ABS_X] = \"X\", [ABS_Y] = \"Y\", [ABS_Z] = \"Z\", [ABS_RX] = \"Rx\", [ABS_RY] = \"Ry\", [ABS_RZ] = \"Rz\", [ABS_THROTTLE] = \"Throttle\", [ABS_RUDDER] = \"Rudder\", [ABS_WHEEL] = \"Wheel\", [ABS_GAS] = \"Gas\", [ABS_BRAKE] = \"Brake\", [ABS_HAT0X] = \"Hat0X\", [ABS_HAT0Y] = \"Hat0Y\", [ABS_HAT1X] = \"Hat1X\", [ABS_HAT1Y] = \"Hat1Y\", [ABS_HAT2X] = \"Hat2X\", [ABS_HAT2Y] = \"Hat2Y\", [ABS_HAT3X] = \"Hat3X\", [ABS_HAT3Y] = \"Hat 3Y\", [ABS_PRESSURE] = \"Pressure\", [ABS_DISTANCE] = \"Distance\", [ABS_TILT_X] = \"XTilt\", [ABS_TILT_Y] = \"YTilt\", [ABS_TOOL_WIDTH] = \"Tool Width\", [ABS_VOLUME] = \"Volume\", [ABS_MISC] = \"Misc\",&#125;;char *misc[MSC_MAX + 1] =&#123; [ 0 ... MSC_MAX] = NULL, [MSC_SERIAL] = \"Serial\", [MSC_PULSELED] = \"Pulseled\", [MSC_GESTURE] = \"Gesture\", [MSC_RAW] = \"RawData\", [MSC_SCAN] = \"ScanCode\",&#125;;char *leds[LED_MAX + 1] =&#123; [0 ... LED_MAX] = NULL, [LED_NUML] = \"NumLock\", [LED_CAPSL] = \"CapsLock\", [LED_SCROLLL] = \"ScrollLock\", [LED_COMPOSE] = \"Compose\", [LED_KANA] = \"Kana\", [LED_SLEEP] = \"Sleep\", [LED_SUSPEND] = \"Suspend\", [LED_MUTE] = \"Mute\", [LED_MISC] = \"Misc\",&#125;;char *repeats[REP_MAX + 1] =&#123; [0 ... REP_MAX] = NULL, [REP_DELAY] = \"Delay\", [REP_PERIOD] = \"Period\"&#125;;char *sounds[SND_MAX + 1] =&#123; [0 ... SND_MAX] = NULL, [SND_CLICK] = \"Click\", [SND_BELL] = \"Bell\", [SND_TONE] = \"Tone\"&#125;;char **names[EV_MAX + 1] =&#123; [0 ... EV_MAX] = NULL, [EV_SYN] = events, [EV_KEY] = keys, [EV_REL] = relatives, [EV_ABS] = absolutes, [EV_MSC] = misc, [EV_LED] = leds, [EV_SND] = sounds, [EV_REP] = repeats,&#125;;#define BITS_PER_LONG (sizeof(long) * 8)#define NBITS(x) ((((x)-1)/BITS_PER_LONG)+1)#define OFF(x) ((x)%BITS_PER_LONG)#define BIT(x) (1UL&lt;&lt;OFF(x))#define LONG(x) ((x)/BITS_PER_LONG)#define test_bit(bit, array) ((array[LONG(bit)] &gt;&gt; OFF(bit)) &amp; 1)int main (int argc, char **argv)&#123; int fd, rd, i, j, k; struct input_event ev[64]; int version; unsigned short id[4]; unsigned long bit[EV_MAX][NBITS(KEY_MAX)]; char name[256] = \"Unknown\"; int abs[5]; if (argc &lt; 2) &#123; printf(\"Usage: evtest /dev/input/eventX\\n\"); printf(\"Where X = input device number\\n\"); return 1; &#125; if ((fd = open(argv[argc - 1], O_RDONLY)) &lt; 0) &#123; perror(\"evtest\"); return 1; &#125; if (ioctl(fd, EVIOCGVERSION, &amp;version)) &#123; perror(\"evtest: can't get version\"); return 1; &#125; printf(\"Input driver version is %d.%d.%d\\n\", version &gt;&gt; 16, (version &gt;&gt; 8) &amp; 0xff, version &amp; 0xff); ioctl(fd, EVIOCGID, id); printf(\"Input device ID: bus 0x%x vendor 0x%x product 0x%x version 0x%x\\n\", id[ID_BUS], id[ID_VENDOR], id[ID_PRODUCT], id[ID_VERSION]); ioctl(fd, EVIOCGNAME(sizeof(name)), name); printf(\"Input device name: \\\"%s\\\"\\n\", name); memset(bit, 0, sizeof(bit)); ioctl(fd, EVIOCGBIT(0, EV_MAX), bit[0]); printf(\"Supported events:\\n\"); for (i = 0; i &lt; EV_MAX; i++) if (test_bit(i, bit[0])) &#123; printf(\" Event type %d (%s)\\n\", i, events[i] ? events[i] : \"?\"); if (!i) continue; ioctl(fd, EVIOCGBIT(i, KEY_MAX), bit[i]); for (j = 0; j &lt; KEY_MAX; j++) if (test_bit(j, bit[i])) &#123; printf(\" Event code %d (%s)\\n\", j, names[i] ? (names[i][j] ? names[i][j] : \"?\") : \"?\"); if (i == EV_ABS) &#123; ioctl(fd, EVIOCGABS(j), abs); for (k = 0; k &lt; 5; k++) if ((k &lt; 3) || abs[k]) printf(\" %s %6d\\n\", absval[k], abs[k]); &#125; &#125; &#125; printf(\"Testing ... (interrupt to exit)\\n\"); while (1) &#123; rd = read(fd, ev, sizeof(struct input_event) * 64); if (rd &lt; (int) sizeof(struct input_event)) &#123; printf(\"yyy\\n\"); perror(\"\\nevtest: error reading\"); return 1; &#125; for (i = 0; i &lt; rd / sizeof(struct input_event); i++) if (ev[i].type == EV_SYN) &#123; printf(\"Event: time %ld.%06ld, -------------- %s ------------\\n\", ev[i].time.tv_sec, ev[i].time.tv_usec, ev[i].code ? \"Config Sync\" : \"Report Sync\" ); &#125; else if (ev[i].type == EV_MSC &amp;&amp; (ev[i].code == MSC_RAW || ev[i].code == MSC_SCAN)) &#123; printf(\"Event: time %ld.%06ld, type %d (%s), code %d (%s), value %02x\\n\", ev[i].time.tv_sec, ev[i].time.tv_usec, ev[i].type, events[ev[i].type] ? events[ev[i].type] : \"?\", ev[i].code, names[ev[i].type] ? (names[ev[i].type][ev[i].code] ? names[ev[i].type][ev[i].code] : \"?\") : \"?\", ev[i].value); &#125; else &#123; printf(\"Event: time %ld.%06ld, type %d (%s), code %d (%s), value %d\\n\", ev[i].time.tv_sec, ev[i].time.tv_usec, ev[i].type, events[ev[i].type] ? events[ev[i].type] : \"?\", ev[i].code, names[ev[i].type] ? (names[ev[i].type][ev[i].code] ? names[ev[i].type][ev[i].code] : \"?\") : \"?\", ev[i].value); &#125; &#125;&#125; 测试效果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# ./evtest /dev/input/event2Input driver version is 1.0.1Input device ID: bus 0x1c vendor 0x0 product 0x159 version 0x0Input device name: &quot;ADXL34x accelerometer&quot;Supported events: Event type 0 (Sync) Event type 1 (Key) Event code 330 (Touch) Event type 3 (Absolute) Event code 0 (X) Value 0 Min -4096 Max 4096 Fuzz 3 Flat 3 Event code 1 (Y) Value 0 Min -4096 Max 4096 Fuzz 3 Flat 3 Event code 2 (Z) Value 0 Min -4096 Max 4096 Fuzz 3 Flat 3Testing ... (interrupt to exit)Event: time 3949236.075868, type 3 (Absolute), code 0 (X), value -223Event: time 3949236.075868, type 3 (Absolute), code 1 (Y), value -10Event: time 3949236.075868, type 3 (Absolute), code 2 (Z), value -13Event: time 3949236.075868, -------------- Report Sync ------------Event: time 3949236.115188, type 3 (Absolute), code 0 (X), value -235Event: time 3949236.115188, -------------- Report Sync ------------Event: time 3949236.154590, type 3 (Absolute), code 0 (X), value -234Event: time 3949236.154590, -------------- Report Sync ------------Event: time 3949236.824446, type 3 (Absolute), code 2 (Z), value -14Event: time 3949236.824446, -------------- Report Sync ------------Event: time 3949236.863862, type 3 (Absolute), code 2 (Z), value -13Event: time 3949236.863862, -------------- Report Sync ------------Event: time 3949236.903264, type 3 (Absolute), code 2 (Z), value -12Event: time 3949236.903264, -------------- Report Sync ------------Event: time 3949236.942659, type 3 (Absolute), code 2 (Z), value -13Event: time 3949236.942659, -------------- Report Sync ------------Event: time 3949237.021471, type 3 (Absolute), code 2 (Z), value -12Event: time 3949237.021471, -------------- Report Sync ------------Event: time 3949237.257883, type 3 (Absolute), code 2 (Z), value -13Event: time 3949237.257883, -------------- Report Sync ------------Event: time 3949238.006540, type 3 (Absolute), code 0 (X), value -233Event: time 3949238.006540, type 3 (Absolute), code 1 (Y), value -11Event: time 3949238.006540, -------------- Report Sync ------------Event: time 3949238.045949, type 3 (Absolute), code 2 (Z), value -14Event: time 3949238.045949, -------------- Report Sync ------------Event: time 3949238.085346, type 3 (Absolute), code 2 (Z), value -13Event: time 3949238.085346, -------------- Report Sync ------------Event: time 3949238.164144, type 3 (Absolute), code 1 (Y), value -10Event: time 3949238.164144, -------------- Report Sync ------------Event: time 3949238.361159, type 3 (Absolute), code 2 (Z), value -12Event: time 3949238.361159, -------------- Report Sync ------------Event: time 3949238.400569, type 3 (Absolute), code 0 (X), value -234Event: time 3949238.400569, -------------- Report Sync ------------Event: time 3949238.676384, type 3 (Absolute), code 2 (Z), value -13Event: time 3949238.676384, -------------- Report Sync ------------Event: time 3949238.755194, type 3 (Absolute), code 0 (X), value -241Event: time 3949238.755194, type 3 (Absolute), code 1 (Y), value -1Event: time 3949238.755194, type 3 (Absolute), code 2 (Z), value 19Event: time 3949238.755194, -------------- Report Sync ------------Event: time 3949238.794592, type 3 (Absolute), code 0 (X), value -298Event: time 3949238.794592, type 3 (Absolute), code 1 (Y), value 42Event: time 3949238.794592, type 3 (Absolute), code 2 (Z), value -33 2.4 详细分析2.4.1 几个重要结构体adxl34x.c的probe()一进来就定义了三个结构体：123struct adxl34x *ac;struct input_dev *input_dev;const struct adxl34x_platform_data *pdata; adxl34x就是针对设备量身定制的，包含所有信息，在对其进行一系列的设置后，在adxl34x-spi.c的probe()里，使用spi_set_drvdata()将其保存到spi_device的私有数据里，以后其它函数可以通过spi_get_drvdata()得到该结构体，从而获取设备的所有信息。input_dev表示一个输入设备，里面有一个输入设备的属性定义。adxl34x_platform_data包含adxl34x设备的属性定义。 定义完后，进行初始化：123456789101112131415ac = kzalloc(sizeof(*ac), GFP_KERNEL);input_dev = input_allocate_device();if (!ac || !input_dev) &#123; err = -ENOMEM; goto err_free_mem;&#125;ac-&gt;fifo_delay = fifo_delay_default;pdata = dev_get_platdata(dev);if (!pdata) &#123; dev_dbg(dev, \"No platform data: Using default initialization\\n\"); pdata = &amp;adxl34x_default_init;&#125;adxl34x使用kzalloc()分配空间并清零。input_dev使用输入子系统提供的input_allocate_device()分配空间。adxl34x_platform_data先尝试从device获取，没有的话使用默认的配置，也就是adxl34x_default_init的内容，里面有ADXL34X支持何种输入事件、电源模式等。 2.4.2 判断中断ADXL34X工作时，通过中断引脚通知主机发生了某中断事件，因此中断是必不可少的，这里检测如果没有中断则返回错误。123456if (!irq) &#123; dev_err(dev, \"no IRQ?\\n\"); err = -ENODEV; goto err_out;&#125; 2.4.3 设置adxl34x1234567891011121314151617181920212223242526272829ac-&gt;fifo_delay = fifo_delay_default;ac-&gt;pdata = *pdata;pdata = &amp;ac-&gt;pdata;ac-&gt;input = input_dev;ac-&gt;dev = dev;ac-&gt;irq = irq;ac-&gt;bops = bops;mutex_init(&amp;ac-&gt;mutex);input_dev-&gt;name = \"ADXL34x accelerometer\";revid = AC_READ(ac, DEVID);switch (revid) &#123;case ID_ADXL345: ac-&gt;model = 345; break;case ID_ADXL346: ac-&gt;model = 346; break;default: dev_err(dev, \"Failed to probe %s\\n\", input_dev-&gt;name); err = -ENODEV; goto err_free_mem;&#125;snprintf(ac-&gt;phys, sizeof(ac-&gt;phys), \"%s/input0\", dev_name(dev)); 将input_dev、adxl34x_platform_data指向adxl34x；将传入的参数赋值给adxl34x，初始化部分adxl34x参数；还读取设备ID判断是ADXL345，还是ADXL346。 2.4.4 设置input_dev先使用__set_bit(ac-&gt;pdata.ev_type, input_dev-&gt;evbit);设置支持哪一类事件，由前面的adxl34x_default_init可知为EV_ABS。如果为EV_ABS类型，再使用_set_bit()和input_set_abs_params()设置能产生该类的哪些事件。其中input_set_abs_params()也是调用的__set_bit()，参数依次为input设备指针、坐标轴、最小范围、最大范围、过滤值、丢弃范围值。123456789__set_bit(ac-&gt;pdata.ev_type, input_dev-&gt;evbit);……__set_bit(ABS_X, input_dev-&gt;absbit);__set_bit(ABS_Y, input_dev-&gt;absbit);__set_bit(ABS_Z, input_dev-&gt;absbit);……input_set_abs_params(input_dev, ABS_X, -range, range, 3, 3);input_set_abs_params(input_dev, ABS_Y, -range, range, 3, 3);input_set_abs_params(input_dev, ABS_Z, -range, range, 3, 3); 接下来设置支持EV_KEY类事件，再具体设置支持类中的哪些事件：1234__set_bit(EV_KEY, input_dev-&gt;evbit);__set_bit(pdata-&gt;ev_code_tap[ADXL_X_AXIS], input_dev-&gt;keybit);__set_bit(pdata-&gt;ev_code_tap[ADXL_Y_AXIS], input_dev-&gt;keybit);__set_bit(pdata-&gt;ev_code_tap[ADXL_Z_AXIS], input_dev-&gt;keybit); 可以看出，设置input_dev的思路就是先设置支持哪一类事件，再设置类中的具体事件。 input子系统中支持的类型含义：1234567891011EV_SYN 同步事件 EV_KEY 键盘事件 EV_REL 相对坐标事件，用于鼠标 EV_ABS 绝对坐标事件，用于摇杆 EV_MSC 其他事件 EV_LED LED灯事件 EV_SND 声音事件 EV_REP 重复按键事件 EV_FF 受力事件 EV_PWR 电源事件 EV_FF_STATUS 受力状态事件 12345678910111213141516171819202122232425262728293031323334353637383940414243input_dev-&gt;phys = ac-&gt;phys;input_dev-&gt;dev.parent = dev;input_dev-&gt;id.product = ac-&gt;model;input_dev-&gt;id.bustype = bops-&gt;bustype;input_dev-&gt;open = adxl34x_input_open;input_dev-&gt;close = adxl34x_input_close;input_set_drvdata(input_dev, ac);__set_bit(ac-&gt;pdata.ev_type, input_dev-&gt;evbit);if (ac-&gt;pdata.ev_type == EV_REL) &#123; __set_bit(REL_X, input_dev-&gt;relbit); __set_bit(REL_Y, input_dev-&gt;relbit); __set_bit(REL_Z, input_dev-&gt;relbit);&#125; else &#123; /* EV_ABS */ __set_bit(ABS_X, input_dev-&gt;absbit); __set_bit(ABS_Y, input_dev-&gt;absbit); __set_bit(ABS_Z, input_dev-&gt;absbit); if (pdata-&gt;data_range &amp; FULL_RES) range = ADXL_FULLRES_MAX_VAL; /* Signed 13-bit */ else range = ADXL_FIXEDRES_MAX_VAL; /* Signed 10-bit */ input_set_abs_params(input_dev, ABS_X, -range, range, 3, 3); input_set_abs_params(input_dev, ABS_Y, -range, range, 3, 3); input_set_abs_params(input_dev, ABS_Z, -range, range, 3, 3);&#125;__set_bit(EV_KEY, input_dev-&gt;evbit);__set_bit(pdata-&gt;ev_code_tap[ADXL_X_AXIS], input_dev-&gt;keybit);__set_bit(pdata-&gt;ev_code_tap[ADXL_Y_AXIS], input_dev-&gt;keybit);__set_bit(pdata-&gt;ev_code_tap[ADXL_Z_AXIS], input_dev-&gt;keybit);if (pdata-&gt;ev_code_ff) &#123; ac-&gt;int_mask = FREE_FALL; __set_bit(pdata-&gt;ev_code_ff, input_dev-&gt;keybit);&#125;if (pdata-&gt;ev_code_act_inactivity) __set_bit(pdata-&gt;ev_code_act_inactivity, input_dev-&gt;keybit); 2.4.5 设置中断ADXL345的中断引脚默认为高电平有效，也可自行修改寄存器改为低电平有效。所有功能都可以同时使用，但是，一些功能可能需要共享中断引脚。中断功能的详细介绍参考手册，内容有点多，有产生新数据就产生中断，加速度超过某个值产生中断，两次加速度超过某个值产生中断等。 这里根据adxl34x_platform_data的内容，设置adxl34x的int_mask。再通过request_threaded_irq()申请线程中断，绑定中断处理函数，并把adxl34x传给中断处理函数。12345678910111213141516171819202122232425ac-&gt;int_mask |= ACTIVITY | INACTIVITY;if (pdata-&gt;watermark) &#123; ac-&gt;int_mask |= WATERMARK; if (!FIFO_MODE(pdata-&gt;fifo_mode)) ac-&gt;pdata.fifo_mode |= FIFO_STREAM;&#125; else &#123; ac-&gt;int_mask |= DATA_READY;&#125;if (pdata-&gt;tap_axis_control &amp; (TAP_X_EN | TAP_Y_EN | TAP_Z_EN)) ac-&gt;int_mask |= SINGLE_TAP | DOUBLE_TAP;if (FIFO_MODE(pdata-&gt;fifo_mode) == FIFO_BYPASS) ac-&gt;fifo_delay = false;AC_WRITE(ac, POWER_CTL, 0);err = request_threaded_irq(ac-&gt;irq, NULL, adxl34x_irq, IRQF_TRIGGER_HIGH | IRQF_ONESHOT, dev_name(dev), ac);if (err) &#123; dev_err(dev, \"irq %d busy?\\n\", ac-&gt;irq); goto err_free_mem;&#125; 在产生中断时，进入中断处理函数adxl34x_irq()，读取中断源寄存器，判断产生的何种中断，调用相应的处理函数。调用input_event()设置要上报的数据值，再调用input_sync()上报。 2.4.6 创建sysfs属性文件同前面的AD7705一样，这里也在/sys/class/input/下创建节点，直接可以访问。123err = sysfs_create_group(&amp;dev-&gt;kobj, &amp;adxl34x_attr_group);if (err) goto err_free_irq; 根据传入的attribute_group结构体可以找到具体实现了哪些功能：12345678910111213141516171819202122232425262728static struct attribute *adxl34x_attributes[] = &#123; &amp;dev_attr_disable.attr, &amp;dev_attr_calibrate.attr, &amp;dev_attr_rate.attr, &amp;dev_attr_autosleep.attr, &amp;dev_attr_position.attr,#ifdef ADXL_DEBUG &amp;dev_attr_write.attr,#endif NULL&#125;;static const struct attribute_group adxl34x_attr_group = &#123; .attrs = adxl34x_attributes,&#125;;static DEVICE_ATTR(position, S_IRUGO, adxl34x_position_show, NULL);static DEVICE_ATTR(autosleep, 0664, adxl34x_autosleep_show, adxl34x_autosleep_store);static DEVICE_ATTR(rate, 0664, adxl34x_rate_show, adxl34x_rate_store);static DEVICE_ATTR(calibrate, 0664, adxl34x_calibrate_show, adxl34x_calibrate_store);static DEVICE_ATTR(disable, 0664, adxl34x_disable_show, adxl34x_disable_store); 可以看出提供了position，获取当前三轴状态；autosleep，设置自动休眠；rate，设置输出数据速率；calibrate，设备校准；disable，启用/禁用设备。 与实测内容吻合。1234# ls /sys/class/input/input2capabilities id name properties uniqdevice modalias phys subsystemevent2 mouse1 power uevent 2.4.7 注册输入子系统123err = input_register_device(input_dev);if (err) goto err_remove_attr; 2.4.8 硬件操作最后，使用adxl34x-spi.c提供的传输函数，根据adxl34x的内容操作ADXL345。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455AC_WRITE(ac, OFSX, pdata-&gt;x_axis_offset);ac-&gt;hwcal.x = pdata-&gt;x_axis_offset;AC_WRITE(ac, OFSY, pdata-&gt;y_axis_offset);ac-&gt;hwcal.y = pdata-&gt;y_axis_offset;AC_WRITE(ac, OFSZ, pdata-&gt;z_axis_offset);ac-&gt;hwcal.z = pdata-&gt;z_axis_offset;AC_WRITE(ac, THRESH_TAP, pdata-&gt;tap_threshold);AC_WRITE(ac, DUR, pdata-&gt;tap_duration);AC_WRITE(ac, LATENT, pdata-&gt;tap_latency);AC_WRITE(ac, WINDOW, pdata-&gt;tap_window);AC_WRITE(ac, THRESH_ACT, pdata-&gt;activity_threshold);AC_WRITE(ac, THRESH_INACT, pdata-&gt;inactivity_threshold);AC_WRITE(ac, TIME_INACT, pdata-&gt;inactivity_time);AC_WRITE(ac, THRESH_FF, pdata-&gt;free_fall_threshold);AC_WRITE(ac, TIME_FF, pdata-&gt;free_fall_time);AC_WRITE(ac, TAP_AXES, pdata-&gt;tap_axis_control);AC_WRITE(ac, ACT_INACT_CTL, pdata-&gt;act_axis_control);AC_WRITE(ac, BW_RATE, RATE(ac-&gt;pdata.data_rate) | (pdata-&gt;low_power_mode ? LOW_POWER : 0));AC_WRITE(ac, DATA_FORMAT, pdata-&gt;data_range);AC_WRITE(ac, FIFO_CTL, FIFO_MODE(pdata-&gt;fifo_mode) | SAMPLES(pdata-&gt;watermark));if (pdata-&gt;use_int2) &#123; /* Map all INTs to INT2 */ AC_WRITE(ac, INT_MAP, ac-&gt;int_mask | OVERRUN);&#125; else &#123; /* Map all INTs to INT1 */ AC_WRITE(ac, INT_MAP, 0);&#125;if (ac-&gt;model == 346 &amp;&amp; ac-&gt;pdata.orientation_enable) &#123; AC_WRITE(ac, ORIENT_CONF, ORIENT_DEADZONE(ac-&gt;pdata.deadzone_angle) | ORIENT_DIVISOR(ac-&gt;pdata.divisor_length)); ac-&gt;orient2d_saved = 1234; ac-&gt;orient3d_saved = 1234; if (pdata-&gt;orientation_enable &amp; ADXL_EN_ORIENTATION_3D) for (i = 0; i &lt; ARRAY_SIZE(pdata-&gt;ev_codes_orient_3d); i++) __set_bit(pdata-&gt;ev_codes_orient_3d[i], input_dev-&gt;keybit); if (pdata-&gt;orientation_enable &amp; ADXL_EN_ORIENTATION_2D) for (i = 0; i &lt; ARRAY_SIZE(pdata-&gt;ev_codes_orient_2d); i++) __set_bit(pdata-&gt;ev_codes_orient_2d[i], input_dev-&gt;keybit);&#125; else &#123; ac-&gt;pdata.orientation_enable = 0;&#125;AC_WRITE(ac, INT_ENABLE, ac-&gt;int_mask | OVERRUN);ac-&gt;pdata.power_mode &amp;= (PCTL_AUTO_SLEEP | PCTL_LINK); 3. 总结通过这两个子系统的驱动代码，总结几个之前写驱动没有意识。1、自定义一个结构体，包含device和设备私有属性，其它函数可通过它获取到所有数据；2、使用互斥锁的意识；3、创建sysfs内容，方便应用层直接访问； 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"AM335X","slug":"AM335X","permalink":"http://yoursite.com/tags/AM335X/"},{"name":"SPI","slug":"SPI","permalink":"http://yoursite.com/tags/SPI/"},{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"hwmon子系统","slug":"hwmon子系统","permalink":"http://yoursite.com/tags/hwmon子系统/"},{"name":"input子系统","slug":"input子系统","permalink":"http://yoursite.com/tags/input子系统/"}]},{"title":"AM335X——SPI设备驱动","date":"2019-01-01T07:54:49.000Z","path":"2019/01/01/AM335X——SPI设备驱动/","text":"最近在AM335X上写了几个SPI设备驱动，记录一下心得。 1. 准备工作与前面写过的I2C驱动一样，SPI驱动也涉及SPI控制器(适配器)驱动和SPI设备驱动。SPI控制器驱动这里不就写了，直接使用SDK自带的，只写SPI设备的驱动。在写SPI设备驱动之前，需要先验证下SDK提供的SPI驱动是否能用，相关的设置是否正确，因此使用内核自带的一个SPI设备驱动进行测试。 1.1 驱动首先配置内核，执行make menuconfig，勾选上McSPI driver for OMAP和User mode SPI device driver support。 1.2 设备树然后还要向设备树添加如下内容：12345678910111213141516171819202122232425262728/* SPI Busses */&amp;spi1 &#123; status = \"okay\"; pinctrl-names = \"default\"; pinctrl-0 = &lt;&amp;spi1_pins&gt;; ti,pindir-d0-out-d1-in; spidev@0 &#123; spi-max-frequency = &lt;25000000&gt;; reg = &lt;0&gt;; compatible = \"rohm,dh2228fv\"; /* spi-cpha; sets CPHA=1, default is CPHA=0 */ /* spi-cpol; sets CPOL=1, default is CPOL=0 */ /* spi-cs-high; default is spi cs low */ &#125;;&#125;;&amp;am33xx_pinmux &#123; spi1_pins: pinmux_spi1 &#123; pinctrl-single,pins = &lt; 0x190 (PIN_INPUT_PULLUP | MUX_MODE3) /* spi1_sclk */ 0x194 (PIN_INPUT_PULLUP | MUX_MODE3) /* spi1_d0 */ 0x198 (PIN_INPUT_PULLUP | MUX_MODE3) /* spi1_d1 */ 0x19c (PIN_INPUT_PULLUP | MUX_MODE3) /* spi1_cs0 */ &gt;; &#125;;&#125;;这里有几个细节，简单说一下：1.pinctrl-0属性引用的spi1_pins，指定了SPI的几个复用引脚，里面的0x190是真实地址0x990-0x800，也就是说设备树中的地址是相对0x800的偏移；2.注意SPI复用引脚不要在设备树其它节点中使用，不然SPI驱动可能用不了；3.AM335x的MOSI和MISO可以互换，需要加上ti,pindir-d0-out-d1-in;来指定D0是MOSI，D1是MISO；4.reg = &lt;0&gt;;表示硬件片选，这里为硬件片选0；5.内核自带的测试驱动程序的compatible为rohm,dh2228fv； 1.3 测试程序使用内核提供的测试程序，编译，测试。测试文件路径：Documentation/spi/spidev_test.c；交叉编译后执行./spidev_test -D /dev/spidev1.0 -v结果：12345spi mode: 0x0bits per word: 8max speed: 500000 Hz (500 KHz)TX | FF FF FF FF FF FF 40 00 00 00 00 95 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF F0 0D | ......@....▒..................▒.RX | FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF | ................................ 此时可以通过逻辑分析仪或者短接MOSI和MISO，判断发出和接收的数据是否正常，从而验证SPI控制器驱动是否正常。 1.4 编译脚本为了方便后续的编译，写了一个脚本进行操作，这个脚本也相当于操作流程，以供参考：[compiler_kernel.sh]1234567891011121314151617181920212223242526272829303132#!/bin/bash#step 0:set envexport CPUS=`grep -c processor /proc/cpuinfo`export ARCH=armexport CROSS_COMPILE=/home/hceng/gcc-linaro-5.3-2016.02-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-export PATH=/home/hceng/gcc-linaro-5.3-2016.02-x86_64_arm-linux-gnueabihf/bin:$PATH#step 1:clean kernel#make distclean#step 2:copy kernel config file #make tisdk_am335x-evm_defconfig#step 3:compiler kernel#make uImage LOADADDR=0x10008000 -j$&#123;CPUS&#125;make zImage -j$&#123;CPUS&#125;#step 4:compiler device tree#make dtbsmake am335x-evm.dtb#step 5:compiler driver module file(dynamic loading)#make modules#make modules_install INSTALL_MOD_PATH=~/rootfs/lib/modules/4.1.18-gbbe8cfc #step 6:copy zImage and dtb to tftp downloadrm /home/hceng/tftp/zImagerm /home/hceng/tftp/am335x-evm.dtbcp ./arch/arm/boot/zImage /home/hceng/tftp/cp ./arch/arm/boot/dts/am335x-evm.dtb /home/hceng/tftp/ 其中第六步，拷贝倒tftp目录下，是为了方便板子启动的时候，通过U-Boot直接tftp下载编译过的内核和设备树，相关命令如下：123456789setenv ipaddr 192.168.1.14; setenv serverip 192.168.1.11; setenv gatewayip 192.168.1.1; setenv netmask 255.255.255.0; setenv fdtfile &apos;am335x-evm.dtb&apos;; setenv rootpath &apos;/home/hceng/rootfs&apos;;setenv netargs &quot;setenv bootargs console=$&#123;console&#125; $&#123;optargs&#125; root=/dev/nfs rootfstype=nfsroot nfsroot=$&#123;serverip&#125;:$&#123;rootpath&#125; ip=$&#123;ipaddr&#125;:$&#123;serverip&#125;:$&#123;gatewayip&#125;:$&#123;netmask&#125;::eth0:off&quot;setenv netboot &quot;echo Booting from network ...; setenv autoload no; tftp $&#123;fdtaddr&#125; $&#123;fdtfile&#125;; tftp $&#123;loadaddr&#125; $&#123;bootfile&#125;; run netargs; bootz $&#123;loadaddr&#125; - $&#123;fdtaddr&#125;&quot;saveenvrun netboot 2. SPI设备——tlc5615TLC5615是一个10位的DAC，最大输出电压位基准电压的两倍。这个驱动比较简单，没什么特别的难点，唯一特殊的是TLC5615每次传输是12位数据(10位data+2位extra)，因此在probe()函数里，需要spi-&gt;bits_per_word = 12;；另外，因为每次传输的数据位12位，spi_write()的第三个参数不再是1，而是spi_write(spi_tlc5615_dev, &amp;ker_buf, 2);； 2.1 设备树12345678910111213141516171819202122232425262728293031323334/* SPI Busses */&amp;spi1 &#123; status = \"okay\"; pinctrl-names = \"default\"; pinctrl-0 = &lt;&amp;spi1_pins&gt;; spidev@0 &#123; spi-max-frequency = &lt;25000000&gt;; reg = &lt;0&gt;; compatible = \"rohm,dh2228fv\"; /* spi-cpha; sets CPHA=1, default is CPHA=0 */ /* spi-cpol; sets CPOL=1, default is CPOL=0 */ /* spi-cs-high; default is spi cs low */ &#125;; spidev@1 &#123; spi-max-frequency = &lt;25000000&gt;; reg = &lt;1&gt;; compatible = \"ti,tlc5615\"; &#125;;&#125;;&amp;am33xx_pinmux &#123; spi1_pins: pinmux_spi1 &#123; pinctrl-single,pins = &lt; 0x190 (PIN_INPUT_PULLUP | MUX_MODE3) /* spi1_sclk */ 0x194 (PIN_INPUT_PULLUP | MUX_MODE3) /* spi1_d0 */ 0x198 (PIN_INPUT_PULLUP | MUX_MODE3) /* spi1_d1 */ 0x19c (PIN_INPUT_PULLUP | MUX_MODE3) /* spi1_cs0 */ &gt;; &#125;;&#125;; 2.2 驱动程序[tl5615.c]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;asm/io.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_device.h&gt;#include &lt;linux/of_platform.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/spi/spi.h&gt;static int major;static dev_t devid;static struct class *tlc5615_class;static struct cdev tlc5615_cdev;static struct spi_device *spi_tlc5615_dev;static int tlc5615_open (struct inode *node, struct file *filp)&#123; return 0;&#125;static int tlc5615_release (struct inode *node, struct file *filp)&#123; return 0;&#125;static ssize_t tlc5615_write (struct file *filp, const char __user *buf, size_t size, loff_t *off)&#123; int ret; unsigned int ker_buf; if(copy_from_user(&amp;ker_buf, buf, 4)) return 0; if (ker_buf &gt; 1023) ker_buf = 1023; ker_buf = (ker_buf &lt;&lt; 2) &amp; (0xFFC); //printk(\"ker_buf=%d\\n\", ker_buf); ret = spi_write(spi_tlc5615_dev, &amp;ker_buf, 2); if(ret != 0) &#123; printk(\"spi write error\\n\"); return -EINVAL; &#125; return 4; &#125;static struct file_operations tlc5615_ops = &#123; .owner = THIS_MODULE, .open = tlc5615_open, .write = tlc5615_write, .release = tlc5615_release,&#125;;static int tlc5615_probe(struct spi_device *spi)&#123; int ret; spi-&gt;bits_per_word = 12; //tl5615 transmits 12bits(10bits data + 2bit extra)each time. if (spi_setup(spi) &lt; 0) &#123; printk(\"spi master doesn't support 12 bits/word \\n\"); return -EINVAL; &#125; spi_tlc5615_dev = spi; if(alloc_chrdev_region(&amp;devid, 0, 1, \"tlc5615\") &lt; 0) &#123; printk(KERN_INFO\"Unable to alloc_chrdev_region.\\n\"); return -EINVAL; &#125; major = MAJOR(devid); cdev_init(&amp;tlc5615_cdev, &amp;tlc5615_ops); ret = cdev_add(&amp;tlc5615_cdev, devid, 1); if (ret &lt; 0) &#123; printk(KERN_ERR \"Unable to cdev_add.\\n\"); goto error; &#125; tlc5615_class = class_create(THIS_MODULE, \"tlc5615\"); device_create(tlc5615_class, NULL, MKDEV(major, 0), NULL, \"tlc5615\"); // /dev/tlc5615 return 0;error: unregister_chrdev_region(devid, 1); return -EINVAL;&#125;static int tlc5615_remove(struct spi_device *spi)&#123; device_destroy(tlc5615_class, MKDEV(major, 0)); class_destroy(tlc5615_class); unregister_chrdev_region(devid, 1); cdev_del(&amp;tlc5615_cdev); return 0;&#125;static const struct of_device_id of_match_spi[] = &#123; &#123; .compatible = \"ti,tlc5615\", .data = NULL &#125;, &#123; /* sentinel */ &#125;&#125;;static struct spi_driver tlc5615_driver = &#123; .probe = tlc5615_probe, .remove = tlc5615_remove, .driver = &#123; .name = \"tlc5615\", .owner = THIS_MODULE, .of_match_table = of_match_spi, &#125;,&#125;;module_spi_driver(tlc5615_driver);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am335x board spi device: tl5615 driver.\");MODULE_VERSION(\"v1.0\"); 2.3 测试程序[tl5615_app.c]1234567891011121314151617181920212223242526272829#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;// ./tl5615_app val // val = 0~4.096v (0~1023)int main(int argc, char **argv)&#123; int fd; float f_val = atof(argv[1]); unsigned int i_val = f_val * 1000 / 4; if(i_val &gt; 1023) i_val = 1023; fd = open(\"/dev/tlc5615\", O_RDWR); if (fd &lt; 0) printf(\"Can't open!\\n\"); write(fd, &amp;i_val, 4); close(fd); return 0;&#125; 输出电压计算公式：1output=2*(Vref)*(val/1024) //其中val为SPI传输的前10位数据。 3. SPI设备——ssd1306SSD1306是一个分辨率为128*64的OLED显示屏。OLED的驱动稍微麻烦一点，除了对SSD1306的基本操作，还要解决以下两个问题。 1.需要设备树提供DC引脚采用SPI接口的OLED，除了时钟引脚(CLK)、使能引脚(EN)、数据发送引脚(MOSI)外，还需要数据/命令切换引脚(DC)。因为OLED只接收数据的缘故，AM335X的数据接收引脚(MISO)就不需要了。因此需要在设备树中加入DC引脚信息，并在驱动中解析使用。 2.需要支持软件片选AM335X的SPI只有两个硬件片选CS0和CS1，现在有了三个设备，两个片选自然是不够的，因此需要添加软件片选，即使用GPIO作为片选引脚。而AM335X的SDK目前是不支持软件片选的，因此需要修改SPI控制器驱动(spi-omap2-mcspi.c)来实现。 修改的思路也比较简单，关注两个变量spi-&gt;chip_select和spi-&gt;cs_gpio。spi-&gt;chip_select是设备树中reg的值，为0、1分别表示CS0和CS1，从2开始，就意味着该设备使用GPIO作为片选了；spi-&gt;cs_gpio是设备树中cs-gpios的值，如果在设备树中值为&lt;0&gt;，这里将为-2，说明使用的是硬件片选，如果在设备树中值为&lt;&amp;gpio0 13 0&gt;，这里将为13，说明使用的是软件片选。 因此只需要在omap2_mcspi_setup()函数里，根据spi-&gt;chip_select的值来判断是否使用的是GPIO片选，如果不是，使用原来的函数，如果是，则对GPIO片选引脚进行初始化。然后在omap2_mcspi_force_cs()函数里，根据spi-&gt;chip_select的值来判断是否使用的是GPIO片选，如果不是，使用原来的函数，如果是，则控制GPIO输出电平实现片选。 修改内容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576--- spi-omap2-mcspi_bak.c 2018-12-27 16:06:05.159509054 +0800+++ spi-omap2-mcspi.c 2018-12-28 11:25:42.242154915 +0800@@ -35,7 +35,7 @@ #include &lt;linux/gcd.h&gt; #include &lt;linux/spi/spi.h&gt;-+#include &lt;linux/gpio.h&gt; #include &lt;linux/platform_data/spi-omap2-mcspi.h&gt; #define OMAP2_MCSPI_MAX_FREQ 48000000@@ -245,14 +245,31 @@ static void omap2_mcspi_force_cs(struct spi_device *spi, int cs_active) &#123; l = mcspi_cached_chconf0(spi);+ if (spi-&gt;cs_gpio &gt;= 0)+ &#123;+ if (cs_active)+ &#123;+ l |= OMAP2_MCSPI_CHCONF_FORCE;+ mcspi_write_chconf0(spi, l);+ gpio_direction_output(spi-&gt;cs_gpio, 0);+ &#125;+ else+ &#123;+ l &amp;= ~OMAP2_MCSPI_CHCONF_FORCE;+ mcspi_write_chconf0(spi, l);+ gpio_direction_output(spi-&gt;cs_gpio, 1);+ &#125;+ &#125;-- mcspi_write_chconf0(spi, l);+ &#123;+ l = mcspi_cached_chconf0(spi);+ if (cs_active)+ l |= OMAP2_MCSPI_CHCONF_FORCE;+ else+ l &amp;= ~OMAP2_MCSPI_CHCONF_FORCE;+ + mcspi_write_chconf0(spi, l);+ &#125; &#125; static void omap2_mcspi_set_master_mode(struct spi_master *master)@@ -995,6 +1012,23 @@ struct omap2_mcspi_dma *mcspi_dma; struct omap2_mcspi_cs *cs = spi-&gt;controller_state; + if (spi-&gt;chip_select &gt; 1) //using GPIO as a chip select, reg value &gt;1 in the devicetree+ &#123; + if (spi-&gt;cs_gpio &lt; 0)+ return -EIO;+ + if (gpio_is_valid(spi-&gt;cs_gpio)) + &#123;+ if ((gpio_request(spi-&gt;cs_gpio, \"cs_gpio\")) &lt; 0) + &#123;+ printk(\"Error requesting gpio %d for spi cs pin\\n\", spi-&gt;cs_gpio);+ return -EBUSY;+ &#125;+ gpio_direction_output(spi-&gt;cs_gpio, 1);+ &#125;+ spi-&gt;chip_select = 0; //using GPIO as a chip select, only use DAM0/channel 0 or 1+ &#125;+ mcspi_dma = &amp;mcspi-&gt;dma_channels[spi-&gt;chip_select]; if (!cs) &#123;@@ -1056,6 +1090,9 @@ mcspi_dma-&gt;dma_tx = NULL; &#125; &#125;+ + if (spi-&gt;cs_gpio &gt;= 0)+ gpio_free(spi-&gt;cs_gpio); &#125; 3.1 设备树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* SPI Busses */&amp;spi1 &#123; status = \"okay\"; pinctrl-names = \"default\"; pinctrl-0 = &lt;&amp;spi1_pins&gt;; ti,pindir-d0-out-d1-in; ti,spi-num-cs = &lt;3&gt;; cs-gpios = &lt;0&gt;, &lt;0&gt;, &lt;&amp;gpio0 13 0&gt;; spidev@0 &#123; compatible = \"rohm,dh2228fv\"; spi-max-frequency = &lt;25000000&gt;; reg = &lt;0&gt;; /* spi-cpha; sets CPHA=1, default is CPHA=0 */ /* spi-cpol; sets CPOL=1, default is CPOL=0 */ /* spi-cs-high; default is spi cs low */ &#125;; spidev@1 &#123; compatible = \"ti,tlc5615\"; spi-max-frequency = &lt;25000000&gt;; reg = &lt;1&gt;; &#125;; spidev@2 &#123; compatible = \"solomon,ssd1306fb-spi\"; //OLED spi-max-frequency = &lt;25000000&gt;; reg = &lt;2&gt;; dc-gpio = &lt;&amp;gpio0 12 0&gt;; pinctrl-0 = &lt;&amp;oled_dc_pin&gt;; &#125;; &#125;;&amp;am33xx_pinmux &#123; spi1_pins: pinmux_spi1 &#123; pinctrl-single,pins = &lt; 0x190 (PIN_INPUT_PULLUP | MUX_MODE3) /* spi1_sclk */ 0x194 (PIN_INPUT_PULLUP | MUX_MODE3) /* spi1_d0 */ 0x198 (PIN_INPUT_PULLUP | MUX_MODE3) /* spi1_d1 */ 0x19c (PIN_INPUT_PULLUP | MUX_MODE3) /* spi1_cs0 */ &gt;; &#125;; oled_dc_pin: oled_dc_pin0 &#123; pinctrl-single,pins = &lt; 0x178 (PIN_INPUT_PULLDOWN | MUX_MODE7) /* conf_uart1_ctsn.gpio0_12 */ &gt;; &#125;;&#125;; 其中ti,spi-num-cs指定片选数量；cs-gpios列出所有的片选引脚，硬件片选填入0代替，软件片选填入对应的GPIO引脚；spidev@2使用软件片选，reg因此要设置为2；dc-gpio设置OLED的DC引脚；pinctrl-0引用oled_dc_pin，将其设置为GPIO功能； 3.2 驱动程序[fb_ssd1306_drv.c]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269#include &lt;asm/io.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_gpio.h&gt;#include &lt;linux/of_device.h&gt;#include &lt;linux/of_platform.h&gt;#include &lt;linux/spi/spi.h&gt;#define OLED_CMD_INIT 0x100001#define OLED_CMD_CLEAR_ALL 0x100002#define OLED_CMD_CLEAR_PAGE 0x100003#define OLED_CMD_SET_POS 0x100004static int major;static dev_t devid;static struct class *ssd1306_class;static struct cdev ssd1306_cdev;static unsigned char *ker_buf;static int spi_oled_dc_pin;static struct spi_device *spi_ssd1306_dev;static void ssd1306_set_dc(char val)&#123; gpio_direction_output(spi_oled_dc_pin, val);&#125;static void ssd1306_write_cmd(unsigned char cmd)&#123; ssd1306_set_dc(0); spi_write(spi_ssd1306_dev, &amp;cmd, 1); ssd1306_set_dc(1); &#125;static void ssd1306_write_data(unsigned char data)&#123; ssd1306_set_dc(1); spi_write(spi_ssd1306_dev, &amp;data, 1); ssd1306_set_dc(1); &#125;static void ssd1306_set_page_addr_mode(void)&#123; ssd1306_write_cmd(0x20); ssd1306_write_cmd(0x02);&#125;static void ssd1306_set_pos(int page, int col)&#123; ssd1306_write_cmd(0xB0 + page); //page address ssd1306_write_cmd(col &amp; 0xF); //Lower Column Start Address ssd1306_write_cmd(0x10 + (col &gt;&gt; 4)); //Lower Higher Start Address &#125;static void ssd1306_clear(void)&#123; int page, i; for (page = 0; page &lt; 8; page ++) &#123; ssd1306_set_pos(page, 0); for (i = 0; i &lt; 128; i++) ssd1306_write_data(0); &#125;&#125;void ssd1306_clear_page(int page)&#123; int i; ssd1306_set_pos(page, 0); for (i = 0; i &lt; 128; i++) ssd1306_write_data(0); &#125;void ssd1306_init(void)&#123; ssd1306_write_cmd(0xAE); /*display off*/ ssd1306_write_cmd(0x00); /*set lower column address*/ ssd1306_write_cmd(0x10); /*set higher column address*/ ssd1306_write_cmd(0x40); /*set display start line*/ ssd1306_write_cmd(0xB0); /*set page address*/ ssd1306_write_cmd(0x81); /*contract control*/ ssd1306_write_cmd(0x66); /*128*/ ssd1306_write_cmd(0xA1); /*set segment remap*/ ssd1306_write_cmd(0xA6); /*normal / reverse*/ ssd1306_write_cmd(0xA8); /*multiplex ratio*/ ssd1306_write_cmd(0x3F); /*duty = 1/64*/ ssd1306_write_cmd(0xC8); /*Com scan direction*/ ssd1306_write_cmd(0xD3); /*set display offset*/ ssd1306_write_cmd(0x00); ssd1306_write_cmd(0xD5); /*set osc division*/ ssd1306_write_cmd(0x80); ssd1306_write_cmd(0xD9); /*set pre-charge period*/ ssd1306_write_cmd(0x1f); ssd1306_write_cmd(0xDA); /*set COM pins*/ ssd1306_write_cmd(0x12); ssd1306_write_cmd(0xdb); /*set vcomh*/ ssd1306_write_cmd(0x30); ssd1306_write_cmd(0x8d); /*set charge pump enable*/ ssd1306_write_cmd(0x14); ssd1306_set_page_addr_mode(); ssd1306_clear(); ssd1306_write_cmd(0xAF); /*display ON*/ &#125;static long ssd1306_ioctl(struct file *file, unsigned int cmd, unsigned long arg)&#123; int page; int col; switch (cmd) &#123; case OLED_CMD_INIT: &#123; ssd1306_init(); break; &#125; case OLED_CMD_CLEAR_ALL: &#123; ssd1306_clear(); break; &#125; case OLED_CMD_CLEAR_PAGE: &#123; page = arg; ssd1306_clear_page(page); break; &#125; case OLED_CMD_SET_POS: &#123; page = arg &amp; 0xff; col = (arg &gt;&gt; 8) &amp; 0xff; ssd1306_set_pos(page, col); break; &#125; &#125; return 0;&#125;static ssize_t ssd1306_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)&#123; int ret; if (count &gt; 4096) return -EINVAL; ret = copy_from_user(ker_buf, buf, count); ssd1306_set_dc(1); /* data */ spi_write(spi_ssd1306_dev, ker_buf, count); return 0;&#125;static struct file_operations ssd1306_ops = &#123; .owner = THIS_MODULE, .unlocked_ioctl = ssd1306_ioctl, .write = ssd1306_write,&#125;;static int ssd1306_probe(struct spi_device *spi)&#123; int ret; spi_ssd1306_dev = spi; spi_oled_dc_pin = of_get_named_gpio(spi_ssd1306_dev-&gt;dev.of_node, \"dc-gpio\", 0); //dc and uart1 is same pin. if (gpio_is_valid(spi_oled_dc_pin)) &#123; if ((gpio_request(spi_oled_dc_pin, \"dc_pin\")) &lt; 0) &#123; printk(KERN_ERR \"Error requesting gpio %d for spi oled dc pin\\n\", spi_oled_dc_pin); return -1; &#125; gpio_direction_output(spi_oled_dc_pin, 0); &#125; ker_buf = kmalloc(4096, GFP_KERNEL); if (!ker_buf) &#123; printk(KERN_ERR \"kmalloc error\\n\"); goto err1; &#125; if(alloc_chrdev_region(&amp;devid, 0, 1, \"ssd1306_dev\") &lt; 0) &#123; printk(KERN_INFO\"Unable to alloc_chrdev_region.\\n\"); goto err2; &#125; major = MAJOR(devid); cdev_init(&amp;ssd1306_cdev, &amp;ssd1306_ops); ret = cdev_add(&amp;ssd1306_cdev, devid, 1); if (ret &lt; 0) &#123; printk(KERN_ERR \"Unable to cdev_add.\\n\"); goto err3; &#125; ssd1306_class = class_create(THIS_MODULE, \"ssd1306_class\"); device_create(ssd1306_class, NULL, MKDEV(major, 0), NULL, \"ssd1306\"); // /dev/ssd1306 return 0; err3: unregister_chrdev_region(devid, 1); cdev_del(&amp;ssd1306_cdev); err2: kfree(ker_buf);err1: gpio_free(spi_oled_dc_pin); return -1;&#125;static int ssd1306_remove(struct spi_device *spi)&#123; device_destroy(ssd1306_class, MKDEV(major, 0)); class_destroy(ssd1306_class); unregister_chrdev_region(devid, 1); cdev_del(&amp;ssd1306_cdev); kfree(ker_buf); gpio_free(spi_oled_dc_pin); return 0;&#125;static const struct of_device_id of_match_spi[] = &#123; &#123; .compatible = \"solomon,ssd1306fb-spi\", .data = NULL &#125;, &#123; /* sentinel */ &#125;&#125;;static struct spi_driver ssd1306_driver = &#123; .probe = ssd1306_probe, .remove = ssd1306_remove, .driver = &#123; .name = \"ssd1306_drv\", .owner = THIS_MODULE, .of_match_table = of_match_spi, &#125;,&#125;;module_spi_driver(ssd1306_driver);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am335x board spi device: ssd1306 driver.\");MODULE_VERSION(\"v1.0\"); SPI设备驱动程序没什么特别的。 3.3 测试程序[oled_app.c]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ioctl.h&gt;/* oled_test init * oled_test clear * oled_test clear &lt;page&gt; * oled_test &lt;page&gt; &lt;col&gt; &lt;string&gt; */#define OLED_CMD_INIT 0x100001#define OLED_CMD_CLEAR_ALL 0x100002#define OLED_CMD_CLEAR_PAGE 0x100003#define OLED_CMD_SET_POS 0x100004const unsigned char oled_asc2_8x16[95][16]=&#123; &#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,// 0 &#123;0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00&#125;,//!1 &#123;0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,//\"2 &#123;0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00&#125;,//#3 &#123;0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00&#125;,//$4 &#123;0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00&#125;,//%5 &#123;0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10&#125;,//&amp;6 &#123;0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,//'7 &#123;0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00&#125;,//(8 &#123;0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00&#125;,//)9 &#123;0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00&#125;,//*10 &#123;0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00&#125;,//+11 &#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00&#125;,//,12 &#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01&#125;,//-13 &#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00&#125;,//.14 &#123;0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00&#125;,///15 &#123;0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00&#125;,//016 &#123;0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,//117 &#123;0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00&#125;,//218 &#123;0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00&#125;,//319 &#123;0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00&#125;,//420 &#123;0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00&#125;,//521 &#123;0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00&#125;,//622 &#123;0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00&#125;,//723 &#123;0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00&#125;,//824 &#123;0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00&#125;,//925 &#123;0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00&#125;,//:26 &#123;0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00&#125;,//;27 &#123;0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00&#125;,//&lt;28 &#123;0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00&#125;,//=29 &#123;0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00&#125;,//&gt;30 &#123;0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00&#125;,//?31 &#123;0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00&#125;,//@32 &#123;0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20&#125;,//A33 &#123;0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00&#125;,//B34 &#123;0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00&#125;,//C35 &#123;0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00&#125;,//D36 &#123;0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00&#125;,//E37 &#123;0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00&#125;,//F38 &#123;0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00&#125;,//G39 &#123;0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20&#125;,//H40 &#123;0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,//I41 &#123;0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00&#125;,//J42 &#123;0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00&#125;,//K43 &#123;0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00&#125;,//L44 &#123;0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00&#125;,//M45 &#123;0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00&#125;,//N46 &#123;0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00&#125;,//O47 &#123;0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00&#125;,//P48 &#123;0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00&#125;,//Q49 &#123;0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20&#125;,//R50 &#123;0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00&#125;,//S51 &#123;0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00&#125;,//T52 &#123;0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00&#125;,//U53 &#123;0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00&#125;,//V54 &#123;0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00&#125;,//W55 &#123;0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20&#125;,//X56 &#123;0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00&#125;,//Y57 &#123;0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00&#125;,//Z58 &#123;0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00&#125;,//[59 &#123;0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00&#125;,//\\60 &#123;0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00&#125;,//]61 &#123;0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,//^62 &#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80&#125;,//_63 &#123;0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,//`64 &#123;0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20&#125;,//a65 &#123;0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00&#125;,//b66 &#123;0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00&#125;,//c67 &#123;0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20&#125;,//d68 &#123;0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00&#125;,//e69 &#123;0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,//f70 &#123;0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00&#125;,//g71 &#123;0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20&#125;,//h72 &#123;0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,//i73 &#123;0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00&#125;,//j74 &#123;0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00&#125;,//k75 &#123;0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,//l76 &#123;0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F&#125;,//m77 &#123;0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20&#125;,//n78 &#123;0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00&#125;,//o79 &#123;0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00&#125;,//p80 &#123;0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80&#125;,//q81 &#123;0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00&#125;,//r82 &#123;0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00&#125;,//s83 &#123;0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00&#125;,//t84 &#123;0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20&#125;,//u85 &#123;0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00&#125;,//v86 &#123;0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00&#125;,//w87 &#123;0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00&#125;,//x88 &#123;0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00&#125;,//y89 &#123;0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00&#125;,//z90 &#123;0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40&#125;,//&#123;91 &#123;0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00&#125;,//|92 &#123;0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00&#125;,//&#125;93 &#123;0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,//~94&#125;; /* page: 0-7 * col : 0-127 * 字符: 8x16象素 */void OLEDPutChar(int fd, int page, int col, char c)&#123; int i = 0; /* 得到字模 */ const unsigned char *dots = oled_asc2_8x16[c - ' ']; /* 发给OLED */ //OLEDSetPos(page, col); //ioctl(fd, OLED_CMD_CLEAR_PAGE, page); ioctl(fd, OLED_CMD_SET_POS, page | (col &lt;&lt; 8)); /* 发出8字节数据 */ //for (i = 0; i &lt; 8; i++) // OLEDWriteDat(dots[i]); write(fd, &amp;dots[0], 8); //OLEDSetPos(page+1, col); //ioctl(fd, OLED_CMD_CLEAR_PAGE, page+1); ioctl(fd, OLED_CMD_SET_POS, (page+1) | (col &lt;&lt; 8)); /* 发出8字节数据 */ //for (i = 0; i &lt; 8; i++) // OLEDWriteDat(dots[i+8]); write(fd, &amp;dots[8], 8);&#125;/* page: 0-7 * col : 0-127 * 字符: 8x16象素 */void OLEDPrint(int fd, int page, int col, char *str)&#123; int i = 0; ioctl(fd, OLED_CMD_CLEAR_PAGE, page); ioctl(fd, OLED_CMD_CLEAR_PAGE, page+1); while (str[i]) &#123; OLEDPutChar(fd, page, col, str[i]); col += 8; if (col &gt; 127) &#123; col = 0; page += 2; ioctl(fd, OLED_CMD_CLEAR_PAGE, page); ioctl(fd, OLED_CMD_CLEAR_PAGE, page+1); &#125; i++; &#125;&#125;void print_usage(char *cmd)&#123; printf(\"Usage:\\n\"); printf(\"%s init\\n\", cmd); printf(\"%s clear\\n\", cmd); printf(\"%s clear &lt;page&gt;\\n\", cmd); printf(\"%s &lt;page&gt; &lt;col&gt; &lt;string&gt;\\n\", cmd); printf(\"eg:\\n\"); printf(\"%s 2 0 100ask.taobao.com\\n\", cmd); printf(\"page is 0,1,...,7\\n\"); printf(\"col is 0,1,...,127\\n\");&#125;int main(int argc, char **argv)&#123; int do_init = 0; int do_clear = 0; int do_show = 0; int page = -1; int col; int fd; if (argc == 2 &amp;&amp; !strcmp(argv[1], \"init\")) do_init = 1; if ((argc == 2) &amp;&amp; !strcmp(argv[1], \"clear\")) &#123; do_clear = 1; &#125; if ((argc == 3) &amp;&amp; !strcmp(argv[1], \"clear\")) &#123; do_clear = 1; page = strtoul(argv[2], NULL, 0); &#125; if (argc == 4) &#123; do_show = 1; page = strtoul(argv[1], NULL, 0); col = strtoul(argv[2], NULL, 0); &#125; if (!do_init &amp;&amp; !do_clear &amp;&amp; !do_show) &#123; print_usage(argv[0]); return -1; &#125; fd = open(\"/dev/ssd1306\", O_RDWR); if (fd &lt; 0) &#123; printf(\"can't open /dev/ssd1306\\n\"); return -1; &#125; if (do_init) ioctl(fd, OLED_CMD_INIT); else if (do_clear) &#123; if (page == -1) ioctl(fd, OLED_CMD_CLEAR_ALL); else &#123; if (page &lt; 0 || page &gt; 7) &#123; printf(\"page is 0,1,...,7\\n\"); return -1; &#125; ioctl(fd, OLED_CMD_CLEAR_PAGE, page); &#125; &#125; else if (do_show) &#123; if (page &lt; 0 || page &gt; 7) &#123; printf(\"page is 0,1,...,7\\n\"); return -1; &#125; if (col &lt; 0 || col &gt; 127) &#123; printf(\"col is 0,1,...,127\\n\"); return -1; &#125; OLEDPrint(fd, page, col, argv[3]); &#125; return 0;&#125; 4. SPI设备——w25q16dvw25q16dv是一个2M大小的Flash。 在写驱动之前，需要了解下这几个知识点： 1.w25q16dv的Byte、Page、Sector、Block之间的关系Byte(字节)由8个bits(位)组成，是数据的最小存储单位，1024个Byte就是我们常见的1KB；Page(页)由256个Byte组成，w25q16dv每次SPI写操作只能是1~256个字节，因此遇到大数据传输时，需要分页写；Sector(扇区)由16个Byte组成，也是4K大小，w25q16dv每次SPI擦除操作就是以Sector为最小单位；Block(块)由16个Sector组成，为64K大小；它们之间大小关系如下：另外，Flash的硬件决定了，每个bits只能从1变为0，不能0变成1，因此每次写之前需要先擦除为0xFF，再写入数据。 2.DMA与SPI的关系AM335X的SPI控制器的源码里，会根据SPI一次传输的数据长短来决定是否启用DMA传输。当一次传输的数据长度小于DMA_MIN_BYTES，则不会启用DMA，CPU会先读取RAM中的数据，再写到SPI控制器的TX_BUF寄存器里面，如下图路线①；当一次传输的数据长度大于DMA_MIN_BYTES，则会启用DMA，CPU设置好DMA后，DMA自动从RAM搬运数据到SPI控制器的TX_BUF寄存器里面，如下图路线②； 3.函数调用关系分析在应用层写操作w25q16dv时，会调用到w25q16dv_drv.c： 123w25q16dv_write(); spi_flash_program(); spi_sync(); 再调用到drivers/spi/spi.c:123__spi_sync(); __spi_pump_messages(); master-&gt;transfer_one_message(master, master-&gt;cur_msg); 再调用到drivers/spi/spi-omap2-mcspi.c:123456omap2_mcspi_transfer_one_message(); dma_map_single(); //根据长度是否映射DMA omap2_mcspi_work(); omap2_mcspi_txrx_dma(); //使用DMA传输 或 omap2_mcspi_txrx_pio(); //使用PIO传输 4.1 设备树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* SPI Busses */&amp;spi1 &#123; status = \"okay\"; pinctrl-names = \"default\"; pinctrl-0 = &lt;&amp;spi1_pins&gt;; ti,pindir-d0-out-d1-in; ti,spi-num-cs = &lt;4&gt;; cs-gpios = &lt;0&gt;, &lt;0&gt;, &lt;&amp;gpio0 13 0&gt;, &lt;&amp;gpio0 14 0&gt;; spidev@0 &#123; compatible = \"rohm,dh2228fv\"; spi-max-frequency = &lt;25000000&gt;; reg = &lt;0&gt;; /* spi-cpha; sets CPHA=1, default is CPHA=0 */ /* spi-cpol; sets CPOL=1, default is CPOL=0 */ /* spi-cs-high; default is spi cs low */ &#125;; spidev@1 &#123; compatible = \"ti,tlc5615\"; spi-max-frequency = &lt;25000000&gt;; reg = &lt;1&gt;; &#125;; spidev@2 &#123; compatible = \"solomon,ssd1306fb-spi\"; //OLED spi-max-frequency = &lt;25000000&gt;; reg = &lt;2&gt;; dc-gpio = &lt;&amp;gpio0 12 0&gt;; pinctrl-0 = &lt;&amp;oled_dc_pin&gt;; &#125;; spidev@3 &#123; spi-max-frequency = &lt;20000000&gt;; reg = &lt;3&gt;; compatible = \"winbond,w25q16dv\"; &#125;; &#125;;&amp;am33xx_pinmux &#123; spi1_pins: pinmux_spi1 &#123; pinctrl-single,pins = &lt; 0x190 (PIN_INPUT_PULLUP | MUX_MODE3) /* spi1_sclk */ 0x194 (PIN_INPUT_PULLUP | MUX_MODE3) /* spi1_d0 */ 0x198 (PIN_INPUT_PULLUP | MUX_MODE3) /* spi1_d1 */ 0x19c (PIN_INPUT_PULLUP | MUX_MODE3) /* spi1_cs0 */ &gt;; &#125;; oled_dc_pin: oled_dc_pin0 &#123; pinctrl-single,pins = &lt; 0x178 (PIN_INPUT_PULLDOWN | MUX_MODE7) /* conf_uart1_ctsn.gpio0_12 */ &gt;; &#125;;&#125;; 4.2 程序驱动[w25q16dv_drv.c]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;asm/io.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_device.h&gt;#include &lt;linux/of_platform.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/spi/spi.h&gt;#include &lt;linux/mtd/cfi.h&gt;#include &lt;linux/mtd/mtd.h&gt;#include &lt;linux/mtd/partitions.h&gt;static struct spi_device *spi_w25q16dv_dev;static struct mtd_info flash_w25q16dv_dev;void spi_flash_read_ID(int *pMID, int *pDID)&#123; unsigned char tx_buf[4]; unsigned char rx_buf[2]; tx_buf[0] = 0x90; tx_buf[1] = 0; tx_buf[2] = 0; tx_buf[3] = 0; spi_write_then_read(spi_w25q16dv_dev, tx_buf, 4, rx_buf, 2); *pMID = rx_buf[0]; *pDID = rx_buf[1];&#125;static void spi_flash_write_eable(int enable)&#123; unsigned char val = enable ? 0x06 : 0x04; spi_write(spi_w25q16dv_dev, &amp;val, 1); &#125;static unsigned char spi_flash_read_status_reg1(void)&#123; unsigned char val; unsigned char cmd = 0x05; spi_write_then_read(spi_w25q16dv_dev, &amp;cmd, 1, &amp;val, 1); return val;&#125;static unsigned char spi_flash_read_status_reg2(void)&#123; unsigned char val; unsigned char cmd = 0x35; spi_write_then_read(spi_w25q16dv_dev, &amp;cmd, 1, &amp;val, 1); return val;&#125;static void spi_flash_wait_when_busy(void)&#123; while (spi_flash_read_status_reg1() &amp; 1) &#123; /* Sector erase time : 60ms * Page program time : 0.7ms * Write status reg time : 10ms */ set_current_state(TASK_INTERRUPTIBLE); //Sleep for a while schedule_timeout(HZ/100); //Judging again after sleeping 10MS(1s=1HZ) &#125;&#125;static void spi_flash_write_status_reg(unsigned char reg1, unsigned char reg2)&#123; unsigned char tx_buf[3]; spi_flash_write_eable(1); tx_buf[0] = 0x01; tx_buf[1] = reg1; tx_buf[2] = reg2; spi_write(spi_w25q16dv_dev, tx_buf, 3); spi_flash_wait_when_busy();&#125;static void spi_flash_clear_protect_for_status_reg(void)&#123; unsigned char reg1, reg2; reg1 = spi_flash_read_status_reg1(); reg2 = spi_flash_read_status_reg2(); reg1 &amp;= ~(1&lt;&lt;7); reg2 &amp;= ~(1&lt;&lt;0); spi_flash_write_status_reg(reg1, reg2);&#125;static void spi_flash_clear_protect_for_data(void)&#123; /* cmp=0,bp2,1,0=0b000 */ unsigned char reg1, reg2; reg1 = spi_flash_read_status_reg1(); reg2 = spi_flash_read_status_reg2(); reg1 &amp;= ~(7&lt;&lt;2); reg2 &amp;= ~(1&lt;&lt;6); spi_flash_write_status_reg(reg1, reg2);&#125;/* erase 4K */void spi_flash_erase_sector(unsigned int addr)&#123; unsigned char tx_buf[4]; tx_buf[0] = 0x20; tx_buf[1] = addr &gt;&gt; 16; tx_buf[2] = addr &gt;&gt; 8; tx_buf[3] = addr &amp; 0xff; spi_flash_write_eable(1); spi_write(spi_w25q16dv_dev, tx_buf, 4); spi_flash_wait_when_busy();&#125;/* program */void spi_flash_program(unsigned int addr, unsigned char *buf, int len)&#123; int ret; int i; unsigned char tx_buf[4]; struct spi_transfer t[] = &#123; &#123; .tx_buf = tx_buf, .len = 4, &#125;, &#123; .tx_buf = buf, .len = len, &#125;, &#125;; struct spi_message m; tx_buf[0] = 0x02; tx_buf[1] = addr &gt;&gt; 16; tx_buf[2] = addr &gt;&gt; 8; tx_buf[3] = addr &amp; 0xff; spi_flash_write_eable(1); spi_message_init(&amp;m); spi_message_add_tail(&amp;t[0], &amp;m); spi_message_add_tail(&amp;t[1], &amp;m); ret = spi_sync(spi_w25q16dv_dev, &amp;m); if (ret) &#123; printk(\"spi_flash_program spi_syn err : %d\\n\", ret); &#125; spi_flash_wait_when_busy(); &#125;void spi_flash_read(unsigned int addr, unsigned char *buf, int len)&#123; unsigned char tx_buf[4]; struct spi_transfer t[] = &#123; &#123; .tx_buf = tx_buf, .len = 4, &#125;, &#123; .rx_buf = buf, .len = len, &#125;, &#125;; struct spi_message m; tx_buf[0] = 0x03; tx_buf[1] = addr &gt;&gt; 16; tx_buf[2] = addr &gt;&gt; 8; tx_buf[3] = addr &amp; 0xff; spi_message_init(&amp;m); spi_message_add_tail(&amp;t[0], &amp;m); spi_message_add_tail(&amp;t[1], &amp;m); spi_sync(spi_w25q16dv_dev, &amp;m); &#125;static void spi_flash_init(void)&#123; spi_flash_clear_protect_for_status_reg(); spi_flash_clear_protect_for_data();&#125;static int w25q16dv_erase(struct mtd_info *mtd, struct erase_info *instr)&#123; unsigned int addr = instr-&gt;addr; unsigned int len = 0; //Judgment parameter if ((addr &amp; (flash_w25q16dv_dev.erasesize - 1)) || (instr-&gt;len &amp; (flash_w25q16dv_dev.erasesize - 1))) &#123; printk(\"w25q16dv_erase:addr/len is not aligned\\n\"); return -EINVAL; &#125; for (len = 0; len &lt; instr-&gt;len; len += 4096) &#123; spi_flash_erase_sector(addr); addr += 4096; &#125; instr-&gt;state = MTD_ERASE_DONE; mtd_erase_callback(instr); return 0;&#125;#define NUM 256static int w25q16dv_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)&#123; int i; int left = len; int rlen;#if 0 spi_flash_read(from, buf, len);#else while (left &gt; 0) &#123; if (left &lt;= NUM) rlen = left; else rlen = NUM; spi_flash_read(from, buf, rlen); from += rlen; buf += rlen; left -= rlen; &#125;#endif *retlen = len; return 0;&#125;static int w25q16dv_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)&#123;#if 0 int data_addr = to; int data_len = len; int i=0, left_len=0, right_len=0, page_num=0; printk(\"data_addr=0x%02x, data_len=0x%x\\n\", data_addr, data_len); for (i = 0; i &lt; 16 &amp;&amp; i &lt; data_len; i++) &#123; printk(\"%02x \", buf[i]); &#125; printk(\"\\n\"); if (data_addr%NUM + data_len &lt;= NUM) &#123; spi_flash_program(data_addr, (unsigned char *)buf, data_len); &#125; else &#123; left_len = NUM - (data_addr%NUM); page_num = (data_len - left_len) / NUM; right_len = len - page_num*NUM - left_len; spi_flash_program(data_addr, (unsigned char *)buf, left_len); for (i=0; i&lt;page_num; i++) spi_flash_program(data_addr+NUM*i+left_len, (unsigned char *)(buf+NUM*i+left_len), NUM); spi_flash_program(data_addr+NUM*i+left_len, (unsigned char *)(buf+NUM*i+left_len), right_len); &#125; *retlen = data_len;#else unsigned int addr = to; int unalign = addr &amp; (NUM - 1); int wlen; int left = len; int i; if (unalign) &#123; wlen = NUM - unalign; if (wlen &gt;= len) wlen = len; spi_flash_program(addr, (unsigned char *)buf, wlen); addr += wlen; buf += wlen; left -= wlen; &#125; while (left &gt; 0) &#123; if (left &gt;= NUM) wlen = NUM; else wlen = left; spi_flash_program(addr, (unsigned char *)buf, wlen); addr += wlen; buf += wlen; left -= wlen; &#125; *retlen = len;#endif return 0;&#125;static int w25q16dv_probe(struct spi_device *spi)&#123; int mid, did; printk(KERN_INFO \"run w25q16dv_probe\\n\"); spi_w25q16dv_dev = spi; spi_flash_init(); spi_flash_read_ID(&amp;mid, &amp;did); printk(\"SPI Flash ID: %02x %02x\\n\", mid, did); memset(&amp;flash_w25q16dv_dev, 0, sizeof(flash_w25q16dv_dev)); /* Setup the MTD structure */ flash_w25q16dv_dev.name = \"w25q16dv_spi_flash\"; flash_w25q16dv_dev.type = MTD_NORFLASH; flash_w25q16dv_dev.flags = MTD_CAP_NORFLASH; flash_w25q16dv_dev.size = 0x200000; /* 2M */ flash_w25q16dv_dev.writesize = 1; flash_w25q16dv_dev.writebufsize = 4096; /* no use */ flash_w25q16dv_dev.erasesize = 4096; /* Minimum unit of erasure */ flash_w25q16dv_dev.owner = THIS_MODULE; flash_w25q16dv_dev._erase = w25q16dv_erase; flash_w25q16dv_dev._read = w25q16dv_read; flash_w25q16dv_dev._write = w25q16dv_write; mtd_device_register(&amp;flash_w25q16dv_dev, NULL, 0); return 0;&#125;static int w25q16dv_remove(struct spi_device *spi)&#123; printk(KERN_INFO \"run w25q16dv_remove\\n\"); mtd_device_unregister(&amp;flash_w25q16dv_dev); return 0;&#125;static const struct of_device_id of_match_spi[] = &#123; &#123; .compatible = \"winbond,w25q16dv\", .data = NULL &#125;, &#123; /* sentinel */ &#125;&#125;;static struct spi_driver w25q16dv_driver = &#123; .probe = w25q16dv_probe, .remove = w25q16dv_remove, .driver = &#123; .name = \"w25q16dv_drv\", .owner = THIS_MODULE, .of_match_table = of_match_spi, &#125;,&#125;;module_spi_driver(w25q16dv_driver);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am335x board spi device: w25q16dv driver.\");MODULE_VERSION(\"v1.0\"); 这是遇到过数不多的块设备驱动，块设备驱动的写法都要忘了，以后块设备驱动可以参考这个。 4.3 测试程序在加载w25q16dv.ko驱动后，将会生成两个设备节点：/dev/mtdx和/dev/mtdblockx。/dev/mtdx是字符设备的节点，可以像字符设备那样读写；/dev/mtdblockx是块设备的节点，可以进行块设备类似的操作；两个节点都是操作的同一设备，而且最后调用的读写函数也是驱动中的同一个；两者差异体现在进行字符设备读写时，可以直接写到某个地址，而对块设备而言，需要先读块的内容，再擦除一个块，再写一个块。 测试方法有两种，一种是自己写应用程序，通过open()、read()、write()等进行操作；另一种是把整个Flash格式化成各种文件系统格式，然后挂载，拷贝文件，卸载，再次挂载检查之前拷贝的文件是否正常。 应用程序读写测试：[spi_flash_app.c]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;mtd/mtd-user.h&gt;#include &lt;errno.h&gt;#include &lt;getopt.h&gt;#include &lt;assert.h&gt;// Data types#define u8 unsigned char#define u16 unsigned short#define u32 unsigned long#define u64 unsigned long long int#define s8 char#define s16 int#define s32 long int#define s64 long long int#define boolean unsigned char#define BUFFER_SIZE 1024#define OTP_NUM_WORDS 0x40#define SUCCESS 0#define FAIL -1#define TRUE 1#define FALSE 0static const char *const short_options = \"ho:d:r:w::e\";static const struct option long_options[] =&#123; &#123;\"help\", no_argument, NULL, 'h'&#125;, &#123;\"device\", required_argument, NULL, 'd'&#125;, &#123;\"read\", required_argument, NULL, 'r'&#125;, &#123;\"offset\", required_argument, NULL, 'o'&#125;, &#123;\"write\", optional_argument, NULL, 'w'&#125;, &#123;\"erase\", no_argument, NULL, 'e'&#125;, &#123;0, 0, 0, 0&#125;&#125;;typedef enum&#123; RUN_READ, RUN_WRITE, RUN_ERASE, RUN_END&#125; run_type;static struct mtd_info_user info;static void show_usage()&#123; printf(\"\\nUsage: ./spi_flash_app -d &lt;device&gt; &lt;operation&gt;\\n\"); printf(\"\\nOperation:\\n\"); printf(\"\\t-e\\n\"); printf(\"\\t-r\\n\"); printf(\"\\t-w\\n\"); printf(\"\\t-o &lt;offset&gt;\\n\"); exit(0);&#125;static int mtd_read(const char *device, const unsigned int offset, const unsigned int size)&#123; assert(device); assert(size &gt; 0); int fd, ret = -1; fd = open(device, O_RDONLY); if(fd &lt; 0) &#123; printf(\"(E) Open device %s failed.\\n\", device); return -1; &#125; if (-1 == lseek(fd, offset, SEEK_SET)) &#123; printf(\"lseek 0x%x error\\n\"); return -1; &#125; char buf[size]; memset(buf, 0, size); ret = read(fd, buf, size); if(ret != -1) &#123; printf(\"buffer_read: \\n\"); int i; for(i = 0; i &lt; ret; i++) &#123; printf(\"%02x \", buf[i]); if(!((i + 1) % 10)) printf(\"\\n\"); &#125; printf(\"\\n Read ok!\\n\"); &#125; else &#123; printf(\"(E) Read error!\\n\"); &#125; close(fd); return ret;&#125;static int mtd_write(const char *device, const void *data, const unsigned int offset, const unsigned int size)&#123; assert(device); assert(data); assert(size &gt; 0); int fd, ret = -1; fd = open(device, O_RDWR); if(fd &lt; 0) &#123; printf(\"(E) Open device %s failed.\\n\", device); return -1; &#125; if (-1 == lseek(fd, offset, SEEK_SET)) &#123; printf(\"lseek 0x%x error\\n\"); return -1; &#125; ret = write(fd, data, size); if(ret != -1) &#123; if( ret == 0) printf(\"\\n Nothing to write!\\n\"); else printf(\"\\n Write ok!\\n\"); &#125; else &#123; printf(\"(E) Write error!\\n\"); &#125; close(fd); return ret;&#125;static int non_region_erase(const int fd, const int start, int count, const int unlock)&#123; mtd_info_t meminfo; if(ioctl(fd, MEMGETINFO, &amp;meminfo) == 0) &#123; erase_info_t erase; erase.start = start; erase.length = meminfo.erasesize; for(; count &gt; 0; count--) &#123; printf(\"Performing Flash Erase of length %u at offset 0x%x\\n\", erase.length, erase.start); fflush(stdout); if(unlock != 0) &#123; printf(\"Performing Flash unlock at offset 0x%x\\n\", erase.start); if(ioctl(fd, MEMUNLOCK, &amp;erase) != 0) &#123; perror(\"MTD unlock failure\"); close(fd); return -1; &#125; &#125; if(ioctl(fd, MEMERASE, &amp;erase) != 0) &#123; perror(\"MTD erase failure\"); close(fd); return -1; &#125; erase.start += meminfo.erasesize; &#125; printf(\" done\\n\"); &#125; return 0;&#125;static int mtd_erase(const char *device, const unsigned int regcount)&#123; assert(device); int fd, ret = -1; fd = open(device, O_RDWR); if(fd &lt; 0) &#123; printf(\"(E) Open device %s failed.\\n\", device); return -1; &#125; if(regcount == 0) &#123; ret = non_region_erase(fd, 0, (info.size / info.erasesize), 0); if(ret == 0) &#123; printf(\"\\n Erase ok!\\n\"); &#125; else &#123; printf(\"(E) Erase error!\\n\"); &#125; &#125; close(fd); return ret;&#125;static int EeReadLineFromEepFile(FILE *DataFile, s8 *Buffer, const u32 BufferSize)&#123; u32 Sign = 0; u16 StringIndex = 0; s16 EeStatus = SUCCESS; boolean EndOfLine = FALSE; boolean Comment = FALSE; do &#123; /* Read line from the file. If the line is longer * it will be serviced below */ if(fgets(Buffer, BufferSize, DataFile) == NULL) &#123; EeStatus = FAIL; break; &#125; /* Look for: * a semicolon in the string indicating a comment * a EOL just for detection if this is a full line * read to the buffer */ for(StringIndex = 0; StringIndex &lt; BufferSize; StringIndex++) &#123; /* Break the loop if string has ended */ if(Buffer[StringIndex] == '\\0') &#123; break; &#125; /* Detect end of line and comments */ if(Buffer[StringIndex] == '\\n' || Buffer[StringIndex] == '\\r' || Buffer[StringIndex] == ';') &#123; /* Determine which we encountered...EOL or * comment...add terminating NULL as needed */ if(Buffer[StringIndex] == ';') &#123; Comment = TRUE; Buffer[StringIndex] = '\\0'; &#125; else &#123; EndOfLine = TRUE; &#125; &#125; &#125; /* If the end of line was not detected - read the rest of * line and omit it if it's a comment */ if(EndOfLine == FALSE) &#123; if(Comment == TRUE) &#123; while((Sign = getc(DataFile)) != EOF) &#123; if(Sign == (u32)'\\n' || Sign == (u32)'\\r') &#123; break; &#125; &#125; &#125; /* If data in buffer does not contain the whole line * (it does not contain comment) * then it will be read in next step */ &#125; /* If this line is empty, clear local flags */ if(*Buffer == '\\0') &#123; EndOfLine = FALSE; Comment = FALSE; &#125; &#125; while(*Buffer == '\\0'); return EeStatus;&#125;static int mtd_write_file(const char *device, const char *filename)&#123; s8 retval = FAIL; u16 i = 0; s16 maxlen = 8 * 64; FILE *file = NULL; u32 b[8]; s8 temp[200]; u16 buffer[OTP_NUM_WORDS * 8]; file = fopen(filename, \"r\"); if(NULL == file) &#123; printf(\"Unable to open specified file: %s\\n\", filename); return -1; &#125; else &#123; //FILE *file_ro = file; // WTF! (FILE *)0x12008 --&gt; (FILE *)0x10000 by sscanf memset(b, 0x0, sizeof(b)); memset(buffer, 0x0, sizeof(buffer)); retval = EeReadLineFromEepFile(file, temp, 200); while ((SUCCESS == retval) &amp;&amp; (i &lt; maxlen)) &#123; // place the hex numbers from the line read in to the temp buffer sscanf(temp, \"%08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\", \\ &amp; (b[0]), &amp;(b[1]), &amp;(b[2]), &amp;(b[3]), \\ &amp; (b[4]), &amp;(b[5]), &amp;(b[6]), &amp;(b[7])); // copy the words to the permanent buffer buffer[i + 0] = b[0]; buffer[i + 1] = b[1]; buffer[i + 2] = b[2]; buffer[i + 3] = b[3]; buffer[i + 4] = b[4]; buffer[i + 5] = b[5]; buffer[i + 6] = b[6]; buffer[i + 7] = b[7]; // increment i by 8 so we can get the next 8 words i += 8; // read the next line retval = EeReadLineFromEepFile(file, temp, 200); &#125; &#125; fclose(file); mtd_write(device, buffer, 0, sizeof(buffer)); return 0;&#125;int main(int argc, char *argv[])&#123; int fd; int i; char *device = NULL; int regcount; run_type mode = -1; int read_size = 0; int write_size = 0; char *opt_file = NULL; unsigned int offset = 0; int c; while((c = getopt_long(argc, argv, short_options, long_options, NULL)) != -1) &#123; switch(c) &#123; case 'h': show_usage(); break; case 'd': device = optarg; break; case 'r': &#123; mode = RUN_READ; read_size = atoi(optarg); printf(\"read_size=%d\\n\", read_size); &#125; break; case 'o': &#123; offset = strtoul(optarg, NULL, 0); printf(\"offset= 0x%x\\n\", offset); &#125; break; case 'w': &#123; mode = RUN_WRITE; opt_file = optarg; printf(\"opt_file : %s\\n\", opt_file); &#125; break; case 'e': mode = RUN_ERASE; break; default: break; &#125; &#125; if(device == NULL) &#123; printf(\"(E) Device is required, please check it.\\n\"); show_usage(); &#125; printf(\"device = %s\\n\", device); fd = open(device, O_RDWR); if(fd &lt; 0) &#123; printf(\"open device %s error\\n\", device); return -1; &#125; if(ioctl(fd, MEMGETINFO, &amp;info) == 0) &#123; printf(\"info.size=%d\\n\", info.size); printf(\"info.erasesize=%d\\n\", info.erasesize); printf(\"info.writesize=%d\\n\", info.writesize); printf(\"info.oobsize=%d\\n\", info.oobsize); &#125; if(ioctl(fd, MEMGETREGIONCOUNT, &amp;regcount) == 0) printf(\"regcount = %d\\n\", regcount); close(fd); if(RUN_READ == mode) mtd_read(device, offset, read_size); else if(RUN_WRITE == mode) &#123; if(opt_file) &#123; printf(\"Write opt_file to device %s\\n\", device); mtd_write_file(device, opt_file); &#125; else &#123; printf(\"Write buf[10] to device %s\\n\", device); char buf[10] = &#123; 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x10, &#125;; mtd_write(device, buf, offset, sizeof(buf)); &#125; &#125; else if(RUN_ERASE == mode) mtd_erase(device, regcount); return 0;&#125; 使用方法：123456789./flash_test -d /dev/mtd10 -e //擦除./flash_test -d /dev/mtd10 -r 10 -o 0 //从地址偏移0读出10字节./flash_test -d /dev/mtd10 -w -o 0 //从地址偏移0写10字节./flash_test -d /dev/mtd10 -r 10 -o 0./flash_test -d /dev/mtd10 -e ./flash_test -d /dev/mtdblock10 -r 10 -o 0 ./flash_test -d /dev/mtdblock10 -w -o 0 ./flash_test -d /dev/mtdblock10 -r 10 -o 0 另外，部分根文件系统集成了flash测试工具，但只能擦除操作：1flash_eraseall /dev/mtd10 当作文件系统测试：1234567891011mkfs.vfat -I /dev/mtdblock10mount -t vfat /dev/mtdblock10 /hcengcp /etc/init.d/rcS /hcengsyncumount /hcengmount -t vfat /dev/mtdblock10 /hcengcat /hceng/rcSdiff /hceng/rcS /etc/init.d/rcS 5. 补充想到几个补充。 1.内核自带SPI设备驱动在最开始的准备工作里，加入了User mode SPI device driver support。起初想的是一个SPI设备驱动用于测试，后来发现并不是简单的用于测试SPI，它还有更重要的作用，就如它的名字一样，”用户模式SPI设备驱动支持”，可以通过它，在Linux应用层直接操作SPI设备。参考自带的应用测试文件Documentation/spi/spidev_test.c，可以通过访问/dev/spidev1.0来控制SPI控制器，例如：1234567891011ioctl(fd, SPI_IOC_WR_MODE, mode); //修改SPI模式ioctl(fd, SPI_IOC_RD_MODE, mode);ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, speed); //修改SPI传输速度ioctl(fd, SPI_IOC_RD_MAX_SPEED_HZ, speed);ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, bits); //修改SPI每次传输数据长度ioctl(fd, SPI_IOC_RD_BITS_PER_WORD, bits);ioctl(fd, SPI_IOC_MESSAGE(1), &amp;transfer); //控制SPI发送/接收数据ioctl(fd, SPI_IOC_MESSAGE(1), &amp;transfer); 通过该驱动的ioctl()，可以实现对SPI控制器的控制，也就可以通过它在用户层控制SPI设备，而不再需要单独为SPI设备写对应的驱动。当然，它也有一些限制，比如这里的片选默认就是设备树指定的CS0，如果要使用其它片选，只能是在应用层操作/sys/class/gpio/x来模拟片选。它适用前面的DAC和OLED等字符设备，不适用于Flash等块设备。 2.w25q16dv驱动的一个Bug使用前面编写的驱动，在将其作为字符设备操作是没有问题的，但作为块设备，先格式化，挂载的时候就会报参数错误。通过排查，发现挂载的时候是要向Flash写入指定数据的，然而并没有写成功，因此挂载失败。把前面每次传输的数据长度NUM由256改为8，可以减缓问题，可以挂载，也可以拷贝小文件，读取正常，但拷贝大文件后，重新挂载读取文件失败。然后发现是DMA传输导致的错误，再往里检查发现是DMA和Cache的数据不一致导致的，这就比较深了，搞不定。初步解决思路是在spi-omap2-mcspi.c中，先使用dma_alloc_coherent分配一个DMA Buffer，大小为4096，在SPI每次使用DMA方式的传输时：①对于DMA写：先把spi_transfer.tx_buf中的数据复制到事先分配的DMA Buffer，并把spi_transfer.tx_dma设置为该Buffer的DMA地址，最后再启动DMA传输；②对于DMA读：把spi_transfer.rx_dma设置为事先分配的DMA Buffer的DMA地址，然后启动DMA传输；当传输完毕，把DMA Buffer中的数据复制到spi_transfer.rx_buf； 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"AM335X","slug":"AM335X","permalink":"http://yoursite.com/tags/AM335X/"},{"name":"SPI","slug":"SPI","permalink":"http://yoursite.com/tags/SPI/"},{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"}]},{"title":"C++学习笔记","date":"2018-09-24T12:46:52.000Z","path":"2018/09/24/C++学习笔记/","text":"学习完了Java，继续C++的学习，C++还有点印象，之前用Qt的时候还写过。 1. C++基础知识1.1 类的引入在C语言中，使用struct将多个数据组成一个新的数据结构，这一思维方式在C++里得到了扩展，变成了类class的概念，既包含多个数据，也可包含函数。 示例：[person1.c]123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;struct person &#123; char *name; int age; char *work; void (*printf_info)(struct person *per); //函数指针&#125;;void printf_info(struct person *per) &#123; printf(\"name = %6s, age = %2d, work = %s\\n\", per-&gt;name, per-&gt;age, per-&gt;work);&#125;int main(int argc, char **argv)&#123; struct person person[] = &#123; &#123;\"hceng\", 23, \"Embedded engineer\", printf_info&#125;, &#123;\"jack\", 21, \"Graphic Designer\", printf_info&#125; &#125;; person[0].printf_info(&amp;person[0]); person[1].printf_info(&amp;person[1]); return 0;&#125; [person2.cpp]123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;//struct person &#123;class person &#123;public: char const *name; //warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings] int age; char const *work; void printf_info(void) &#123; printf(\"name = %6s, age = %2d, work = %s\\n\", name, age, work); //函数实现直接写在了里面,且可访问数据 &#125;&#125;;int main(int argc, char **argv)&#123; struct person person[] = &#123; &#123;\"hceng\", 23, \"Embedded engineer\"&#125;, &#123;\"jack\", 21, \"Graphic Designer\"&#125; &#125;; person[0].printf_info(); person[1].printf_info(); return 0;&#125; 编译：12gcc -o person1 person1.cg++ -o person2 person2.cpp 结果：12name = hceng, age = 23, work = Embedded engineername = jack, age = 21, work = Graphic Designer 对该示例进行分析： 1.1 C语言里，使用struct将多个变量组合在了一起，由于C语言的struct里不能有函数，因此使用函数指针来指向函数；1.2 main里，使用struct person这一新数据类型，定义了数组变量person[]，并对每个成员初始化；1.3 通过调用结构体里的函数指针，来调用函数，函数要访问结构体里的数据，因此还需要将结构体作为参数传入； 2.1 同样的功能，在C++里面，该示例做了如下改变：2.2 因为扩充了strcut的功能，使用新的关键字class来表示集合；2.3 加上了权限管理，比如这里的public；2.4 集合可以包含函数，同时也可以访问该集合的变量，无需传入参数；2.5 初始化和调用，也精简了一点； 1.2 访问控制C++通过public、protected、private三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。与Java不同的是C++中的public、private、protected只能修饰类的成员，不能修饰类，C++中的类没有共有私有之分。 在类的内部(定义类的代码内部)，无论成员被声明为public、protected还是private，都是可以互相访问的，没有访问权限的限制。在类的外部(定义类的代码之外)，只能通过对象访问成员，并且通过对象只能访问public属性的成员，不能访问private、protected属性的成员。 示例： [person.cpp]1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;class Person &#123;private: //默认权限 char const *name; int age; char const *work;public: void setName(char const *name) &#123; this-&gt;name = name; &#125; int setAge(int age) &#123; if(age &lt; 0 || age &gt; 150) &#123; this-&gt;age = 0; return -1; &#125; this-&gt;age = age; return 0; &#125; void setWork(char const *work) &#123; this-&gt;work = work; &#125; void printInfo(void) &#123; printf(\"name = %6s, age = %2d, work = %s\\n\", name, age, work); //函数实现直接写在了里面,且可访问数据 &#125;&#125;;int main(int argc, char **argv)&#123; int ret = 0; Person per; //per.name = \"hceng\"; //因为是private属性,无法直接访问 per.setName(\"hceng\"); //通过类里的函数间接访问 ret = per.setAge(-23); //间接访问,可以实现对传入参数的控制 per.setWork(\"Embedded engineer\"); per.printInfo(); return ret;&#125; 结果： 1name = hceng, age = 0, work = Embedded engineer 对该示例进行分析： 定义了一个class类Person，有三个私有的成员变量，四个公共的成员函数； 2.1 main里，先创建了一个Person类的对象per；2.2 通过对象per不能直接访问私有属性，可以通过公有属性的函数进行间接访问；2.3 将成员变量设置为私有，有利于对传入参数的控制； 1.3 程序结构为了让代码结构更有层次感，类似C语言那种使用.h头文件和.c文件分离的方式。示例程序结构如下：1234567.├── dog.cpp├── dog.h├── main.cpp├── Makefile├── person.cpp└── person.h person.h和dog.h里面是类的定义；person.cpp和dog.cpp里面是类的实现；main.cpp里面是函数的调用，Makefile里面是整个工程代码的组织编译、清理； 文件比较多，就不贴代码了，示例代码见文末的Github链接。 在person.cpp和dog.cpp都定义了同名的printVersion()函数，为了区分这两个函数，加入了命名空间namespace这一关键词，将代码放在不同名字的命名空间里，调用的时候就有了区分。 调用也有三种方式：1.直接使用，比如创建Person对象:P::Person per;；调用同名的函数:P::printVersion();；2.使用using关键词声明，在主函数里或者外面，使用using D::Dog声明，后面可以使用Dog来表示D:Dog；3.使用using namespace D;，将整个命名空间导入，后面可以使用Dog来表示D:Dog； 1.4 重载与Java类似，如果函数名相同，函数的参数不同(类型、数量、顺序任一不同)，同名不同参数的函数之间，互相称之为重载函数。调用时，根据传入的参数，自动选择对应的函数。 示例： [main.cpp]123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;int add(int a, int b)&#123; cout&lt;&lt;\"add int+int = \"&lt;&lt;a+b&lt;&lt;endl; return a+b;&#125;double add(int a, double b)&#123; cout&lt;&lt;\"add int+double = \"&lt;&lt;a+b&lt;&lt;endl; return (double)a+b;&#125;double add(double a, int b)&#123; cout&lt;&lt;\"add double+int = \"&lt;&lt;a+b&lt;&lt;endl; return (double)a+b;&#125;int add(int a, int b, int c)&#123; cout&lt;&lt;\"add int+int+int = \"&lt;&lt;a+b+c&lt;&lt;endl; return a+b+c;&#125;int main(int argc, char **argv)&#123; add(1, 1); add(1, 1.5); add(1.5, 1); add(1, 1, 1); return 0;&#125; 结果： 1234add int+int = 2add int+double = 2.5add double+int = 2.5add int+int+int = 3 对该示例进行分析： 四个同名函数，第一个和第二个参数类型不同，第二个和第三个参数类型位置不同，第一个和第三个参数数量不同，传入不同类型的参数，调用对应的函数； 1.5 指针与引用C++和C语言中的指针是一样，可以通过指针来实现修改传入函数的参数。在C++里新引入了引用的概念，就是某一个变量或对象的别名，对引用的操作与对其所绑定的变量或对象的操作完全等价。语法如下：12类型 &amp;引用名=目标变量名int &amp;e = d; //使用e代替d C语言中&amp;是取址，C++中表示引用，C语言中没有引用。 示例： [main.cpp]1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;void add1(int a)&#123; a = a + 1;&#125;void add2(int *b) &#123; *b = *b + 1; //指针操作&#125;void add3(int &amp;c) //引用&#123; c = c + 1;&#125;int main(int argc, char **argv)&#123; int a = 99; int b = 99; int c = 99; int d = 99; int &amp;e = d; //使用e代替d add1(a); cout&lt;&lt;\"a = \"&lt;&lt;a&lt;&lt;endl; add2(&amp;b); cout&lt;&lt;\"b = \"&lt;&lt;b&lt;&lt;endl; add3(c); cout&lt;&lt;\"c = \"&lt;&lt;c&lt;&lt;endl; e++; cout&lt;&lt;\"d = \"&lt;&lt;d&lt;&lt;endl; return 0;&#125; 结果： 1234a = 99b = 100c = 100d = 100 对该示例进行分析： 1.1 函数add1()传入形参，在函数里面修改值，并不改变实参；1.2 函数add2()传入的是指针，在函数里修改该指针，改变了实参；1.3 函数add3()传入的是引用，在函数里修改该引用，改变了实参；1.4 使用指针作为函数的形参达到的效果虽然和使用引用一样，但当调用函数时仍需要为形参指针变量在内存中分配空间，而引用则不需要这样，故在C++中推荐使用引用而非指针作为函数的参数； 2.1 使用e引用d，对e进行操作，实际就是对d进行操作，修改了d； 引用参考博客：C++：引用的简单理解 1.5 构造函数/析构函数/拷贝构造函数 构造函数：与Java里面的构造函数类似，用于实例化对象时，对其初始化；析构函数：C++独有的，在对象销毁前瞬间，由系统自动调用析构函数；拷贝构造函数：C++独有的，只有一个形参，且该形参是对本类类型对象的引用； 示例： [Person.cpp]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;using namespace std;class Person &#123;private: char *name; int age; char *work;public: void setName(char *name) &#123; this-&gt;name = name; &#125; int setAge(int age) &#123; if(age &lt; 0 || age &gt; 150) &#123; this-&gt;age = 0; return -1; &#125; this-&gt;age = age; return 0; &#125; void setWork(char *work) &#123; this-&gt;work = work; &#125; void printInfo(void) &#123; if (this-&gt;name &amp;&amp; this-&gt;work) cout&lt;&lt;\"name = \"&lt;&lt;name&lt;&lt;\", age = \"&lt;&lt;age&lt;&lt;\", work = \"&lt;&lt;work&lt;&lt;endl; else cout&lt;&lt;\"name = NULL\"&lt;&lt;\", age = \"&lt;&lt;age&lt;&lt;\", work = NULL\"&lt;&lt;endl; &#125; //构造函数:和类名相同,无返回值,可以设置默认值 Person() //一但有了其它构造函数,默认的就必须写出来才能使用 &#123; this-&gt;name = NULL; this-&gt;age = 0; this-&gt;work = NULL; &#125; Person(char *name, int age = 0, char *work = (char *)\"none\") //age和work设置有默认值 &#123; //this-&gt;name = name; this-&gt;name = new char[strlen(name) + 1]; //为了测试析构函数的自动调用,这里使用开辟堆空间存放数据 strcpy(this-&gt;name, name); //this-&gt;work = work; this-&gt;work = new char[strlen(work) + 1]; strcpy(this-&gt;work, work); if(age &lt; 0 || age &gt; 150) this-&gt;age = 0; else this-&gt;age = age; &#125; ~Person() &#123; cout &lt;&lt; \"~Person()\"&lt;&lt;endl; if (this-&gt;name) &#123; cout&lt;&lt;\"name = \"&lt;&lt;name&lt;&lt;endl; delete this-&gt;name; &#125; if (this-&gt;work) &#123; cout&lt;&lt;\"work = \"&lt;&lt;work&lt;&lt;endl; delete this-&gt;work; &#125; &#125; //拷贝构造函数 Person(Person &amp;per) &#123; cout &lt;&lt; \"Person(Person &amp;per)\"&lt;&lt;endl; this-&gt;name = new char[strlen(per.name) + 1]; strcpy(this-&gt;name, per.name); this-&gt;work = new char[strlen(per.work) + 1]; strcpy(this-&gt;work, per.work); if(age &lt; 0 || age &gt; 150) this-&gt;age = 0; else this-&gt;age = per.age; &#125;&#125;;void test_object()&#123; Person per0; //调用无参构造函数(后面无括号,有括号相当于声明) Person per1((char *)\"jack\"); //调用带参构造函数,未传入的未默认值 Person *per2 = new Person((char *)\"hceng\", 23, (char *)\"Embedded engineer\"); //这种方式需要使用delete手动清除 per0.printInfo(); per1.printInfo(); per2-&gt;printInfo(); delete per2; //如果不手动删除,在调用完test_object()后,分配的堆空间不会被释放 cout &lt;&lt; \"delete per2 end\"&lt;&lt;endl;&#125;int main(int argc, char **argv)&#123; test_object(); cout &lt;&lt; \"run test_object end\"&lt;&lt;endl; Person per1((char *)\"hceng\", 23, (char *)\"Embedded engineer\"); Person per2(per1); per2.printInfo(); return 0;&#125; 结果： 1234567891011121314151617181920name = NULL, age = 0, work = NULLname = jack, age = 0, work = nonename = hceng, age = 23, work = Embedded engineer~Person()name = hcengwork = Embedded engineerdelete per2 end~Person()name = jackwork = none~Person()run test_object endPerson(Person &amp;per)name = hceng, age = 23, work = Embedded engineer~Person()name = hcengwork = Embedded engineer~Person()name = hcengwork = Embedded engineer 对该示例进行分析： 1.1 定义了一个Person类，里面有三个私有的成员变量，四个公共的成员函数，两个构造函数，一个析构函数，一个拷贝构造函数；1.2 外部两个函数，一个主函数，一个被主函数调用的test_object()； 2.1 主函数首先调用test_object()；2.2 test_object()里使用三种方式实例化对象：调用无参构造函数，调用带参构造函数，new创建一个对象，调用带参的构造函数；2.3 带参的构造函数，参数可以指定默认值；2.4 一但有了带参的构造函数，就必须写出无参的构造函数才能调用无参的构造函数；2.5 前两种实例化方式，在对象销毁前瞬间，由系统自动调用析构函数；而第三种方式必须手动使用delete删除； 3.1 将Person类的实例化对象per1作为参数传给Person per2()，就是拷贝构造函数，将调用Person(Person &amp;per)；3.2 在拷贝构造函数里，将传入的per赋值给自己； 4.1 从打印结果分析，先调用test_object()，实例化了三个对象，然后对应的打印出他们信息；4.2 接着delete per2，调用析构函数清理了per2；4.3 结束test_object()的调用，释放per0和per1，自动调用析构函数清理；4.4 接着实例化per1，再将其作为参数传给per2，此时调用拷贝构造函数，将per1的内容拷贝给per2；4.5 结束时，自动调用析构函数，依次清理per0和per2； 1.6 静态成员静态成员的提出是为了解决数据共享的问题。在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。 如下例子，需要统计总共生成了多少个类。 示例： [person.cpp]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;using namespace std;class Person &#123;private: char *name; int age; char *work; static int cnt;public: static int getCount1(void) &#123; return cnt; &#125; static int getCount2(void); Person() &#123; this-&gt;name = NULL; this-&gt;age = 0; this-&gt;work = NULL; cnt++; &#125; Person(char *name, int age = 0, char *work = (char *)\"none\") &#123; //this-&gt;name = name; this-&gt;name = new char[strlen(name) + 1]; strcpy(this-&gt;name, name); //this-&gt;work = work; this-&gt;work = new char[strlen(work) + 1]; strcpy(this-&gt;work, work); if(age &lt; 0 || age &gt; 150) this-&gt;age = 0; else this-&gt;age = age; cnt++; &#125; //析构函数 ~Person() &#123; &#125; //拷贝构造函数 Person(Person &amp;per) &#123; cnt++; &#125;&#125;;int Person::cnt = 0; //cnt定义和初始化int Person::getCount2(void) &#123; return cnt; &#125;int main(int argc, char **argv)&#123; Person per0; Person per1((char *)\"jack\"); Person *per2 = new Person((char *)\"hceng\", 23, (char *)\"Embedded engineer\"); Person per3(per1); Person per4[10]; Person *per5 = new Person[10]; cout &lt;&lt; \"person number = \"&lt;&lt;Person::getCount1()&lt;&lt;endl; cout &lt;&lt; \"person number = \"&lt;&lt;per1.getCount1()&lt;&lt;endl; cout &lt;&lt; \"person number = \"&lt;&lt;per5-&gt;getCount1()&lt;&lt;endl; cout &lt;&lt; \"person number = \"&lt;&lt;per5-&gt;getCount2()&lt;&lt;endl; return 0;&#125; 结果： 1234person number = 24person number = 24person number = 24person number = 24 对该示例进行分析： 1.1 定义了一个Person类，包含四个成员变量，其中cnt是静态成员变量；1.2 接下来是两个静态方法，只有静态方法才能访问静态成员变量。两个静态方法前者实现了具体的内容，后者只是声明；1.3 再是两个构造函数，在每个构造函数里添加cnt++，实现每次实例化对象时调用计数；1.4 最后是析构函数和拷贝构造函数，拷贝构造函数也会实例化对象，也要cnt++； 2.1 前面的Person类里，只是声明了cnt，还需要定义和初始化；2.2 函数getCount2()也需要定义实现具体的内容； 之后就可通过Person或者任何其中一个对象访问cnt； 1.7 友员函数友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend。 比如下面的例子，add()函数想访问Friend类的私有成员。 示例： [point.cpp]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;using namespace std;class Point &#123;private: int x; int y; public: Point() &#123; &#125; Point(int a, int b) : x(a+1), y(b) &#123; &#125; int getX() &#123; return x; &#125; int getY() &#123; return y; &#125; void printInfo() &#123; cout&lt;&lt;\"sum: (\"&lt;&lt;x&lt;&lt;\", \"&lt;&lt;y&lt;&lt;\")\"&lt;&lt;endl; &#125; friend Point add(Point &amp;p1, Point &amp;p2);&#125;;Point add(Point &amp;p1, Point &amp;p2)&#123; Point p; p.x = p1.x + p2.x; p.y = p1.y + p2.y; return p;&#125;int main(int argc, char **argv)&#123; Point p1(1, 2); cout&lt;&lt;\"p1: (\"&lt;&lt;p1.getX()&lt;&lt;\", \"&lt;&lt;p1.getY()&lt;&lt;\")\"&lt;&lt;endl; Point p2(2, 3); cout&lt;&lt;\"p2: (\"&lt;&lt;p2.getX()&lt;&lt;\", \"&lt;&lt;p2.getY()&lt;&lt;\")\"&lt;&lt;endl; Point sum = add(p1, p2); sum.printInfo(); return 0;&#125; 结果： 123p1: (2, 2)p2: (3, 3)sum: (5, 5) 对该示例进行分析： 1 定义了类Point，包含两个私有成员变量，两个构造函数，三个成员函数，以及一个友员函数的声明； 2.1 第二个带参数的构造函数，有一个构造函数初始化列表；2.2 它以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式；2.3 在进行带参数的实例化对象时，成员x就等于传入的参数a加1； 3.1 在主函数里，先实例化p1和p2；3.2 友员函数add()可以直接访问f1和f2的私有成员变量，不再通过调用其成员函数进行访问，提高了效率； 1.8 运算符的重载运算符的重载顾名思义就是对运算符进行重载，比如原来的加号+，只能实现基本数据类型的相加，现在对其扩展功能，实现对类的相加。在使用运算符重载前，必须先定义一个运算符重载函数，其名字为operator，后随一个要重载的运算符。例如:12operator+ 加法operator* 乘法 下例实现了对加法+0，自增运算++、打印输出&lt;&lt;进行重载。 示例： [point.cpp]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;using namespace std;class Point &#123;private: int x; int y; public: Point() &#123; &#125; Point(int a, int b) : x(a), y(b) &#123; //x = a; //y = b; &#125; void printInfo() &#123; cout&lt;&lt;\"printInfo: (\"&lt;&lt;x&lt;&lt;\", \"&lt;&lt;y&lt;&lt;\")\"&lt;&lt;endl; &#125; friend Point operator+(Point &amp;p1, Point &amp;p2); friend Point&amp; operator++(Point &amp;p); friend Point operator++(Point &amp;p, int a); friend ostream&amp; operator&lt;&lt;(ostream &amp;o, Point p); #if 0 //a+b Point operator+(Point &amp;p) &#123; cout&lt;&lt;\"operator+(Point &amp;p)\"&lt;&lt;endl; Point r; r.x = this-&gt;x + p.x; r.y = this-&gt;y + p.y; return r; &#125; //++a Point&amp; operator++(void) &#123; cout&lt;&lt;\"operator++(void)\"&lt;&lt;endl; this-&gt;x += 1; this-&gt;y += 1; return *this; &#125; //a++ Point operator++(int a) &#123; cout&lt;&lt;\"operator++(int a)\"&lt;&lt;endl; Point r; r = *this; this-&gt;x += 1; this-&gt;y += 1; return r; &#125;#endif&#125;;//a+bPoint operator+(Point &amp;p1, Point &amp;p2)&#123; cout&lt;&lt;\"operator+(Point &amp;p1, Point &amp;p2)\"&lt;&lt;endl; Point r; r.x = p1.x + p2.x; r.y = p1.y + p2.y; return r;&#125;//++aPoint&amp; operator++(Point &amp;p)&#123; cout&lt;&lt;\"operator++(Point &amp;p)\"&lt;&lt;endl; p.x += 1; p.y += 1; return p;&#125;//a++Point operator++(Point &amp;p, int a)&#123; cout&lt;&lt;\"operator++(Point &amp;p, int a)\"&lt;&lt;endl; Point r; r = p; p.x += 1; p.y += 1; return r;&#125; //&lt;&lt;ostream&amp; operator&lt;&lt;(ostream &amp;o, Point p) //第一个参数不是Point类型,不能写到成员函数里&#123; cout&lt;&lt;\"(\"&lt;&lt;p.x&lt;&lt;\", \"&lt;&lt;p.y&lt;&lt;\")\"; return o;&#125;int main(int argc, char **argv)&#123; Point p1(1, 2); Point p2(4, 5); Point p; p = p1 + p2; p.printInfo(); p = ++p1; p.printInfo(); p1.printInfo(); p = p2++; p.printInfo(); p2.printInfo(); cout&lt;&lt;p&lt;&lt;p1&lt;&lt;p2&lt;&lt;endl; return 0;&#125; 结果： 123456789operator+(Point &amp;p1, Point &amp;p2)printInfo: (5, 7)operator++(Point &amp;p)printInfo: (2, 3)printInfo: (2, 3)operator++(Point &amp;p, int a)printInfo: (4, 5)printInfo: (5, 6)(4, 5)(2, 3)(5, 6) 对该示例进行分析： 1.1 定义了类Point，包含两个私有变量，两个构造函数，一个成员函数，四个重载函数；1.2 这四个重载函数，可以作为成员函数，在类里面实现，也可作为类外函数，在类外实现，只在类里面声明；1.3 重载函数作为成员函数时，可以直接访问类的私有属性；重载函数作为类外函数时，通过友员的声明，访问类的私有属性；1.4 同名的operator++()，不含参数int a表示前缀++，带参数int a的表示后缀++；1.5 operator&lt;&lt;因为第一个参数不是Point类型，不能作为成员函数； 2.主函数里，使用重载后的+可以实现Point类的相加，以及Point类的++和&lt;&lt;； 2. C++面向对象编程如同Java面向对象编程一样，C++面向对象编程也有三大特性：封装性、继承性、多态性。 2.1 访问扩展和继承这里定义一个基类Father，两个继承于Father的派生类Son和Daughter。 示例： [person.cpp]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;using namespace std;class Father &#123;private: int money; protected: int room_key; int room_car; public: int phone; int address; void working(void) &#123; cout&lt;&lt;\"father working\"&lt;&lt;endl; &#125; int getMoney(void) &#123; return money; &#125; void setMoeny(int money) &#123; this-&gt;money = money; &#125;&#125;;class Son : public Father &#123;private: int book; using Father::phone; public: using Father::room_car; //using Father::money; //无法改变父类private类型的属性 void learning(void) &#123; cout&lt;&lt;\"son learning\"&lt;&lt;endl; &#125; void getKey(void) &#123; //s.money = 10; //private属性,子类也无法访问 room_key = 1; //protected属性,子类可以访问 &#125;&#125;;class Daughter : protected Father &#123;private:public: void dancing(void) &#123; cout&lt;&lt;\"daughter dancing\"&lt;&lt;endl; room_key = 1; //不管何种继承,在派生类内部使用父类时无差别 &#125; void working(void) //覆写 &#123; cout&lt;&lt;\"daughter working\"&lt;&lt;endl; &#125;&#125;;int main(int argc, char **argv)&#123; Son s; Daughter d; //s.money = 10; //private属性,外部无法访问 s.setMoeny(10); //s.room_key = 1; //protected属性,外部无法访问 s.getKey(); s.working(); //public,外部可以直接访问 s.learning(); s.room_car = 1; //子类将其变为了public,使得可以访问 //s.phone = 1; //子类将其变为了private,使得不能访问 d.dancing(); //自己的属性没有 //d.working(); //protected继承,父类方法变为protected,外部无法访问 d.working(); return 0;&#125; 结果： 1234father workingson learningdaughter dancingdaughter working 对该示例进行分析： 1.1 定义一个类Father，有一个私有属性money，两个保护属性room_key和room_car，两个公共属性phone和address，以及三个共有的方法working()、getMoney()，setMoeny()；1.2 定义一个类Son，公共继承于Father。有一个私有属性book，以及将父类的phone属性变成了私有属性。将父类的保护属性room_car变成了公共属性，父类的私有属性无法改变。有两个公有方法learning()、getKey()。其中getKey()能访问了父类的保护属性，但不能访问私有属性；1.3 定义一个类Daughter，保护继承于Father。有一个公共方法dancing()，访问了父类的保护属性。覆写了父类的working()方法； 2.1 主函数先实例化了Son和Daughter；2.2 外部无法直接访问类中的私有属性money，只能通过父类提供的公共函数setMoney()进行访问；2.3 外部无法直接访问父类的保护属性room_key，只能通过父类提供的公共函数setKey()进行访问；2.4 函数working()来自基类Father，函数learning()来自派生类Son；2.5 room_car在基类中原为保护属性，在派生类里被改为了公共属性，因此可被外界访问；2.6 同理将原公共属性phone改为了私有属性，外部无法访问；另外，派生类无法修改基类的私有属性；2.7 类Daughter，保护继承于Father，父类的所有属性、函数，外部都无法直接访问；2.8 派生类Daughter覆写了基类的working()，且为公共的，因此外部可以直接访问； 3.基类成员在派生类中的访问控制属性如下： 继承类型 \\ 基类访问属性 public protected private public public public 隔离 protected protected protected 隔离 private private private 隔离 2.2 多重继承大多数程序使用单个基类的公用继承，但是在某些情况下，单继承是不够的，必须使用多继承。比如，对于沙发床，既继承于沙发，也继承于床。 C++允许为一个派生类指定多个基类，这样的继承结构被称做多重继承。因为不同的基类，可能有相同的属性，导致派生类出现二义性。出现二义性，要么显示的指出要调用的是哪个类中的成员，要么就使用虚基类。C++提供虚基类(virtual base class)的方法，使得在继承共同基类时只保留一份成员。 示例： [person.cpp]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;using namespace std;//method 1class Sofa &#123;private: int weight;public: void watchTV(void) &#123; cout&lt;&lt;\"Sofa: watch TV\"&lt;&lt;endl; &#125; void setWeight(int weight) &#123; this-&gt;weight = weight; &#125; int getWeight(void) &#123; return weight; &#125;&#125;;class Bed &#123;private: int weight;public: void sleep(void) &#123; cout&lt;&lt;\"Bed: sleep\"&lt;&lt;endl; &#125; void setWeight(int weight) &#123; this-&gt;weight = weight; &#125; int getWeight(void) &#123; return weight; &#125;&#125;;class Sofabed : public Sofa , public Bed &#123; &#125;; //method 2class Furniture &#123;private: int weight;public: void setWeight(int weight) &#123; this-&gt;weight = weight; &#125; int getWeight(void) &#123; return weight; &#125; &#125;;class Sofa1 : virtual public Furniture &#123;public: void watchTV(void) &#123; cout&lt;&lt;\"Sofa1: watch TV\"&lt;&lt;endl; &#125;&#125;;class Bed1 : virtual public Furniture &#123;public: void sleep(void) &#123; cout&lt;&lt;\"Bed1: sleep\"&lt;&lt;endl; &#125;&#125;;class Sofabed1 : public Sofa1 , public Bed1 &#123; &#125;; int main(int argc, char **argv)&#123; Sofabed s; Sofabed1 s1; s.watchTV(); s.sleep(); //s.setWeight(100); //无法确定是哪一个基类的方法 s.Sofa::setWeight(100); s1.watchTV(); s1.sleep(); s1.setWeight(100); return 0;&#125; 结果： 1234Sofa: watch TVBed: sleepSofa1: watch TVBed1: sleep 对该示例进行分析： 1.1 定义了一个类Sofa，包含一个私有属性weight，三个公共的方法watchTV()、setWeight()、getWeight()；1.2 定义了一个类Bed，包含一个私有属性weight，三个公共的方法sleep()、setWeight()、getWeight()；1.3 定义了一个类Sofabed，继承于Sofa和Bed； 2.1 定义了一个类Furniture，包含一个私有属性weight，两个公共的方法setWeight()、getWeight()；2.2 定义了一个类Sofa1，虚拟继承于Furniture，有一个公共方法watchTV()；2.3 定义了一个类Bed1，虚拟继承于Furniture，有一个公共方法sleep()；2.4 定义了一个类Sofabed1，继承于Sofa1和Bed1； 3.1 实例化了Sofabed，可以直接访问各基类中的方法，但遇到了同名的方法，需要指定是哪一个类的方法；3.2 实例化了Sofabed1，可以直接访问各基类中的方法，因为其基类都继承于虚基类Furniture，因此setWeight()方法只存在一份，不会出现二义性； 2.3 构造顺序我们构造的类开始越来越复杂，一个类可能含有一个或多个基类，基类有可能是虚拟基类，另外类本身也可能有对象成员，这里就理一下它们的构造顺序。 这里构造的类比较多，它们的关系如下： 其中虚线表示虚拟继承。 示例： [CompanySofabed.cpp]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;using namespace std;class Furniture &#123;public: Furniture(void) &#123; cout &lt;&lt; \"Furniture(void)\" &lt;&lt; endl; &#125;&#125;;class Verification &#123;public: Verification(void) &#123; cout &lt;&lt; \"Verification(void)\" &lt;&lt; endl; &#125;&#125;;class Sofa : virtual public Furniture, virtual public Verification &#123;public: Sofa(void) &#123; cout &lt;&lt; \"Sofa(void)\" &lt;&lt; endl; &#125;&#125;;class Bed : virtual public Furniture, virtual public Verification &#123;public: Bed(void) &#123; cout &lt;&lt; \"Bed(void)\" &lt;&lt; endl; &#125;&#125;;class Sofabed : public Sofa , public Bed &#123;public: Sofabed(void) &#123; cout &lt;&lt; \"Sofabed(void)\" &lt;&lt; endl; &#125; Sofabed(char *s) &#123; cout &lt;&lt; \"Sofabed(char *s)\" &lt;&lt; endl; &#125; &#125;; class Company &#123;public: Company(void) &#123; cout &lt;&lt; \"Company(void)\" &lt;&lt; endl; &#125; Company(char *s) &#123; cout &lt;&lt; \"Company(char *s)\" &lt;&lt; endl; &#125; &#125;;class Type &#123;public: Type(void) &#123; cout &lt;&lt; \"Type(void)\" &lt;&lt; endl; &#125; &#125;;class Date &#123;public: Date(void) &#123; cout &lt;&lt; \"Date(void)\" &lt;&lt; endl; &#125; Date(char *s) &#123; cout &lt;&lt; \"Date(char *s)\" &lt;&lt; endl; &#125; &#125;;class CompanySofabed : public Sofabed, virtual public Company &#123;private: Type type; Date date; public: CompanySofabed(void) &#123; cout &lt;&lt; \"CompanySofabed(void)\" &lt;&lt; endl; &#125; CompanySofabed(char *s1, char *s2, char *s3): Sofabed(s1), Company(s2), date(s3) &#123; cout &lt;&lt; \"CompanySofabed(char *s)\" &lt;&lt; endl; &#125; &#125;;int main(int argc, char **argv)&#123; CompanySofabed c((char *)\"good\", (char *)\"xxx\", (char *)\"2018\"); return 0;&#125; 结果： 123456789Furniture(void)Verification(void)Company(char *s)Sofa(void)Bed(void)Sofabed(char *s)Type(void)Date(char *s)CompanySofabed(char *s) 对该示例进行分析： 1.1 基类与衍生类的关系如前面的图，这里就不复述了；1.2 为每个类创建个构造函数，以便打印观察构造顺序； 2.1 从结果可以看出，虚拟基类最先执行构造，且构造一次；2.2 然后再是非虚拟基类，依次按顺序构造；2.3 再是类自己的对象成员，按声明的顺序构造；2.4 最后是类自己构造； 3.1 注意对类自己对象成员的赋值，是使用的对象的名字；3.2 析构顺序，与构造顺序相反； 2.4 多态前面的封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。也就是说，不论传递过来的究竟是那个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。 C++支持两种多态性：编译时多态性，运行时多态性；a、编译时多态性(静态多态)：通过重载函数实现；b、运行时多态性(动态多态)：通过虚函数实现； 利用重载前面已经介绍过了，就是传入的参数不一样，从而调用对应的同名函数。这里主要分析动态多态，即利用虚函数实现。 对于虚函数，采用动态联编，对象里有一个指针，指向虚函数表，调用虚函数时，会根据对象里的指针找到表，从表中取出函数来执行对于非虚函数，采用静态联编，编译时就确定调用哪个函数； 差别：静态联编效率高，动态联编支持多态； 示例： [human.cpp]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;using namespace std;class Human &#123;public: virtual void eating(void) &#123; cout &lt;&lt; \"use hand to eat\" &lt;&lt; endl; &#125; virtual Human* test(void) &#123; cout &lt;&lt; \"Human test\" &lt;&lt; endl; &#125; virtual ~Human() &#123; cout &lt;&lt; \"~Human\" &lt;&lt; endl; &#125;&#125;;class American : public Human &#123;public: void eating(void) &#123; cout &lt;&lt; \"use knife to eat\" &lt;&lt; endl; &#125; virtual American* test(void) &#123; cout &lt;&lt; \"American test\" &lt;&lt; endl; &#125; virtual ~American() &#123; cout &lt;&lt; \"~American\" &lt;&lt; endl; &#125;&#125;;class Chinese : public Human &#123;public: void eating(void) &#123; cout &lt;&lt; \"use chopsticks to eat\" &lt;&lt; endl; &#125; virtual Chinese* test(void) &#123; cout &lt;&lt; \"Chinese test\" &lt;&lt; endl; &#125; virtual ~Chinese() &#123; cout &lt;&lt; \"~Chinese\" &lt;&lt; endl; &#125;&#125;;void test_eating(Human&amp; h)&#123; h.eating();&#125;void test_return(Human&amp; h)&#123; h.test();&#125;int main(int argc, char **argv)&#123; Human h; American a; Chinese c; test_eating(h); test_eating(a); test_eating(c); test_return(h); test_return(a); test_return(c); return 0;&#125; 结果： 1234567891011use hand to eatuse knife to eatuse chopsticks to eatHuman testAmerican testChinese test~Chinese~Human~American~Human~Human 对该示例进行分析： 1.1 定义了三个类，Human是基类，American和Chinese是其派生类；1.2 Human里有一个virtual修饰的eating()虚函数，两个派生类同名的函数也自动是虚函数；1.3 一般只有函数名、参数和返回值都相同的才能设为虚函数，但当返回值为当前对象的指针或引用时，也可以设为虚函数，这里每个类都有一个test()函数，函数名、参数都一样，只是返回类型是对象的指针，因此可以被设置为虚函数；1.4 析构函数一般都声明为虚函数，不然可能都释放的都是基类； 2.1 主函数里，分别实例化三个类，分别调用test_eating()，因为eating()是虚函数，编译时对象生成一个指针指向虚函数表，调用虚函数时，会根据对象里的指针找到表，从而找到对应的函数执行；2.2 test()在每个类中的名字、参数相同，返回值为该对象的指针，因此可以设置为虚函数，从而实现调用各自类中对应函数； 3.1 只有类的成员函数才能声明为虚函数；3.2 静态成员函数、内联函数、构造函数不能是虚函数；3.3 对于重载(函数参数不同)，也不可设为虚函数；3.4 对于覆盖(函数参数、返回值相同)，才可以设为虚函数；3.5 函数参数相同，但是返回值是当前对象的指针或引用时，也可以设为虚函数； 2.5 类型转换对比C语言，C++的类型转换也分显式转换和隐式转换。 在C语言中，隐式转换，类似将short类型变量直接赋值给int类型变量，就会自动隐式转换；在C语言中，显式转换，通过(int)修饰short，就是指定转换类型的显示转换；在C++中，隐式转换和C语言差不多，这里重点记录下C++的显式转换。 C++有四种强制类型转换操作符：static_cast、dynamic_cast、const_cast、reinterpret_cast。格式为：强制类型转换操作符&lt;type&gt;(expression) static_cast：最常用的类型转换符，比如基本数据类型之间的转换。也可用于基类和子类之间指针或引用的转换，进行上行转换(把子类的指针或引用转换成基类表示)是安全的；进行下行转换(把基类指针或引用转换成子类指针或引用)时，由于没有动态类型检查，所以是不安全的。注意：static_cast不能转换掉const、volitale、或者__unaligned属性。 dynamic_cast：用于运行时检查该转换是否类型安全，但只在多态场合时合法，即该类至少具有一个虚函数。主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。Type必须是类的指针、类的引用或者void *，且type类型要和expression一致。 const_cast：该操作符用于去除原来类型的const或volatile属性，type和expression的类型是一样的。 reinterpret_cast：reinterpret的意思就是重新解释，此操作符的意思即为数据的二进制形式重新解释，但是不改变其值。type必须是一个指针、引用、算术类型、函数指针或者成员指针，它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针。如果type是类指针类型，那么expression也必须是一个指针；如果type是一个引用，那么expression也必须是一个引用。和C语言的强制转换类似，没有安全性检查。 下面举个例子，对其具体分析。 示例： [human.cpp]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;using namespace std;class Human &#123;public: virtual void eating(void) &#123; cout &lt;&lt; \"use hand to eat\" &lt;&lt; endl; &#125;&#125;;class American : public Human &#123;public: void eating(void) &#123; cout &lt;&lt; \"use knife to eat\" &lt;&lt; endl; &#125;&#125;;class Chinese : public Human &#123;public: void eating(void) &#123; cout &lt;&lt; \"use chopsticks to eat\" &lt;&lt; endl; &#125;&#125;;class Chongqing : public Chinese &#123;public: void eating(void) &#123; cout &lt;&lt; \"use chopsticks to eat Chongqing\" &lt;&lt; endl; &#125;&#125;;void show_type(Human&amp; h)&#123; //Pointer American *a; Chinese *c; Chongqing *cq; if (a = dynamic_cast&lt;American *&gt;(&amp;h)) cout &lt;&lt; \"this human is American\" &lt;&lt; endl; if (c = dynamic_cast&lt;Chinese *&gt;(&amp;h)) cout &lt;&lt; \"this human is Chinese\" &lt;&lt; endl; if (cq = dynamic_cast&lt;Chongqing *&gt;(&amp;h)) cout &lt;&lt; \"this human is Chongqing\" &lt;&lt; endl; //Reference if (cq = dynamic_cast&lt;Chongqing *&gt;(&amp;h)) &#123; //American&amp; am = dynamic_cast&lt;American&amp;&gt;(h); //unable convert, generate aborted Chinese&amp; ch = dynamic_cast&lt;Chinese&amp;&gt;(h); Chongqing&amp; cqr = dynamic_cast&lt;Chongqing&amp;&gt;(h); &#125;&#125;int main(int argc, char **argv)&#123; double a = 4.44; int b = a; //double to int int c = (int)a; int d = static_cast&lt;int&gt;(a); cout&lt;&lt;\"b = \"&lt;&lt;b&lt;&lt;\" \"&lt;&lt;\"c = \"&lt;&lt;c&lt;&lt;\" \"&lt;&lt;\"d = \"&lt;&lt;d&lt;&lt;endl; const char *e = \"www.hceng.cn\"; char *f = const_cast&lt;char *&gt;(e); //clear const attribute cout&lt;&lt;\"e = \"&lt;&lt;e&lt;&lt;\" \"&lt;&lt;\"f = \"&lt;&lt;f&lt;&lt;endl; unsigned int *g =reinterpret_cast&lt;unsigned int *&gt;(f); //char * to unsigned int * cout&lt;&lt;\"g = \"&lt;&lt;g&lt;&lt;endl; Human hu; American am; Chinese ch; Chongqing cq; show_type(hu); show_type(am); show_type(ch); show_type(cq); American *h1 =static_cast&lt;American *&gt;(&amp;hu); //American *h2 = static_cast&lt;American *&gt;(&amp;cq); Chinese *h3 = static_cast&lt;Chinese *&gt;(&amp;cq); return 0;&#125; 结果： 1234567b = 4 c = 4 d = 4e = www.hceng.cn f = www.hceng.cng = 0x55be4eac1347this human is Americanthis human is Chinesethis human is Chinesethis human is Chongqing 对该示例进行分析： 1.1 定义了四个类，Human是American和Chinese的基类，Chinese是Chongqing的基类；1.2 基类Human有个虚函数eating()，其它三个类都直接或间接从它继承过来，因此也各种有该虚函数； 2.1 主函数里，首先是将一个double转换成int，b是通过隐式转换得到，c是通过C语言风格的强制转换得到，d是通过C++的static_cast强制类型转换操作符得到；2.2 字符串指针e，定义时被const修饰，通过const_cast强制类型转换操作符，可以去掉const得到f，注意两者的数据类型要一致；2.3 接着通过reinterpret_cast强制类型转换操作符，将字符串指针char *转换成了unsigned int *类型的指针，从而直接打印g就是f的地址。另外因为前面去掉了const，这里才能对f操作；这里f是指针，因此g也必须是指针；2.4 分别实例化四个类，调用show_type()。在show_type()里，先通过dynamic_cast尝试类的平行转换，如果转换成功，说明传入的参数就是该类，两个无关联的类是不能直接转换的。在传入的是Chongqing类时，即可向上转换成Chinese，也可平行转换成Chongqing，因此打印了两次。dynamic_cast必须用于多态场合，因此各个类里面需要有虚函数；2.5 在show_type()里，前面dynamic_cast的type是指针，后面使用的type是引用。使用引用的缺点是转换失败是产生异常，中断程序，因此最好使用type是指针。2.6 继续看主函数，使用static_cast进行类的转换，将Human向下转换成American，static_cast不会检查是否能转换，因此是不安全的；再将Chongqing转换成American，两个无关联的类之间转换，编译器检查到了就无法编译通过；最后尝试将Chongqing向上转换成Chinese，效果和dynamic_cast是一样的； 3. C++高级编程3.1 抽象类前面介绍了虚函数，这里再衍生出纯虚函数，实现抽象类。 纯虚函数：在声明虚函数时被“初始化”为0的函数，形式如：virtual void eating(void) = 0;； 抽象类：凡是有纯虚函数的类，都是抽象类，抽象类不能实例化，其派生的子类需覆写所有纯虚函数才能实例化，否则子类还是抽象类； 引入抽象类的意义：1.为了实现运行时多态性，需要在基类中定义虚函数；2.在很多情况下，基类本身生成对象是不合情理的。例如，动物作为基类可以派生出小猫、小狗等实例化，但对动物进行实例化就明显是不合理的。 将函数定义为虚函数，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象，这样就很好地解决了上述两个问题。 本次示例将各个类的代码分离成独自的文件，更贴近实际工作。 示例：[Makefile]1234567891011Human: main.o libHuman.so g++ -o $@ $&lt; -L. -lHuman%.o : %.cpp g++ -fPIC -c -o $@ $&lt; libHuman.so : Chinese.o American.o Human.o g++ -shared -o $@ $^ clean: rm -f *.o *.so Human 分析： 这里使用了分层的思想，将提供类(各个类的声明和定义)和使用类(主函数里使用类)分开； libHuman.so包含了所有类，当对类做了修改时，只需要make libHuman.so即可； 之后libHuman.so和main.o合并，当在主函数对类的使用做了修改时，只需要make，不会重新编译各个类； 执行时候，需要先指定库的路径，即LD_LIBRARY_PATH=. ./Human； [human.h]12345678910111213141516171819202122232425#ifndef _HUMAN_H#define _HUMAN_H#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;class Human &#123;private: char *name;public: void setName(char *name); char *getName(void); virtual void eating(void) = 0; //纯虚函数,提供模板 virtual void wearing(void) = 0; virtual void driving(void) = 0; virtual ~Human();&#125;;Human&amp; CreateAmerican(char *name, int age, char *addr);Human&amp; CreateChinese(char *name, int age, char *addr);#endif [human.cpp]1234567891011121314151617#include \"Human.h\"void Human::setName(char *name)&#123; this-&gt;name = name;&#125;char *Human::getName(void)&#123; return this-&gt;name;&#125;Human::~Human()&#123; cout&lt;&lt;\"~Human()\"&lt;&lt;endl;&#125; 分析： 定义类Human，其中有三个纯虚函数； 在类外，声明了两个函数，用于创建两个类。 把两个函数声明放在这是因为，减少主函数包含类的头文件，这样主函数只包含Human.h，其它类做了修改时，不再编译主函数； [American.h]1234567891011121314151617181920212223#ifndef _AMERICAN_H#define _AMERICAN_H#include &lt;iostream&gt;#include \"Human.h\"using namespace std;class American : public Human&#123;private: char addr[100]; int age;public: void eating(void); void wearing(void); void driving(void); American(); American(char *name, int age, char *addr); virtual ~American();&#125;;#endif [American.cpp]123456789101112131415161718192021222324252627282930313233343536373839#include \"American.h\"void American::eating(void) &#123; cout &lt;&lt; \"Eating American food\" &lt;&lt; endl;&#125;void American::wearing(void)&#123; cout &lt;&lt; \"Wearing American clothes\" &lt;&lt; endl;&#125;void American::driving(void)&#123; cout &lt;&lt; \"Driving American car\" &lt;&lt; endl;&#125;American::American()&#123; &#125;American::American(char *name, int age, char *addr)&#123; setName(name); this-&gt;age = age; memset(this-&gt;addr, 0, 100); strcpy(this-&gt;addr, addr);&#125;American::~American()&#123; cout &lt;&lt; \"~American()\" &lt;&lt; endl;&#125;Human&amp; CreateAmerican(char *name, int age, char *addr)&#123; return *(new American(name, age, addr));&#125; 分析： 类American继承于抽象类Human，必须实现抽象类的所有纯虚函数； 函数CreateAmerican()实现American类的创建； [Chinese.h]12345678910111213141516#ifndef _CHINESE_H#define _CHINESE_H#include \"Human.h\"using namespace std;class Chinese : public Human&#123;public: void eating(void); void wearing(void); void driving(void); virtual ~Chinese();&#125;;#endif [Chinese.cpp]12345678910111213141516171819202122232425#include \"Chinese.h\"void Chinese::eating(void) &#123; cout &lt;&lt; \"Eating Chinese food\" &lt;&lt; endl;&#125;void Chinese::wearing(void)&#123; cout &lt;&lt; \"Wearing Chinese clothes\" &lt;&lt; endl;&#125;void Chinese::driving(void)&#123; cout &lt;&lt; \"Driving Chinese car\" &lt;&lt; endl;&#125;Chinese::~Chinese()&#123; cout &lt;&lt; \"~Chinese()\" &lt;&lt; endl;&#125;Human&amp; CreateChinese(char *name, int age, char *addr)&#123; return *(new Chinese());&#125; 分析： 类Chinese继承于抽象类Human，必须实现抽象类的所有纯虚函数； 函数CreateChinese()实现Chinese类的创建； [main.cpp]123456789101112131415161718192021#include \"Human.h\"void test_eating(Human *h)&#123; h-&gt;eating();&#125;int main(int argc, char **argv)&#123; Human&amp; a = CreateAmerican((char *)\"jk\", 22, (char *)\"America\"); Human&amp; c = CreateChinese((char *)\"hceng\", 23, (char *)\"Chine\"); Human* h[2] = &#123;&amp;a, &amp;c&#125;; int i; for (i=0; i&lt;2; i++) test_eating(h[i]); delete &amp;a; delete &amp;c; return 0;&#125; 分析： 通过函数间接创建两个子类，利用虚函数的特性调用各自的函数； 删除各自实例化的类，前提是类的析构函数是virtual修饰的； 结果：123456Eating American foodEating Chinese food~American()~Human()~Chinese()~Human() 3.2 函数模板C++是一门强类型语言，所以无法做到像动态语言(python javascript)那样子，编写一段通用的逻辑，可以把任意类型的变量传进去处理。泛型编程弥补了这个缺点，通过把通用逻辑设计为模板，摆脱了数据类型的限制，提供了继承机制以外的另一种抽象机制，极大地提升了代码的可重用性。 模板又分为函数模板和类模板，这里先分析函数模板。函数模板只是编译指令，一般写在头文件中。编译程序时，编译器根据函数的参数来“推导”模板的参数，然后生成具体的模板函数。 函数模板只支持两种隐式转换：const转换和数组/函数指针转换。const转换：函数参数为非const引用/指针, 它可以隐式转换为const引用/指针；数组/函数指针转换：数组可以隐式转换为“指向第1个元素的指针”(a[0]);参数为“函数的名字”时，它隐式转换为“函数指针”；其他隐式转换都不支持，比如：算术转换、派生类对象向上转换等； 函数模板支持重载，注意函数的选择规则：1.先列出候选函数，包括普通函数、参数推导成功的模板函数；2.这些候选函数，根据“类型转换”来排序(其中模板函数只支持前面介绍的两种隐式转换)；3.如果某个候选函数的参数，和调用时传入的参数更匹配，则选择该候选函数；4.如果这些候选函数参数匹配度相同，如果只要一个非模板函数，就选它；如果只有模板函数，就选“更特化”的模板函数；否则导致“二义性”； 举个例子，需要实现一个比较两个数大小的函数，在原来C语言中，需要定义多个功能一样，但参数不一样，函数名也不一样的函数，然后根据不同的参数，调用对应的函数。在现在的C++中，利用模板函数和模板函数的重载，可以极大的精简该过程。 示例：[compare.cpp]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;iostream&gt;using namespace std;/*int&amp; compare_max1(int&amp; a, int&amp; b)&#123; return (a &lt; b) ? b : a;&#125;double&amp; compare_max2(double&amp; a, double&amp; b)&#123; return (a &lt; b) ? b : a;&#125;*/template&lt;typename T&gt;T&amp; compare_max1(T&amp; a, T&amp; b)&#123; cout&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;endl; return (a &lt; b) ? b : a;&#125;template&lt;typename T&gt;const T&amp; compare_max2(const T&amp; a, const T&amp; b)&#123; cout&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;endl; return (a &lt; b) ? b : a;&#125;template&lt;typename T&gt;T* compare_max3(T* a, T* b)&#123; cout&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;endl; return (a &lt; b) ? b : a;&#125;template&lt;typename T&gt;void test_func(T f)&#123; cout&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;endl;&#125;float f1(int a, int b)&#123; &#125;/*******************************/#if 1int&amp; overload_template(int&amp; a, int&amp; b)&#123; cout&lt;&lt;\"1 \"&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;endl;&#125;#endif#if 1template&lt;typename T&gt;T&amp; overload_template(T&amp; a, T&amp; b)&#123; cout&lt;&lt;\"2 \"&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;endl;&#125;#endif#if 0template&lt;typename T&gt;T overload_template(T a, T b)&#123; cout&lt;&lt;\"3 \"&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;endl;&#125;#endif#if 1template&lt;typename T&gt;const T&amp; overload_template(const T&amp; a, const T&amp; b)&#123; cout&lt;&lt;\"4 \"&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;endl;&#125;#endifint main(int argc, char **argv)&#123; int ia = 2, ib = 3; float fa = 2, fb = 3; compare_max1(ia,ib); compare_max1(fa,fb); cout&lt;&lt;\"-------------------------\"&lt;&lt;endl; compare_max2(ia,ib); cout&lt;&lt;\"-------------------------\"&lt;&lt;endl; char ca[] = \"ca\"; char cb[] = \"cb\"; char cc[] = \"cc123\"; compare_max1(ca, cb); //compare_max1(ca, cc); compare_max3(ca, cc); cout&lt;&lt;\"-------------------------\"&lt;&lt;endl; test_func(f1); test_func(*f1); cout&lt;&lt;\"-------------------------\"&lt;&lt;endl; overload_template(ia,ib); int *pa = &amp;ia; int *pb = &amp;ib; overload_template(pa, pb); return 0;&#125; 结果：12345678910111213T&amp; compare_max1(T&amp;, T&amp;) [with T = int]T&amp; compare_max1(T&amp;, T&amp;) [with T = float]-------------------------const T&amp; compare_max2(const T&amp;, const T&amp;) [with T = int]-------------------------T&amp; compare_max1(T&amp;, T&amp;) [with T = char [3]]T* compare_max3(T*, T*) [with T = char]-------------------------void test_func(T) [with T = float (*)(int, int)]void test_func(T) [with T = float (*)(int, int)]-------------------------1 int&amp; overload_template(int&amp;, int&amp;)2 T&amp; overload_template(T&amp;, T&amp;) [with T = int*] 对该示例进行分析： 1.1 首先定义了三个模板函数：compare_max1()(参数为引用)、compare_max2()(参数为const修饰的引用)、compare_max3()(参数为指针)；1.2 再定义了一个模板函数test_func()，和一个普通函数f1()；1.3 又定义四个名字一样的函数overload_template()，第一个是普通函数，第二个是参数为引用的模板函数，第三个是参数为普通的模板函数，第四个是参数为const修饰的引用模板函数；1.4 宏__PRETTY_FUNCTION__可以打印带参数类型的函数，便于分析；2.1 主函数里，首先定义了两组不同类型的数据，都可以调用compare_max1()，从打印结果可以看到，函数的参数类型都转换为传入的参数类型；2.2 再调用compare_max2()，从打印结果可以看到参数类型自动转换成了const类型，该隐式转换是支持的；2.3 再定义了三个数据，cc的长度和ca、cb不一样。使用compare_max1()传入ca和cb，可以看到数据类型都是char [3].2.4 而如果使用compare_max1()传入ca和cc，它们一个数据类型为char [3]，一个为char [6]，和模板函数的定义(两个参数类型一样)不一致，无法编译通过。2.5 使用compare_max3()传入ca和cc却有可以，因为函数模板定义的是指针类型，传入数组可以隐式转换为“指向第1个元素的指针”(a[0])，它们的数据类型就是一致的了；2.6 使用test_func()分别传入函数名字f1和函数指针*f1，其效果是一样的，因为传入参数为“函数的名字”时，它隐式转换为“函数指针”；2.7 向函数overload_template()传入两个int类型数据，最优调用的是参数吻合的非模板函数；2.8 向函数overload_template()传入两个指针类型数据，非模板函数的参数类型为int肯定不用调用了，就去看模板函数，模板函数的2、3都是最优吻合的，存在“二义性”，需要屏蔽一个。模板函数4因为有const修饰，优先级稍微靠后一点，除非前面的都屏蔽，才会调用他它； 3.模板函数重载后，注意函数的选择规则； 3.3 类模板C++除了支持函数模板，还支持类模板(Class Template)。函数模板中定义的参数类型可以用在函数声明和函数定义中，类模板中定义的参数类型可以用在类声明和类实现中。类模板的目的同样是为了摆脱了数据类型的限制，提升了代码的可重用性 声明类模板的语法为：1234template&lt;typename 参数类型1, typename 参数类型2, … &gt; class 类名&#123; //TODO:&#125;; 类型参数不能为空，多个类型参数用逗号隔开。一但声明了类模板，就可以将参数类型用于类的成员函数和成员变量了。换句话说，原来使用int、float、char等内置类型的地方，都可以用类型参数来代替。 示例： [car.cpp]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;using namespace std;template&lt;typename T&gt;class Car &#123;private: T t;public: void car_weight(const T &amp;t); void printInfo(void);&#125;;template&lt;typename T&gt;void Car&lt;T&gt;::car_weight(const T &amp;t)&#123; this-&gt;t = t;&#125;template&lt;typename T&gt;void Car&lt;T&gt;::printInfo(void)&#123; cout&lt;&lt;\"Car weight is:\"&lt;&lt;t&lt;&lt;endl;&#125;#if 1//定做(重载)template&lt;&gt;class Car&lt;char *&gt; &#123;public: void car_weight(const char *t); void printInfo(void);&#125;;void Car&lt;char *&gt;::car_weight(const char *t)&#123; cout&lt;&lt;\"Car weight is:\"&lt;&lt;t&lt;&lt;endl;&#125;void Car&lt;char *&gt;::printInfo(void)&#123; cout&lt;&lt;\"Car&lt;char *&gt;\"&lt;&lt;endl;&#125;#endifint main(int argc, char **argv)&#123; Car&lt;int&gt; ic; ic.car_weight(1000); ic.printInfo(); Car&lt;double&gt; dc; dc.car_weight(999.99); dc.printInfo(); Car&lt;char *&gt; cc; cc.car_weight((char *)\"1000kg\"); cc.printInfo(); return 0;&#125; 结果： 1234Car weight is:1000Car weight is:999.99Car weight is:1000kgCar&lt;char *&gt; 对该示例进行分析： 1.1 先定义了一个类模板Car，它的私有成员变量t和公共函数car_weight()的参数都用T代替，表示一个任意的数据类型；1.2 然后实现成员函数car_weight()和printInfo()，注意格式；1.3 然后定做了一个类，类似重载，它的类名和前面的类模板一样，但数据类型是确定了的，成员函数的内容也可以重新定义。1.4 在实例化的时候，如果传入的数据类型刚好是char *就会优先调用这个类； 2.1 主函数分别示例化了三个不同数据类型的对象，int和double类型都会调用前面的类模板Car的成员函数；2.2 char *类型的则会调用类Car&lt;char *&gt;的成员函数； 3.4 异常与Java类似，C++也有异常机制，关键字也差不多。 异常是程序在执行期间产生的问题。C++异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。异常提供了一种转移程序控制权的方式。 C++异常处理涉及到三个关键字：try、catch、throw。 throw: 当问题出现时，程序会抛出一个异常，这是通过使用throw关键字来完成； try: try块中的代码标识将被激活的特定异常，它后面通常跟着一个或多个catch块； catch: 在想要处理问题的地方，通过异常处理程序捕获异常，catch关键字用于捕获异常； 示例： [exception.cpp]1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;class MyException &#123;public: virtual void printInfo(void) &#123; cout&lt;&lt;\"This is MyException\"&lt;&lt;endl; &#125;&#125;;class MySubException : public MyException &#123;public: void printInfo(void) &#123; cout&lt;&lt;\"This is MySubException\"&lt;&lt;endl; &#125;&#125;;//A-&gt;B-&gt;C//void C(int in) throw(int, double) //C++11中丢弃//noexcept(false)可能抛出异常;noexcept(true)/noexcept不会抛出异常;void C(int in) noexcept(false) &#123; int i = 1; double d = 1.1; if (0 == in) cout&lt;&lt;\"No Exception\"&lt;&lt;endl; else if (1 == in) throw i; else if (2 == in) throw d; else if (3 == in) throw MyException(); else if (4 == in) throw MySubException();&#125;void B(int i)&#123; cout&lt;&lt;\"run B start\"&lt;&lt;endl; C(i); cout&lt;&lt;\"run B end\"&lt;&lt;endl;&#125;void A(int i)&#123; try&#123; B(i); &#125; catch (int j) &#123; cout&lt;&lt;\"catch int style exception\"&lt;&lt;endl; &#125; catch (MyException &amp;e) &#123; e.printInfo(); &#125;//catch (...) &#123; //cout&lt;&lt;\"catch other style exception\"&lt;&lt;endl; //&#125;&#125;void my_terminate_func()&#123; cout&lt;&lt;\"run my_terminate_func\"&lt;&lt;endl;&#125;int main(int argc, char **argv)&#123; int i ; set_terminate(my_terminate_func); if (argc != 2) &#123; cout&lt;&lt;\"Usage: \"&lt;&lt;endl; cout&lt;&lt;argv[0]&lt;&lt;\" &lt;0|1|2|3|4&gt;\"&lt;&lt;endl; return -1; &#125; i = strtoul(argv[1], NULL, 0); A(i); return 0;&#125; 结果： 1234567891011121314151617hceng@android:/work/c++_learn/18th_exception$ ./exception 0run B startNo Exceptionrun B endhceng@android:/work/c++_learn/18th_exception$ ./exception 1run B startcatch int style exceptionhceng@android:/work/c++_learn/18th_exception$ ./exception 2run B startrun my_terminate_funcAborted (core dumped)hceng@android:/work/c++_learn/18th_exception$ ./exception 3run B startThis is MyExceptionhceng@android:/work/c++_learn/18th_exception$ ./exception 4run B startThis is MySubException 对该示例进行分析： 1.1 定义了一个基类MyException，再派生出它的一个子类MySubException；1.2 基类MyException有一个被virtual修饰的虚函数printInfo，其子类的printInfo也自动为虚函数； 2.1 定义了三个函数，函数A调用B、函数B调用函数C；2.2 函数A将调用函数B放在了try块中，后面使用多个catch捕获不同的异常；2.3 catch后面指定想要捕捉的异常类型，这里为int数据类型和MyException类；2.4 使用catch (...)可以表示捕获其它未指定的异常类型；2.5 函数B调用函数C；2.6 函数C有一个noexcept修饰符，它是C++11新提供的异常说明符，用于声明一个函数不会抛出异常。使用noexcept设置为不抛出异常，能阻止异常的传播；这里使用noexcept(false)表示可能抛出异常；2.7 函数C抛出的异常有int、double、MyException和MySubException； 3.1 定义了函数my_terminate_func()；3.2 使用set_terminate()将前面自己定义的函数作为异常处理函数； 4.1 主函数根据传入的不同参数，是函数C抛出对应的异常。4.2 当参数为0时，函数C没有抛出异常；4.3 当参数为1时，函数C抛出int异常，被函数A捕获处理；4.4 当参数为2时，函数C抛出double异常，没有被任何函数捕获，最后调用terminate()处理；4.5 当参数为3时，函数C抛出MyException异常，被函数A捕获处理；4.6 当参数为4时，函数C抛出MySubException异常，因为是虚函数的缘故，这里调用子类的打印函数； 3.5 智能指针在C++中，可以直接操作内存，给编程增加了不少的灵活性。但是灵活性是有代价的，程序员必须负责自己负责释放自己申请的内存，否则就会出现内存泄露。智能指针就是为了解决这个问题而存在的。它和其他指针没有本质的区别，主要的目的就是为了解决悬挂指针、内存泄露的问题。其原理就是使用智能指针类SmartPointer，将一个计数器RefBase与类指向的对象相关联，当对象还有引用的时候，就不执行释放内存的操作，当引用计数为0时，就执行内存释放操作，并且将指针重置为NULL。 这里先尝试自己实现一个智能指针，理解其实现原理，然后再使用Android自带的智能指针重新测试。 示例： [smartpointer.cpp]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;class RefBase &#123;private: int count;public: RefBase() : count(0) &#123;&#125; void incStrong() &#123; count++; &#125; void decStrong() &#123; count--; &#125; int getStrongCount() &#123; return count; &#125; &#125;;class Person : public RefBase &#123;public: Person() &#123; cout&lt;&lt;\"Person()\"&lt;&lt;endl; &#125; ~Person() &#123; cout&lt;&lt;\"~Person()\"&lt;&lt;endl; &#125; void printInfo(void) &#123; cout&lt;&lt;\"This is Person\"&lt;&lt;endl; &#125;&#125;;template&lt;typename T&gt;class SmartPointer &#123;private: T *sp; public: SmartPointer() : sp(0) &#123;&#125; SmartPointer(T *pt) &#123; cout&lt;&lt;\"SmartPointer(T *pt)\"&lt;&lt;endl; sp = pt; sp-&gt;incStrong(); &#125; SmartPointer(const SmartPointer &amp;pt) &#123; cout&lt;&lt;\"SmartPointer(T &amp;pt)\"&lt;&lt;endl; sp = pt.sp; sp-&gt;incStrong(); &#125; ~SmartPointer() &#123; cout&lt;&lt;\"~SmartPointer()\"&lt;&lt;endl; if (sp) &#123; sp-&gt;decStrong(); if (sp-&gt;getStrongCount() == 0) &#123; delete sp; sp = NULL; &#125; &#125; &#125; T *operator-&gt;() &#123; return sp; &#125; T&amp; operator*() &#123; return *sp; &#125;&#125;;template&lt;typename T&gt;void test_func(SmartPointer&lt;T&gt; &amp;pt)&#123; SmartPointer&lt;T&gt; sp = pt; cout&lt;&lt;\"In test_func:\"&lt;&lt;sp-&gt;getStrongCount()&lt;&lt;endl; sp-&gt;printInfo(); //(*sp).printInfo();&#125;int main(int argc, char **argv)&#123; int i; SmartPointer&lt;Person&gt; sp = new Person(); cout&lt;&lt;\"Before call test_func:\"&lt;&lt;sp-&gt;getStrongCount()&lt;&lt;endl; for (i=0; i&lt;2; i++) &#123; test_func(sp); cout&lt;&lt;\"After call test_func:\"&lt;&lt;sp-&gt;getStrongCount()&lt;&lt;endl; &#125; return 0;&#125; 结果： 123456789101112131415Person()SmartPointer(T *pt)Before call test_func:1SmartPointer(T &amp;pt)In test_func:2This is Person~SmartPointer()After call test_func:1SmartPointer(T &amp;pt)In test_func:2This is Person~SmartPointer()After call test_func:1~SmartPointer()~Person() 对该示例进行分析： 1.1 定义了类RefBase用于引用计数，在构造的时候就赋初值为0，提供三个函数进行加、减、查询计数；1.2 定义了类Person用于测试，继承于RefBase；1.3 定义了类模板SmartPointer用于指针管理，包含指针类成员、三个构造函数、一个析构函数、两个运算符重载函数；1.4 创建了模板函数test_func()用于测试； 2.1 主函数里，首先new Person()，传给sp会调用到SmartPointer(T *pt)，此时count引用加1；2.2 然后调用test_func()，会调用到SmartPointer(const SmartPointer &amp;pt)，传给sp，count引用再加1；2.3 sp作为局部变量在使用完后，自动释放，调用析构函数~SmartPointer()，count减1；2.4 主函数循环，再次调用test_func()，重复2.2、2.3的步骤；2.5 主函数执行完，释放主函数的sp，再次调用~SmartPointer()，count变为0，将会执行delete sp;，最终调用~Person()； 3.以后创建指针类，不需要Person *p = new Person();，而使用SmartPointer&lt;Person&gt; p = new Person();，就不需要自己手动delete p;了。 示例： [androidsmartpointer.cpp]123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include \"RefBase.h\"using namespace std;using namespace android::RSC;class Person : public LightRefBase&lt;Person&gt; &#123;public: Person() &#123; cout&lt;&lt;\"Person()\"&lt;&lt;endl; &#125; ~Person() &#123; cout&lt;&lt;\"~Person()\"&lt;&lt;endl; &#125; void printInfo(void) &#123; cout&lt;&lt;\"This is Person\"&lt;&lt;endl; &#125;&#125;;template&lt;typename T&gt;void test_func(sp&lt;T&gt; &amp;pt)&#123; sp&lt;T&gt; sp = pt; cout&lt;&lt;\"In test_func:\"&lt;&lt;sp-&gt;getStrongCount()&lt;&lt;endl; sp-&gt;printInfo(); //(*sp).printInfo();&#125;int main(int argc, char **argv)&#123; int i; sp&lt;Person&gt; sp = new Person(); cout&lt;&lt;\"Before call test_func:\"&lt;&lt;sp-&gt;getStrongCount()&lt;&lt;endl; for (i=0; i&lt;2; i++) &#123; test_func(sp); cout&lt;&lt;\"After call test_func:\"&lt;&lt;sp-&gt;getStrongCount()&lt;&lt;endl; &#125; return 0;&#125; 结果： 123456789Person()Before call test_func:1In test_func:2This is PersonAfter call test_func:1In test_func:2This is PersonAfter call test_func:1~Person() 对该示例进行分析： 1.1 使用Android源码中自带的引用计数类和智能指针类，也就是Android轻量级指针；1.2 相比自己实现的智能指针，Android源码提供的轻量级指针对引用计数有了原子操作，计数时避免了被其它相关的线程打断；1.3 效果和前面自己写的智能指针基本一致； 3.7 Android强/弱指针Android中定义了两种智能指针类型：强指针sp(strong pointer)、弱指针(weak pointer)强指针与一般意义的智能指针概念相同，通过引用计数来记录有多少使用者在使用一个对象，如果所有使用者都放弃了对该对象的引用，则该对象将被自动销毁。弱指针也指向一个对象，但是弱指针仅仅记录该对象的地址，不能通过弱指针来访问该对象，也就是说不能通过弱指针来调用对象的成员函数或访问对象的成员变量。 要想访问弱指针所指向的对象，需首先将弱指针升级为强指针(通过wp类所提供的promote()方法)。弱指针所指向的对象是有可能在其它地方被销毁的，如果对象已经被销毁，wp的promote()方法将返回空指针，这样就能避免出现地址访问错的情况。 为什么引入弱指针呢?如下例中的这种情况，father和son相互引用，会导致释放时两者都没法释放，造成内存泄露。因此引入弱指针来解决这种情况。 示例： [pointer.cpp]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;utils/RefBase.h&gt;#include &lt;LightPointeRefBase.h&gt;using namespace std;#define LIGHTPOINT 1 #if LIGHTPOINTusing namespace android::RSC;class Person : public LightRefBase&lt;Person&gt; &#123;private: sp&lt;Person&gt; father; sp&lt;Person&gt; son; public: Person() &#123; cout&lt;&lt;\"Person()\"&lt;&lt;endl; &#125; ~Person() &#123; cout&lt;&lt;\"~Person()\"&lt;&lt;endl; &#125; void printInfo(void) &#123; cout&lt;&lt;\"This is Person\"&lt;&lt;endl; &#125; void setFather(sp&lt;Person&gt; &amp;father) &#123; this-&gt;father = father; &#125; void setSon(sp&lt;Person&gt; &amp;son) &#123; this-&gt;son = son; &#125;&#125;;#elseusing namespace android;class Person : public RefBase &#123;private: wp&lt;Person&gt; father; wp&lt;Person&gt; son; public: Person() &#123; cout&lt;&lt;\"Person()\"&lt;&lt;endl; &#125; ~Person() &#123; cout&lt;&lt;\"~Person()\"&lt;&lt;endl; &#125; void printInfo(void) &#123; cout&lt;&lt;\"This is Person\"&lt;&lt;endl; &#125; void setFather(sp&lt;Person&gt; &amp;father) &#123; this-&gt;father = father; &#125; void setSon(sp&lt;Person&gt; &amp;son) &#123; this-&gt;son = son; &#125;&#125;;#endifvoid test_func(int mode)&#123; if(mode) &#123; sp&lt;Person&gt; father = new Person(); sp&lt;Person&gt; son = new Person(); father-&gt;setSon(son); &#125; else &#123; sp&lt;Person&gt; father = new Person(); sp&lt;Person&gt; son = new Person(); father-&gt;setSon(son); son-&gt;setFather(father); &#125;&#125;int main(int argc, char **argv)&#123; int mode = atoi(argv[1]); if (mode &lt; 2) test_func(mode); else &#123;#if LIGHTPOINT #else wp&lt;Person&gt; s1 = new Person(); //s1-&gt;printInfo(); //ERROR, \"wp\" no override \"-&gt;\" //(*s1).printInfo(); //ERROR, \"wp\" no override \"*\" sp&lt;Person&gt; s2 = s1.promote(); if (s2 != 0) s2-&gt;printInfo();#endif &#125; return 0;&#125; 结果： 12345678910111213141516171819202122232425//#define LIGHTPOINT 1hceng@android:/work/c++_learn/20th_strongpointer_weekpointer$ ./pointer 0Person()Person()hceng@android:/work/c++_learn/20th_strongpointer_weekpointer$ ./pointer 1Person()Person()~Person()~Person()//#define LIGHTPOINT 0hceng@android:/work/c++_learn/20th_strongpointer_weekpointer$ ./pointer 0Person()Person()~Person()~Person()hceng@android:/work/c++_learn/20th_strongpointer_weekpointer$ ./pointer 1Person()Person()~Person()~Person()hceng@android:/work/c++_learn/20th_strongpointer_weekpointer$ ./pointer 2Person()This is Person~Person() 对该示例进行分析： 1.1 条件编译，假设#define LIGHTPOINT 1，此时使用强指针，主函数根据传入参数调用test_func()；1.2 mode = 0时，father和son相互引用，使用完后，并没有调用析构函数释放；1.3 mode = 1时，father和son没有相互引用，使用完后，调用析构函数进行了释放； 2.1 条件编译，假设#define LIGHTPOINT 0，此时使用弱指针，主函数根据传入参数调用test_func()；2.2 可以看到无论father和son有无相互引用，结果都调用析构函数正常释放了； 3.1 在使用弱指针时，实例化s1，无法通过s1访问Person类成员函数，只能先通过promote()转化，才能访问Person类成员函数； 4. 设计模式4.1 单例模式在Android源码中有许多的设计模式，其中单例模式就是最常见的一个。 单例模式就是一个类只能被实例化一次，即只能有一个实例化的对象的类。 像Windows系统的任务管理器一样，你无论打开多少次，始终显示的一个窗口。定义一个统一的全局变量可以确保对象随时可以被访问，但不能防止创建多个对象。一个最好的办法就是让类自身负责创建和保存它的唯一实例，并保证不创建其他实例，它还提供了一个访问该实例的方法，这就是单例模式的应用场景。 示例： [singleton.cpp]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;using namespace std;#if 0//hungry modeclass Singleton &#123;private: static Singleton *gInstance;private: Singleton() &#123; cout&lt;&lt;\"Singleton()\"&lt;&lt;endl; &#125; public: static Singleton *getInstance() &#123; return gInstance; &#125; void printInfo() &#123; cout&lt;&lt;\"This is Singleton\"&lt;&lt;endl; &#125;&#125;;Singleton *Singleton::gInstance = new Singleton;#else //Lazy mode class Singleton &#123;private: static Singleton *gInstance; static pthread_mutex_t g_tMutex;private: Singleton() &#123; cout&lt;&lt;\"Singleton()\"&lt;&lt;endl; &#125; public: static Singleton *getInstance() &#123; #if 0 if (NULL == gInstance) &#123; pthread_mutex_lock(&amp;g_tMutex); if (NULL == gInstance) gInstance = new Singleton; pthread_mutex_unlock(&amp;g_tMutex); &#125; #else pthread_mutex_lock(&amp;g_tMutex); static Singleton *gInstance; pthread_mutex_unlock(&amp;g_tMutex); #endif return gInstance; &#125; void printInfo() &#123; cout&lt;&lt;\"This is Singleton\"&lt;&lt;endl; &#125;&#125;;Singleton *Singleton::gInstance = NULL;pthread_mutex_t Singleton::g_tMutex = PTHREAD_MUTEX_INITIALIZER;#endifvoid *start_routine_thread1(void *arg)&#123; cout&lt;&lt;\"this is thread 1 ……\"&lt;&lt;endl; Singleton *s = Singleton::getInstance(); s-&gt;printInfo(); return NULL;&#125;void *start_routine_thread2(void *arg)&#123; cout&lt;&lt;\"this is thread 2 ……\"&lt;&lt;endl; Singleton *s = Singleton::getInstance(); s-&gt;printInfo(); return NULL;&#125;int main(int argc, char **argv)&#123; Singleton *s1 = Singleton::getInstance(); s1-&gt;printInfo(); Singleton *s2 = Singleton::getInstance(); s2-&gt;printInfo(); //Singleton *s3 = new getInstance(); //Singleton s4; pthread_t threadID1; pthread_t threadID2; pthread_create(&amp;threadID1, NULL, start_routine_thread1, NULL); pthread_create(&amp;threadID2, NULL, start_routine_thread2, NULL); sleep(2); return 0;&#125; 结果： 12345678hceng@android:/work/c++_learn/21th_singleton$ g++ -o singleton singleton.cpp -lpthreadhceng@android:/work/c++_learn/21th_singleton$ ./singleton This is SingletonThis is Singletonthis is thread 1 ……This is Singletonthis is thread 2 ……This is Singleton 对该示例进行分析： 1.1 示例中有两种实现方法：饿汉模式(hungry mode)和懒汉模式(Lazy mode)；1.2 饿汉就是第一时间需要食物，即类在定义的时候就进行实例化Singleton *Singleton::gInstance = new Singleton;；1.3 懒汉就是不到万不得已，是不会要食物的，即类在第一次用到类实例的时候才会去实例化Singleton *Singleton::gInstance = NULL; Singleton *s = Singleton::getInstance();；1.4 在访问量较小时，采用懒汉实现，以牺牲时间换空间；在访问量比较大，访问的线程比较多时，采用饿汉会有更好的性能，以空间换时间； 2.1 Singleton类里，有一个private、static的类指针gInstance，保存唯一的实例；2.2 构造函数为private或protect防止被外部函数调用，进行实例化；2.3 实例的动作由一个public的类方法getInstance()代劳，该方法返回类唯一的实例；2.4 懒汉模式因为在使用getInstance()实例化时，可能发生冲突，因此需要加锁控制； 3.1 从示例结果可以看到，无论是主函数实例化类，还是在其它线程实例化类，结果都没有创建新的实例化对象，达到了目的；3.2 构造函数变成了私有函数，只向外提供了getInstance()接口，防止了通过其它途径实例化对象； 4.2 桥接模式Bridge桥接模式将抽象(Abstraction)与实现(Implementation)分离，使得二者可以独立地变化。软件设计中，如果只有一维在变化，那么用继承就可以圆满的解决问题，如果有超过一维的变化，就最好用桥接模式。 举例一个操作系统和电脑公司的例子。 示例： [install1.cpp]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;using namespace std;class OS &#123;public: virtual void Install() = 0;&#125;;class LinuxOS : public OS &#123;public: virtual void Install() &#123; cout&lt;&lt;\"Install Linux OS\"&lt;&lt;endl; &#125;;&#125;;class WindowsOS : public OS &#123;public: virtual void Install() &#123; cout&lt;&lt;\"Install Windows OS\"&lt;&lt;endl; &#125;;&#125;;class Company &#123;public: virtual void Use() = 0;&#125;;class Msi : public Company &#123;public: virtual void Use() &#123; cout&lt;&lt;\"Msi computer \"; &#125;;&#125;;class Dell : public Company &#123;public: virtual void Use() &#123; cout&lt;&lt;\"Dell computer \"; &#125;;&#125;;class MsiUseLinuxOS : public LinuxOS, public Msi &#123;public: void InstallOS() &#123; Use(); Install(); &#125;&#125;;class DellUseWindowsOS : public WindowsOS, public Dell &#123;public: void InstallOS() &#123; Use(); Install(); &#125;&#125;;class MsiUseWindowsOS : public WindowsOS, public Msi &#123;public: void InstallOS() &#123; Use(); Install(); &#125;&#125;;class DellUseLinuxOS : public LinuxOS, public Dell &#123;public: void InstallOS() &#123; Use(); Install(); &#125;&#125;;int main(int argc, char **argv)&#123; MsiUseLinuxOS a; a.InstallOS(); DellUseWindowsOS b; b.InstallOS(); return 0;&#125; 结果： 12Msi computer Install Linux OSDell computer Install Windows OS 对该示例进行分析： 1.1 定义了类OS，有一个方法Install()，生成两个派生类LinuxOS和WindowsOS；1.2 定义了类Company，有一个方法Use()，生成两个派生类Msi和Dell；1.3 不同的电脑公司可能装不同的操作系统，就可能生成四个新类MsiUseLinuxOS、DellUseWindowsOS、MsiUseWindowsOS、DellUseLinuxOS； 2.1 主函数实例化了安装操作系统的电脑；2.2 可见生成的类数量很多，为两个维度的乘积，且某一方发生了增添，最后生成的类也要有很大的改动，关系如下图： 示例： [install2.cpp]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;using namespace std;class OS &#123;public: virtual void Install() = 0;&#125;;class LinuxOS : public OS &#123;public: virtual void Install() &#123; cout&lt;&lt;\"Install Linux OS\"&lt;&lt;endl; &#125;;&#125;;class WindowsOS : public OS &#123;public: virtual void Install() &#123; cout&lt;&lt;\"Install Windows OS\"&lt;&lt;endl; &#125;;&#125;;class Company &#123;public: virtual void Use() = 0; virtual void InstallOS() = 0;&#125;;class Msi : public Company &#123;private: OS *impl;public: Msi(OS *impl) &#123; this-&gt;impl = impl; &#125;; virtual void Use() &#123; cout&lt;&lt;\"Msi computer \"; &#125;; virtual void InstallOS() &#123; Use(); impl-&gt;Install(); &#125;;&#125;;class Dell : public Company &#123;private: OS *impl;public: Dell(OS *impl) &#123; this-&gt;impl = impl; &#125;; virtual void Use() &#123; cout&lt;&lt;\"Dell computer \"; &#125;; virtual void InstallOS() &#123; Use(); impl-&gt;Install(); &#125;;&#125;;int main(int argc, char **argv)&#123; OS *lin = new LinuxOS(); OS *win = new WindowsOS(); Company *a = new Msi(lin); Company *b = new Dell(win); a-&gt;InstallOS(); b-&gt;InstallOS(); return 0;&#125; 结果： 12Msi computer Install Linux OSDell computer Install Windows OS 对该示例进行分析： 1.1 定义了类OS，有一个方法Install()，生成两个派生类LinuxOS和WindowsOS；1.2 定义了类Company，有一个方法Use()，生成两个派生类Msi和Dell；1.3 Msi和Dell有一个InstallOS()方法，它并不是直接实现的，而是调用传入的OS类的Install()方法，即将抽象和实现分开； 2.1 主函数实例化了安装操作系统的电脑；2.2 可见并没有生成各个厂家安装操作系统的类，且某一方发生了增添，都对对方没有任何影响，关系如下图： 5. 其它所有示例源码:Github 参考资料:韦东山第四期Android驱动_C++快速入门 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Android基础","slug":"Android基础","permalink":"http://yoursite.com/tags/Android基础/"}]},{"title":"JAVA学习笔记","date":"2018-09-12T14:48:34.000Z","path":"2018/09/12/JAVA学习笔记/","text":"毕业后就没怎么碰Java了，为了后面Android的学习，将Java的基础知识整理一下。 0. 开发环境的搭建在后面Java学习的过程中，要敲写示例代码在Linux上测试，因此需要先用虚拟机安装一个Linux发行版和Java。准备使用的Linux发行版为Ubuntu18.04.1，考虑到后期Android学习也会在该虚拟机上，因此在安装过程就得先设置好硬盘大小和交换分区，感觉还是有必要记录一下。 0.1 为Ubuntu设置两个分区首先是安装虚拟机VMware Workstation Pro和下载Ubuntu 18.04.1 LTS就不废话了。然后新建虚拟机，选择“自定义(高级)”，再默认“下一步”，然后选择下载好的Ubuntu镜像文件ubuntu-18.04.1-desktop-amd64.iso，设置名字、密码等，再设置虚拟机文件放置位置(选择一个剩余空间大于100G的盘)，选择核心数，设置内存，设置为“使用桥接网络”，默认IO控制器类型，默认磁盘类型，再选择“创建新虚拟磁盘”，磁盘大小为20G(作为root分区，存放Ubuntu自身系统等)，磁盘文件名也改为“root.vmdk”，然后取消“创建后开启虚拟机”再点击“完成”，此时再选择“编辑虚拟机设置”，选中“CD/DVD (SATA) 正在使用文件autoinst.iso”，将其移除，再点击“添加”，选择“硬盘”，再一直点默认“下一步”，直到设置磁盘大小界面，设置为100G(作为work分区，存放后面的Android源码等)，名字也改为“work.vmdk”，完成后，即可“开启此虚拟机”。 这里解释下为什么这样繁琐的设置两个分区。假如只有一个分区，在以后的使用中，假如Ubuntu不小心被损坏，不能进入系统，那么系统里保存的数据就无法获取，资料也就没了。假如分成了两个分区，一个作为系统分区，一个作为工作数据分区，即使Ubuntu系统崩溃，只需重新安装一个Ubuntu，挂接原来的工作数据分区即可，所有的文件仍然会保留。此外，扩展分区大小，也相对比较方便。 0.2 为Ubuntu设置交换分区首次启动虚拟机后，进入系统配置界面，选择默认语言“English”，点击“Install Ubuntu”，选择默认键盘布局，选择最小安装“Minimal installation”，去掉“Download update while installing Ubuntu”，不然要安装很久，然后点击“Continue”，选择“Someting else”，选中“/dev/sda”(20G的root分区)，右键点击“New Partition Table……”，在弹出的窗口选择“Continue”，再选中新出现的“free space”，右键点击“Add……”，在“Use as:”选项卡里选择“swap area”，大小改为10240(Android编译要求16G的内存+交换分区，内存不够交换分区凑)，完成后再点击该“free space”，把剩下的大小作为“Ext4 journaling file system”，“Mount point:”设置为根目录“/”，然后以类似的方式设置“/dev/sdb”，全部空间作为“Ext4 journaling file system”，“Mount point:”设置为手动编辑的“/work”，分区完成效果如下： 最后点击“Install Now”，选择时区为“Shanghai”，设置主机名字、密码等，再根据提示重启。 0.3 为Ubuntu安装基本软件前面的博客Linux开发环境配置及shell script对嵌入式开发所需使用到的软件有过一次分析，另外博客搭建嵌入式Linux开发环境有如何安装和配置，参考博客，完成对ftp、ssh、nfs、smaba、vim的安装和配置，这些就不废话了，目前只是学习Java，至于其它的软件，后面需要再安装。 接下来就是安装本次的最主要的Java：1sudo apt-get install openjdk-8-jdk 这里只安装了JDK，因为JDK包含了JRE: JDK (Java Development Kit)：JAVA开发环境，包含JRE； JRE (Java Runtime Environment)：JAVA运行环境，包含虚拟机但不包含编译器； 以上就完成了Java学习环境的准备。 1. Java基础1.1 第一个Java程序[Hello.java]12345public class Hello &#123; public static void main(String args[]) &#123; System.out.println(\"Hello world!\"); &#125; &#125; 编译、执行：12javac Hello.java //编译java Hello //执行 这里Java文件名首字母大写是因为:在Java编程规范里，类的首字母要大写，而类的名字要和文件名一致； 1.2 数据类型Java的数据类型分为8个基本数据类型和3个引用数据类型。 1.2.1 基本数据类型 序号 数据类型 关键字 占用比特数/字节数 取值范围 缺省数值 1 布尔型 boolean 8/1 true,false false 2 字节型 byte 8/1 -128~127 0 3 字符型 char 16/2 0~65535 ‘\\u0’ 4 短整数 short 16/2 -32768~32767 0 5 整型 int 32/4 -2147483648~2147483647 0 6 长整型 long 64/8 -9.22E-45~9.22E+18 0 7 单精度浮点型 float 32/4 1.4013E-45~3.4028E+38 0.0F 8 双精度浮点型 double 64/8 2.22551E-208~1.7977E+308 0.0D Java中所有的基本数据类型都有固定的存储范围和所占内存空间的大小，而不受具体操作系统的影响，来保证Java程序的可移植性。整形数据默认为int数据类型，浮点型默认为double数据类型，如果要表示long型数据或float型数据，要在相应的数值后面加上l、L或f、F，否则会出现编译问题。 1.2.2 引用数据类型Java的引用数据类型包括：数组(array)、类(class)、接口(interface)，其缺省值都为null。基本数据类型的变量名指向具体的数值，而引用数据类型的变量名指向存数据对象的内存地址，有点类型C语言的指针。当引用指向null时，Java会自动释放对应的空间。 1.2.3 数据转换Java在不丢失数据的前提下，可以实现自动转换，比如int型转换为long型，即由小范围变大范围可以，大范围变小范围不行。 示例：[Var.java]1234567891011121314151617181920212223242526272829303132333435public class Var &#123; public static void main(String args[]) &#123; //基本数据类型:变量名指向具体的数值(数据在栈) boolean a = true; //布尔型 byte b = 1; //字节型 char c = 'h'; //字符型 short d = 2; //短整数 int e = 3; //整型 long f = 4L; //长整型 float g = 3.14F; //单精度浮点型 double h = 3.14D; //双精度浮点型 //引用数据类型:变量名指向存数据对象的内存地址(引用在栈,数据在堆) int p1[] = new int[10]; //分配整数数组,类似C语言int p1[10];或int* p1 = malloc(10*sizeof(int)); int p2[] = &#123;1, 2, 3&#125;; //分配并定义,类似C语言int p2[10] = &#123;1, 2, 3&#125;; String str = \"hceng\"; //类引用,分配并定义,类似C语言char str[] = \"hceng\"; p1 = null; //自动释放 p2 = null; str = null; //数据转换 int a1 = 30; long b1 = a1; //自动转换,因为long的表示范围比int大 float c1 = 3.1f; int d1 = (int)c1; //必须使用强制转换,因为数据会丢失 short s = 1; //s = s + 1; //出错,因为s+1自动将s变成了int型与1相加,再赋值给short型的s,大范围变小范围不行 //s = s + s; //出错,因为s+s也会自动变成int型赋值给short型的s,大范围变小范围不行 s = (short)(s + 1); s = (short)(s + s); &#125;&#125; 1.3 运算符、表达式、语句Java的分支if, if...else, if...else if...else, switch和循环while, do...while, for; break, continue都和C语言是一样的。 1.4 方法在C语言里函数的的叫法，在Java中没有了，类似的东西叫方法，所谓的方法就是用来解决一类问题的代码的有序组合，是一个功能模块。 1.4.1 方法的格式1234public static 返回值类型 方法名称 (类型 参数1, 类型 参数2, ...) ｛ 程序语句; [return 表达式];｝ 示例：12345public static int add(int x, int y) &#123; int sum; sum = x + y; return sum;&#125; 1.4.2 方法的重载即方法名相同，参数类型或个数不同，返回值也可相同也可以不同，就会调用到不同的方法。 示例： [Method.java]12345678910111213141516171819public class Method &#123; public static void main(String args[]) &#123; System.out.println(add(1, 2)); System.out.println(add(1, 2, 3)); System.out.println(add(1.0f, 2.0f)); &#125; public static int add (int x, int y) &#123; return x + y; &#125; public static int add (int x, int y, int z) &#123; return x + y + z; &#125; public static float add (float x, float y) &#123; return x + y; &#125;&#125; 结果： 123363.0 三个方法名字都一样，第一个和第二个参数个数不同，第一个和第三个参数类型不同，在调用方法时，传入的参数和哪一个匹配，就会调用到哪一个方法。 1.4.3 方法的参数 示例： [Param.java]1234567891011121314151617181920212223public class Param &#123; public static void main(String args[]) &#123; int x = 1; System.out.println(\"Before x=\" + x); fun(x); System.out.println(\"After x=\" + x); int p[] = new int[1]; p[0] = 2; System.out.println(\"Before p=\" + p[0]); fun(p); System.out.println(\"After p=\" + p[0]); &#125; public static void fun(int x) &#123; x = 100; &#125; public static void fun(int[] p) &#123; p[0] = 200; &#125;&#125; 结果： 1234Before x=1After x=1Before p=2After p=200 与C语言类型，如果传入的为形参，在方法里修改变量值，外部的方法的参数不会被改变，可以通过引用数组(类型C语言的指针)的方式，实现对传入参数的修改。基本数据作为参数，方法内部对参数的修改不影响调用者；引用数据作为参数，方法内部修改了堆，结果会保留下来； 2. Java面向对象编程在Java中，方法类似C语言中函数，类类似C语言中结构体。Java面向对象编程有三大特性：封装性、继承性、多态性。 2.1 类的引入在Java面向对象的思维里，把拥有共同特征的事物抽象出来叫做类，把符合这个类特征的个体叫做对象。比如“人”就是类，具体的某个人“张三”就是对象，类的共同特征包含“人的名字”、“人的年龄”等。 如下面例子，定义了一个类Person，在main里，通过new创建具体的对象，再通过对象调用成员方法，或者直接访问类方法或类变量。 示例： [Oop.java]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//类的定义(类是创建对象的模板,创建对象也叫类的实例化)class Person &#123; //类变量(调用不需要实例化对象) static int count; //类方法(调用不需要实例化对象) static void printPerson () &#123; System.out.println(\"This is a class of Person\"); &#125; //静态代码块(只会被调用一次,且先于构造代码块、构造方法执行) static &#123; System.out.println(\"Execute only once\"); &#125; //构造代码块(每次创建对象时都会被调用,且先于构造方法执行) &#123; System.out.println(\"Every call is executed\"); count ++; &#125; //类的成员 String name; //成员变量 int age; //成员变量 //成员方法 String getName() &#123; return name; &#125; //构造方法(没有返回值，方法名必须和类名一样) //实现new时传入参数,重载实现传入的参数多样化 public Person () &#123; name = \"null\"; age = 0; &#125; public Person (String name) &#123; this.name = name; //name是局部变量 age = 0; &#125; public Person (String name, int age) &#123; this.name = name; this.age = age; &#125;&#125;//一个源文件中只能有一个public类,且与文件名相同public class Oop &#123; public static void main(String args[]) &#123; Person p0 = new Person(); //创建对象,即类的实例化 Person p1 = new Person(\"hceng\"); Person p2 = new Person(\"hceng, 23\"); System.out.println(p0.getName()); //调用成员方法 System.out.println(p1.getName()); System.out.println(p2.getName()); Person.printPerson(); //访问类方法 System.out.println(\"Person number is \" + Person.count); //访问类变量 &#125;&#125; 结果： 123456789Execute only onceEvery call is executedEvery call is executedEvery call is executednullhcenghceng, 23This is a class of PersonPerson number is 3 对该示例进行分析，涉及了好几个知识点。 Person通过class关键词定义为类； 2.1 通过static修饰的变量叫类变量，可以不通过new创建对象进行访问；2.2 通过static修饰的方法叫类方法，可以不通过new创建对象进行访问； 3.1 通过static { }修饰的代码块叫静态代码块，在类被创建的时候调用，且只会被调用一次，先于构造代码块、构造方法执行；3.2 通过{ }修饰的代码块叫构造代码块，在每次类被创建的时候调用，先于构造方法执行； 4.1 接下来是类的成员，包含成员变量和成员方法；4.2 成员方法:实现对类中成员变量的操作，提供某些功能，成员方法通过对象调用； 5.1 接下来是构造方法，没有返回值，方法名必须和类名一样，如果没实现构造方法，编译器自动加上一个无参数的空构造方法；5.2 构造方法:用于创建类的实例并对实例的成员变量进行初始化，构造方法通过new运算符调用；5.3 这里利用重载实现了传入参数的多样化，this关键字表示当前类； 6.1 接下来是public修饰的类，也是唯一的一个，和文件名相同，里面有main成员方法；6.2 在main里，首先创建了三个对象，每个对象传入的参数不同，调用的构造方法也会不同；6.3 然后调用对象的成员方法；6.4 最后直接对类变量、类方法进行访问； 2.2 封装性在Java中，将属性(变量)和方法封装成一个整体(也就是类)，就是封装性的体现。 对于这个整体，里面有些属性外部可以直接访问，有些可能期望按要求访问，对于特殊的属性，可以先设置为私有的权限，再通过属性的方法进行访问，就属性的方法里就是我们期望访问的方式。 就比如下例中的年龄，我们期望年龄为非负的值，假如外部直接修改年龄就有被设置为负的风险。现在将年龄私有化，使外部无法访问，只能通过公共的类的方法进行访问，这个方法里就对传入的参数进行判断纠正，从而满足年龄非负的要求。 示例： [Enc.java]123456789101112131415161718192021222324252627class Person &#123; /* 成员变量(属性) */ //int age; //default private int age; //私有,只能供类内部访问 /* 成员方法 */ public void setAge(int age) &#123; if (age &lt; 0 || age &gt; 200) age = 0; else this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125;public class Enc &#123; public static void main(String args[]) &#123; Person per = new Person(); //per.age = -1; //外部直接访问,不好控制 per.setAge(-1); System.out.println(per.getAge()); &#125;&#125; 结果： 10 Java中四种权限：private: 被其修饰的属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问；default:默认访问权限，只允许在同一个包中进行访问；protected:被其修饰的属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问；public: 被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包访问； 权限 类内 同包 不同包子类 不同包非子类 private √ × × × default √ √ × × protected √ √ √ × public √ √ √ √ 2.3 继承性2.3.1 引入为了实现代码的复用，Java中引入了继承性。如下例子，子类Student继承了父类Person，就可以访问父类的属性(非私有)和方法(非私有)。 示例： [Ext.java]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class Person &#123; //变量/属性 private int age; //方法 public void setAge(int age) &#123; if (age &lt; 0 || age &gt; 200) age = 0; else this.age = age; &#125; public int getAge() &#123; return age; &#125; public void printfInfo() &#123; System.out.println(\"age = \" + age); &#125; final public void testFinal() &#123; &#125; //构造方法 public Person() &#123; //系统默认的构造函数,如果没有,编译器会自动生成 System.out.println(\"for test Person() call\"); &#125; public Person(int age) &#123; this.age = age; System.out.println(\"for test Person(int age) call\"); &#125;&#125;//Student从父类(Person)继承class Student extends Person &#123; private String school; public void setSchool(String school) &#123; this.school = school; &#125; public String getSchool() &#123; return this.school; &#125; //覆写(方法名在父类中有同名方法) public void printfInfo() &#123; System.out.println(\"school = \" + school); &#125; //父类方法用了final修饰,子类无法覆写 //public void testFinal() &#123; // //&#125; //构造方法 public Student() &#123; //系统默认的构造函数,如果没有,编译器会自动生成 //super(); //调用父类的构造函数(无参数),默认调用,可不写 super(15); //调用父类的构造函数(有参数) super.printfInfo(); //super就指代的父类 System.out.println(\"for test Student() call\"); &#125;&#125;public class Ext &#123; public static void main(String args[]) &#123; Student per = new Student(); per.setAge(10); //方法来源于父类 System.out.println(per.getAge()); per.setSchool(\"ShenZhen\"); //方法来源于自己扩展 System.out.println(per.getSchool()); per.printfInfo(); //覆写的父类方法 &#125;&#125; 结果： 123456for test Person(int age) callage = 15for test Student() call10ShenZhenschool = ShenZhen 对该示例进行分析： 1.1 定义了一个类Person，包含一个变量(私有)、四个方法、两个构造方法；1.2 第四个构造方法使用了final修饰，后面子类将不能对其覆写；1.3 两个构造方法，一个不带参数，一个带参数； 2.1 子类Student从父类Person通过关键词extends继承，包含一个新变量(私有)、三个方法、一个构造方法；；2.2 方法printfInfo和父类的方法printfInfo名字一样，父类被覆写，调用printfInfo会调用子类的printfInfo；2.3 方法testFinal被注释，因为父类使用final修饰了同名的方法，子类不能再覆写；2.4 子类的构造方法被调用时，会先默认调用父类的构造方法，即用super表示，如果super带参数，表示调用父类带参数的构造方法，同时还可以通过super访问父类的属性(非私有)和方法(非私有)； 3.1 在main里，首先new实例化了一个Student类；3.2 调用Student类的setAge方法，这个方法是从父类继承过来的；3.3 调用Student类的setSchool方法，这个方法是子类自己扩展的；3.4 调用Student类的printfInfo方法，这个方法父类和子类都有，子类覆写父类的方法； 2.3.2 继承的限制前面引入了继承，子类从父类继承过来，也就拥有了父类的一些特性，但继承也是有限制的： 父类的私有属性不能被子类访问； 父类的私有方法不能被子类访问； 子类覆写的方法不能缩小权限，即父类public，子类不能private； 示例： [Limit.java]12345678910111213141516171819202122232425262728293031323334353637class Father &#123; private int money; public void setMoney(int money) &#123; this.money = money; &#125; public void printfInfo1() &#123; System.out.println(\"This is Father printfInfo1()\"); &#125; private void printfInfo2() &#123; System.out.println(\"This is Father printfInfo2()\"); &#125;&#125;class Son extends Father &#123; //private void printfInfo1() &#123; //System.out.println(\"This is Son printfInfo1()\"); //&#125; public void printfInfo2() &#123; System.out.println(\"This is Son printfInfo2()\"); &#125;&#125;public class Limit &#123; public static void main(String args[]) &#123; Son son = new Son(); //son.money = 100; son.setMoney(100); son.printfInfo1(); son.printfInfo2(); &#125;&#125; 结果： 12This is Father printfInfo1()This is Son printfInfo2() 对该示例进行分析： 1 定义了一个类Father，包含一个变量(私有)、三个方法(其中一个私有)； 2.1 子类Son从父类Father继承，只有一个方法；2.2 方法printfInfo1被private修饰，表示私有，而父类同名方法是公共的，不能覆写，无法编译通过；2.3 方法printfInfo2被public修饰，表示公共，父类也有个同名方法，但却是私有的，因此这里不是覆写，而是定义的新方法； 3.1 main里面实例化了一个类Son；3.2 Son从父类Father继承过来，父类的私有变量不能直接访问，只能通过父类提供的公共方法来访问；3.3 父类的printfInfo1是公共的，子类的printfInfo1也只能是公共的；3.4 父类的printfInfo2是私有的，子类无法访问，子类的printfInfo2是新定义的； 2.3.3 抽象类抽象类作用:规定子类必须实现的方法，起“模板”作用； 示例： [Abstract.java]1234567891011121314151617181920//抽象类abstract class Father &#123; public abstract void study(); //规定了子类必须实现的方法&#125;//子类class Son extends Father &#123; public void study() &#123; //实现抽象类定义的方法 System.out.println(\"Son study\"); &#125;&#125;public class Abstract &#123; public static void main(String args[]) &#123; //Father father = new Father(); //抽象类不能实例化对象 Son son = new Son(); son.study(); &#125;&#125; 结果： 1Son study 对该示例进行分析： 1 通过abstract关键字定义了一个抽象类Father，里面有一个abstract修饰的方法，但没有具体的实现内容； 2 子类Son从父类Father继承，实现了父类的方法； 3 main里不能对抽象类进行实例化，只能对抽象类的子类进行实例化，访问其方法 2.3.4 接口接口作用:跟抽象类相似，起“模板”作用；子类可以继承多个接口，突破“单继承”的限制； 示例： [Interface.java]12345678910111213141516171819202122232425262728293031//接口interface A &#123; public static final int i = 10; //接口只能定义常量 public abstract void printNum();&#125;interface B &#123; public static final String name = \"hceng\"; public abstract void printString();&#125;//子类class Son implements A,B &#123; public void printNum() &#123; //实现接口定义的方法 System.out.println(\"Num = \" + i); &#125; public void printString() &#123; System.out.println(\"String = \" + name); &#125;&#125;public class Interface &#123; public static void main(String args[]) &#123; Son son = new Son(); son.printNum(); son.printString(); &#125;&#125; 结果： 12Num = 10String = hceng 对该示例进行分析： 1.1 通过interface关键字定义两个接口A和B，里面定义了常量和抽象方法；1.2 接口里面只能定义常量，抽象类可以定义常量和变量； 2.1 子类Son同时从接口A和B继承，突破了抽象类突破“单继承”的限制；2.2 子类Son依旧得实现接口里面所有的抽象方法； 3 main实例化Son，访问实现的方法； 2.4 多态性多态性体现在方法和对象上。 在前面的例子中，方法的多态性已经接触过了，体现在方法的重载与覆写。 方法的重载(overload):定义多个同名方法，其参数类型、个数不同； 方法的覆写(override):子类里实现跟父类同样的方法，覆盖掉父类； 对象的多态性就是父对象和子对象之前的转换，转换分为向上转换和向下转换。 向上转型:子对象向父对象转型的过程，例如猫类转换为动物类(小范围转大范围自动)，子对象独有的成员将不可访问(只能识别父对象中的内容)； 向下转型:父对象强制转换为子对象的过程，例如动物类强制转换为猫类(大范围转小范围强制)，； 另外，可以通过引用变量 instanceof 类名的方式来判断引用变量所指向的对象是否属于某个类； 示例： [Limit.java]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Father &#123; public void printfInfo() &#123; System.out.println(\"This is Father\"); &#125; public void work() &#123; System.out.println(\"Father is working……\"); &#125; &#125;class Son extends Father &#123; public void printfInfo() &#123; System.out.println(\"This is Son\"); &#125; public void palyGame() &#123; System.out.println(\"Son is playing games……\"); &#125; &#125;class Daughter extends Father &#123; public void printfInfo() &#123; System.out.println(\"This is Daughter\"); &#125; public void dance() &#123; System.out.println(\"Daughter is dancing……\"); &#125; &#125;public class Cnv &#123; public static void main(String args[]) &#123; Father father1 = new Father(); Son son = new Son(); father1 = son; //向上转换 father1.printfInfo(); //father1.palyGame(); //只能调用被子类覆写的方法，不能调用只在子类中定义的方法 Father father2 = new Daughter(); //创建子类的实例化对象(先向上转换) Daughter daughter = (Daughter)father2; //向下转换 (Daughter daughter = new Daughter();) daughter.printfInfo(); System.out.println(\"--------------------\"); Father f = new Father(); Son s = new Son(); Daughter d = new Daughter(); //向上转换 示例 printf(f); printf(s); printf(d); //向下转换 示例 printAction(f); printAction(s); printAction(d); &#125; public static void printf(Father f) &#123; f.printfInfo(); &#125; public static void printAction(Father f) &#123; if (f instanceof Son) &#123; Son s = (Son)f; s.palyGame(); &#125; else if (f instanceof Daughter) &#123; Daughter d = (Daughter)f; d.dance(); &#125; else if (f instanceof Father) &#123; //Father要在最后,每个对象都属于Father f.work(); &#125; &#125;&#125; 结果： 123456789This is SonThis is Daughter--------------------This is FatherThis is SonThis is DaughterFather is working……Son is playing games……Daughter is dancing…… 对该示例进行分析： 1.1 首先定义了三个类，其中Son和Daughter继承于Father；1.2 每个类里面都有一个同名的printfInfo方法和各自的独有的方法； 2.1 main方法里，首先创建了father1和son这两个对象，然后将子类赋值给父类，进行向上转换，父类只能调用被子类覆写的方法printfInfo，最后结果也是调用的子类覆写的方法；2.2 首先创建子类的实例化对象father2(即先向上转换，不然后面无法向下转换)，此时father2的类型是Father，再用Daughter强制向下转换，得到daughter，此时可以调用子类的所有方法； 3.1 先分别实例化了三个类对应的对象；3.2 调用方法printf，传入不同类的对象，自动向上转换，调用各自同名的方法；3.3 调用方法printAction，传入不同类的对象，自动向上转换，再判断是对象是否属于对应类，再进行向下强制转换，从而调用其私有的方法(因为s和d都属于f，所以对f的判断要放在最后)； 2.5 异常程序运行时，发生的不被期望的事件，它阻止了程序按照程序员的预期正常执行，这就是异常。异常发生时，是任程序自生自灭，立刻退出终止，还是输出错误给用户？或者用C语言风格：用函数返回值作为执行状态？。Java提供了更加优秀的解决办法：异常处理机制。异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。 Java标准库内建了一些通用的异常，这些类以Throwable为顶层父类，Throwable又派生出Error类和Exception类。 Error(错误)：Error类以及他的子类的实例，代表了JVM本身的错误，不能被程序员通过代码处理，所以不用管； Exception(异常)：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件，可以被Java异常处理机制使用； 针对Javac对异常的处理要求，将异常类分为2类: checked exception(可查异常):IOException以及它子类的异常，这些异常必须处理，否则编译不会通过； unckecked exception(不可查异常):RuntimeException以及它的子类，不要求必须处理，发生异常时程序退出； 针对要处理的异常，可以自己处理，也可也通过throws抛出异常，让别人处理： 示例： [Div.java]1234567891011121314151617181920212223242526272829303132333435363738394041/* 除法运算: java Div 6 2 -&gt; 6/2=3*/public class Div &#123; public static void main(String args[]) &#123; int m, n, r; m=n=r=0; //初始化 try &#123; m = Integer.parseInt(args[0]); n = Integer.parseInt(args[1]); r = div(m, n); craetException(); &#125; catch (NumberFormatException exception1) &#123; //自己处理:数字格式异常(java Div 6 a) System.out.println(\"====An exception occurs1:\"+exception1+\"=====\"); &#125; catch (ArithmeticException exception2) &#123; //处理扔过来的异常:除零错误异常(java Div 6 0) System.out.println(\"====An exception occurs2:\"+exception2+\"=====\"); &#125; catch (RuntimeException runtimeexception) &#123; //处理所有不可查异常,比如位数不够(java Div 6) System.out.println(\"====An exception occurs:\"+runtimeexception+\"=====\"); &#125; catch (Exception exception) &#123; //处理自己通过throw创建的可查异常 System.out.println(\"====An exception occurs:\"+exception+\"=====\"); &#125; finally &#123; //无论是否发生异常,finally代码块中的代码总会被执行,完成清理类型等收尾善后性质的功能 System.out.println(\"finally\"); //finally中不要包含return &#125; System.out.println(m+\"/\"+n+\"=\"+r); &#125; //扔给调用者处理:除零错误异常(java Div 6 0) //public static int div(int m, int n) throws ArithmeticException &#123; public static int div(int m, int n) &#123; //ArithmeticException是不可查异常,出现后会自动抛出,可以不要throws int r; r = m / n; return r; &#125; //自己创建的可查异常NullPointerException,必须处理,这里将其抛出,因此必须要throws public static void craetException() throws Exception &#123; throw new Exception(\"My Craeted Exception\"); &#125;&#125; 结果： 12345678910111213141516hceng@android:/work/java_learn/09th_exception$ java Div 6 3====An exception occurs:java.lang.Exception: My Craeted Exception=====finally6/3=2hceng@android:/work/java_learn/09th_exception$ java Div 6 a====An exception occurs1:java.lang.NumberFormatException: For input string: &quot;a&quot;=====finally6/0=0hceng@android:/work/java_learn/09th_exception$ java Div 6 0====An exception occurs2:java.lang.ArithmeticException: / by zero=====finally6/0=0hceng@android:/work/java_learn/09th_exception$ java Div 6 ====An exception occurs:java.lang.ArrayIndexOutOfBoundsException: 1=====finally6/0=0 对该示例进行分析： 1 该示例实现了一个整数除法运算，同时对输入参数的合法性进行了异常处理； 2.1 main方法里，首先定义了三个变量并初始化；2.2 try { }代码块包含了可能出现异常的代码；2.3 通过Integer.parseInt方法将字符args[0]和args[1]转换成了整型，这里可能出现NumberFormatException和ArrayIndexOutOfBoundsException异常，比如传入a就无法转换成对应数字，传入的参数少一个也会转换出错；2.4 方法div的定义在后面，可能出现ArithmeticException异常，即初始不能为零；2.5 方法craetException的定义在后面，在里面自己产生了一个可查异常，必须处理的异常；2.6 接下来的catch (异常类 异常变量名) { }代码块，捕获到对应异常，即进行代码块代码；2.7 无论是否发生异常，finally { }代码块的内容总会被执行，一般在里面做一些清理类型的善后收尾工作，注意不要在里面写return代码，因为如果前面的try或catch块中有return或throw语句，会先执行finally块，此时finally中有return就直接返回了，无法再返回来执行try或catch块中return或throw语句里面的内容；2.8 接下来是打印出结果； 3.1 定义了Div方法，因为可能发生ArithmeticException异常，该异常是不可查异常，出现后可以自动抛出，所以在方法名定义那可以不加throws ArithmeticException；3.2 定义了craetException方法，该方法是通过new建立，throw抛出，从前面的图中可以知道Exception类异常包含IOException可查异常和RuntimeException不可查异常，因为是可查异常的关系，要么自己处理，要么手动抛出，这里抛出的话，方法名定义得加上throws Exception，否则编译都无法通过；3.3 这里的两个方法，都是抛出异常，也可以自己通过try {} catch {}处理掉；在选择抛出时，前者因为是不可查异常，在方法名定义时可以不加throws 异常类型，后者反之得加上； 4 运行代码时，分别列举了正常运行、传入参数为字母错误、传入参数除数为零、传入参数少一个的情况，异常都被捕获到，程序没有当时直接退出，而是执行了异常处理代码块的内容，继续执行； 2.6 包及访问权限为了更好地组织类，Java提供了包机制，解决类的同名冲突问题；如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 假设有如下情况，hceng和jack两个程序员，实现了同一个Math.java类，实现了同名方法add，但内容不同，源码组织情况如下：1234567├── hceng│ ├── Math.java│ └── Permission.java├── jack│ ├── Math.java│ └── TestAccess.java└── Pack.java 使用如下命令编译：1javac -d . hceng/*.java jack/*.java *.java 编译后文件组织如下：12345678910111213141516├── hceng│ ├── Math.java│ └── Permission.java├── jack│ ├── Math.java│ └── TestAccess.java├── pack│ ├── hceng│ │ ├── Math.class│ │ ├── packagePermission.class│ │ └── Permission.class│ └── jack│ ├── Math.class│ └── TestAccess.class├── Pack.class└── Pack.java 执行java Pack效果如下：1234567add1:3add2:4add2:-1Can only be accessed by this class: a = 1Access in the same package: b = 2Access in different packages: c = 3Accessible anywhere: d = 4 源码见文末的Github链接，在10th_package里面。 先从文件组织的角度进行分析： 1.1 hceng路径下有个Math.java，里面有个Math方法和sub方法，通过package关键字指定了打包的路径为pack/hceng；1.2 jack路径下有个Math.java，里面有个Math方法，通过package关键字指定了打包的路径为pack/jack； 2.1 编译时加入了-d参数，表示指定生成的包文件路径；2.2 根据编译参数和类文件package的定义，就在当前路径在生成了pack/hceng和pack/jack存放了对应的class； 3.1 当前路径下有个Pack.java，通过import关键字将前面两个包导入了该类里面；3.2 main里面，通过指定包的路径调用对应的方法，比如pack.jack.Math.add和pack.hceng.Math.add，解决调用同名类的冲突； 再从访问权限的角度进行分析： 1.1 hceng路径下有个Permission.java，里面有个公共的Permission类和非公共的packagePermission类，外部只能访问公共的Permission类；1.2 从类的权限角度可知:public类可以被外包访问，非public类只能在本包访问，另外，一个文件只能有一个public类； 2.1 hceng路径下有个Permission.java，在类Permission里定义了四种权限的属性(属性加static是因为可以不通过new创建，直接访问)；2.2 针对private的属性，只能在本类里访问，因此在本类的方法可以直接调用(方法加static是因为可以不通过new创建，直接访问)；2.3 针对default的属性，只能在同包里访问，因此在同包的另一个方法里实现了访问；2.4 针对protected的属性，只能在不同包子类里访问，因此在jack/路径下创建了TestAccess.java，它属于pack.jack包，里面通过继承类访问了该属性；2.5 针对public的属性，在任何地方都可以访问，因此在Pack里直接进行了访问；2.6 从属性权限角度可知:类成员的访问权限如下： 权限 类内 同包 不同包子类 不同包非子类 private √ × × × default √ √ × × protected √ √ √ × public √ √ √ √ 最后再补充一下jar，对于前面生成的pack目录，我们可以将其压缩打包，相关命令如下：123jar -cvf pack.jar ./pack //打包jar -tvf pack.jar //查看包内容jar -xvf pack.jar //解包 操作逻辑和tar压缩一样的，很好记。 此时在当前目录生成pack.jar，删除pack文件夹，执行export CLASSPATH=.:pack.jar指定运行查找包的路径，执行java Pack仍可正常运行。 2.7 内部类内部类，在类的内部定义一个类，通过内部这个类，可以访问到该类的私有属性。内部类又分一般内部类、静态内部类、匿名内部类。 示例： [Inner.java]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class OutClass &#123; //一般内部类 private int a = 1; class InnerClass1 &#123; public void printInfo() &#123; System.out.println(\"a = \" + a); &#125; &#125; //静态内部类 private static int b = 2; static class InnerClass2 &#123; public void printInfo() &#123; System.out.println(\"b = \" + b); &#125; &#125;&#125;interface PrintInterface &#123; public void printInfo();&#125;class MyInterface implements PrintInterface &#123; public void printInfo() &#123; System.out.println(\"MyInterface\"); &#125;&#125;public class Inner &#123; public static void main(String args[]) &#123; OutClass o = new OutClass(); //依次定义外部类 OutClass.InnerClass1 i1 = o.new InnerClass1(); //内部类 i1.printInfo(); OutClass.InnerClass2 i2 = new OutClass.InnerClass2(); //直接定义内部类 i2.printInfo(); //正常调用继承于接口的类 MyInterface m = new MyInterface(); m.printInfo(); //匿名内部类(没有名字的内部类,必须继承一个父类或实现一个接口) PrintInterface p = new PrintInterface() &#123; public void printInfo() &#123; System.out.println(\"PrintInterface\"); &#125; &#125;; p.printInfo(); &#125;&#125; 结果： 1234a = 1b = 2hello MyInterfacehello PrintInterface 对该示例进行分析： 1.1 定义了一个OutClass类，里面包含两个私有变量和两个内部类，再通过内部类的方法访问私有变量；1.2 两者区别是后者使用static修饰变量和类，使得可以不通过new直接访问类方法； 2.1 定义了一个接口PrintInterface，接口里定义了一个printInfo方法；2.2 定义了类MyInterface继承于接口PrintInterface，并实现了printInfo方法； 3.1 在main里，先实例化外部类，再实例化内部类，才能方法问一般内部类的方法；3.2 针对静态内部类，可以直接定义内部类，再访问其方法； 4.1 针对继承于接口/父类的子类，一般先实例化，再访问其方法；4.2 也可以在使用时，再定义方法内容，再访问其方法，这就是匿名内部类，一个没有名字的内部类； 3. JNIJNI(Java Native Interface)就是JAVA本地接口，它允许Java代码和Native代码进行交互，这里的Native代码指C、C++语言等编程语言。无论是Android还是Linux，其底层都是用C语言编写的，因此很多程序和库都也是用C、C++来写的，重复利用这些Native语言编写的库是十分有必要的，而且一般Native语言编写的库具有更好的性能。这样就产生了一个问题，Java世界的代码要怎么使用Native世界的代码呢，这就需要一个桥梁来将它们连接在一起，而JNI就是这个桥梁。 3.1 JAVA调用C3.1.1 Java访问C库的方法Java访问C库的的步骤有三步：1.Java中加载C库(System.loadLibrary)；2.建立Java函数名与C库函数名的映射关系；3.在Java程序里调用C库的函数； 其中，建立Java函数名与C库函数名映射关系的方法有两种：隐式建立和显式建立； 示例：[Jni.java]1234567891011121314public class Jni &#123; /* 1.加载 */ static &#123; //静态代码块(只会被调用一次) System.loadLibrary(\"native\"); //C语言会编译生成libnative.so,这里加载它 &#125; /* 2.声明 */ public native static void hello_implicit(); //声明(static静态方法,可直接调用) public native static void hello_explicit(); /* 3.调用 */ public static void main(String args[]) &#123; hello_implicit(); hello_explicit(); &#125;&#125; [native.c]1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include \"Jni.h\"//隐式建立:函数名必须固定格式,参考生成的Jni.hvoid Java_Jni_hello_1implicit(JNIEnv *env, jobject cls)&#123; printf(\"hello java, I am from C language(implicit)\\n\");&#125;//显式建立,函数名自定义void c_hello(JNIEnv *env, jobject cls)&#123; printf(\"hello java, I am from C language(explicit)\\n\");&#125;static const JNINativeMethod methods[] = &#123; &#123;\"hello_explicit\", \"()V\", (void *)c_hello&#125;, //Java里调用的函数名;JNI字段描述符(参数、返回值);C语言实现的本地函数&#125;;//一旦Java调用System.loadLibrary,就会先调用JNI_OnLoadJNIEXPORT jint JNICALLJNI_OnLoad(JavaVM *jvm, void *reserved)&#123; JNIEnv *env; jclass cls; //根据版本获得env,为后面提供函数 if ((*jvm)-&gt;GetEnv(jvm, (void **)&amp;env, JNI_VERSION_1_4)) return JNI_ERR; //查获取调用本程序的类 cls = (*env)-&gt;FindClass(env, \"Jni\"); if (cls == NULL) return JNI_ERR; //使用RegisterNatives将C和Java建立联系 if ((*env)-&gt;RegisterNatives(env, cls, methods, sizeof(methods)/sizeof(methods[0])) &lt; 0) return JNI_ERR; return JNI_VERSION_1_4;&#125; 编译及设置：12345678javac Jni.javajavah -jni Jnigcc -I /usr/lib/jvm/java-1.8.0-openjdk-amd64/include/ -I /usr/lib/jvm/java-1.8.0-openjdk-amd64/include/linux -fPIC -shared -o libnative.so native.cexport LD_LIBRARY_PATH=.java Jni 结果：12hello java, I am from C language(implicit)hello java, I am from C language(explicit) 对该示例进行分析： 1.1 在Java里，先在静态代码块里加载对应的库；1.2 然后声明要使用的方法，使用static修饰的方法不用实例化；1.3 main里调用方法； 2.1 在C语言里，先包含一个头文件，这个头文件通过javac Jni.java、javah -jni Jni生成，里面有根据Java声明的方法自动生成的C语言函数定义；2.2 隐式建立:只需函数名和生成的Jni.h一致就行，Java执行方法时就自动调用函数；2.3 显式建立:函数名自定义，但需要创建JNI_OnLoad方法将Java和C建立联系； 3.1.2 Java和C库传递数据Java调用C语言，一般都要进行数据的传递，包括Java传入数据，C语言返回数据，这里对基本数据类、字符串、数据进行传递示例。 示例：[Jni.java]1234567891011121314151617181920212223242526272829public class Jni &#123; static &#123; System.loadLibrary(\"native\"); &#125; //基本类型数据 public native static float typeData1(int a); //字符串 public native static String typeData2(String str); //数组 public native static int[] typeData3(int[] a); public static void main(String args[]) &#123; int [] a = &#123;1, 2, 3, 4&#125;; int [] b = null; int i; System.out.println(typeData1(4)); System.out.println(typeData2(\"hceng\")); b = typeData3(a); for (i = 0; i &lt; b.length; i++) System.out.print(b[i]+\" \"); System.out.println(); &#125;&#125; [native.c]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;stdio.h&gt;#include \"Jni.h\"#include &lt;stdlib.h&gt;#if 0//隐式建立jfloat Java_Jni_typeData1(JNIEnv *env, jclass cls, jint a)&#123; printf(\"C: get val: %d, will return (float)%d \\n\", a, a); return (float)a;&#125;jstring Java_Jni_typeData2(JNIEnv *env, jclass cls, jstring str)&#123; const jbyte *cstr; cstr = (*env)-&gt;GetStringUTFChars(env, str, NULL); if (cstr == NULL) return NULL; printf(\"C: get str: %s, will return jack \\n\", cstr); (*env)-&gt;ReleaseStringUTFChars(env, str, cstr); return (*env)-&gt;NewStringUTF(env, \"jack\");&#125;jintArray JNICALL Java_Jni_typeData3(JNIEnv *env, jclass cls, jintArray arr)&#123; jint *carr; jint *oarr; jintArray rarr; jint i, n = 0; carr = (*env)-&gt;GetIntArrayElements(env, arr, NULL); if (carr == NULL) return 0; n = (*env)-&gt;GetArrayLength(env, arr); printf(\"C: get number: \"); for (i = 0; i &lt; n; i++) printf(\"%d \", carr[i]); printf(\", will return opposite number\\n\"); oarr = malloc(sizeof(jint) * n); if (oarr == NULL) &#123; (*env)-&gt;ReleaseIntArrayElements(env, arr, carr, 0); return 0; &#125; for (i = 0; i &lt; n; i++) oarr[i] = carr[n-1-i]; (*env)-&gt;ReleaseIntArrayElements(env, arr, carr, 0); /* create jintArray */ rarr = (*env)-&gt;NewIntArray(env, n); if (rarr == NULL) return 0; (*env)-&gt;SetIntArrayRegion(env, rarr, 0, n, oarr); free(oarr); return rarr;&#125;#else //显式建立jfloat JNICALL c_typeData1(JNIEnv *env, jclass cls, jint a)&#123; printf(\"C: get val = %d, will return (float)%d \\n\", a, a); return (float)a;&#125;jstring JNICALL c_typeData2(JNIEnv *env, jclass cls, jstring str)&#123; const jbyte *cstr; cstr = (*env)-&gt;GetStringUTFChars(env, str, NULL); if (cstr == NULL) return NULL; printf(\"C: get str = %s, will return jack \\n\", cstr); (*env)-&gt;ReleaseStringUTFChars(env, str, cstr); return (*env)-&gt;NewStringUTF(env, \"jack\");&#125;jintArray JNICALL c_typeData3(JNIEnv *env, jclass cls, jintArray arr)&#123; jint *carr; jint *oarr; jintArray rarr; jint i, n = 0; carr = (*env)-&gt;GetIntArrayElements(env, arr, NULL); if (carr == NULL) return 0; n = (*env)-&gt;GetArrayLength(env, arr); printf(\"C: get number: \"); for (i = 0; i &lt; n; i++) printf(\"%d \", carr[i]); printf(\", will return opposite number\\n\"); oarr = malloc(sizeof(jint) * n); if (oarr == NULL) &#123; (*env)-&gt;ReleaseIntArrayElements(env, arr, carr, 0); return 0; &#125; for (i = 0; i &lt; n; i++) oarr[i] = carr[n-1-i]; (*env)-&gt;ReleaseIntArrayElements(env, arr, carr, 0); /* create jintArray */ rarr = (*env)-&gt;NewIntArray(env, n); if (rarr == NULL) return 0; (*env)-&gt;SetIntArrayRegion(env, rarr, 0, n, oarr); free(oarr); return rarr;&#125;static const JNINativeMethod methods[] = &#123; &#123;\"typeData1\", \"(I)F\", (void *)c_typeData1&#125;, &#123;\"typeData2\", \"(Ljava/lang/String;)Ljava/lang/String;\", (void *)c_typeData2&#125;, &#123;\"typeData3\", \"([I)[I\", (void *)c_typeData3&#125;, &#125;;JNIEXPORT jint JNICALLJNI_OnLoad(JavaVM *jvm, void *reserved)&#123; JNIEnv *env; jclass cls; if ((*jvm)-&gt;GetEnv(jvm, (void **)&amp;env, JNI_VERSION_1_4)) return JNI_ERR; cls = (*env)-&gt;FindClass(env, \"Jni\"); if (cls == NULL) return JNI_ERR; if ((*env)-&gt;RegisterNatives(env, cls, methods, sizeof(methods)/sizeof(methods[0])) &lt; 0) return JNI_ERR; return JNI_VERSION_1_4;&#125;#endif 结果：123456C: get val: 4, will return (float)4 4.0C: get str: hceng, will return jack jackC: get number: 1 2 3 4 , will return opposite number4 3 2 1 对该示例进行分析： 1.1 在Java中，依次声明了以基本数据类型、字符串、数组为参数和返回值的方法；1.2 然后调用方法，传入参数，打印返回结果； 2.1 C语言里，分别隐式建立和显式建立编写了函数，两者主要区别在函数名和关系的建立上；2.2 以显式建立为例，函数c_typeData1接收Java传入的基本数据类型，直接处理，返回相应数据；2.3 函数c_typeData2接收Java传入的字符串，不能直接处理，使用GetStringUTFChars()获取字符串指针，用完后使用ReleaseStringUTFChars()释放，使用NewStringUTF()返回字符串；2.4 函数c_typeData3接收Java传入的数据，不能直接处理，使用GetIntArrayElements()获取数据，GetArrayLength()获得数组长度，用完后使用ReleaseIntArrayElements()释放，使用NewIntArray()创建JNI数组，通过SetIntArrayRegion()将数组保存到JNI数组；2.5 修改methods[]，使Java的方法和C语言的函数对应，以及输入输出参数(参考生成的Jni.h)； 3.2 C调用JAVAC语言调用Java相对简单一点，流程大致如下： 1.创建一个Java虚拟机2.找到要调用的类；3.获取/设置属性(非必须): 3.1获取属性ID； 3.2获取/设置属性；4.对于静态方法不需要示例化对象： 4.1获取方法ID； 4.2准备传入参数(非必需)； 4.3调用方法；5.对于非静态方法需要实例化对象： 5.1获取构造方法()ID； 5.2创建对象； 5.3获取方法ID； 5.4准备传入参数(非必需)； 5.5调用方法；6.销毁创建的Java虚拟机： 示例：[Hello.java]12345678910111213public class Hello &#123; private static String name; private static int age; public static void main(String args[]) &#123; //静态方法 System.out.println(\"java: name: \"+ name + \", age: \" + age); &#125; public int typeData(String str) &#123; //非静态方法 System.out.println(\"java: get str: \"+ str + \" ,will return 100\"); return 100; &#125;&#125; [caller.c]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;stdio.h&gt; #include &lt;jni.h&gt; /* create java virtual machine*/jint create_vm(JavaVM** jvm, JNIEnv** env) &#123; JavaVMInitArgs args; JavaVMOption options[1]; args.version = JNI_VERSION_1_6; args.nOptions = 1; options[0].optionString = \"-Djava.class.path=./\"; args.options = options; args.ignoreUnrecognized = JNI_FALSE; return JNI_CreateJavaVM(jvm, (void **)env, &amp;args); &#125; int main(int argc, char **argv)&#123; int r; int ret = 0; JavaVM* jvm; JNIEnv* env; jclass cls; jfieldID nameID, ageID; jmethodID mid, cid; jobject jobj; jstring jstr; /* 1. create java virtual machine */ if (create_vm(&amp;jvm, &amp;env)) &#123; printf(\"can not create jvm\\n\"); return -1; &#125; /* 2. get class */ cls = (*env)-&gt;FindClass(env, \"Hello\"); if (cls == NULL) &#123; printf(\"can not find hello class\\n\"); ret = -1; goto destroy; &#125; /*----------------Non-generic part------------------*/ /* 3.get/set field */ // 3.1 get field id (GetFieldID, GetStaticFieldID) // 3.2 get/set field (Get&lt;Type&gt;Field,GetStatic&lt;Type&gt;Field / Set&lt;Type&gt;Field,SetStatic&lt;Type&gt;Field) //java: private static String name; nameID = (*env)-&gt;GetStaticFieldID(env, cls, \"name\", \"Ljava/lang/String;\"); //3.1 if (nameID == NULL) &#123; ret = -1; printf(\"can not get field name\\n\"); //3.2 goto destroy; &#125; jstr = (*env)-&gt;NewStringUTF(env, \"hceng\"); (*env)-&gt;SetStaticObjectField(env, jobj, nameID, jstr); //java: private static int age; ageID = (*env)-&gt;GetStaticFieldID(env, cls, \"age\", \"I\"); //3.1 if (ageID == NULL) &#123; ret = -1; printf(\"can not get field age\\n\"); goto destroy; &#125; (*env)-&gt;SetStaticIntField(env, jobj, ageID, 23); //3.2 /*Branch1:------for static method, No need create object-------*/ /* 4. call method */ // 4.1 get method id (GetMethodID, GetStaticMethodID) // 4.2 Preparation parameter // 4.3 call method (CallVoidMethod, CallStaticVoidMethod) mid = (*env)-&gt;GetStaticMethodID(env, cls, \"main\",\"([Ljava/lang/String;)V\"); //4.1 if (mid == NULL) &#123; ret = -1; printf(\"can not get method\\n\"); goto destroy; &#125; (*env)-&gt;CallStaticVoidMethod(env, cls, mid, NULL); //4.3 /*Branch2:------for no static method, Need create object-------*/ /* 4. create object */ // 4.1 get constructor method id (GetMethodID) // 4.2 create new object (NewObject) cid = (*env)-&gt;GetMethodID(env, cls, \"&lt;init&gt;\", \"()V\"); //4.1 if (cid == NULL) &#123; ret = -1; printf(\"can not get constructor method\\n\"); goto destroy; &#125; jobj = (*env)-&gt;NewObject(env, cls, cid); //4.2 if (jobj == NULL) &#123; ret = -1; printf(\"can not create object\\n\"); goto destroy; &#125; /* 5. call method */ // 5.1 get method id (GetMethodID, GetStaticMethodID) // 5.2 Preparation parameter // 5.2 call method (CallVoidMethod, CallStaticVoidMethod) mid = (*env)-&gt;GetMethodID(env, cls, \"typeData\",\"(Ljava/lang/String;)I\"); //5.1 if (mid == NULL) &#123; ret = -1; printf(\"can not get method\\n\"); goto destroy; &#125; jstr = (*env)-&gt;NewStringUTF(env, \"www.hceng.cn\"); //5.2 r = (*env)-&gt;CallIntMethod(env, jobj, mid, jstr); //5.3 printf(\"%d\\n\", r); destroy: (*jvm)-&gt;DestroyJavaVM(jvm); return ret;&#125; 编译、设置环境变量： 12345678javac Hello.javajavap -p -s Hello.class // get Signaturegcc -I /usr/lib/jvm/java-1.8.0-openjdk-amd64/include/ -I /usr/lib/jvm/java-1.8.0-openjdk-amd64/include/linux -o caller caller.c -L /usr/lib/jvm/java-8-openjdk-amd64/jre/lib/amd64/server/ -ljvmLD_LIBRARY_PATH=/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/amd64/server/ ./caller 结果： 123java: name: hceng, age: 23java: get str: www.hceng.cn ,will return 100100 对该示例进行分析： 1.1 Java文件里有个Hello类，里面有两个静态变量、一个静态方法、一个非静态方法；1.2 非静态方法typeData 需要传入一个参数和会返回一个整型； 2.1 将创建Java虚拟机封装成函数create_vm()，以后有需要直接调用；2.2 调用FindClass()找到Java中要调用的类； 3.1 假如要修改属性，需要先得到属性的ID，针对静态和非静态属性，分别调用GetStaticFieldID()、GetFieldID()；3.2 通过NewStringUTF()得到可以在Java中使用的字符串；3.3 通过SetStaticObjectField()或SetObjectField()设置Java中的字符串；3.4 通过SetStaticIntField或SetIntField()设置Java中的整型； 4.1 如果要调用静态方法，就需要实例化对象；4.2 通过GetStaticMethodID()获得静态方法的ID；4.3 通过CallStaticVoidMethod()调用静态无返回值方法，最后一个参数是需要传入的参数； 5.1 如果要调用非静态方法，就需要先实例化对象；5.2 通过GetMethodID()获得构造方法的ID，对于构造方法，参数名字始终为&lt;init&gt;；5.3 通过NewObject()实例化对象；5.4 通过GetMethodID()获得非静态方法ID；5.5 通过CallIntMethod()调用非静态方法，返回值就是Java方法的返回值； 6.销毁创建的Java虚拟机； 可以发现，要操作/调用Java中的属性或方法，都需要通过函数得到其ID，获取的函数又分为静态和非静态，然后再设置/调用等；另外，获取ID的函数需要传入Signature(JNI字段描述符)，可通过javap -p -s Hello.class命令，可以打印出对应类的Signature； 4. Java的高级应用4.1 泛型泛型(Generics)是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。通俗的讲，泛型就是操作类型的占位符，即：假设占位符为T，那么此次声明的数据结构操作的数据类型为T类型。比如下面的例子，在实例化对象时，可以指定不同数据类型，既可以是整型，也可以是字符串类型，从而打印的结果就完全不同。 示例： [Generics.java]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147//普通类class Person1 &#123; private int age; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return this.age; &#125;&#125;//泛型class Person2&lt;T&gt; &#123; private T age; public void setAge(T age) &#123; this.age = age; &#125; public T getAge() &#123; return this.age; &#125;&#125;//泛型接口interface Person3&lt;T&gt; &#123; public void setAge(T age); public T getAge();&#125;//一般继承class Student1&lt;T&gt; extends Person2&lt;T&gt; &#123;&#125;class Student2 extends Person2&lt;String&gt; &#123; &#125;//接口继承class Student3&lt;T&gt; implements Person3&lt;T&gt; &#123; T age; public void setAge(T age) &#123; this.age = age; &#125; public T getAge() &#123; return this.age; &#125; &#125;class Student4 implements Person3&lt;String&gt; &#123; String age; public void setAge(String age) &#123; this.age = age; &#125; public String getAge() &#123; return this.age; &#125; &#125;public class Generics &#123; public static void main(String args[]) &#123; //常规方法,传入参数数据类型固定 Person1 p1 = new Person1(); p1.setAge(23); System.out.println(p1.getAge()); System.out.println(\"--------------------------\"); //泛型,传入参数数据类型可以不固定 Person2&lt;Integer&gt; p2 = new Person2&lt;Integer&gt;(); p2.setAge(24); printInfo(p2); genericsMethod(p2); Person2&lt;String&gt; p3 = new Person2&lt;String&gt;(); p3.setAge(\"24 years old\"); printInfo(p3); genericsMethod(p3); System.out.println(\"--------------------------\"); //定义数据类型通用的对象 Person2&lt;?&gt; p4; p4 = p2; printInfo(p4); //无法 p4.setAge(); p4 = p3; printInfo(p4); System.out.println(\"--------------------------\"); //子类继承:子类也泛型 Student1&lt;Integer&gt; s1 = new Student1&lt;Integer&gt;(); s1.setAge(10); printInfo(s1); genericsMethod(s1); //子类继承:子类不泛型 Student2 s2 = new Student2(); s2.setAge(\"10 years old\"); printInfo(s2); genericsMethod(s2); System.out.println(\"--------------------------\"); //接口子类继承:子类也泛型 Student3&lt;Integer&gt; s3 = new Student3&lt;Integer&gt;(); s3.setAge(10); System.out.println(\"interface:\" + s3.getAge()); //子类继承:子类不泛型 Student4 s4 = new Student4(); s4.setAge(\"10 years old\"); System.out.println(\"interface:\" + s4.getAge()); System.out.println(\"--------------------------\"); //受限泛型 printInfo1(s1); //参数限制了只能是Number类或其子类 //printInfo1(s2); //printInfo2(s1); printInfo2(s2); //参数限制了只能是String类或其父类 &#125; //方法参数通用 public static void printInfo(Person2&lt;?&gt; p) &#123; System.out.println(\"printInfo:\" + p.getAge()); &#125; //方法的参数泛型 public static &lt;T&gt; void genericsMethod(Person2&lt;T&gt; p) &#123; System.out.println(\"genericsMethod:\" + p.getAge()); &#125; //受限泛型 //上限:参数只能是Number类或其子类 public static void printInfo1(Person2&lt;? extends Number&gt; p) &#123; System.out.println(\"extends:\" + p.getAge()); &#125; //下限:参数只能是String类或其父类 public static void printInfo2(Person2&lt;? super String&gt; p) &#123; System.out.println(\"extends:\" + p.getAge()); &#125;&#125; 结果： 123456789101112131415161718192023--------------------------printInfo:24genericsMethod:24printInfo:24 years oldgenericsMethod:24 years old--------------------------printInfo:24printInfo:24 years old--------------------------printInfo:10genericsMethod:10printInfo:10 years oldgenericsMethod:10 years old--------------------------interface:10interface:10 years old--------------------------extends:10extends:10 years old 对该示例进行分析： 1.1 首先是一个普通类Person1，包含一个私有int类型数据，两个方法；1.2 然后是一个泛型类Person2，包含的元素同上，把int换成了T；1.3 之后是一个泛型接口Person3，也是使用T代替数据类型，里面有两个方法模板；1.4 接下来是两个类Student1和Student2继承于Person2，前者数据类型是T，后者是String；1.5 最后是两个类Student3和Student4继承于接口Person3，前者数据类型是T，后者是String；1.6 从这几个例子中，可以看到泛型可以用在类、接口和方法的创建中，称之为泛型类、泛型接口、泛型方法； 2.1 main里，首先是普通的类的实例化，传入int类型数据，再打印；2.2 接着是泛型的实例化，实例化时可以指定类里面的数据类型，这里的例子前者是int类型数据，后者是String类型数据；2.3 接下来实例化对象p4，使用通配符?来代替数据类型，可以被其它数据类型赋值，但只能读取，不能设置；2.4 然后是子类继承的实例化，前者定义类的时候类型是T，仍有泛型的特性，实例化的时候指定为int类型，后者定义类的时候类型是String，为普通的类型，只能为字符串；2.5 接口的继承也是，前面定义的时候，可以选择子类继续保持类泛型，或者变成普通类；2.6 受限泛型，方法printInfo1参数里有? extends Number，表示上限，参数限制了只能是Number类或其子类；方法printInfo2参数里有? super String，表示下限，参数限制了只能是String类或其父类；2.7 从这几个例子中，可以看到子类从父类继承，或者从接口继承，仍可以保持泛型的特性，也可以设置为普通类；此外还有受限泛型，限制泛型支持的数据类型范围； 4.2 反射JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 反射就是把java类中的各种成分映射成一个个的Java对象，例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。 示例：[Reflect.java]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package hceng;import java.lang.reflect.Method;import java.lang.reflect.Field;import java.lang.reflect.Constructor;class Person &#123; private String name; void setName(String name) &#123; this.name = name; &#125; String getName() &#123; return this.name; &#125;&#125;;public class Reflect &#123; public static void main(String args[]) throws Exception &#123; //获得class的方法一 Class&lt;?&gt; c1 = Class.forName(\"hceng.Person\"); //must be caught or declared to be thrown //获得class的方法二 Person p = new Person(); Class&lt;?&gt; c2 = p.getClass(); //获得class的方法三 Class&lt;?&gt; c3 = Person.class; System.out.println(c1.getName()); System.out.println(c2.getName()); System.out.println(c3.getName()); System.out.println(\"--------------------------\"); int arr1[] = &#123;1, 2, 3&#125;; int arr2[][] = &#123; &#123;1, 2, 3&#125;, &#123;1,2&#125; &#125;; Class&lt;?&gt; a1 = arr1.getClass(); Class&lt;?&gt; a2 = arr2.getClass(); Class&lt;?&gt; a3 = int.class; System.out.println(a1.getName()); System.out.println(a2.getName()); System.out.println(a3.getName()); System.out.println(\"--------------------------\"); //类的实例化 Class&lt;?&gt; j = Class.forName(\"jack.Person\"); Object p1 = j.newInstance(); //无参构造方法 Constructor&lt;?&gt; con = j.getConstructor(String.class); //有参构造方法 Object p2 = con.newInstance(\"hceng\"); System.out.println(\"--------------------------\"); //通过反射调用方法 Method set = j.getMethod(\"setName\", String.class); set.invoke(p1, \"jack1\"); set.invoke(p2, \"jack2\"); Method get = j.getMethod(\"getName\"); System.out.println(get.invoke(p1)); System.out.println(get.invoke(p2)); System.out.println(\"--------------------------\"); //通过修改属性 Field name = j.getDeclaredField(\"name\"); //公共、私有的都可以访问 name.setAccessible(true); //因为name是私有的,需要先修改访问权限 name.set(p1, \"hello, hceng\"); name.set(p2, \"hello, jack\"); System.out.println(name.get(p1)); System.out.println(name.get(p2)); System.out.println(\"--------------------------\"); //通过传入参数,灵活调用不同的包 Class&lt;?&gt; h = Class.forName(args[0]); Constructor&lt;?&gt; c = h.getConstructor(String.class); Object o = c.newInstance(\"hceng\"); &#125;&#125; [Person.java]1234567891011121314151617181920212223package jack;public class Person &#123; private String name; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; //构造方法 public Person() &#123; System.out.println(\"Constructor1 of Person\"); &#125; public Person(String name) &#123; this.name = name; System.out.println(\"Constructor2 of Person, name is \"+this.name); &#125;&#125;; [Student.java]1234567891011121314151617181920212223package jack;public class Student &#123; public String name; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; //构造方法 public Student() &#123; System.out.println(\"Constructor1 of Student\"); &#125; public Student(String name) &#123; this.name = name; System.out.println(\"Constructor2 of Student, name is \"+this.name); &#125;&#125;; 编译：1javac -d . *.java 结果：1234567891011121314151617181920212223242526272829303132333435363738hceng@android:/work/java_learn/14th_reflect$ java hceng.Reflect jack.Personhceng.Personhceng.Personhceng.Person--------------------------[I[[Iint--------------------------Constructor1 of PersonConstructor2 of Person, name is hceng--------------------------jack1jack2--------------------------hello, hcenghello, jack--------------------------Constructor2 of Person, name is hcenghceng@android:/work/java_learn/14th_reflect$ java hceng.Reflect jack.Studenthceng.Personhceng.Personhceng.Person--------------------------[I[[Iint--------------------------Constructor1 of PersonConstructor2 of Person, name is hceng--------------------------jack1jack2--------------------------hello, hcenghello, jack--------------------------Constructor2 of Student, name is hceng 对该示例进行分析： 1.1 整个示例有三个文件Reflect.java、Person.java、Student.java，其中Reflect.java在包hceng里，其余两个在包jack里；1.2 在Person.java里，定义了一个类Person，包含一个私有变量、两个公共方法、两个构造方法(一个含参，一个不含)；1.3 在Student.java里，定义了一个类Student，包含一个私有变量、两个公共方法、两个构造方法(一个含参，一个不含)； 2.1 在main里，示例了三种获取类的方法：通过包名字、通过实例化的对象、直接通过类名字，注意每种方法都会产生异常，这里为了简洁，直接将异常抛出；2.2 得到了类，可以通过getName方法得到类完整名字； 3.1 定义一个一维数组，一个二维数组，一个整型数据类，得到其类名；3.2 可以看到每种数据类型的类名都不一样； 4.1 通过包名，得到包jack.Person里类；4.2 对于无参的构造方法，直接调用newInstance进行实例化；4.3 有参的构造方法，先getConstructor得到构造函数，再调用newInstance传入参数实例化； 5.1 先通过getMethod，传入参数为方法名和数据类型，得到类里面的方法；5.2 再通过invoke调用该方法，传入参数为实例化的对象和调用方法的参数； 6.1 通过getDeclaredField得到类属性；6.2 如果属性是私有属性，需要使用setAccessible修改访问权限；6.3 通过set修改属性内容，通过get获取属性内容； 7.1 之前通过import导入需要的包，从而调用不同的类，在程序中固定了，现在可以将包名作为参数传入，实现灵活的调用；， 在Java运行中，可以通过三种方式得到运行期间的类：通过包名、通过实例化的对象、通过类名字；通过这个类再实例化对象，修改属性或者调用方法等操作； 5. 其它所有示例源码:Github 参考资料:韦东山第四期Android驱动_Java快速入门 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Android基础","slug":"Android基础","permalink":"http://yoursite.com/tags/Android基础/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"RK3399——裸机大全","date":"2018-08-16T09:40:06.000Z","path":"2018/08/16/RK3399——裸机大全/","text":"以64位的RK3399为例，实现裸机的启动、中断、串口(printf移植)、定时器、ADC、PWM、I2C、SPI、LCD(MIPI)等；这应该是最后一次写裸机代码了，老是写裸机，都要写吐了。这次选的是64位平台(ARMv8架构)的Firefly-RK3399，注定坑多，也更有挑战性一点。 1.ARMv8基础1.1 基本概念 1.架构和内核型号 架构(Architecture):就是常说的ARMv5(32bits)、ARMv6(32bits)、ARMv7(32bits)、ARMv8(32/64bits)； 内核型号:就是常说的ARM7、ARM9、Cortex-A系列(Aplication)、Cortex-R系列(Runtime)、Cortex-M系列(MCU)； 举例:单片机STM32F103C8T6采用Cortex-M3内核，采用ARMv7-M架构； 瑞芯微RK3288采用4个Cortex-A17，采用ARMv7-A架构； 瑞芯微RK3399采用2个Cortex-A72和4个Cortex-A53组成，Cortex-A72和Cortex-A53都是ARMv8-A架构。 高通骁龙845处理器由4个Cortex-A75和4个Cortex-A55组成，Cortex-A75和Cortex-A55都是ARMv8-A架构。 发展迭代： 2.AArch64/AArch32/A64/A32/T32 名字 类型 说明 AArch64 架构 指基于64bits运作的ARMv8架构（通用寄存器X0-X30） AArch32 架构 指基于32bits运作的ARMv8架构，并且兼容之前的ARMv7架构（通用寄存器R0-R15） A64 指令集 指在AArch64模式下支持的ARM 64bits指令集 A32 指令集 指ARMv7架构下支持的ARM 32bits指令集，在ARMv8中也有新加入的A32指令集 T32 指令集 指ARMv7架构下支持的Thumb2 16/32bits指定集，在ARMv8中也有新加入的T32指令集。 1.2 AArch64/32寄存器 AArch64 Special Role in the procedure call standard x0…x7 Parameter/result registers(参数传入/返回结果） x8 Indirect result location register x9…x15 Temporary registers(临时寄存器) x16 IP0 The first intra-procedure-call scratch register (can be used by call veneers and PLT code); at other times may be used as a temporary register. x17 IP1 The second intra-procedure-call temporary register (can be used by call veneers and PLT code); at other times may be used as a temporary register. x18 The Platform Register, if needed; otherwise a temporary register. x19…x28 Callee-saved registers(由被调用者保存的寄存器) x29 FP The Frame Pointer(栈帧指针) x30 LR The Link Register(链接寄存器) SP The Stack Pointer(栈指针) AArch32 Special Role in the procedure call standard r0…r3 Parameter/result registers r4…r11 Temporary registers (r9 also as platform register) r12 IP The Intra-Procedure-call scratch register. r13 SP The second intra-procedure-call temporary register (can be used by call veneers and PLT code); at other times may be used as a temporary register. r14 LR The Platform Register, if needed; otherwise a temporary register. r15 PC Callee-saved registers 两者区别： Execution StateNoteAArch641. 提供31个64bits的通用寄存器(x0~x30，其中x30可作为LR)2. 提供64bits程序计数器(PC)、栈指针(SP)、异常链接寄存器(ELR)3. 提供32个128bits 的SIMD Vector与Scalar Floating-Point寄存器4. 定义ARMv8 EL0~EL3共4个执行权限(Execution Privilege)5. 支持64bits Virtual-Addressing6. 定义一组PSTATE用以保存PE(Processing Element)状态AArch321. 提供16个32bits的通用寄存器(r0~r12，其中r13=SP、r14=LR、r15=PC，且r14需要同时供ELR与LR之用）2. 提供一个ELR，用以作为从Hyp-Mode的Exception返回之用3. 提供32个64bits的Advanced SIMD Vector与Scalar Floating-Point寄存器4. 提供A32与T32两种指令集的组合5. 使用32bits Virtual-Addressing6. 只使用CPSR(当前程序状态寄存器)保存PE(Processing Element)状态。 1.3 ARMv8 Exception Level针对Security的需求，ARMv8的系统软件设计可以提供安全模式与非安全模式的状态。ARMv8规定了CPU有4种运行级别。每种运行级别下标的数字越大，其权力级别越高。其中EL0为非特权等级，即平时应用程序运行时的级别；EL1为特权等级，即操作系统运行时的级别；EL2为虚拟机监视器运行级别，即虚拟机的控制层运行的级别；EL3为切换EL1和EL2级别时需要进入的一个级别，为CPU的最高级别。 若底层EL(Exception Level)为32bits，则上层EL的软件就只能是32位。 若底层的EL为64bits，则上层EL就可以依据需求选择为32bits或是64bits。 2.RK3399启动先看一下RK3399的启动流程图[1]： 从图中可以得到以下几个结论： 1.RK3399上电后，会从0xffff0000获取romcode并运行； 2.然后依次从Nor Flash、Nand Flash、eMMC、SD/MMC获取ID BLOCK，ID BLOCK正确则启动，都不正确则从USB端口下载； 3.如果emmc启动，则先读取SDRAM(DDR)初始化代码到内部SRAM，然后初始化DDR，再将emmc上的代码(剩下的用户代码)复制到DDR运行； 4.如果从USB下载，则先获取DDR初始化代码，下载到内部SRAM中，然后运行代码初始化DDR，再获取loader代码(用户代码)，放到DDR中并运行； 5.无论是何种方式，都需要DDR的初始化代码，结合前面RK3288的经验，就是向自己写的代码加上”头部信息”，这个”头部信息”就包含DDR初始化操作； 2.1 官方启动分析如何分析一款芯片的启动方式？前面的一篇博客iMX6ULL上手体验，里面已经分析过了，大致就是先用厂家提供的资料，配置相关环境、编译、烧写，运行起来。然后就有了U-boot源码，从U-boot就可以几乎提取出所有的裸机代码，本文也是这样做的。 分析U-Boot的编译流程，可以看到如下内容：123456789101112131415./tools/boot_merger ./tools/rk_tools/RKBOOT/RK3399MINIALL.iniout:rk3399_loader_v1.09.109.binfix opt:rk3399_loader_v1.09.109.binmerge success(rk3399_loader_v1.09.109.bin)./tools/trust_merger ./tools/rk_tools/RKTRUST/RK3399TRUST.iniout:trust.imgmerge success(trust.img)./tools/loaderimage --pack --uboot u-boot.bin uboot.imgpack input u-boot.bin pack file size: 315128 crc = 0xb4d13cd6uboot version: U-Boot 2014.10-RK3399-06 (Aug 16 2018 - 04:00:27)pack uboot.img success! /work/firefly-rk3399Firefly-RK3399 make images finish! 可以看出这里使用了三个工具，产生了三个文件：①:使用boot_merger，参数为RK3399MINIALL.ini，得到loader文件rk3399_loader_v1.09.109.bin，打开RK3399MINIALL.ini内容为：1234567891011121314151617181920[CHIP_NAME]NAME=RK330C[VERSION]MAJOR=1MINOR=09[CODE471_OPTION]NUM=1Path1=tools/rk_tools/bin/rk33/rk3399_ddr_800MHz_v1.09.binSleep=1[CODE472_OPTION]NUM=1Path1=tools/rk_tools/bin/rk33/rk3399_usbplug_v1.09.bin[LOADER_OPTION]NUM=2LOADER1=FlashDataLOADER2=FlashBootFlashData=tools/rk_tools/bin/rk33/rk3399_ddr_800MHz_v1.09.binFlashBoot=tools/rk_tools/bin/rk33/rk3399_miniloader_v1.09.bin[OUTPUT]PATH=rk3399_loader_v1.09.109.bin 得知依赖的文件有:DDR相关的rk3399_ddr_800MHz_v1.09.bin、USB相关的rk3399_usbplug_v1.09.bin、miniloader(瑞芯微修改的一个bootloader)相关的rk3399_miniloader_v1.09.bin。boot_merger将这三个bin文件最后合并成rk3399_loader_v1.09.109.bin。 ②:使用trust_merger，参数为RK3399TRUST.ini，生成trust.img； ③:使用loaderimage将u-boot.bin变成uboot.img； 最后使用Android Tools，烧写rk3399_loader_v1.09.109.bin、trust.img和uboot.img即可启动U-Boot。 对以上过程进行分析，再加上实验测试和结合RK3288的经验，得出裸机启动文件的制作结论如下：使用boot_merger将rk3399_ddr_800MHz_v1.09.bin、rk3399_usbplug_v1.09.bin和自己的裸机文件rk3399.bin合并出新文件即可。 2.2 制作裸机启动文件经过分析和测试，现实现了emmc和TF卡启动裸机程序，并把整个过程整理了一个工程模板。工程模板见GitHub，里面包含两个文件夹和两个文件。 code文件夹存放裸机源码；tools存放制作“头部”的工具和配置文件；rk3399_hardware_tool.sh是一个shell脚本，用于自动生成加“头部”后的裸机文件；README.txt是操作说明； 以后只需要先进入code文件夹修改裸机源码，然后执行make生成rk399.bin，再退出到工程目录下，执行脚本rk3399_hardware_tool.sh即可生成rk3288_emmc.bin和rk3288_sd.bin； rk3288_emmc.bin用于emmc启动：Windows下使用AndroidTool.exe，开发板进入MaskRom模式，烧入Loader位置; rk3288_sd.bin用于SD卡启动：Linux下，插上SD卡，执行sudo dd if=rk3399_sd.bin of=/dev/sdb seek=$(((0x000040)))(其中/dev/sdb为SD卡) 3.Uboot启动部分分析为了方便后面从U-boot提取所需裸机代码，有必要先对U-boot进行分析，本节只分析启动部分的，后续具体某个模块，如LCD，将在后面对应的章节分析。另外，本次分析是的RK3399，64位的ARMv8架构，与市面上较多的32位ARMv7架构SOC略有区别，注意不要混淆。RK3399编译过的U-boot已上传GitHub。U-boot执行的第一个文件是start.S，下面开始对其进行分析。 3.1 start.S所在文件路径：u-boot/arch/arm/cpu/armv8/start.S 1.检查loader tag [unimportant] 1234567891011121314151617181920212223.globl _start_start: nop b reset //hceng:首先跳到reset ……reset:#ifdef CONFIG_ROCKCHIP /* * check loader tag */ ldr x0, =__loader_tag ldr w1, [x0] ldr x0, =LoaderTagCheck ldr w2, [x0] cmp w1, w2 b.eq checkok //hceng:LoaderTag正常则跳到checkok ，反之退出U-Boot进入maskrom or miniloader ret /* return to maskrom or miniloader */checkok:#endif 这里检查loader tag对后面写裸机没什么用。 2.设置中断向量等 [important] 123456789101112131415161718192021 adr x0, vectors //hceng:将中断向量地址保存到x0 switch_el x1, 3f, 2f, 1f //hceng:根据CurrentEL的bit[3:2]位得知当前的EL级别，跳转到不同的分支进行处理，这里实测跳到3f，即上电为EL33: msr vbar_el3, x0 //hceng:将中断向量保存到vbar_el3(Vector Base Address Register (EL3)) mrs x0, scr_el3 //hceng:获取scr_el3(Secure Configuration Register)的值 orr x0, x0, #0xf //hceng:将低四位设置为1:EA|FIQ|IRQ|NS msr scr_el3, x0 //hceng:写入scr_el3 msr cptr_el3, xzr //hceng:清除cptr_el3(Architectural Feature Trap Register (EL3))，Enable FP/SIMD ldr x0, =COUNTER_FREQUENCY //hceng:晶振频率：24000000hz msr cntfrq_el0, x0 //hceng:将晶振频率写入cntfrq_el0(Counter-timer Frequency register) #ifdef CONFIG_ROCKCHIP msr cntvoff_el2, xzr /* clear cntvoff_el2 for kernel */#endif b 0f //hceng:跳到本段结尾的0f，后面的未执行2: msr vbar_el2, x0 mov x0, #0x33ff //hceng:FP为Float Processor(浮点运算器)；SIMD为Single Instruction Multiple Data(采用一个控制器来控制多个处理器) msr cptr_el2, x0 /* Enable FP/SIMD */ b 0f1: msr vbar_el1, x0 mov x0, #3 &lt;&lt; 20 msr cpacr_el1, x0 /* Enable FP/SIMD */0: 注：1.switch_el这一宏定义伪指令在u-boot/arch/arm/include/asm/macro.h定义；2.vbar_el3等寄存器定义在文档ARMv8-A_Architecture_Reference_Manual_(Issue_A.a).pdf[2]中；3.XZR/WZR(word zero rigiser)分别代表64/32位，zero register的作用就是0，写进去代表丢弃结果，拿出来是0； 中断向量的定义在文件u-boot/arch/arm/cpu/armv8/exceptions.S中，内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* * Exception vectors. */ .align 11 //hceng:注意这里的对齐11，是因为vbar_el3的低11为是Reserved，需要为0 //因此需要从2^11=2k的倍数位置起存放vectors .globl vectorsvectors: .align 7 //hceng:每个中断向量的偏移为32字节 b _do_bad_sync /* Current EL Synchronous Thread */ .align 7 b _do_bad_irq /* Current EL IRQ Thread */ .align 7 b _do_bad_fiq /* Current EL FIQ Thread */ .align 7 b _do_bad_error /* Current EL Error Thread */ .align 7 b _do_sync /* Current EL Synchronous Handler */ .align 7 b _do_irq /* Current EL IRQ Handler */ .align 7 b _do_fiq /* Current EL FIQ Handler */ .align 7 b _do_error /* Current EL Error Handler */_do_bad_sync: //hceng:对应的异常处理函数 exception_entry bl do_bad_sync_do_bad_irq: exception_entry bl do_bad_irq_do_bad_fiq: exception_entry bl do_bad_fiq_do_bad_error: exception_entry bl do_bad_error_do_sync: exception_entry bl do_sync_do_irq: exception_entry //hceng:保护现场，把ELR/X0~X30保存到堆栈 bl do_irq exception_exit //hceng:恢复现场，从堆栈恢复ELR/X0~X30_do_fiq: exception_entry bl do_fiq_do_error: exception_entry bl do_error这一部分功能就是根据当前的EL级别，配置中断向量、MMU、Endian、i/d Cache等，比较重要。 3.配置ARM核心特定勘误表 [unimportant] 12/* Apply ARM core specific erratas */bl apply_core_errata 看样子是对ARM做一些勘误，实测没有用到，不重要。 4.lowlevel_init [important] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 /* Processor specific initialization */ bl lowlevel_init ……WEAK(lowlevel_init) mov x29, lr /* Save LR */#if defined(CONFIG_ROCKCHIP) /* switch to el1 secure */#if defined(CONFIG_SWITCH_EL3_TO_EL1) //hceng:实测没有定义，不需要从EL3切换到EL1，从前面可以看出，现在已经是EL1 /* * Switch to EL1 from EL3 */ mrs x0, CurrentEL /* check currentEL */ cmp x0, 0xc b.ne el1_start /* currentEL != EL3 */ ldr x0, =0xd00 /* ST, bit[11] | RW, bit[10] | HCE, bit[8] */ msr scr_el3, x0 ldr x0, =0x3c5 /* D, bit[9] | A, bit[8] | I, bit[7] | F, bit[6] | 0b0101 EL1h */ msr spsr_el3, x0 ldr x0, =el1_start msr elr_el3, x0 eretel1_start: nop#endif /* CONFIG_SWITCH_EL3_TO_EL1 */#endif /* CONFIG_ROCKCHIP */#if defined(CONFIG_GICV2) || defined(CONFIG_GICV3) //hceng:实测定义的是CONFIG_GICV3 branch_if_slave x0, 1f //hceng:通过mpidr_el1寄存器，判断当前处理器是否是从属CPU，如果是选择所有affinity为0的作为主CPU ldr x0, =GICD_BASE //hceng:把GICD基地址作为参数传给gic_init_secure bl gic_init_secure //hceng:初始化主CPU的中断寄存器1:#if defined(CONFIG_GICV3) ldr x0, =GICR_BASE //hceng:把GICR基地址作为参数传给gic_init_secure_percpu bl gic_init_secure_percpu //hceng:初始化其它各个CPU的中断寄存器#elif defined(CONFIG_GICV2) //hceng:未执行 ldr x0, =GICD_BASE ldr x1, =GICC_BASE bl gic_init_secure_percpu#endif#if defined(CONFIG_ROCKCHIP) /* * Setting HCR_EL2.TGE AMO IMO FMO for exception rounting to EL2 */ mrs x0, CurrentEL /* check currentEL */ cmp x0, 0x8 //hceng:根据CurrentEL的bir[3:2]判断当前运行级别，0xC(EL3)、0x8(EL2)、0x4(EL1)、0x0(EL0)，实测并没处于EL2，后面的内容不执行 b.ne endseting /* currentEL != EL2 */ mrs x9, hcr_el2 //hceng:hcr_el2(Hypervisor Configuration Register) orr x9, x9, #(7 &lt;&lt; 3) /* HCR_EL2.AMO IMO FMO set */ orr x9, x9, #(1 &lt;&lt; 27) /* HCR_EL2.TGE set */ msr hcr_el2, x9endseting: nop#endif /* CONFIG_ROCKCHIP */ branch_if_master x0, x1, 2f //hceng:通过mpidr_el1寄存器，判断当前处理器是否是主CPU，如果是选择所有affinity为0的作为主CPU；实测跳到2f /* * Slave should wait for master clearing spin table. * This sync prevent salves observing incorrect * value of spin table and jumping to wrong place. */#if defined(CONFIG_GICV2) || defined(CONFIG_GICV3)#ifdef CONFIG_GICV2 ldr x0, =GICC_BASE#endif bl gic_wait_for_interrupt#endif /* * All slaves will enter EL2 and optionally EL1. */ bl armv8_switch_to_el2 #ifdef CONFIG_ARMV8_SWITCH_TO_EL1 bl armv8_switch_to_el1#endif#endif /* CONFIG_ARMV8_MULTIENTRY */2: //hceng：前面的都没执行，跳到这，返回 mov lr, x29 /* Restore LR */ retENDPROC(lowlevel_init) 注：1.branch_if_slave和branch_if_master在u-boot/arch/arm/include/asm/macro.h定义；2.gic_init_secure和gic_init_secure_percpu这两个中断初始化的关键函数在u-boot/arch/arm/lib/gic_64.S定义；3.armv8_switch_to_el2和armv8_switch_to_el1在u-boot/arch/arm/cpu/armv8/exceptions.S定义； lowlevel_init的主要功能就是中断的初始化，后面写中断服务程序的使用会用到。 5.是否需要在U-Boot开启多核CPU [unimportant] 1234567891011121314 branch_if_master x0, x1, master_cpu /* * Slave CPUs */slave_cpu: wfe ldr x1, =CPU_RELEASE_ADDR ldr x0, [x1] cbz x0, slave_cpu br x0 /* branch to the given address */master_cpu: /* On the master CPU */#endif /* CONFIG_ARMV8_MULTIENTRY */ 实测没有定义，不用管。 6.跳转到_main [important]到此start.S的工作就基本完成了，接下来就交给ARM公共的_main。 3.2 crt0_64.S所在文件路径：u-boot/arch/arm/cpu/armv8/start.S_main在crt0_64.S里，crt0是C-runtime Startup Code的简称，意思就是运行C代码之前的准备工作，包括设置栈、重定位、清理BSS段等； 1.设置栈 [important]1234567/* * Set up initial C runtime environment and call board_init_f(0). */ ldr x0, =(CONFIG_SYS_INIT_SP_ADDR) //hceng:设置栈顶为0x80000000=2G sub x0, x0, #GD_SIZE /* allocate one GD above SP */ bic sp, x0, #0xf /* 16-byte alignment for ABI compliance */ mov x18, sp /* GD is above SP */ 这里栈需要16字节对齐，即要求地址为16的倍数，只需要二进制位最后四位为0(2的4次方)，与前面中断向量地址需要2K对齐，实现原理类似。另外U-Boot在SP上面分配了一块GD(global data)，后面写裸机用不到。 2.board_init_f [important] 12mov x0, #0 //hceng:将0作为参数传入board_init_fbl board_init_f board_init_f所在文件路径：u-boot/common/board_f.c。board_init_f中调用initcall_run_list(init_sequence_f)，init_sequence_f是个数组，里面是将要进行初始化的函数列表，完成一些前期的初始化工作，比如board相关的early的初始化board_early_init_f、环境变量初始化env_init、串口初始化的serial_init、I2C初始化init_func_i2c、设备树相关准备工作fdtdec_prepare_fdt、打印CPU信息print_cpuinfo、SDRAM初始化dram_init、计算重定位信息setup_reloc等； 3.重定位 [important] 12345678910111213141516171819/* * Set up intermediate environment (new sp and gd) and call * relocate_code(addr_moni). Trick here is that we&apos;ll return * &apos;here&apos; but relocated. */ ldr x0, [x18, #GD_START_ADDR_SP] /* x0 &lt;- gd-&gt;start_addr_sp */ bic sp, x0, #0xf /* 16-byte alignment for ABI compliance */ ldr x18, [x18, #GD_BD] /* x18 &lt;- gd-&gt;bd */ sub x18, x18, #GD_SIZE /* new GD is below bd */#ifndef CONFIG_SKIP_RELOCATE_UBOOT adr lr, relocation_return ldr x9, [x18, #GD_RELOC_OFF] /* x9 &lt;- gd-&gt;reloc_off */ add lr, lr, x9 /* new return address after relocation */ ldr x0, [x18, #GD_RELOCADDR] /* x0 &lt;- gd-&gt;relocaddr */ b relocate_code#endifrelocation_return: 先是更新了gd结构体，然后根据宏CONFIG_SKIP_RELOCATE_UBOOT决定是否要重定位。这里是不需要重定位的，因为链接脚本u-boot.lds里面的链接地址是0x00000000，而RK3399上电后，加头的boot code会自动将代码复制到DDR(0x00000000)，两者地址相同，不需要重定位。重定位的代码在u-boot/arch/arm/lib/relocate_64.S里面。 4.重新设置异常向量表 [important] 1234/* * Set up final (full) environment */ bl c_runtime_cpu_setup /* still call old routine */ 如果发生了重定位，需要重新设置异常向量表。c_runtime_cpu_setup定义在start.S里面。 12345678910111213ENTRY(c_runtime_cpu_setup) /* Relocate vBAR */ adr x0, vectors switch_el x1, 3f, 2f, 1f3: msr vbar_el3, x0 b 0f2: msr vbar_el2, x0 b 0f1: msr vbar_el1, x00: retENDPROC(c_runtime_cpu_setup) 5.清理BSS段 [important]接下来就是清除BSS段，将未定义的全局变量设置为0。在以前使用Keil单片机编程时，未初始化的全局变量默认为0，那是因为集成开发环境为我们做了清理BSS段的操作，现在没有了集成开发环境，就需要我们自己做。1234567891011/* * Clear BSS section */ ldr x0, =__bss_start /* this is auto-relocated! */ ldr x1, =__bss_end /* this is auto-relocated! */ mov x2, #0clear_loop: str x2, [x0] add x0, x0, #8 cmp x0, x1 b.lo clear_loop 6.board_init_r [important]接下来就是板子的后半部分的初始化：123456/* call board_init_r(gd_t *id, ulong dest_addr) */mov x0, x18 /* gd_t */ldr x1, [x18, #GD_RELOCADDR] /* dest_addr */b board_init_r /* PC relative jump *//* NOTREACHED - board_init_r() does not return */ board_init_r所在文件路径：u-boot/common/board_f.c。与前面的board_init_f类似，board_init_r中调用initcall_run_list(init_sequence_r)，init_sequence_r是个数组，里面是将要进行初始化的函数列表，又是一系列的初始化操作。之前遇到的LCD初始化就是在这里。初始化数组列表最后一个成员是run_main_loop，将最终跳到主循环main_loop。 crt0_64.S主要就是为C语言运行设置栈和进行了重定位，以及两个阶段的初始化:board_init_f(front)和board_init_r(rear)，最后进入主循环。 3.3 总结U-Boot启动流程示意图： 4.中断4.1 分析在U-Boot中找到如下几个文件： u-boot/arch/arm/cpu/armv8/rk33xx/irqs.c:包含中断的基本操作，如：初始化、注册、使能等； u-boot/arch/arm/cpu/armv8/rk33xx/irqs-gic.c:包含非GPIO类型中断的使能、去能； u-boot/arch/arm/cpu/armv8/rk33xx/irqs-gpio.c:包含GPIO类型中断的使能、去能、触发类型； u-boot/board/rockchip/rk33xx/demo.c:包含一些测试代码，如：定时器中断测试、GPIO中断测试； irqs.c里的函数:首先是irq_init()里面包含gic中断初始化和gpio中断初始化，函数里注释gic has been init in Start.S和之前的猜测一样，在start.S里面已经gic初始化了；然后是irq_install_handler()里面实现了中断的注册，即把对应中断号放在g_irq_handler[]数组里；再是irq_handler_enable()，将对应的中断处理函数使能，具体实现的函数在irqs-gic.c和irqs-gpio.c里面。此外还有使能总中断enable_interrupts()；最后就是do_irq()中断处理函数。 irqs-gic.c里的函数:包含gic_handler_enable()和gic_handler_disable()，在前面irq_handler_enable()调用； irqs-gpio.c里的函数:包含gic_handler_enable()、gpio_irq_enable和gpio_irq_set_type()，在前面irq_handler_enable()调用； demo.c里的函数:包含定时器中断测试board_gic_test()和GPIO中断测试board_gpio_irq_test()； 因此，除了start.S里的初始化，还需移植irq_install_handler()、irq_handler_enable、do_irq()三个函数，此外还有定时器中断测试和GPIO测试函数。 4.2 启动和中断代码因为start.S里面包含了中断初始化代码，即gic_init_secure和gic_init_secure_percpu，移植的时候直接复制过来的，因此也把start.S贴出来。start.S是对U-boot的start.S进行了裁剪和修改，思路和前面U-Boot的流程差不多，几个重定位、绝对跳转、代码对齐的坑，都踩完了，下面的start.S有时间的话可以好好看下。[start.S]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333 #include &quot;macro.h&quot;.text.global _start_start: /* Could be EL3/EL2/EL1, Initial State: Little Endian, MMU Disabled, i/dCache Disabled */ ldr x0, =vectors //Exception vectors(Absolute address) msr vbar_el3, x0 //RVBAR_EL3, Reset Vector Base Address Register (if EL3 implemented) mrs x0, scr_el3 orr x0, x0, #0xf //SCR_EL3.NS|IRQ|FIQ|EA msr scr_el3, x0 msr cptr_el3, xzr //Enable FP/SIMD ldr x0, =24000000 //24MHz msr cntfrq_el0, x0 //Initialize CNTFRQ bl lowlevel_init //Processor specific initialization ldr x0, =0x80000000 //sp=2G bic sp, x0, #0xf //16-byte alignment for ABI compliance bl relocate relocate_complete: bl clean_bssclean_bss_complete: //bl main ldr lr, =main //Absolute address ret halt: b halt /*******************************************************/ led_debug: mov x0, #0xff720000 mov x1, #0xff720000 ldr w1, [x1,#4] orr w1, w1, #0x2000 str w1, [x0,#4] mov x0, #0xff720000 mov x1, #0xff720000 ldr w1, [x1] orr w1, w1, #0x2000 str w1, [x0] b halt /*******************************************************/ lowlevel_init: mov x29, lr //Save LR ldr x0, =0xFEE00000 //RKIO_GICD_PHYS GIC DIST bl gic_init_secure ldr x0, =0xFEF00000 //RKIO_GICR_PHYS bl gic_init_secure_percpu mov lr, x29 //Restore LR ret /*******************************************************/ //ref: u-boot/arch/arm/lib/gic_64.S /*Initialize Distributor x0: Distributor Base*/gic_init_secure: mov w9, #0x37 //EnableGrp0 | EnableGrp1NS //EnableGrp1S | ARE_S | ARE_NS str w9, [x0, 0x0000] //Secure GICD_CTLR ldr w9, [x0, 0x0004] and w10, w9, #0x1f //ITLinesNumber cbz w10, 1f //No SPIs add x11, x0, (0x0080 + 4) add x12, x0, (0x0d00 + 4) mov w9, #~00: str w9, [x11], #0x4 str wzr, [x12], #0x4 //Config SPIs as Group1NS sub w10, w10, #0x1 cbnz w10, 0b1: ret /*Initialize ReDistributor x0: ReDistributor Base*/gic_init_secure_percpu: mrs x10, mpidr_el1 lsr x9, x10, #32 bfi x10, x9, #24, #8 //w10 is aff3:aff2:aff1:aff0 mov x9, x01: ldr x11, [x9, 0x0008] lsr x11, x11, #32 //w11 is aff3:aff2:aff1:aff0 cmp w10, w11 b.eq 2f add x9, x9, #(2 &lt;&lt; 16) b 1b /* x9: ReDistributor Base Address of Current CPU */2: mov w10, #~0x2 ldr w11, [x9, 0x0014] and w11, w11, w10 //Clear ProcessorSleep str w11, [x9, 0x0014] dsb st isb3: ldr w10, [x9, 0x0014] tbnz w10, #2, 3b //Wait Children be Alive add x10, x9, #(1 &lt;&lt; 16) //SGI_Base mov w11, #~0 str w11, [x10, 0x0080] str wzr, [x10, 0x0d00] //SGIs|PPIs Group1NS mov w11, #0x1 //Enable SGI 0 str w11, [x10, 0x0100] /* Initialize Cpu Interface */ /* rockchip: first check elx for running on different el */ switch_el x0, el3_sre, el2_sre, el1_sreel3_sre: mrs x10, S3_6_C12_C12_5 orr x10, x10, #0xf //SRE &amp; Disable IRQ/FIQ Bypass &amp; //Allow EL2 access to ICC_SRE_EL2 msr S3_6_C12_C12_5, x10 isbel2_sre: mrs x10, S3_4_C12_C9_5 orr x10, x10, #0xf //SRE &amp; Disable IRQ/FIQ Bypass &amp; //Allow EL1 access to ICC_SRE_EL1 msr S3_4_C12_C9_5, x10 isbel1_sre: mrs x0, CurrentEL //check currentEL cmp x0, 0xC b.ne el1_ctlr //currentEL != EL3 el3_ctlr: mov x10, #0x3 //EnableGrp1NS | EnableGrp1S msr S3_6_C12_C12_7, x10 isb msr S3_6_C12_C12_4, xzr isbel1_ctlr: mov x10, #0x3 //EnableGrp1NS | EnableGrp1S msr S3_0_C12_C12_7, x10 isb msr S3_0_C12_C12_4, xzr //NonSecure ICC_CTLR_EL1 isb mov x10, #0xf0 //Non-Secure access to ICC_PMR_EL1 msr S3_0_C4_C6_0, x10 isb ret /*******************************************************///ref:D:u-boot/arch/arm/cpu/armv8/exceptions.S/* Enter Exception. * This will save the processor state that is ELR/X0~X30 to the stack frame.*/ .macro exception_entry stp x29, x30, [sp, #-16]! stp x27, x28, [sp, #-16]! stp x25, x26, [sp, #-16]! stp x23, x24, [sp, #-16]! stp x21, x22, [sp, #-16]! stp x19, x20, [sp, #-16]! stp x17, x18, [sp, #-16]! stp x15, x16, [sp, #-16]! stp x13, x14, [sp, #-16]! stp x11, x12, [sp, #-16]! stp x9, x10, [sp, #-16]! stp x7, x8, [sp, #-16]! stp x5, x6, [sp, #-16]! stp x3, x4, [sp, #-16]! stp x1, x2, [sp, #-16]! /* Could be running at EL3/EL2/EL1 */ switch_el x11, 3f, 2f, 1f3: mrs x1, esr_el3 mrs x2, elr_el3 b 0f2: mrs x1, esr_el2 mrs x2, elr_el2 b 0f1: mrs x1, esr_el1 mrs x2, elr_el10: stp x2, x0, [sp, #-16]! mov x0, sp.endm/* * Exit Exception. * This will restore the processor state that is ELR/X0~X30 * from the stack frame. */.macro exception_exit ldp x2, x0, [sp],#16 /* Could be running at EL3/EL2/EL1 */ switch_el x11, 3f, 2f, 1f3: msr elr_el3, x2 b 0f2: msr elr_el2, x2 b 0f1: msr elr_el1, x20: ldp x1, x2, [sp],#16 ldp x3, x4, [sp],#16 ldp x5, x6, [sp],#16 ldp x7, x8, [sp],#16 ldp x9, x10, [sp],#16 ldp x11, x12, [sp],#16 ldp x13, x14, [sp],#16 ldp x15, x16, [sp],#16 ldp x17, x18, [sp],#16 ldp x19, x20, [sp],#16 ldp x21, x22, [sp],#16 ldp x23, x24, [sp],#16 ldp x25, x26, [sp],#16 ldp x27, x28, [sp],#16 ldp x29, x30, [sp],#16 eret.endm/* Exception vectors.*/ .align 11vectors: .align 7 b _do_bad_sync //Current EL Synchronous Thread .align 7 b _do_bad_irq //Current EL IRQ Thread .align 7 b _do_bad_fiq //Current EL FIQ Thread .align 7 b _do_bad_error //Current EL Error Thread .align 7 b _do_sync //Current EL Synchronous Handler .align 7 b _do_irq //Current EL IRQ Handler .align 7 b _do_fiq //Current EL FIQ Handler .align 7 b _do_error //Current EL Error Handler _do_bad_sync: exception_entry bl halt //do_bad_sync_do_bad_irq: exception_entry bl halt //do_bad_irq_do_bad_fiq: exception_entry bl halt //do_bad_fiq_do_bad_error: exception_entry bl halt //do_bad_error_do_sync: exception_entry bl halt //do_sync_do_irq: exception_entry bl do_irq //do_irq exception_exit_do_fiq: exception_entry bl halt //do_fiq_do_error: exception_entry bl halt //do_error/*******************************************************/relocate: adr x0, _start ldr x1, =_start cmp x0, x1 b.eq relocate_complete //No need relocate ldr x2, =__bss_start //relocate end addrcpy: ldr x3, [x0] //ldr x3, [x0], #8 //ldp x10, x11, [x0], #16 //copy from source address [x0] add x0, x0, #8 str x3, [x1] //str x3, [x1], #8 //stp x10, x11, [x1], #16 //copy to target address [x1] add x1, x1, #8 cmp x1, x2 b.lo cpy b relocate_complete /*******************************************************/ clean_bss: ldr x0, =__bss_start //bss start ldr x1, =__bss_end //bss end mov x2, #0 clean_loop: str x2, [x0] add x0, x0, #8 cmp x0, x1 b.lo clean_loop b clean_bss_complete 前面的中断初始化完成了，接下来就是注册、使能、执行中断、中断测试几个函数：[int.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/*************Function：interrupt**************/#include \"int.h\"#include \"led.h\"#include \"timer.h\"void irq_init(void)&#123; /* gic has been init in Start.S */&#125;void enable_interrupts(void)&#123; asm volatile(\"msr daifclr, #0x03\");&#125;/* irq interrupt install handle */void irq_install_handler(int irq, interrupt_handler_t *handler, void *data)&#123; if (g_irq_handler[irq].m_func != handler) g_irq_handler[irq].m_func = handler;&#125;/* enable irq handler */int irq_handler_enable(int irq)&#123; unsigned long M, N; if (irq &gt;= NR_GIC_IRQS) return -1; M = irq / 32; N = irq % 32; GICD-&gt;ISENABLER[M] = (0x1 &lt;&lt; N); return 0;&#125;void do_irq(void)&#123; unsigned long nintid; unsigned long long irqstat; asm volatile(\"mrs %0, \" __stringify(ICC_IAR1_EL1) : \"=r\" (irqstat)); nintid = (unsigned long)irqstat &amp; 0x3FF; /* here we use gic id checking, not include gpio pin irq */ if (nintid &lt; NR_GIC_IRQS) g_irq_handler[nintid].m_func((void *)(unsigned long)nintid); asm volatile(\"msr \" __stringify(ICC_EOIR1_EL1) \", %0\" : : \"r\" ((unsigned long long)nintid)); asm volatile(\"msr \" __stringify(ICC_DIR_EL1) \", %0\" : : \"r\" ((unsigned long long)nintid)); isb();&#125;static void board_timer_isr(void)&#123; static unsigned char led_flag = 0; TIMER3-&gt;INTSTATUS = 0x01; //clrear interrupt if(led_flag == 0) led_mode(0); else led_mode(1); led_flag = !led_flag;&#125;void test_timer_irq(void)&#123; /* enable exceptions */ enable_interrupts(); /* timer set */ TIMER3-&gt;CURRENT_VALUE0 = 0x0FFFFFF; TIMER3-&gt;LOAD_COUNT0 = 0x0FFFFFF; TIMER3-&gt;CONTROL_REG = 0x05; //auto reload &amp; enable the timer /* register and enable */ irq_install_handler(TIMER_INTR3, (interrupt_handler_t *)board_timer_isr, (void *)(0)); irq_handler_enable(TIMER_INTR3);&#125;static void board_gpio_isr(void)&#123; if (GPIO4-&gt;INT_STATUS &amp; (0x01 &lt;&lt; (3 * 8 + 5))) //Interrupt status &#123; GPIO4-&gt;PORTA_EOI |= (0x01 &lt;&lt; (3 * 8 + 5)); //Clear interrupt //if ((GPIO4-&gt;EXT_PORTA &amp; (0x01&lt;&lt;(3*8+5))) == 0) led_mode(2); &#125;&#125;//GPIO4_D5void test_gpio_irq(void)&#123; /* enable exceptions */ enable_interrupts(); /* GPIO set */ GPIO4-&gt;SWPORTA_DDR &amp;= ~(0x01 &lt;&lt; (3 * 8 + 5)); //should be Input GPIO4-&gt;INTEN |= (0x01 &lt;&lt; (3 * 8 + 5)); //Interrupt enable GPIO4-&gt;INTMASK &amp;= ~(0x01 &lt;&lt; (3 * 8 + 5)); //Interrupt bits are unmasked GPIO4-&gt;INTTYPE_LEVEL |= (0x01 &lt;&lt; (3 * 8 + 5)); //Edge-sensitive GPIO4-&gt;INT_POLARITY &amp;= ~(0x01 &lt;&lt; (3 * 8 + 5)); //Active-low GPIO4-&gt;DEBOUNCE |= (0x01 &lt;&lt; (3 * 8 + 5)); //Enable debounce /* register and enable */ irq_install_handler(GPIO4_INTR, (interrupt_handler_t *)board_gpio_isr, (void *)(0)); irq_handler_enable(GPIO4_INTR);&#125; 在主函数里对重定位的验证可以尝试定义一个全局变量检查是否正常，对清BSS段的验证可以尝试定义一个未初始化的全局变量检查是否正常，对中断的验证可以测试定时器中断是否正常，GPIO中断通过外接按键检测是否正常：[main.c]link1234567891011121314151617181920212223242526272829#include \"led.h\"unsigned int test_a = 0x1234; //for test relocateunsigned int test_b; //for test clean bssint main(void)&#123; led_mode(1); //YELLOW LED if ((0x1234 != test_a) || (0 != test_b)) &#123; led_mode(3); led_delay(); led_mode(0); led_delay(); &#125; test_timer_irq(); test_gpio_irq(); while(1) &#123; &#125; return 0;&#125; 测试效果：上电后，黄色LED1间隔闪烁；按下按键，蓝色LED2亮，随后熄灭。 5.串口串口的移植和前面iMX6ULL上手体验里的移植，思路是差不多，先找到U-Boot的uart相关代码，移植好后为printf提供对应函数即可。 5.1 uart代码U-Boot里uart相关代码路径：u-boot/drivers/serial/serial_rk.c可以看到rk_uart_init()是串口初始化，里面依次调用了引脚复用rk_uart_iomux()、串口复位rk_uart_reset()、设置IRDA SIR功能rk_uart_set_iop()、设置串口属性rk_uart_set_lcr()、设置波特率rk_uart_set_baudrate()、设置串口FIFOrk_uart_set_fifo()。初始化完成后，就可以收发数据了，这里只实现了发生数据rk_uart_sendbyte()。移植的过程还是比较简单，寄存器比较少，注意在设置波特率函数里，需要用到除法，为了简便，可先算出来直接赋值。这里的波特率为最大的1.5M。 [uart.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include \"grf.h\"#include \"uart.h\"static void rk_uart_iomux(void)&#123; GRF_GPIO4B_IOMUX = (3 &lt;&lt; 18) | (3 &lt;&lt; 16) | (2 &lt;&lt; 2) | (2 &lt;&lt; 0);&#125;static void rk_uart_reset()&#123; /* UART reset, rx fifo &amp; tx fifo reset */ UART2_SRR = (0x01 &lt;&lt; 1) | (0x01 &lt;&lt; 1) | (0x01 &lt;&lt; 2); led_mode(2); /* interrupt disable */ UART2_IER = 0x00;&#125;static void rk_uart_set_iop(void)&#123; UART2_MCR = 0x00;&#125;static void rk_uart_set_lcr(void)&#123; UART2_LCR &amp;= ~(0x03 &lt;&lt; 0); UART2_LCR |= (0x03 &lt;&lt; 0); //8bits UART2_LCR &amp;= ~(0x01 &lt;&lt; 3); //parity disabled UART2_LCR &amp;= ~(0x01 &lt;&lt; 2); //1 stop bit&#125;static void rk_uart_set_baudrate(void)&#123; volatile unsigned long rate; unsigned long baudrate = 1500000; /* uart rate is div for 24M input clock */ //rate = 24000000 / 16 / baudrate; rate = 1; UART2_LCR |= (0x01 &lt;&lt; 7); UART2_DLL = (rate &amp; 0xFF); UART2_DLH = ((rate &gt;&gt; 8) &amp; 0xFF); UART2_LCR &amp;= ~(0x01 &lt;&lt; 7);&#125;static void rk_uart_set_fifo(void)&#123; /* shadow FIFO enable */ UART2_SFE = 0x01; /* fifo 2 less than */ UART2_SRT = 0x03; /* 2 char in tx fifo */ UART2_STET = 0x01;&#125;void uart_init(void)&#123; rk_uart_iomux(); rk_uart_reset(); rk_uart_set_iop(); rk_uart_set_lcr(); rk_uart_set_baudrate(); rk_uart_set_fifo();&#125;void rk_uart_sendbyte(unsigned char byte)&#123; while((UART2_USR &amp; (0x01 &lt;&lt; 1)) == 0); UART2_THR = byte;&#125;void rk_uart_sendstring(char *ptr)&#123; while(*ptr) rk_uart_sendbyte(*ptr++);&#125;/* 0xABCDEF12 */void rk_uart_sendhex(unsigned int val)&#123; int i; unsigned int arr[8]; for (i = 0; i &lt; 8; i++) &#123; arr[i] = val &amp; 0xf; val &gt;&gt;= 4; /* arr[0] = 2, arr[1] = 1, arr[2] = 0xF */ &#125; /* printf */ rk_uart_sendstring(\"0x\"); for (i = 7; i &gt;= 0; i--) &#123; if (arr[i] &gt;= 0 &amp;&amp; arr[i] &lt;= 9) rk_uart_sendbyte(arr[i] + '0'); else if(arr[i] &gt;= 0xA &amp;&amp; arr[i] &lt;= 0xF) rk_uart_sendbyte(arr[i] - 0xA + 'A'); &#125;&#125; 5.2 printf移植printf库移植的方法：1.先在printf.h里，用__out_putchar替换成自己实现的字节发送函数rk_uart_sendbyte；2.然后在printf.c里，为其提供宏va_start、va_arg、va_end、_INTSIZEOF和va_list； 在第二步里，之前ARMv7的可以直接使用，现在使用ARMv8，实测发现打印有问题，找到交叉编译工具里对应宏的位置，直接加入头文件stdarg.h即可。[printf.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include \"printf.h\"#include &lt;stdarg.h&gt;/************************************************************************************************/#if 0typedef char *va_list;#define _INTSIZEOF(n) ( (sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1) )#define va_start(ap,v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) )//#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )#define va_arg(ap,t) ( *(t *)( ap=ap + _INTSIZEOF(t), ap- _INTSIZEOF(t)) )#define va_end(ap) ( ap = (va_list)0 )#endif/************************************************************************************************/unsigned char hex_tab[] = &#123;'0', '1', '2', '3', '4', '5', '6', '7', \\ '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' &#125;;static int outc(int c)&#123; __out_putchar(c); return 0;&#125;static int outs (const char *s)&#123; while (*s != '\\0') __out_putchar(*s++); return 0;&#125;static int out_num(long n, int base, char lead, int maxwidth)&#123; unsigned long m = 0; char buf[MAX_NUMBER_BYTES], *s = buf + sizeof(buf); int count = 0, i = 0; *--s = '\\0'; if (n &lt; 0) m = -n; else m = n; do &#123; *--s = hex_tab[m % base]; count++; &#125; while ((m /= base) != 0); if( maxwidth &amp;&amp; count &lt; maxwidth) &#123; for (i = maxwidth - count; i; i--) *--s = lead; &#125; if (n &lt; 0) *--s = '-'; return outs(s);&#125;/*ref: int vprintf(const char *format, va_list ap); */static int my_vprintf(const char *fmt, va_list ap)&#123; char lead = ' '; int maxwidth = 0; for(; *fmt != '\\0'; fmt++) &#123; if (*fmt != '%') &#123; outc(*fmt); continue; &#125; lead = ' '; maxwidth = 0; //format : %08d, %8d,%d,%u,%x,%f,%c,%s fmt++; if(*fmt == '0') &#123; lead = '0'; fmt++; &#125; while(*fmt &gt;= '0' &amp;&amp; *fmt &lt;= '9') &#123; maxwidth *= 10; maxwidth += (*fmt - '0'); fmt++; &#125; switch (*fmt) &#123; case 'd': out_num(va_arg(ap, int), 10, lead, maxwidth); break; case 'o': out_num(va_arg(ap, unsigned int), 8, lead, maxwidth); break; case 'u': out_num(va_arg(ap, unsigned int), 10, lead, maxwidth); break; case 'x': out_num(va_arg(ap, unsigned int), 16, lead, maxwidth); break; case 'c': outc(va_arg(ap, int )); break; case 's': outs(va_arg(ap, char *)); break; default: outc(*fmt); break; &#125; &#125; return 0;&#125;//ref: int printf(const char *format, ...);int printf(const char *fmt, ...)&#123; va_list ap; va_start(ap, fmt); my_vprintf(fmt, ap); va_end(ap); return 0;&#125;int printf_test(void)&#123; printf(\"=========This is printf test=========\\n\"); printf(\"test char = %c,%c\\n\", 'H', 'c'); printf(\"test decimal1 number = %d\\n\", 123456); printf(\"test decimal2 number = %d\\n\", -123456); printf(\"test hex1 number = 0x%x\\n\", 0x123456); printf(\"test hex2 number = 0x%08x\\n\", 0x123456); printf(\"test string = %s\\n\", \"www.hceng.cn\"); return 0;&#125;void puts(char *ptr)&#123; while(*ptr) rk_uart_sendbyte(*ptr++);&#125; 测试效果： 6.定时器RK3399有12个通用定时器(timer0~timer11)、12个安全定时器(stimer0~stimer11)、2个PMU定时器(pmutimer0~pmutimer1)。定时器部分比较简单，很多东西都是固定的，比如定时器的时钟来源都是24MHz的晶振，也就是定时器周期为1/24us。此外定时器的计数只能由小向大增加。定时器支持两种模式:自由运行模式和用户自定义模式，其实就是前者计数达到设定值后，自动装载计数循环，后者需要手动重新装载，实现循环。 6.1 编程思路这里希望通过用定时器实现一个比较准确的延时函数，包括us、ms、s的延时。1.首先设置CONTROLREG，关闭定时器、设置为用户定义计数模式(用户确定循环次数)、中断屏蔽(不需要中断处理函数)；2.向LOAD_COUNT0、LOAD_COUNT1放入计数结束值，向LOAD_COUNT2、LOAD_COUNT3放入计数初始值，默认为0；3.设置CONTROLREG，开启定时器，计数器开始运行；4.读取中断状态INTSTATUS判断时候完成计数，清中断，本次计数完成； 6.2 实现代码[timer.c]link12345678910111213141516171819202122232425262728293031323334#include \"timer.h\"//timer4 is used for delay.void delay_us(volatile unsigned long int i)&#123; unsigned long int count_value = 24 * i; //24MHz; period=(1/24000000)*1000000=1/24us TIMER4-&gt;CONTROL_REG &amp;= ~(0x01 &lt;&lt; 0); //Timer disable TIMER4-&gt;CONTROL_REG |= (0x01 &lt;&lt; 1); //Timer mode:user-defined count mode TIMER4-&gt;CONTROL_REG &amp;= ~(0x01 &lt;&lt; 2); //Timer interrupt mask TIMER4-&gt;LOAD_COUNT0 = count_value &amp; 0xFFFFFFFF; //load_count_low bits TIMER4-&gt;LOAD_COUNT1 = (count_value &gt;&gt; 32); //load_count_high bits TIMER4-&gt;CONTROL_REG |= (0x01 &lt;&lt; 0); //Timer enable while(!(TIMER4-&gt;INTSTATUS &amp; (0x01 &lt;&lt; 0))); TIMER4-&gt;INTSTATUS |= (0x01 &lt;&lt; 0); //Write 1 clear the interrupt TIMER4-&gt;CONTROL_REG &amp;= ~(0x01 &lt;&lt; 0); //Timer enable disable&#125;void delay_ms(volatile unsigned long int i)&#123; for(; i &gt; 0; i--) delay_us(1000);&#125;void delay_s(volatile unsigned long int i)&#123; for(; i &gt; 0; i--) delay_ms(1000);&#125; 7.ADCRK3399有两类ADC： TS-ADC(Temperature Sensor): 内嵌的两路ADC，一路检测CPU温度，一路检测GPU温度； ADC精度10bit，时钟频率必须低于800KHZ; 测量范围为-40℃~125℃，精度只有5℃； 支持用户自定义和自动模式(前者用户自己控制，后者控制器自动查询)； SAR-ADC(Successive Approximation Register): 六路ADC，精度10bit； 时钟频率必须小于13MHZ; 7.1 编程思路这里希望通过用SAR-ADC获取外部ADC值，通过TS-ADC获取内部CPU/GPU温度。 SAR-ADC1.首先设置SARADC_CTRL[3]，关闭ADC；2.设置SARADC_CTRL[2:0]，选择ADC通道；3.设置SARADC_CTRL[3]，启动ADC转换；4.读取ADC状态SARADC_STAS判断是否转换完成；5.读取ADC数据SARADC_DATA； TS-ADC(User-Define Mode)1.首先设置TSADC_AUTO_CON为用户定义模式、ADC值与温度值负关系；2.设置TSADC_USER_CON选择通道、复位、转换开始；3.设置TSADC_INT_EN，使能ADC完成中断；4.读取ADC中断状态TSADC_INT_PD判断是否转换完成，并清理；5.根据选择的通道，从对应的TSADC_DATA0或TSADC_DATA1读取ADC数据； 这里的TS-ADC得到的数值和温度并不是完全的线性关系，根据提供的表格，可以计算出一个大致的线性关系：y = 0.5823x - 273.62 7.2 实现代码[timer.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include \"uart.h\"#include \"printf.h\"#include \"timer.h\"#include \"int.h\"#include \"adc.h\"unsigned int get_saradc_val(unsigned char channel)&#123; unsigned int val; //delay between power up and start command //SARADC_DLY_PU_SOC = 8; //DLY_PU_SOC + 2 SARADC_CTRL &amp;= ~(0x01 &lt;&lt; 3); //ADC power down control bit SARADC_CTRL |= (channel &lt;&lt; 0); //ADC input source selection //SARADC_CTRL |= (0x01&lt;&lt;3); //Interrupt enable. SARADC_CTRL |= (0x01 &lt;&lt; 3); //ADC power up and reset delay_us(100); //不能立即就判断状态 while(SARADC_STAS &amp; 0x01); //The status register of A/D Converter 1’b0: ADC stop val = SARADC_DATA &amp; 0x3FF; //A/D value of the last conversion (DOUT[9:0]). return val;&#125;//channel0: CPU temperature//channel1: GPU temperatureint get_tsadc_temp(unsigned char channel)&#123; int val; if ((channel != 0) &amp;&amp; (channel != 1)) &#123; printf(\"get_tsadc_temp set channel error.\\n\"); return -255; &#125; //User-Define Mode TSADC_AUTO_CON &amp;= ~(0x01 &lt;&lt; 0); //TSADC controller works at user-define mode TSADC_AUTO_CON |= (0x01 &lt;&lt; 1); //RK3399 is negative temprature coefficient TSADC_USER_CON &amp;= ~(0x07 &lt;&lt; 0); //clear TSADC_USER_CON |= (channel &lt;&lt; 0); //PD_DVDD and ADC input source selection TSADC_USER_CON |= (0x01 &lt;&lt; 3); //CHSEL_DVDD and ADC power up and reset TSADC_USER_CON |= (0x01 &lt;&lt; 4); //the start_of_conversion will be controlled by TSADC_USER_CON[5]. TSADC_USER_CON |= (0x01 &lt;&lt; 5); //start conversion TSADC_INT_EN |= (0x01 &lt;&lt; 16); //eoc_interrupt enable in user defined mode while(!(TSADC_INT_PD &amp; (0x01 &lt;&lt; 16))); //wait ADC conversion stop TSADC_INT_PD &amp;= ~(0x01 &lt;&lt; 16); if (0 == channel) val = (int)(0.5823 * (float)(TSADC_DATA0) - 273.62); //y = 0.5823x - 273.62 else val = (int)(0.5823 * (float)(TSADC_DATA1) - 273.62); //y = 0.5823x - 273.62 printf(\"get_tsadc_temp = %d \\n\", val); return val;&#125; 测试效果： 8.I2CRK3399拥有8个I2C，其功能和其它SOC的I2C差不多，这里通过I2C读写EEPROM，具体的操作和前面博客AM437x——I2C裸机差不多，也实现了两个版本：GPIO模拟和寄存器控制，这里主要介绍寄存器控制版本。 8.1 编程思路0.首先是I2C引脚复用、设置SCK时钟、注册/使能中断(非必须)等； 写EEPROM1.清空控制寄存器CON并使能；2.设置I2C模式transmit only；3.设置CON启动开始信号，并读取IPD等待开始信号发送完成；4.设置TXDATA0实现从机地址、写地址、数据的设定，设置传输数据个数，等待传输完成；5.设置CON发送结束信号，并读取IPD等待结束信号发送完成； 读EEPROM1.清空控制寄存器CON并使能；2.设置I2C模式transmit only + restart + transmit address + receive only；3.设置MRXADDR设定从机地址，设置MRXRADDR设定从机寄存器地址；4.设置TXDATA0实现从机地址、写地址、数据的设定，设置传输数据个数，等待传输完成；5.设置MRXCNT值接收一个数据，读取IPD等待接收数据完成；6.设置CON发送结束信号，并读取IPD等待结束信号发送完成；7.读取RXDATA0获得数据； 8.2 实现代码[i2c.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include \"i2c.h\"#include \"uart.h\"#include \"printf.h\"#include \"timer.h\"//GPIO1_B3/I2C4_SDA//GPIO1_B4/I2C4_SCLvoid i2c_init(void)&#123; //1.GPIO1_B3/I2C4_SDA、GPIO1_B4/I2C4_SCL设置为功能引脚,注意高位要先置为1才能写; PMUGRF_GPIO1B_IOMUX |= ((0xFFFF0000 &lt;&lt; 0) | (0x01 &lt;&lt; 6) | (0x01 &lt;&lt; 8)); //2.设置SCK时钟 //3.注册/使能中断&#125;void eeprom_write(unsigned char addr, unsigned char data)&#123; //0.清空控制寄存器并使能 I2C4-&gt;CON &amp;= ~(0x7F &lt;&lt; 0); I2C4-&gt;IPD &amp;= ~(0x7F &lt;&lt; 0); I2C4-&gt;CON |= 0x01 &lt;&lt; 0; //使能 //1.设置模式:transmit only I2C4-&gt;CON &amp;= ~(0x03 &lt;&lt; 1); //2.开始信号 I2C4-&gt;CON |= 0x01 &lt;&lt; 3; //开始信号 while(!(I2C4-&gt;IPD &amp; (0x01 &lt;&lt; 4))); //等待开始信号发完 I2C4-&gt;IPD |= (0x01 &lt;&lt; 4); //清开始信号标志 //3.I2C从机地址+写地址+数据 (3个字节) I2C4-&gt;TXDATA0 = 0xA0 | (addr &lt;&lt; 8) | (data &lt;&lt; 16); I2C4-&gt;MTXCNT = 3; while(!(I2C4-&gt;IPD &amp; (0x01 &lt;&lt; 2))); //MTXCNT data transmit finished interrupt pending bit I2C4-&gt;IPD |= (0x01 &lt;&lt; 2); //4.结束信号 I2C4-&gt;CON &amp;= ~(0x01 &lt;&lt; 3); //手动清除start(注意:前面的开始信号控制位理论会自动清0,实测没有,这里必须手动清,否则是开始信号) I2C4-&gt;CON |= (0x01 &lt;&lt; 4); while(!(I2C4-&gt;IPD &amp; (0x01 &lt;&lt; 5))); I2C4-&gt;IPD |= (0x01 &lt;&lt; 5);&#125;//自动发送从机地址和从机寄存器地址unsigned char eeprom_read(unsigned char addr)&#123; unsigned char data = 0; //0.清空控制寄存器并使能 I2C4-&gt;CON &amp;= ~(0x7F &lt;&lt; 0); I2C4-&gt;IPD &amp;= ~(0x7F &lt;&lt; 0); I2C4-&gt;CON |= 0x01 &lt;&lt; 0; //使能 //必须收到ack,否则停止传输(非必需) //I2C4-&gt;CON |= (0x01&lt;&lt;6); //stop transaction when NAK handshake is received //1.设置模式:transmit address (device + register address) --&gt; restart --&gt; transmit address –&gt; receive only I2C4-&gt;CON |= (0x01 &lt;&lt; 1); //自动发送从机地址和从机寄存器地址 //2.从机地址 I2C4-&gt;MRXADDR = (0xA0 | (1 &lt;&lt; 24)); //3.从机寄存器地址 I2C4-&gt;MRXRADDR = (addr | (1 &lt;&lt; 24)); //地址只有6位,超过6位怎么办? //4.开始信号 I2C4-&gt;CON |= (0x01 &lt;&lt; 3); while(!(I2C4-&gt;IPD &amp; (0x01 &lt;&lt; 4))); I2C4-&gt;IPD |= (0x01 &lt;&lt; 4); //5.接收一个数据且不响应 I2C4-&gt;CON |= (0x01 &lt;&lt; 5); I2C4-&gt;MRXCNT = 1; while(!(I2C4-&gt;IPD &amp; (0x01 &lt;&lt; 3))); I2C4-&gt;IPD |= (0x01 &lt;&lt; 3); //6.结束信号 I2C4-&gt;CON &amp;= ~(0x01 &lt;&lt; 3); //手动清除start I2C4-&gt;CON |= (0x01 &lt;&lt; 4); while(!(I2C4-&gt;IPD &amp; (0x01 &lt;&lt; 5))); I2C4-&gt;IPD |= (0x01 &lt;&lt; 5); return (I2C4-&gt;RXDATA0 &amp; 0xFF);&#125; 主函数里先向EEPROM写数据，再读出数据并打印出来，是否是预期的值。12345678910111213141516171819i2c_init();//write eeprom.for(i=0; i&lt;5; i++) &#123; eeprom_write(i,2*i); delay_ms(4);//Must be delayed more than 4ms. &#125;printf(\"write eeprom ok\\n\\r\");delay_ms(10);//read eeprom. for(i=0; i&lt;5; i++) &#123; printf(\"read_data%d = %d\\n\\r\", i, eeprom_read(i)); delay_ms(4); &#125; 测试效果： 9.SPIRK3399有6组SPI，协议也是标准的，没什么好说的。通过SPI读取Flash，也实现了两个版本：GPIO模拟和寄存器控制，这里主要介绍寄存器控制版本。 9.1 编程思路0.首先是SPI引脚复用、设置时钟、SPI模式(SCPH=1，SCPOL=1)等；1.实现发送一字节函数：使能SPI、向TXDR[0]写入待发送的数据、根据SR等待发送完成及空闲、关闭SPI；2.实现接收一字节函数：使能SPI、向TXDR[0]写入空数据、根据SR等待接收完成及空闲、读出RXDR[0]数据、关闭SPI；3.实现片选函数；4.剩下的就是SPI Flash(W25Q16DV)相关的操作，比如发送哪个指令读取ID，发送哪个指令擦除数据等，参考具体的Flash芯片手册； 值得注意的几点有：1.SPI Flash(W25Q16DV)每次写操作某个分区前都得先擦除该分区；2.注意片选的连续性，比如写使能指令(0x06)和写状态寄存器指令(0x01)之间的片选不能中断； 9.2 实现代码[spi.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261#include \"spi.h\"#include \"uart.h\"#include \"printf.h\"#include \"timer.h\"#include \"gpio.h\"#include \"grf.h\"void spi_init(void)&#123; //SPI1_CSn0/GPIO1_B2_U //SPI1_CLK/GPIO1_B1_U //SPI1_TXD/GPIO1_B0_U //SPI1_RXD/GPIO1_A7_U //1.IOMUX PMUGRF_GPIO1A_IOMUX = 0xFFFF8000; PMUGRF_GPIO1B_IOMUX = 0xFFFF002A; SPI1-&gt;ENR &amp;= ~(0x01 &lt;&lt; 0); //关闭SPI //2.Clock Ratios master mode:Fspi_clk&gt;= 2 × (maximum Fsclk_out) //CRU_CLKGATE2_CON &amp;= ~(0x01&lt;&lt;9); //默认SPI1 source clock开启 //CRU_CLKGATE6_CON &amp;= ~(0x01&lt;&lt;4); //默认SPI1 APB clock开启 SPI1-&gt;BAUDR = 24; //Fsclk_out = 48/24= 2M 48 &gt;= 2x2 //3.注册/使能中断(本程序未使用,用的查询) //register_irq(IRQ_SPI1, spi_irq_isr); //irq_handler_enable(IRQ_SPI1); //SPI1-&gt;IPR &amp;= ~(0x01&lt;&lt;4); //Active Interrupt Polarity Level is HIGH(default) //SPI1-&gt;IMR |= ((0x01&lt;&lt;4) | (0x01&lt;&lt;3) | (0x01&lt;&lt;2) | (0x01&lt;&lt;1) | (0x01&lt;&lt;0)); //Interrupt Mask //4.DMA(可以不用) //SPI1-&gt;DMACR |= ((0x01&lt;&lt;1) | (0x01&lt;&lt;0)); // Transmit/Receive DMA enabled //SPI1-&gt;DMATDLR = 1; //? //SPI1-&gt;DMARDLR = 1; //? //5.SPI模式 //[1:0]Data Frame Size:8bit data //[5:2]Control Frame Size:8-bit serial data transfer //[6]SCPH:Serial clock toggles at start of first data bit //[7]SCPOL:Inactive state of serial clock is high //[13]BHT:apb 8bit write/read, spi 8bit write/read //[19:18]XFM(Transfer Mode):Transmit &amp; Receive(default) //[20]OPM(Operation Mode):Master Mode(default) SPI1-&gt;CTRLR0 &amp;= ~(0x03 &lt;&lt; 0) ; SPI1-&gt;CTRLR0 |= ((0x01 &lt;&lt; 0) | (0x07 &lt;&lt; 2) | (0x01 &lt;&lt; 6) | (0x01 &lt;&lt; 7) | (0x01 &lt;&lt; 13)); //设置SPI模式&#125;void spi_send_byte(unsigned char val)&#123; SPI1-&gt;ENR |= (0x01 &lt;&lt; 0); //SPI Enable SPI1-&gt;TXDR[0] = val &amp; 0xFFFF; while(!(SPI1-&gt;SR &amp; (0x01 &lt;&lt; 2))); //Transmit FIFO is empty while(SPI1-&gt;SR &amp; (0x01 &lt;&lt; 0)); //SPI is idle or disabled SPI1-&gt;ENR &amp;= ~(0x01 &lt;&lt; 0); //SPI Disable&#125;static unsigned char spi_recv_byte(void)&#123; unsigned char val = 0; SPI1-&gt;ENR |= (0x01 &lt;&lt; 0); //SPI Enable SPI1-&gt;TXDR[0] = 0; //因为是发送接收模式,FIFO在发送时也会接收数据,这里发送空数据,就可读取数据 while(SPI1-&gt;SR &amp; (0x01 &lt;&lt; 3)); //SReceive FIFO is not empty while(SPI1-&gt;SR &amp; (0x01 &lt;&lt; 0)); //SPI is idle or disabled val = SPI1-&gt;RXDR[0] &amp; 0xFF; //读数据 SPI1-&gt;ENR &amp;= ~(0x01 &lt;&lt; 0); //SPI Disable,为了清空FIFO return val;&#125;void spi_flash_set_cs(unsigned char flag)&#123; if(!flag) SPI1-&gt;SER |= (0x01 &lt;&lt; 0); else SPI1-&gt;SER &amp;= ~(0x01 &lt;&lt; 0);&#125;/* 通用部分 */static void spi_flash_send_addr(unsigned int addr)&#123; spi_send_byte(addr &gt;&gt; 16); spi_send_byte(addr &gt;&gt; 8); spi_send_byte(addr &amp; 0xff);&#125;static void spi_flash_write_enable(int enable)&#123; if (enable) &#123; spi_flash_set_cs(0); spi_send_byte(0x06); spi_flash_set_cs(1); &#125; else &#123; spi_flash_set_cs(0); spi_send_byte(0x04); spi_flash_set_cs(1); &#125;&#125;static unsigned char spi_flash_read_status_reg1(void)&#123; unsigned char val; spi_flash_set_cs(0); spi_send_byte(0x05); val = spi_recv_byte(); spi_flash_set_cs(1); return val;&#125;static unsigned char spi_flash_read_status_reg2(void)&#123; unsigned char val; spi_flash_set_cs(0); spi_send_byte(0x35); val = spi_recv_byte(); spi_flash_set_cs(1); return val;&#125;static void spi_flash_wait_when_busy(void)&#123; while (spi_flash_read_status_reg1() &amp; 1);&#125;static void spi_flash_write_status_reg(unsigned char reg1, unsigned char reg2)&#123; spi_flash_write_enable(1); spi_flash_set_cs(0); spi_send_byte(0x01); spi_send_byte(reg1); spi_send_byte(reg2); spi_flash_set_cs(1); spi_flash_wait_when_busy();&#125;static void spi_flash_clear_protect_for_status_reg(void)&#123; unsigned char reg1, reg2; reg1 = spi_flash_read_status_reg1(); reg2 = spi_flash_read_status_reg2(); reg1 &amp;= ~(1 &lt;&lt; 7); reg2 &amp;= ~(1 &lt;&lt; 0); spi_flash_write_status_reg(reg1, reg2);&#125;static void spi_flash_clear_protect_for_data(void)&#123; /* cmp=0,bp2,1,0=0b000 */ unsigned char reg1, reg2; reg1 = spi_flash_read_status_reg1(); reg2 = spi_flash_read_status_reg2(); reg1 &amp;= ~(7 &lt;&lt; 2); reg2 &amp;= ~(1 &lt;&lt; 6); spi_flash_write_status_reg(reg1, reg2);&#125;/* erase 4K */void spi_flash_erase_sector(unsigned int addr)&#123; spi_flash_write_enable(1); spi_flash_set_cs(0); spi_send_byte(0x20); spi_flash_send_addr(addr); spi_flash_set_cs(1); spi_flash_wait_when_busy();&#125;/* program */void spi_flash_program(unsigned int addr, unsigned char *buf, int len)&#123; int i; spi_flash_write_enable(1); spi_flash_set_cs(0); spi_send_byte(0x02); spi_flash_send_addr(addr); for (i = 0; i &lt; len; i++) spi_send_byte(buf[i]); spi_flash_set_cs(1); spi_flash_wait_when_busy();&#125;void spi_flash_read(unsigned int addr, unsigned char *buf, int len)&#123; int i; spi_flash_set_cs(0); spi_send_byte(0x03); spi_flash_send_addr(addr); for (i = 0; i &lt; len; i++) buf[i] = spi_recv_byte(); spi_flash_set_cs(1);&#125;void spi_flash_init(void)&#123; spi_flash_clear_protect_for_status_reg(); spi_flash_clear_protect_for_data();&#125;void spi_flash_read_ID(unsigned int *pMID, unsigned int *pDID)&#123; spi_flash_set_cs(0); spi_send_byte(0x90); spi_flash_send_addr(0); *pMID = spi_recv_byte(); *pDID = spi_recv_byte(); spi_flash_set_cs(1);&#125; 在主函数里先读取Flash的MID和PID，然后初始化Flash(去除写状态寄存器保护和写数据保护)，再写入数据，读出数据检测是否一致。123456789101112131415 spi_init();spi_flash_read_ID(&amp;mid, &amp;pid);printf(\"SPI Flash : MID = 0x%02x, PID = 0x%02x\\n\\r\", mid, pid); spi_flash_init(); while(1)&#123; spi_flash_erase_sector(4096); spi_flash_program(4096, \"hceng\", 7); spi_flash_read(4096, str, 7); printf(\"SPI Flash read from 4096: %s\\n\\r\", str); delay_s(2); &#125; 测试效果： 10.PWMRK3399有四组PWM，其中PWM3可以配置为第二功能用于红外IR。这里使用MIPI接口的PWM1为例，输出指定占空比的波形。 10.1 编程思路1.首先是PWM引脚复用；2.关闭PWM控制器；3.设置时钟源、比例系数、预分频(可默认)；4.设置模式:连续模式,占空比极性为高、左对齐(默认)；5.设置占空比，其中PERIOD_HPR是总周期，DUTY_LPR是有效周期，Duty cycle=DUTY_LPR/PERIOD_HPR；6.启动PWN控制器； 10.2 实现代码[pwm.c]link1234567891011121314151617181920212223242526272829303132333435363738394041#include \"pwm.h\"#include \"gpio.h\"#include \"timer.h\"//GPIO4_C6/PWM1//0~100void pwm1_out(unsigned char val)&#123;#if 0 //test gpio ok GPIO4-&gt;SWPORTA_DDR |= (0x01 &lt;&lt; (2 * 8 + 6)); while(1) &#123; GPIO4-&gt;SWPORTA_DR &amp;= ~(0x01 &lt;&lt; (2 * 8 + 6)); delay_ms(10); GPIO4-&gt;SWPORTA_DR |= (0x01 &lt;&lt; (2 * 8 + 6)); delay_ms(10); &#125;#else //1.IOMUX GRF_GPIO4C_IOMUX |= ((0x03&lt;&lt;28) | (0x01&lt;&lt;12)); // 1'b1: pwm_1 //GRF_SOC_CON2 |= ((0x01&lt;&lt;16) | (0x01&lt;&lt;0)); //P136 1'b1: pwm_1 //2.Set PWM PWM1-&gt;CTRL &amp;= ~(0x01&lt;&lt;0); //PWM channel disabled //2.1 设置时钟源、比例系数、预分频、 //PWM1-&gt;CTRL |= ((0x01&lt;&lt;16) | (0x01&lt;&lt;12) | (0x01&lt;&lt;9));//Scale Factor / Prescale Factor / Clock Source Select //2.2 设置模式:连续模式,占空比极性为高、左对齐(默认) PWM1-&gt;CTRL |= (0x01&lt;&lt;1) | (0x01&lt;&lt;3); //PWM Operation Mode 01: Continuous mode. //3.Set Duty Cycle if(val &gt; 100) val = 100; PWM1-&gt;PERIOD_HPR = 100; //总周期 PWM1-&gt;DUTY_LPR = val; //占空比=val/总周期 //4.Start PWM1-&gt;CTRL |= (0x01&lt;&lt;0);#endif &#125; 11.LCD待填坑…… 参考资料：[1]. Rockchip RK3399TRM V1.3 Part1.pdf Rockchip RK3399TRM V1.3 Part2.pdf[2]. ARMv8-A_Architecture_ReferenceManual(Issue_A.a).pdf[3]. u-boot源码阅读(二)[4]. u-boot启动流程分析(1)_平台相关部分[5]. ARMv8 与Linux的新手笔记 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"裸机","slug":"裸机","permalink":"http://yoursite.com/tags/裸机/"},{"name":"Uboot","slug":"Uboot","permalink":"http://yoursite.com/tags/Uboot/"},{"name":"RK3399","slug":"RK3399","permalink":"http://yoursite.com/tags/RK3399/"}]},{"title":"RK3288——LCD裸机","date":"2018-07-19T01:12:32.000Z","path":"2018/07/19/RK3288——LCD裸机/","text":"在RK3288平台上，采用裸机实现LVDS和MIPI接口的LCD显示。 1.常见的LCD显示接口在之前写的Exynos4412——LCD驱动里，使用的RGB接口。除了RGB接口，如今市面上主流的还有LVDS、MIPI、eDP接口。 接口分辨率接口电平说明RGB800x480以下TTL几乎所有的SOC都支持RGB接口；在小屏、低端设备中广泛使用；LVDS1024x768及以上差分信号中高端的SOC大多数都集成，也可通过转换芯片将RGB转成LVDS输出；在大屏，中高端平板、笔记本中使用；MIPI1080P以下差分信号大多数中高端的SOC都集成，也可通过转换芯片实现；手机平台的标准接口，在手机中广泛使用；eDP1080P以上差分信号高端SOC中集成，相对比较新的规范；支持超高分辨率，有取代LVDS的趋势； 各接口示意图如下： RGB接口：RGB接口也叫TTL(Transistor Transistor Logic)接口，它是唯一一个采用TTL电平的LCD接口。如果数据接口R、G、B都只使用0~5共6x3根数据线，即为18bit RGB接口，如果R、G、B都使用0~7共8x3根数据线，即称为24bit RGB接口;它的详细介绍，可以参考前面的Exynos4412——LCD驱动; LVDS接口：LVDS(Low Voltage Differential Signaling)，即一种采用低压差分信号技术的LCD接口，克服了TTL电平方式传输宽带高码率数据时功耗大、EMI电磁干扰大等缺点；如果数据接口只使用LVDS_D0~D2这三组数据线，就是6bit 模式；如果使用LVDS_D0~D3这四组数据线，就是8bit 模式； MIPI接口：MIPI(Mobile Industry Processor Interface)，为了推进手机应用处理器接口的标准化而产生的。MIPI是一系列接口的总称，MIPI下应用比较多的是DSI(Display Serial Interface)和CSI(Camera Serial Interface)，分别针对显示屏应用和摄像头应用。这里的MIPI接口，实质上指的是DSI接口； eDP接口：eDP(Embedded Display Port)，主要用于将视频源连接到显示设备（如计算机显示器），还可以传输音频，USB和其他形式的数据；该部分目前资料较少，RK3288芯片手册该部分寄存器都没给，属于保密范围，暂时没法研究； 2.LVDS2.1 分析过程先理一下分析的思路： 1.首先需要一个RK3288的开发板(这里使用的是Firefly生产的AIO-3288J)，且带有LVDS接口的屏，且提供的资料能够让屏亮起来； 2.根据提供资料、源码，重头编译一下源码，包括U-boot、Kernel、Android等(编译Android可能需要设置交换分区)； 3.编译完成后，将生成的镜像文件烧录至开发板，验证是否可用； 4.可用后，就有了显示部分的源码，先从设备树文件夹入手，查看生成了哪些dtb文件，即表示对应的dts被使用了，再找到对应的dts文件，找到lcd、screen、blacklinght、lvds等关键词的部分； 5.得出RK3288的LVDS至少和VOP(lcdc)、lvds、screen、blacklinght这四个部分有关，再利用设备树compatible与内核匹配和源码若使用都会生成.o这两个特性，找到对应部分的内核源码； 6.修改内核源码，重新编译烧录，观察现象；比如，找到内核源码中lvds相关部分，屏蔽掉lvds_en()这一明显关键的函数后，发现开发板开机后，启动内核屏幕仍然会出现logo，因此推测U-boot也做了LVDS的相关初始化，内核中的lvds_en()可能用于后续锁屏等屏幕的开闭； 7.屏蔽多个关键函数，发现除去背光函数对屏幕显示有影响外，其它的关键函数的屏蔽，对开始显示logo都没影响； 8.在U-boot中，直接操作寄存器使能背光，同时屏蔽进入内核的代码，发现进入U-boot即可显示logo，因此U-boot里肯定有完整的LVDS显示的操作，内核就暂时不用管了； 9.以U-boot中lcdc_init()、lvds_en()等为核心突破口，先打印出该部分的寄存器操作值，再屏蔽掉该部分代码，自己直接向寄存器写值，重新烧录，查看logo是否仍显示；如果logo存在，则表示自己直接操作该部分寄存器成功； 10.以此类推，逐渐屏蔽源码，改为自己直接操作寄存器，最后按照源码的函数调用顺序，依次操作寄存器，单独生成bin文件，测试显示成功即可； 11.查阅相关寄存器，分析、注释； 对LVDS接口的LCD显示分析如下： 对LVDS接口的LCD操作框架总结如下： 这其中有两个值得一提的点： 1.核心板上有个电源IC，需要通过I2C设置电源IC的输出，提供给显示模块，如果没有设置，屏幕是不会有显示的； 2.屏幕参数的设置，用到了前面1.3LCD显示原理的知识：12345678910//hspw+hbp+col+hfp:8+8+800+48=848VOP_BIG_DSP_HTOTAL_HS_END = ((8&lt;&lt;0) | (848&lt;&lt;16)); //0:HS_PW 16:HTOTALVOP_BIG_DSP_HACT_ST_END = ((816&lt;&lt;0) | (16&lt;&lt;16)); //0:COL_END 16:COL_START//vspw+vbp+row+vfp:4+11+1280+32=1312VOP_BIG_DSP_VTOTAL_VS_END = ((4&lt;&lt;0) | (1312&lt;&lt;16));//0:VS_PW 16:VTOTALVOP_BIG_DSP_VACT_ST_END = ((1295&lt;&lt;0) | (15&lt;&lt;16)); //0:ROW_END 16:ROW_STARTVOP_BIG_POST_DSP_HACT_INFO = ((816&lt;&lt;0) | (16&lt;&lt;16)); //0:COL_END 16:COL_STARTVOP_BIG_POST_DSP_VACT_INFO = ((1295&lt;&lt;0) | (15&lt;&lt;16)); //0:ROW_END 16:ROW_START 在水平方向，由HSYNC(hspw)+HBP+Active weigth(col)+HFP=Total weigth(HTOTAL)，再根据LCD的手册，取合适的值，填入寄存器对应位；比如，VOP_BIG_DSP_HTOTAL_HS_END的低16位填入HSYNC(hspw)值，高16位填入Total weigth(HTOTAL)；VOP_BIG_DSP_HACT_ST_END低16位填入HSYNC(hspw)+HBP+Active weigth(col)的值，高16位填入HSYNC(hspw)+HBP的值；都是吻合LCD的显示原理的。 2.2 源码及效果源码见Github。 3.MIPI3.1 分析过程先理一下分析的思路： 1.首先需要一个带有MIPI屏的RK3288的开发板，Firefly生产的AIO-3288J的MIPI屏已经停产，也没找到兼容的，因此又去弄了一个带MIPI屏的RK3288开发板(荣品生产的king3288)； 2.根据提供的资料，编译源码，下载，烧录、测试； 3.有了前面的经验，猜测开机LOGO显示的代码在U-Boot中，注释掉U-Boot中common/cmd_bootrk.c里的//do_bootm_linux(0, 0, NULL, &amp;images);，使其不能引导内核，重新编译U-Boot，下载，发现有LOGO显示，证明U-Boot里有MIPI屏显示操作； 4.依旧是找到LOGO显示的相关代码，修改，编译，烧写，观察现象，最终得到独立的MIPI屏显示相关代码； 对MIPI接口的LCD显示分析如下： MIPI部分的代码比LVDS感觉要乱一些，主要是因为在结构体里定义了函数，使用Source Insight分析代码时，没那么方便，涉及到了三个结构体如下，分别是VOP、MIPI接口、面板的相关操作： 这其中有两个值得一提的点： 1.它们的PMIC使用的同一款，且配置一样，直接就可以用之前的代码； 2.不能直接读出所有配置的寄存器，然后对比，因为实测有些寄存器操作后，需要一个等待时间(需要读取另一个寄存器判断)，才能进行下一个寄存器的操作，就可能出现源码和自己代码的寄存器值都一样，但实际效果不一样； 3.2 源码及效果源码见Github。 4.心得 1.熟悉了如果从驱动中提取出裸机代码，看清了对寄存器的实质操作，有利于理解整个流程； 2.无论是何种接口的LCD，都有共性，比如都需要向buf写数据，且告诉对应寄存器；针对RK3288，都使用VOP对buf数据处理，然后再通过不同的接口发送出去，都需要根据LCD面板来设置时间参数； 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"裸机","slug":"裸机","permalink":"http://yoursite.com/tags/裸机/"},{"name":"LCD","slug":"LCD","permalink":"http://yoursite.com/tags/LCD/"},{"name":"RK3288","slug":"RK3288","permalink":"http://yoursite.com/tags/RK3288/"}]},{"title":"Linux声卡驱动","date":"2018-06-27T01:22:47.000Z","path":"2018/06/27/Linux声卡驱动/","text":"了解、学习Linux声卡驱动，并在Tiny4412上实现声音的播放和录制。 1.声卡基础1.1 基本概念记得是初中还是高中物理，里面说过声音是由物体振动产生，然后通过空气传播到耳朵里。把耳朵换成咪头，声音振动咪头，改变了咪头两端的电压，ADC再采集电压，就记录了音频数据；反之，将记录的数据通过DAC转成电压，通过运放放大，就使喇叭振动就产生了声音。这整个过程，涉及声音质量的参数有三个： 采样频率：就是单位时间内ADC采集的次数，一般是8kHz~96kHz； 转换精度：就是每次ADC采集或者DAC转换的精度。一般有8bit、16bit、24bit； 通道数：就是单声道、双声道； 在Linux声卡驱动的发展中，最开始使用的声卡驱动框架是OSS(Open Sound System)。从2.6版本开始，ALSA(Advanced Linux Sound Architecture)成为Linux内核中默认的标准音频驱动程序集，OSS则被标记为废弃。OSS和ALSA的主要区别: OSS:提供基于ioctl等原始编程接口访问设备； ALSA:除了提供基于ioctl等原始编程接口，还专门为简化应用程序的编写提供了相应的函数库，相对OSS更加方便； 后面编写的驱动，将采用ALSA框架。 1.2音频编解码芯片一般来说，大多数SOC都不包含音频的转换，可能是因为功耗、模数干扰等考虑，因此大多数都是外接了一个音频编解码芯片(Codec)。音频文件从Flash加载到RAM中，再由DMA将其通过I2S发送给Codec，再由Codec的DAC变成模拟信号，驱动功放使喇叭播放声音；同时，SOC通过I2C(有些Codec不是I2C，而是其它的接口)设置Codec的寄存器，调整声音大小等。 因此，整个声卡框架涉及的驱动可能有SOC的DMA、I2S、I2C以及Codec驱动。 2.硬件接口Tiny4412的声卡部分原理图如下，所采用的codec芯片为WM8960，该电路大致可分为四部分： ① IIS接口，负责Exynos4412和WM8960之间的数据传输 FunctionSOCCodecNoteDateXi2sCDCLK0MCLK系统时钟Xi2sSCLK0BCLK数据时钟Xi2sLRCK0DACLRC左右声道切换Xi2sSDO0_0DATDAT数据输出(播放)Xi2sSDI0ADCDAT数据输入(录音) ② I2C接口，负责Exynos4412对WM8960寄存器的配置 FunctionSOCCodecNoteControlXi2cSCL0SCLKI2C时钟Xi2cSDA0SDINI2C数据 ③ 录音 采用咪头和耳机接口进行录音； ④ 播放 采用耳机接口播放音频，另外还有一个耳机插入检测Earphone_detect； 最近急需入坑Android，声卡这个坑暂停一下，后续再回来填！ 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"Exynos4412","slug":"Exynos4412","permalink":"http://yoursite.com/tags/Exynos4412/"},{"name":"音频驱动","slug":"音频驱动","permalink":"http://yoursite.com/tags/音频驱动/"}]},{"title":"嵌入式Linux——WIFI网卡","date":"2018-06-21T06:58:18.000Z","path":"2018/06/21/嵌入式Linux——WIFI网卡/","text":"如何在嵌入式Linux中，使用WIFI无线网卡。嵌入式中设备想要联网，无非就 有线和无线 两种方式。有线就插上网线，没什么好说的；无线的话一种是将WIFI模块集成焊接在板子上，另一种是WIFI模块以USB的方式接到板子上。本次使用的就是USB接口的WIFI无线网卡，实现开发板使用WIFI无线网卡访问互联网和作为个人热点。 1.准备工作1.2 WIFI基础知识WIFI网卡有两种工作模式，一种是无线终端模式(STA)，也就是手机日常使用的模式，通过该模式连接网络上网；一种是无线热点模式(AP)，也就是手机的个人热点模式，通过该模式提供热点供其它设备上网； 无线网络的安全性由两部分组成：认证和加密。 认证:使得只有允许的设备才能连接到无线网络； 加密:确保数据的保密性和完整性，即数据在传输过程中不会被篡改； 常用的认证算法有:开放认证、共享秘钥认证、802.11x认证、PSK认证。其中802.11x认证和PSK认证安全性较高，分别应用于企业和个人的环境; 常用的加密算法有:WEB加密、TKIP加密、CCMP加密算法。其中WEB加密和TKIP加密都是RC4的加密算法，安全性较低；CCMP加密采用AES对称加密算法，安全性较高。 安全策略认证方式加密方式备注Openopenopen开放WiFi，无任何加密openWEP开放WiFi，仅数据加密WEPWEPWEP共享密钥认证，容易破解WPA802.11XTKIP/WEP比较安全，用于企业PSKTKIP/WEP比较安全，用于个人WPA2802.11XCCMP/TKIP/WEP目前最安全，用于个人PSKCCMP/TKIP/WEP目前最安全，用于个人 连入超市、商场等公共WIFI的时候，不需要输入密码，但要通过网页输入手机号，使用验证码验证，也就是采用802.11X进行的验证，通过服务器完成的验证。使用手机开个人热点的时候，可以选择安全性OPEN、WEP、WPA、WPA2，也就对应不同的安全等级。 我手里的MIX2S，MIUI10个人热点里面就仅OPEN和WPA2两个选项，感觉这是个趋势，要么最简单的OPEN，要么就最安全的WPA2(WPA2是向下兼容的)，逐渐扔掉历史的包袱。 1.2 选择无线网卡首先是选择合适的无线网卡，选取的原则是根据WIFI无线网卡的VID和PID判断内核是否支持该无线网卡。 1.获取无线网卡ID将无线网卡插入Windows电脑，打开设备管理器，选中无线网卡，右键“属性”，切换到“详细信”息选项卡，在“属性”下拉栏中选择”硬件ld”，即可得到无线网卡的ID：我的无线网卡VID是0x148F，PID是0x3070； 2.查询内核是否支持可以从wireless.kernel.org得到支持的设备列表。可以从列表中搜到前面的VID和PID，因此说明内核是支持现在使用的无线网卡。此外，还可以得知对应的驱动应该为rt2800usb、rt2870sta。 1.3 移植WIFI驱动 前面根据ID得到了对应的网卡驱动名字，但还不是很靠谱，建议直接在驱动中搜索ID，更靠谱：1grep &quot;0x3070&quot; drivers/net/wireless/ -nr 得到：drivers/net/wireless/ralink/rt2x00/rt2800usb.c:1091: { USB_DEVICE(0x148f, 0x3070) },，知道了对应的驱动文件是rt2800usb.c； 再查看对应路径的Makfeile：1cat drivers/net/wireless/ralink/rt2x00/Makefile 得到：obj-$(CONFIG_RT2800USB) += rt2800usb.o，知道了对应的宏是CONFIG_RT2800USB； 进入内核目录，执行：1make menuconfig 搜索CONFIG_RT2800USB，得知其依赖：Depends on: NETDEVICES [=y] &amp;&amp; WLAN [=y] &amp;&amp; WLAN_VENDOR_RALINK [=y] &amp;&amp; RT2X00 [=n] &amp;&amp; USB [=y]，可以知道RT2X00 [=n]没有打开，再搜索它，如此循环，直到RT2800USB [=y]。 这里有个注意的就是，当开启的上层的某个依赖，下层的某个选项可能会多出来许多选项，而这些选项原来是没有的，不要固化思维。 最后重新编译内核即可。 1.4 使用buildroot移植应用想要使用无线网卡，需要用到四个软件： iw:可用于OPEN、WEP这两种”认证/加密”，以及扫描WIFI热点等； wpa_supplicant:可用于前面4种”认证/加密”； hostapd:能够使得无线网卡切换为AP模式； dhcp:STA模式使WIFI网卡动态获取IP，AP模式分配IP； 也就是需要移植这四个软件，目前的方法有：1.逐个下载源码，交叉编译，配置，可以还需要相关依赖库，缺点是费时费力；2.使用Yocto等工具，制作发行版的根文件系统，例如Ubuntu16.04，里面有apt-get，可以自动下载安装，缺点是制作发行版根文件系统比较麻烦，且体积较大；3.使用buildroot制作根文件系统，选择需要的软件，自动生成根文件系统，相对简单，体积也较小； 本次就以buildroot为例，制作含需要应用程序的根文件系统。 首先从GitHub下载针对Tiny4412修改后的buidroot 1git clone -b board_tiny4412 https://github.com/hceng/buildroot.git 查看支持的board 12cd buildroot/make list-defconfigs 得知tiny4412对应的配置文件:tiny4412_defconfig - Build for tiny4412； 配置提供的配置文件 1make tiny4412_defconfig 添加自己所需软件执行: 1make menuconfig 对应勾选所需软件：12345678910111213141516171819202122232425Target packages ---&gt; Networking applications ---&gt; [*] dhcp (ISC) [*] dhcp server [*] Enable delayed ACK feature [*] dhcp relay [*] dhcp client …… [*] hostapd [*] Enable ACS (NEW) [*] Enable EAP [*] Enable WPS …… [*] iw …… [*] wpa_supplicant [*] Enable nl80211 support [*] Enable AP mode [ ] Enable EAP [ ] Enable HS20 [ ] Enable syslog support [ ] Enable WPS [*] Install wpa_cli binary [*] Install wpa_client shared library [*] Install wpa_passphrase binary 修改主机名、欢迎语、root密码等 123456System configuration ---&gt; (tiny_4412) System hostname (Welcome to hceng&apos;s board.) System banner …… [*] Enable root login with password (123456) Root password 生成根文件系统执行: 1make buildroot会自动下载相关源码包，整个过程时间比较久，最后生成buildroot/output/images/rootfs.tar，解压到SD卡rootfs分区即可。 1.5 添加firmware此时开发板启动Linux后，使用ifconfig wlan0 up启动无线网卡，提示：1234ieee80211 phy0: rt2x00lib_request_firmware: Info - Loading firmware file &apos;rt2870.bin&apos;rt2800usb 2-2.2:1.0: Direct firmware load for rt2870.bin failed with error -2ieee80211 phy0: rt2x00lib_request_firmware: Error - Failed to request Firmwareifconfig: SIOCSIFFLAGS: No such file or directory 提示需要firmware文件rt2870.bin。 继续通过网站wireless.wiki.kernel.org去下载该固件。 得到rt2870.bin后，拷贝到单板/lib/firmware/下即可。 1.6 启动WIFI网卡 注意：双网卡的单板的两个网卡IP不能设置为同一网段，原因参考这里。 也就是先把有线网卡IP设置为其它网段，比如：1ifconfig eth0 192.168.2.220 然后启动WIFI网卡，并设置IP(路由器IP为192.168.1.1)：12ifconfig wlan0 upifconfig wlan0 192.168.1.220 此时效果如下： 2.无线终端模式——STA完成前面的准备工作后，就可以通过软件使用无线网卡了。 2.1 iw的使用 列出WIFI网卡的性能: 1iw list 扫描WIFI热点 12iw dev wlan0 scan iw dev wlan0 scan | grep SSID: 连接到开放AP 1iw wlan0 connect hceng 查看连接状态 1iw dev wlan0 link 断开WIFI连接 1iw wlan0 disconnect 还可以连接加密的WEP，这里就不研究了。 注意：1.如果连接的不是路由器(IP为192.168.1.1)，而是Android手机热点(IP一般为192.168.43.1)，那么要将WIFI网卡IP设置为43网段，如:192.168.43.10，才能ping通192.168.43.1。 2.此时只能ping路由器和局域网设备，如果要联外网，还需要如下操作：①修改/etc/resolv.conf，添加DNS:nameserver 192.168.1.1，如果是手机热点为nameserver 192.168.43.1；②设置网关，输入命令:route add default gw 192.168.1.1，如果是手机热点为route add default gw 192.168.43.1； 2.2 wpa_supplicant的使用wpa_supplicant本是开源项目，被谷歌修改后加入android移动平台，它主要是用来支持WEP，WPA/WPA2和WAPI无线协议和加密认证的。wpa_supplicant是一个连接、配置WIFI的工具，它主要包含wpa_supplicant(命令行模式)与wpa_cli(交互模式)两个程序。通常情况下，可以通过wpa_cli来进行WIFI的配置与连接，如果有特殊的需要，可以编写应用程序直接调用wpa_supplicant的接口直接开发。 记得以前想查看Android手机连接过的WIFI热点密码时，就直接使用RE文件管理器查看/data/misc/wifi/wpa_supplicant.conf即可(需ROOT)，里面有所有连接过的WIFI名字和密码。从这里可以看出，最后WIFI名字和密码，都会被保存到一个配置文件里，在Linux中，路径就是/etc/wpa_supplicant.conf。 连接开放网络向/etc/wpa_supplicant.conf加入：1234network=&#123; ssid=&quot;hceng&quot; key_mgmt=NONE&#125; 初始化wpa_supplicant，执行：1wpa_supplicant -B -d -i wlan0 -c /etc/wpa_supplicant.conf 查看连接状态：1wpa_cli -iwlan0 status 断开连接：123wpa_cli -iwlan0 disconnectkillall wpa_supplicant 重新连接：1wpa_cli -iwlan0 reconnect 连接加密网络(WAP2)向/etc/wpa_supplicant.conf加入：1234network=&#123; ssid=&quot;hceng_test&quot; psk=&quot;12345678&quot;&#125; 初始化wpa_supplicant，执行：1wpa_supplicant -B -d -i wlan0 -c /etc/wpa_supplicant.conf 至于WEP和WAP方式，也就是配置文件的不同，这里就不去深究了，以后遇到了再说。 2.3 dhclient的使用至此，已经可以连接WIFI了，但还有一些问题。就如前面，需要手动设置设备的IP，且要根据热点的网段设置，还可能与同网段的设备IP冲突。为了解决这个问题，引入了DHCP，自动分配IP地址。 就像家里的设备连接到路由器一样，除了输入名字，密码，其它都不用操作，而且还不会出现IP冲突的情况。 连接好WIFI后，输入：1dhclient wlan0 实现自动获取分配的IP，并设置。 2.4 自动脚本现在已经从功能上实现了WIFI无线网卡的使用，但使用过程步骤比较多，相对麻烦。理想的效果无论何时插上WIFI无线网卡，都自动连接WIFI，且自动获取IP地址。 这就要用到USB的热拔插机制，很久以前写过一篇U盘自动挂载的文章，用的就是这个机制。 1.首先修改/etc/mdev.conf配置文件加入WIFI无线网卡的热拔插事件：12# hceng add for wifiwlan0 root:root 660 * /sbin/auto_wifi.sh 其中*表示插拔都执行后面的脚本。 2.自动连接脚本/sbin/auto_wifi.sh但检测到USB网卡插拔后，就会执行该脚本：[auto_wifi.sh]link123456789101112#!/bin/shif [ $ACTION = \"add\" ];then echo --------usb wifi connect--------- &gt; /dev/console wpa_supplicant -B -d -i wlan0 -c /etc/wpa_supplicant.conf wpa_cli -B -i wlan0 -a/sbin/auto_dhcp.shelse echo --------usb wifi disconnect--------- &gt; /dev/console killall wpa_supplicant killall wpa_cli killall dhclientfi 如果是插入USB无线网卡，将执行wpa_supplicant -B -d -i wlan0 -c /etc/wpa_supplicant.conf连接wifi，再执行wpa_cli -B -i wlan0 -a/sbin/auto_dhcp.sh调用dhcp的脚本； 如果是拔出USB无线网卡，将清除所有相关进程； 3.自动dhcp脚本/sbin/auto_dhcp.sh[auto_dhcp.sh]link1234567891011#!/bin/shIFNAME=$1CMD=$2if [ \"$CMD\" = \"CONNECTED\" ]; then echo ========connect $IFNAME, dhclient for it======= &gt; /dev/console dhclient $IFNAMEfiif [ \"$CMD\" = \"DISCONNECTED\" ]; then echo ========disconnect $IFNAME, kill dhclient for it======= &gt; /dev/console killall dhclientfi 如果是连接，将调用dhclient分配IP，反之清除dhclient进程。 4.为脚本加上可执行权限12chmod +x /sbin/auto_wifi.shchmod +x /sbin/auto_dhcp.sh 最后便可实现自动连接WIFI，且自动获取IP地址。 3.无线热点模式——AP无线热点模式共需要两步操作，先使用hostapd将无线网卡切换成AP模式，再使用dhcpd分配IP。 3.1 hostapd的使用先清除前面STA模式的所有操作，重新启动单板。 创建/etc/hostapd.conf配置文件 1.OPEN模式：123456ctrl_interface=/var/run/hostapdssid=hcengchannel=1interface=wlan0driver=nl80211 2.WAP/WAP2模式：123456789101112131415161718ctrl_interface=/var/run/hostapdssid=hceng#hw_mode=gchannel=1interface=wlan0#bridge=br0driver=nl80211macaddr_acl=0#accept_mac_file=/etc/hostapd.accept#deny_mac_file=/etc/hostapd.denyauth_algs=1wpa=3wpa_passphrase=12345678wpa_key_mgmt=WPA-PSKwpa_pairwise=TKIPrsn_pairwise=CCMP 注释：ctrl_interface：为了后面hostapd_cli链接上hostapd；ssid：无线热点名字；hw_mode：指定802.11协议，其中a=IEEE 802.11a，b=IEEE 802.11b， g=IEEE 802.11g；channel：设定无线信道；interface：指定使用哪一个无线网卡；bridge：指定所处网桥，对于一个同时接入公网、提供内部网和无线接入的路由器来说，设定网桥很有必要；driver：指定无线驱动；macaddr_acl：指定MAC地址过滤规则： 0表示允许除禁止列表外的设备； 1表示只允许在允许列表的设备； 2表示使用外部RADIUS服务器；accept_mac_file：指定允许MAC列表文件所在路径；deny_mac_file：指定禁止MAC列表文件所在路径；auth_algs：指定采用哪种认证算法，采用位域(bit fields)方式来制定； 1表示使用WPA； 2表示使用WEP； 3表示使用WPA/WEP；wpa：指定WPA类型，采用位域(bit fields)方式来制定； 1表示使用WPA； 2表示使用WPA2； 3表示使用WPA2/WPA；wpa_passphrase：WIFI的密钥；wpa_key_mgmt：PSK为个人AP，不使用服务器认证；wpa_pairwise：指定WPA的加密方式；rsn_pairwise：指定WPA2的加密方式； 3.2 dhcpd的使用如果此时启动热点，实测手机一直卡在获取IP地址，无法连接到热点，因此热点还需自动分配IP地址。 编辑/etc/dhcpcd.conf配置文件将原来的/etc/dhcpcd.conf复制备份，再修改配置文件如下：12345subnet 192.168.2.0 netmask 255.255.255.0 &#123; range 192.168.2.10 192.168.2.100; option domain-name-servers 192.168.2.1; option routers 192.168.2.1;&#125; 指定了子网IP起始地址、子网掩码、动态分配的IP范围、DNS服务器、路由。 3.3 启动热点 1.启动无线网卡，并设置IP 12ifconfig wlan0 upifconfig wlan0 192.168.2.1 2.启动AP和DHCP启动命令： 12hostapd -B /etc/hostapd.confdhcpd -cf /etc/dhcpcd.conf wlan0 对应的停止命令：12killall hostapdkillall dhcpd 3.其它操作查看热点状态：1hostapd_cli all_sta 查看热点配置：1hostapd_cli get_config 查看已连接的设备：1iw dev wlan0 station dump 3.4 自动脚本和前面的一样，假如希望实现USB无线网卡的热拔插，自动进入AP模式，只需如下操作： 1.首先修改/etc/mdev.conf配置文件加入WIFI无线网卡的热拔插事件： 123# hceng add for wifi#wlan0 root:root 660 * /sbin/auto_wifi.shwlan0 root:root 660 * /sbin/auto_wifi_ap.sh 2.自动AP脚本/sbin/auto_wifi_ap.sh但检测到USB网卡插拔后，就会执行该脚本： [auto_wifi_ap.sh]link12345678910111213#!/bin/shif [ $ACTION = \"add\" ];then echo --------usb wifi connect--------- &gt; /dev/console hostapd -B /etc/hostapd.conf ifconfig wlan0 192.168.2.1 dhcpd -cf /etc/dhcpcd.conf wlan0else echo --------usb wifi disconnect--------- &gt; /dev/console killall hostapd killall dhcpdfi 3.为脚本添加可执行权限执行： 1chmod +x /sbin/auto_wifi_ap.sh 之后就插上无线网卡，就自动启动了热点；拔掉无线网卡，就自动关闭热点。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux环境编程","slug":"Linux环境编程","permalink":"http://yoursite.com/tags/Linux环境编程/"},{"name":"WiFi网卡","slug":"WiFi网卡","permalink":"http://yoursite.com/tags/WiFi网卡/"}]},{"title":"Linux摄像头驱动4——CMOS摄像头","date":"2018-05-20T08:02:12.000Z","path":"2018/05/20/Linux摄像头驱动4——CMOS摄像头/","text":"Linux摄像头驱动学习第四篇，对CMOS摄像头进行学习，实现在Tiny4412上使用CMOS摄像头采集图像，在LCD上显示图像。坚持到了Linux摄像头学习的最后一部分——CMOS摄像头。写完本篇博客后，摄像头部分就暂告一个段落，希望以后有机会继续接触更多。 1.CMOS摄像头基础本次使用的是百问网提供的OV7740摄像头模块，先对该模块的基础知识进行整理。 CMOS摄像头是指采用CMOS图像传感器的摄像头。CMOS摄像头的结构一般如下： 1.1 摄像头参数根据OV7740的datasheet可以得到以下特性和参数： support for output formats: RAW RGB and YUV output formats: 8-/10-bit RAW RGB data, 8-bit YUV [注1] support for image sizes: VGA, and QVGA, CIF and any size smaller [注2] active array size: 656 x 488 lens size: 1/5” pixel size: 4.2 μm x 4.2 μm [注3] input clock frequency: 6 ~ 27 MHz [注4] scan mode: progressive [注5] [注1]①:输出的格式支持8/10bit的RAW RGB格式，8bit的YUV格式；②:RAW RGB就只有红绿蓝三种颜色的数据，而RGB数据不仅只表示红绿蓝三种颜色，还能表示由红绿蓝组合成的任何一种颜色；③:YUV:由Y(亮度信号)、U(R-Y的色差信号)、V(B-Y的色差信号)组成，与RGB是两种不同描述颜色的方法，它们的转换公式如下(RGB取值范围均为0-255)： 1234567 Y = 0.299R + 0.587G + 0.114B U = -0.147R - 0.289G + 0.436B V = 0.615R - 0.515G - 0.100B R = Y + 1.14V G = Y - 0.39U - 0.58V B = Y + 2.03U [注2]输出分辨率为：VGA(640x480)、QVGA(240x320)、CIF(352x288)、其它更小的任意大小； [注3]①:有效感光阵列的大小:656 x 488 = 320128(30W)，指感光区域内单像素点的数量，像素越多，拍摄画面幅面就越大，可拍摄的画面的细节就越多；②:镜头大小：1/5寸，指感光区域对角线距离，尺寸越大，材料成本越高；③:像素大小: 4.2μm x 4.2μm，指单个感光元件的长宽尺寸，也称单像素的开口尺寸，开口尺寸越大，单位时间内进入的光量就越大，芯片整体性能就相对较高，最终拍摄画面的整体画质相对较优秀； 单像素尺寸是图像传感器一个相当关键的参数，也就是都号称1200万像素的相机和手机，相机的效果远远好于手机的原因。手机由于体积限制，尽管像素很多，但每个像素都很小，拍摄瞬间进光量也小，成像质量就自然差一些了。 [注4]输入时钟频率: 6~27MHz即0V7740摄像头模组的工作时钟范围，这个将由SOC提供给CMOS； [注5]扫描模式: 连续扫描(P)扫描方式一般分为”逐行扫描”(P)和”隔行扫描”(I)两种。逐行扫描:每一帧图像由电子束顺序地一行接着一行连续扫描而成；隔行扫描:把每一帧图像通过两场扫描完成则是隔行扫描，两场扫描中，第一场（奇数场）只扫描奇数行，依次扫描1、3、5…行，而第二场（偶数场）只扫描偶数行，依次扫描2、4、6…行。隔行扫描技术在传送信号带宽不够的情况下起了很大作用，逐行扫描和隔行扫描的显示效果主要区别在稳定性上面，隔行扫描的行间闪烁比较明显，逐行扫描克服了隔行扫描的缺点，画面平滑自然无闪烁。 再来看看OV7740的内部数据处理框图： 分为了三部分： image sensor core(ISC)功能：图像翻转、增益大小调整、黑电平校准、饱和度的控制、OTP存储器； image sensor processor(ISP)功能：提供测试功能、镜头补偿功能、自动白平衡、颜色空间的转换功能（RAW RGB-&gt;RGB、RGB-&gt;YUV）、窗口功能(自动裁剪图片)、缩小放大功能； image output interface(ISI)功能：RAW RGB/YUV(图片数据格式)、VGA/QVGA、BT601/BT656BT601有独立的行同步信号线、帧同步信号线，而BT656是将这两种信号内嵌到数据中； 1.2 硬件接口CMOS摄像头模块对外的接口如下： 对应接到Tiny4412的引脚： 按功能可以将接口分为两类： 控制类： 名字 功能 I2CSDA I2C总线的数据线 I2CSCL I2C总线的时钟线 功能：①：初始化：对摄像头模块进行相应的初始化操作，让摄像头模块能够正常的输出摄像头数据；②：控制: 设置亮度、旋转、缩放等操作； 数据传输类： 名字 功能 输入/输出(针对模块) CAMRST 复位CMOS摄像头模块 Input CAMCLK 摄像头模块工作的系统时钟(24MHz) Input CAM_HREF 行同步信号 Output CAM_VSYNC 帧同步信号 Output CAM_PCLK 像素时钟 Output CAMDATA0~7 八根数据线 Output 功能：传输图像数据，类似LCD的RGB接口； 摄像头工作流程：首先SOC输出MCLK给摄像头提供时钟，然后控制CAMRST复位摄像头，再通过I2C初始化、设置摄像头，最后在HREF、VSYNC和PCLK的控制下，通过D0~D7这八根数据线将数据发给SOC。 1.3 Camera控制器前面所示的电路是ITU-R BT-601/656接口，除此之外，Exynos4412还支持AXI-bus接口和MIPI (CSI)接口。Exynos4412通过CAMIF(Camera Interface)来选择输入源等操作。就目前了解的来看，高像素的摄像头一般采用MIPI(CSI)接口。这里使用的是ITU-R BT-601接口，后面有机会再试试MIPI(CSI)接口。 摄像头的采集的数据CPU一般不直接处理，主控芯片里面集成了Camera控制器FIMC(FullyInteractive Mobile Camera)来处理。摄像头先把图像数据传给Camera控制器，经过控制器处理(裁剪拉升后直接预览或者编码)之后交给CPU处理。实际上摄像头工作需要的时钟(MCLK)也是FIMC给它提供的。 摄像头的驱动主要分为两部分:一部分由模组厂家或者sensor厂家提供的初始化代码，通常是一段数组，通过I2C 总线来控制，用于设置sensor 寄存器，使用时一般不需要修改，如需调整，也由模组厂家完成；另外一部分是应用处理器端的代码，这部分需要各个平台自行开发，在Exynos4412中就是CAMIF和FIMC。 CMOS摄像头模块，实质上是一个I2C设备。通过I2C设置、控制摄像头，SOC的摄像头控制器(CAMIF和FIMC)负责数据的处理。因此后面CMOS驱动的核心就是：I2C设备驱动+CAMIF驱动+FIMC驱动。 2.遇到问题1.实测OV7740模块I2C通信时，必须要提供PCLK，而不是MCLK，这里和理解的刚好相反，检查硬件也没发现什么问题，待解决；2.内核自带了FIMC驱动、CAMIF驱动是非4412的，用起来悬，没找到相关成功的demo，测试摸索了一段时间无果，功力不够，决定暂时搁置，回头再来研究； 12345bakup：# 2.驱动框架 ### 1.1 设备树文件 ### 3.寄存器分析 ## 4.测试 # 参考资料：camera理论基础和工作原理详细的摄像头模组工作原理(使用samsung系列处理器) 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"摄像头","slug":"摄像头","permalink":"http://yoursite.com/tags/摄像头/"},{"name":"CMOS","slug":"CMOS","permalink":"http://yoursite.com/tags/CMOS/"}]},{"title":"Linux摄像头驱动3——LCD显示","date":"2018-05-18T08:01:05.000Z","path":"2018/05/18/Linux摄像头驱动3——LCD显示/","text":"Linux摄像头驱动学习第三篇，在Tiny4412的LCD上显示摄像头采集图像。前面的UVC驱动，实现了在Ubuntu主机上显示摄像头采集的图像，但那不是最终目的，最终目的是在嵌入式设备上显示图像。本篇博客尝试写一个应用程序，实现USB摄像头采集的图像在Tiny4412的LCD上显示。所以本篇算不上驱动开发，更多的是Linux环境下编程。 1.将驱动加入内核在开始应用编程之前，需要先准备好驱动，在LCD上显示摄像头图像，至少需要三个驱动：LCD驱动、背光驱动、UVC驱动。这三个驱动都在前面写过了，只需要加载即可。以前都是使用的insmod xx.ko进行动态加载驱动，每次开发板上电后，都需要手动/脚本里加载驱动，有点麻烦。反观内核自带的驱动，使用make menuconfig进入图形配置界面里，找到对应的驱动，可以设置为Y(编译到内核)、M(编译成模块)、N(不编译)。当设置为Y后，进入系统后，就自带了该驱动，不再需要手动加载。 前者常用于调试阶段，就算驱动有问题，内核崩溃了，下次内核还能正常启动，修改驱动后重新加载，很方便。后者常用于发布阶段，加入到内核，就不能再修改了，也就少了一些加载驱动的操作。 本次就仿照内核的方式，使用make menuconfig将驱动直接加到内核里。在这之前需要理解三个文件： Kconfig：driver/下的每个目录都有，在内核配置时候，提供配置选项； Makefile：driver/下的每个目录都有，在编译的时候，判断是否加入内核； .config:在源码根目录下，作为最终的内核编译的依据； 因此，以上三个文件，是主要影响内核模块编译的文件，后面只需要修改这三个文件即可。 1.创建驱动目录在driver/目录下新建一个hceng_drv目录作为存放自己驱动源码的目录。 2.创建底层配置文件在driver/hceng_drv/下创建Kconfig和Makefile，并将驱动源码backlight_drv.c、lcd_drv.c、uvc_drv.c，也放在里面。编辑Kconfig如下： 1234567891011121314151617181920212223242526## Backlight &amp;&amp; LCD &amp;&amp; UVC device configuration#menu &quot;Hceng add driver&quot; config BACKLIGHT tristate &quot;Backlight support&quot; default y help This is backlight driver to tiny4412 from hceng. config LCD tristate &quot;LCD support&quot; depends on BACKLIGHT default y help This is LCD driver to tiny4412 from hceng. config UVC tristate &quot;UVC support&quot; depends on BACKLIGHT &amp;&amp; LCD default y help This is UVC driver to tiny4412 from hceng. endmenu 包含在menu/endmenu中的内容会成为Hceng add driver的子菜单；每一个子菜单项都是由config来定义的；congfig下方的tristate、depends on、default、help等为config的属性，用于定义该菜单项的类型、依赖项、默认值、帮助信息等； 编辑Makefile如下：123obj-$(CONFIG_BACKLIGHT) += backlight_drv.oobj-$(CONFIG_LCD) += lcd_drv.oobj-$(CONFIG_UVC) += uvc_drv.o 根据CONFIG_*是y、m还是n，再决定是否将后面的*.o编译到内核。这里的CONFIG_*就是由最后的.config决定。 3.编辑上级配置文件这里我的hceng_drv/上级是driver/，因此修改driver/下的Kconfig和Makefile。修改Kconfig，在menu/endmenu之间的任意位置添加：1source &quot;drivers/hceng_drv/Kconfig&quot; 这里的写的位置，会影响在make menuconfig，即这里写得比较靠前，在配置界面也是比较靠前。 修改Makefile，在任意位置添加：123obj-$(CONFIG_BACKLIGHT) += hceng_drv/obj-$(CONFIG_LCD) += hceng_drv/obj-$(CONFIG_UVC) += hceng_drv/ 4.配置执行make menuconfig，在配置界面找到：12Device Drivers ---&gt; Hceng add driver ---&gt; 将添加的三个驱动勾选上，最后保存、退出，就将更改的内容写到了.config。最后重新make编译，也得到添加自己驱动的内核。 也可以直接修改.config配置文件，加入：123CONFIG_BACKLIGHT=yCONFIG_LCD=yCONFIG_UVC=y 再make，也一样得到添加自己驱动的内核。 2.软件框架①:首先从摄像头获取数据放入video_buf，数据的格式(YUV、MJPEG、RGB)和分辨率可能有多种；②:Tiny4412的LCD仅支持RGB格式，因此需要数据格式转换；③:Tiny4412的LCD分辨率是800X480，因此可能需要大小缩放；④:根据LCD显示流程，必须要将显示数据写入显存(FrameBuffer)；⑤:最后LCD控制器会将显存数据自动搬运到LCD/VGA等显示设备上； 在应用编程中，要习惯面向对象编程(Object Oriented Programming)，也就是把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数，在C语言中常常用结构体(struct)来实现。 关于Linux内核C语言中的面向对象的实现，可以参考这篇博客，介绍了如何C语言实现面向对象，也通过这个能稍微理解Linux驱动中的操作函数的原理。 这里，模仿内核的编程框架，为每个模块实现一个管理链表，模块对应加入链表，再调用对应的操作函数，框架如下： 这个框架，在这里暂时不能体会到它的优势，以后接触多了，应该就能感受了。 简单说明下这个框架，主要有四个模块:video用于摄像头数据采集，convert用于格式转换、process用于缩放等操作、dispaly用于显示。以convert为例，有一个manager管理每个子模块，将每个子模块放入链表，向上提供统一的操作接口，调用对应文件的操作函数。 3.编程_获取摄像头数据使用结构体video_device来表示摄像头设备，包含了设备的文件句柄、像素格式、分辨率、buf信息、操作函数等：1234567891011121314151617181920212223242526272829303132typedef struct video_device &#123; int fd; //文件句柄 int pixel_format; //像素格式 int width, height; //分辨率:宽*高 int buf_count; //buf数量 int buf_maxlen; //每个buf最大长度 int buf_cur_index; //当前buf索引 unsigned char *video_buf[VIDEO_BUFFER_NUM]; //每个video buf的地址 //操作函数 p_video_operations p_video_fops; &#125;video_device, *p_video_device;//摄像头设备的操作函数typedef struct video_operations &#123; char *name; int (*init_device)(char *dev_name, p_video_device p_video_dev); int (*exit_device)(p_video_device p_video_dev); int (*get_format)(p_video_device p_video_dev); int (*get_frame)(p_video_device p_video_dev, p_video_buffer p_video_buf); int (*put_frame)(p_video_device p_video_dev, p_video_buffer p_video_buf); int (*start_device)(p_video_device p_video_dev); int (*stop_device)(p_video_device p_video_dev); struct video_operations *p_next;&#125;video_operations, *p_video_operations; 使用结构体video_buffer来表示摄像头采集的数据，包含每帧数据信息、像素格式等：12345678910111213141516//图片像素的数据typedef struct pixel_datas &#123; int width; //宽度: 一行有多少个像素 int height; //高度: 一列有多少个像素 int bpp; //一个像素用多少位来表示 int line_bytes; //一行数据有多少字节 int total_bytes; //所有字节数 unsigned char *pixel_datas_addr; //像素数据存储的地址&#125;pixel_datas, *p_pixel_datas;//摄像头的数据typedef struct video_buffer &#123; pixel_datas pixel_datas; //图片像素的数据 int pixel_format; //像素的格式&#125;video_buffer, *p_video_buffer; 3.1 video_manager.cvideo_manager.c主要功能是操作video_operations构成的链表，涉及的函数有：123int register_video_ops(p_video_operations p_video_ops);void show_video_ops(void);p_video_operations get_video_ops(char *name);此外，通过video_device_init()初始化链表上指定设备节点的设备，通过video_init()注册设备。 对链表的操作比较简单，见GitHub。 3.2 v4l2.c首先构建一个video_operations结构体，然后注册并具体实现函数的功能。12345678910111213141516171819202122//构造一个video_operations结构体static video_operations v4l2_video_ops =&#123; .name = \"v4l2\", .init_device = v4l2_init_device, .exit_device = v4l2_exit_device, .get_format = v4l2_get_format, .get_frame = v4l2_get_frame_streaming, .put_frame = v4l2_put_frame_streaming, .start_device = v4l2_start_device, .stop_device = v4l2_stop_device,&#125;;/* 注册这个结构体 */int v4l2_init(void)&#123; return register_video_ops(&amp;v4l2_video_ops);&#125; 首先是v4l2_init_device()，它的内容比较多，前面写uvc驱动的时候，对应用层的操作其实都脑补了一遍，包含的步骤如下: 1.VIDIOC_QUERYCAP:获取设备信息(是否为摄像头、名字、版本等)2.VIDIOC_ENUM_FMT:查询支持哪些种格式3.VIDIOC_S_FMT:设置设备使用何种格式4.VIDIOC_REQBUFS:申请buf5.根据接口类型进行对应操作(streaming接口需要映射) streaming接口： 6.1查询分配的buf(获得每个buf大小、偏移) 6.2映射buf到用户空间(将用户空间buf和内核空间buf 进行绑定) 6.3将映射的buf放入驱动的buf队列 readwrite接口： 7.1准备read()所需参数 这样一系列操作后，p_video_dev就包含了几乎摄像头设备的所有信息。 对于streaming接口，使用v4l2_get_frame_streaming()和v4l2_put_frame_streaming()来获取数据。首先poll()查询是否有数据，使用VIDIOC_DQBUF从队列取出数据，最后再VIDIOC_QBUF放入队列。 对于streaming接口，使用v4l2_get_frame_readwrite()来获取数据。 无论是何种方式，最后p_video_buf就包含了摄像头采集的图像数据。 4.编程_格式转换前面的UVC驱动，通过USB设备描述符知道了摄像头图像数据格式是MJPEG，而LCD只支持RGB格式，且前面LCD驱动，设置的LCD为RGB32格式。因此这里需要把MJPEG转换成RGB32格式。 使用结构体video_convert来表示一种转换，包含名字、判断是否支持转换、转换等：12345678typedef struct video_convert&#123; char *name; int (*judge_support)(int pixel_format_in, int pixel_format_out); int (*convert)(p_video_buffer video_buf_in, p_video_buffer video_buf_out); int (*convert_exit)(p_video_buffer video_buf_out); struct video_convert *p_next;&#125; video_convert, *p_video_convert; 4.1 convert_manager.c这里依旧使用链表来管理，这里有三类转换：MJPEG转RGB、YUV转RGB、RGB转RGB，将它们都放到链表中，通过get_video_convert_format()传入待转换的格式，从链表中依次查询谁支持该转换，如果支持，就得到p_video_convert，就可以调用到对应的操作函数。从这个例子中，稍微能感受到这个框架的优势，添加新格式的话，将变得很容易。具体的链表操作和前面的差不多。 4.2 mjpeg2rgb.c目前只是需要实现USB摄像头的MJPEG转RGB，所以暂时只对mjpeg2rgb.c分析。需要实现video_convert里构造函数，其中转换的过程是调用的libjpeg库，其转换流程在LCD驱动_5.测试程序中有详细的分析，这里只对两个不同点就行分析。 1.转换错误处理函数libjpeg库自带的转换错误处理函数在出错时，会退出程序。但在将摄像头图像转换的过程中，某一帧出现问题，可以忽略过去，画面顶多卡顿一下，为了不让程序退出，需要自己定义错误处理函数，并绑定。 12345678910111213141516171819202122232425typedef struct my_error_mgr&#123; struct jpeg_error_mgr pub; jmp_buf setjmp_buffer;&#125;my_error_mgr, *p_my_error_mgr;//参考libjpeg里的bmp.c,自定义的libjpeg库出错处理函数://默认的错误处理函数是让程序退出,这里不让程序退出static void my_error_exit(j_common_ptr cinfo)&#123; static char err_str[JMSG_LENGTH_MAX]; p_my_error_mgr my_err = (p_my_error_mgr)cinfo-&gt;err; /* Create the message */ (*cinfo-&gt;err-&gt;format_message) (cinfo, err_str); printf_debug(\"%s\\n\", err_str); longjmp(my_err-&gt;setjmp_buffer, 1);&#125;…… cinfo.err = jpeg_std_error(&amp;jerr.pub); //绑定jerr错误结构体至jpeg对象结构体 jerr.pub.error_exit = my_error_exit; //设置为自己定义的出错处理函数 2.BPP转换前面LCD驱动里，将LCD设置为了RGB32(实际还是RGB24，多出来的没有使用)，而摄像头采集的数据格式为RGB24，因此需要RGB24转RGB32。 如果源bpp和目标bpp一致，直接memcpy()复制，长度就是宽的像素个数x每个像素由3*8位构成/8位构成一字节：width\\*(8+8+8)/8=width\\*3如果是24BPP转32BPP，需要把源数据变长： 123456789101112131415161718192021222324252627282930313233343536373839404142//把已经从JPG文件取出的一行像素数据,转换为能在显示设备上使用的格式static int covert_one_line(int width, int scr_bpp, int dst_bpp, unsigned char *scr_datas, unsigned char *dst_datas)&#123; int i; int pos = 0; unsigned int red, green, blue, color; unsigned short *dst_datas_16bpp = (unsigned short *)dst_datas; unsigned int *dst_datas_32bpp = (unsigned int *)dst_datas; if (scr_bpp != 24) return -1; if (dst_bpp == 24) memcpy(dst_datas, scr_datas, width*3); //len=width*(8+8+8)/8=width*3 else &#123; for (i = 0; i &lt; width; i++) &#123; red = scr_datas[pos++]; green = scr_datas[pos++]; blue = scr_datas[pos++]; if (dst_bpp == 32) &#123; color = (red &lt;&lt; 16) | (green &lt;&lt; 8) | blue; *dst_datas_32bpp = color; dst_datas_32bpp++; &#125; else if (dst_bpp == 16) &#123; /* 565 */ red = red &gt;&gt; 3; green = green &gt;&gt; 2; blue = blue&gt;&gt; 3; color = (red &lt;&lt; 11) | (green &lt;&lt; 5) | (blue); *dst_datas_16bpp = color; dst_datas_16bpp++; &#125; &#125; &#125; return 0;&#125; 即先定义一个unsigned int *类型的指针dst_datas_32bpp，先提取出r、g、b，再组成新格式，复制给指针指向的变量，由于是unsigned int *类型的指针，指针每增加1，实际移动32位，即刚好指向下一个像素。连续操作后，dst_datas指针指向的位置，就是转换后的数据开始位置。 5.编程_图像处理处理部分有两个操作，一个是图像的缩放，一个是将图片放在Framebuffer指定位置。 5.1 zoom.c图像的缩放算法没有去深入研究，这里只简单的学习了下近邻取样插值缩放法。巧的是LCD分辨率是800*480，摄像头采集的图片分辨率是640*480，两者的宽是一样的，实际上并没有用到缩放。缩放的原理还是比较简单，图片 某个像素的长/宽 与 图片的长/宽 比值是始终不变的，根据这一规则，可以得到坐标的两个关系： 因此，已知缩放后图片中的任意一点(Dx, Dy)，可以求得其对应的原图片中的点Sx=Dx*Sw/Dw，Sy=Dy*Sh/Dh，然后直接复制对应原图图像数据到对应的缩放后的图片位置。此外，为了避免每行重复计算，先将Sx=Dx*Sw/Dw的计算结果保存下来，在每行的处理里直接调用。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//近邻取样插值方法缩放图片int pic_zoom(p_pixel_datas origin_pic, p_pixel_datas zoom_pic)&#123; unsigned long x, y; unsigned long scr_y; unsigned char *scr, *dest; unsigned long *src_x_table; unsigned long dst_width = zoom_pic-&gt;width; unsigned long pixel_bytes = origin_pic-&gt;bpp / 8; printf_debug(\"src:\\n\"); printf_debug(\"%d x %d, %d bpp, data: 0x%x\\n\", origin_pic-&gt;width, origin_pic-&gt;height, origin_pic-&gt;bpp, (unsigned int)origin_pic-&gt;pixel_datas_addr); printf_debug(\"dest:\\n\"); printf_debug(\"%d x %d, %d bpp, data: 0x%x\\n\", zoom_pic-&gt;width, zoom_pic-&gt;height, zoom_pic-&gt;bpp, (unsigned int)zoom_pic-&gt;pixel_datas_addr); if (origin_pic-&gt;bpp != zoom_pic-&gt;bpp) return -1; src_x_table = malloc(sizeof(unsigned long) * dst_width); if (NULL == src_x_table) &#123; printf_debug(\"malloc error!\\n\"); return -1; &#125; for (x = 0; x &lt; dst_width; x++) //生成表 src_x_table src_x_table[x] = (x * origin_pic-&gt;width / zoom_pic-&gt;width); for (y = 0; y &lt; zoom_pic-&gt;height; y++) &#123; scr_y = (y * origin_pic-&gt;height / zoom_pic-&gt;height); dest = zoom_pic-&gt;pixel_datas_addr + y * zoom_pic-&gt;line_bytes; scr = origin_pic-&gt;pixel_datas_addr + scr_y * origin_pic-&gt;line_bytes; for (x = 0; x &lt; dst_width; x++) &#123; //原图座标: src_x_table[x]，src_y 缩放座标: x, y memcpy(dest + x * pixel_bytes, scr + src_x_table[x]*pixel_bytes, pixel_bytes); &#125; &#125; free(src_x_table); return 0;&#125; 5.2 merge.c使用pic_merge()函数来实现将图片放在Framebuffer指定位置。前面得到了经过缩放(图片的宽和LCD的宽一致)的图片数据，知道了这个数据的地址，理论上直接放到Frambuffer的起始地址即可，这样图片会以LCD左上角为基点显示图片，显示出来效果如下图1，此情况理想的效果应该如图2所示；如果图片缩放后宽和LCD的宽还不一致，且又把图片数据直接放到Frambuffer的起始地址，则显示效果如图3，此情况理想的效果应该如图4所示； 以图4的极端情况为例，要想图片居中显示，需要(x，y)的坐标，这个简单，用(LCD宽-图片宽)/2得到x，用(LCD高-图片高)/2得到y。还需要将以(0,0)为起点的图片数据，依次复制到以(x，y)为起点，新地址的偏移就是(x，y)前的全部数据。1234567891011121314151617181920212223//将图片放在Framebuffer指定位置int pic_merge(int x, int y, p_pixel_datas small_pic, p_pixel_datas big_pic)&#123; int i; unsigned char *scr; unsigned char *dst; if ((small_pic-&gt;width &gt; big_pic-&gt;width) || (small_pic-&gt;height &gt; big_pic-&gt;height) || (small_pic-&gt;bpp != big_pic-&gt;bpp)) return -1; scr = small_pic-&gt;pixel_datas_addr; //目标地址的偏移就是指定坐标之前的所有数据:y*每行数据+x的数据 dst = big_pic-&gt;pixel_datas_addr + y * big_pic-&gt;line_bytes + x * big_pic-&gt;bpp / 8; for (i = 0; i &lt; small_pic-&gt;height; i++) &#123; memcpy(dst, scr, small_pic-&gt;line_bytes); scr += small_pic-&gt;line_bytes; dst += big_pic-&gt;line_bytes; &#125; return 0;&#125; 6.编程_图像显示使用结构体disp_operations来表示显示操作：12345678910111213typedef struct disp_operations &#123; char *name; //显示模块的名字 int x_res; //X分辨率 int y_res; //Y分辨率 int bpp; //一个像素用多少位来表示 int line_width; //一行数据占据多少字节 unsigned char *dis_mem_addr; //显存地址 int (*device_init)(char *name); //设备初始化函数 int (*show_pixel)(int pen_x, int pen_y, unsigned int color); //把指定座标的像素设为某颜色 int (*clean_screen)(unsigned int back_color); //清屏为某颜色 int (*show_page)(p_pixel_datas p_pixel_data); //显示一页,数据源自p_video_mem struct disp_operations *p_next; //链表&#125;disp_operations, *p_disp_operations; 6.1 disp_manager.c还是用链表的方式管理图像显示模块，这里的图像显示模块就一个LCD。除了常规的注册、显示、获取ops的函数，还有选中指定显示模块并初始化select_and_init_disp_dev()，获取显示设备的参数get_disp_resolution()，获取显示设备的buf信息get_video_buf_for_disp()，以及LCD显示flush_pixel_datas_to_dev()。 6.2 lcd.clcd.c里填充disp_operations结构体的四个操作函数。 device_init()里通过ioctl()和mmap()得到LCD的可变参数和映射地址，保存到disp_operations结构体里； fb_show_pixel()用来显示一个像素，根据BPP不同，对传入的颜色进行对应处理，放在基地址后的坐标偏移； fb_clean_screen()用于全屏显示一种颜色，用于清屏； fb_show_page()用于显示整屏图像，即将数据复制到显存位置； 7.编程_主函数完成了以上各个模块的函数，现在就在主函数里组织起来。程序框图如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194static void print_help(void)&#123; printf(\"Usage: video2lcd [options]... [FILE]...\\n\"); printf(\"The LCD displays the image captured by the camera.\\n\"); printf(\"Options:\\n\"); printf(\"\\t\" \"-v\" \"\\t\\tSelect the camera device, default: /dev/video0\\n\"); printf(\"\\t\" \"-d\" \"\\t\\tSelect the lcd display device, default: /dev/fb0\\n\"); printf(\"\\t\" \"-h\" \"\\t\\tDisplay this information.\\n\");&#125;static void stop_app(int signo)&#123; printf(\"\\nexit.\\n\"); _exit(0);&#125;int main(int argc, char **argv)&#123; int i, ret; float k; video_device video_dev; p_video_convert video_conv; int pixel_formt_of_video, pixel_formt_of_disp; int top_left_x, top_left_y; int lcd_width, lcd_height, lcd_bpp; p_video_buffer video_buf_cur; video_buffer video_buf, convert_buf, zoom_buf, frame_buf; char *get_argv[2] = &#123;&#125;; signal(SIGINT, stop_app); //0.传入参数判断 for(i = 1; i &lt; argc; i++) &#123; if (!strcmp(\"-v\", argv[i])) &#123; if(NULL == argv[i + 1]) &#123; print_help(); return -1; &#125; else get_argv[0] = argv[i + 1]; &#125; else if (!strcmp(\"-d\", argv[i])) &#123; if(NULL == argv[i + 1]) &#123; print_help(); return -1; &#125; else get_argv[1] = argv[i + 1]; &#125; else if (!strcmp(\"-h\", argv[i])) &#123; print_help(); return 0; &#125; &#125; //1.初始化显示设备并获取显示设备参数 display_init(); //注册所有显示设备(fb和crt) if (get_argv[1] == NULL) //选择和初始化指定的显示设备 select_and_init_disp_dev(\"lcd\", \"/dev/fb0\"); //default:lcd的/dev/fb0 else select_and_init_disp_dev(\"lcd\", get_argv[1]); get_disp_resolution(&amp;lcd_width, &amp;lcd_height, &amp;lcd_bpp); //获取设备的分辨率和支持的bpp get_video_buf_for_disp(&amp;frame_buf); //得到显存的各种信息(分辨率、bpp、大小、地址等) pixel_formt_of_disp = frame_buf.pixel_format; //2.初始化采集设备 video_init(); //注册所有图像采集设备(v4l2协议) ret = video_device_init(get_argv[0], &amp;video_dev); //初始化指定的/dev/video0 if (ret) &#123; printf_debug(\"video_device_init for %s error!\\n\", get_argv[0]); return -1; &#125; pixel_formt_of_video = video_dev.p_video_fops-&gt;get_format(&amp;video_dev); //获取视频格式 //3.转换初始化 video_convert_init(); //注册所有支持的转换方式(yuv、mjpeg、rgb) //传入采集设备格式和显示设备支持格式,在链表里依次判断是否支持该格式转换 video_conv = get_video_convert_format(pixel_formt_of_video, pixel_formt_of_disp); if (NULL == video_conv) &#123; printf_debug(\"Can not support this format convert\\n\"); return -1; &#125; //4.启动摄像头设备 ret = video_dev.p_video_fops-&gt;start_device(&amp;video_dev); if (ret) &#123; printf_debug(\"start_device for %s error!\\n\", get_argv[0]); return -1; &#125; memset(&amp;video_buf, 0, sizeof(video_buf)); memset(&amp;convert_buf, 0, sizeof(convert_buf)); convert_buf.pixel_format = pixel_formt_of_disp; convert_buf.pixel_datas.bpp = lcd_bpp; memset(&amp;zoom_buf, 0, sizeof(zoom_buf)); while (1) &#123; //5.读入摄像头数据 ret = video_dev.p_video_fops-&gt;get_frame(&amp;video_dev, &amp;video_buf); if (ret) &#123; printf_debug(\"get_frame for %s error!\\n\", get_argv[0]); return -1; &#125; video_buf_cur = &amp;video_buf; if (pixel_formt_of_video != pixel_formt_of_disp) //采集的图像格式和显示的图像格式不一致 &#123; //6.格式转换 ret = video_conv-&gt;convert(&amp;video_buf, &amp;convert_buf); if (ret) &#123; printf_debug(\"convert for %s error!\\n\", get_argv[0]); return -1; &#125; video_buf_cur = &amp;convert_buf; &#125; //现在video_buf_cur就是最后的图像数据 //7.如果图像分辨率大于LCD, 缩放 if ((video_buf_cur-&gt;pixel_datas.width &gt; lcd_width) || (video_buf_cur-&gt;pixel_datas.height &gt; lcd_height)) &#123; //确定缩放后的分辨率 //把图片按比例缩放到video_mem上, 居中显示 //1. 先算出缩放后的大小 k = (float)video_buf_cur-&gt;pixel_datas.height / video_buf_cur-&gt;pixel_datas.width; //长宽比例 zoom_buf.pixel_datas.width = lcd_width; zoom_buf.pixel_datas.height = lcd_width * k; if ( zoom_buf.pixel_datas.height &gt; lcd_height) &#123; zoom_buf.pixel_datas.width = lcd_height / k; zoom_buf.pixel_datas.height = lcd_height; &#125; zoom_buf.pixel_datas.bpp = lcd_bpp; zoom_buf.pixel_datas.line_bytes = zoom_buf.pixel_datas.width * zoom_buf.pixel_datas.bpp / 8; zoom_buf.pixel_datas.total_bytes = zoom_buf.pixel_datas.line_bytes * zoom_buf.pixel_datas.height; if (!zoom_buf.pixel_datas.pixel_datas_addr) &#123; zoom_buf.pixel_datas.pixel_datas_addr = malloc(zoom_buf.pixel_datas.total_bytes); if (NULL == zoom_buf.pixel_datas.pixel_datas_addr) return -1; &#125; pic_zoom(&amp;video_buf_cur-&gt;pixel_datas, &amp;zoom_buf.pixel_datas); video_buf_cur = &amp;zoom_buf; &#125; //合并进framebuffer //接着算出居中显示时左上角坐标 top_left_x = (lcd_width - video_buf_cur-&gt;pixel_datas.width) / 2; top_left_y = (lcd_height - video_buf_cur-&gt;pixel_datas.height) / 2; pic_merge(top_left_x, top_left_y, &amp;video_buf_cur-&gt;pixel_datas, &amp;frame_buf.pixel_datas); flush_pixel_datas_to_dev(&amp;frame_buf.pixel_datas); ret = video_dev.p_video_fops-&gt;put_frame(&amp;video_dev, &amp;video_buf); if (ret) &#123; printf_debug(\"put_frame for %s error!\\n\", get_argv[0]); return -1; &#125; //把framebuffer的数据刷到LCD上, 显示 &#125; return 0;&#125; 8. Makefile最后，还需要用Makefile将整个工程组织编译。这里总结一个通用的Makefile模板。 8.1 基础知识首先总结一些基础知识： 常用通配符 12345%.o ——&gt; 表示所有的.o文件%.c ——&gt; 表示所有的.c文件$@ ——&gt; 表示目标$&lt; ——&gt; 表示第1个依赖文件$^ ——&gt; 表示所有依赖文件 常用变量 1234:= ——&gt; 即时变量，它的值在定义的时候确定；(可追加内容)= ——&gt; 延时变量，只有在使用到的时候才确定，在定义/等于时并没有确定下来；?= ——&gt; 延时变量, 如果是第1次定义才起效, 如果在前面该变量已定义则忽略；(不覆盖前面的定义)+= ——&gt; 附加, 它是即时变量还是延时变量取决于前面的定义； 常用参数 1234567-Wp,-MD,xx.o.d ——&gt; 生成依赖xx.o.d-I /xx ——&gt; 指定头文件(.h)目录xx-L /xx ——&gt; 指定库文件(.so)目录xx-Wall ——&gt; 打开gcc的所有警告-Werror ——&gt; 将所有的警告当成错误进行处理-O2 ——&gt; 优化等级-g ——&gt; gdb调试 常用函数 12345$(foreach var,list,text) ——&gt; 将list里面的每个成员,都作text处理$(filter pattern...,text) ——&gt; 在text中取出符合patten格式的值$(filter-out pattern...,text) ——&gt; 在text中取出不符合patten格式的值$(wildcard pattern) ——&gt; pattern定义了文件名的格式,wildcard取出其中存在的文件$(patsubst pattern,replacement,$(var)) ——&gt; 从列表中取出每一个值,如果符合pattern,则替换为replacement 举例：假设当前路径下有a.c b.c c.c Makefile四个文件，Makefile内容如下：123456789101112131415161718192021A = a b c B = $(foreach f, $(A), $(f).o)C = a b c d/D = $(filter %/, $(C))E = $(filter-out %/, $(C))files = $(wildcard *.c)files2 = a.c b.c c.c d.c e.c abcfiles3 = $(wildcard $(files2))dep_files = $(patsubst %.c,%.d,$(files2))all: @echo B = $(B) @echo D = $(D) @echo E = $(E) @echo files = $(files) @echo files3 = $(files3) @echo dep_files = $(dep_files) 执行结果：123456B = a.o b.o c.o //把A中每个成员加上后缀.oD = d/ //取出C中符合搜索条件&quot;/&quot;的成员，常用于取出文件夹E = a b c //取出C中不符合搜索条件&quot;/&quot;的成员，常用于取出非文件夹files = a.c b.c c.c //取出当前路径下的a.c b.c c.c三个文件，常用于得到当前路径的文件files3 = a.c b.c c.c //取出当前路径下存在的a.c b.c c.c三个文件，常用于判断文件是否存在dep_files = a.d b.d c.d d.d e.d abc //替换符合条件&quot;.c&quot;的文件为&quot;.d&quot;，常用于文件后缀的修改 8.2 Makefile分析下面对本程序的Makefile进行分析。在本程序中Makefile分为3类: 1.顶层目录的Makefile2.顶层目录的Makefile.build3.各级子目录的Makefile 1.顶层目录的Makefile它除了定义obj-y来指定根目录下要编进程序去的文件、子目录外，主要是定义工具链、编译参数、链接参数(即文件中用export导出的各变量)； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 1.定义编译工具简写并声明(以变其它文件可使用)CROSS_COMPILE = arm-linux-gnueabihf-AS = $(CROSS_COMPILE)asLD = $(CROSS_COMPILE)ldCC = $(CROSS_COMPILE)gccCPP = $(CC) -EAR = $(CROSS_COMPILE)arNM = $(CROSS_COMPILE)nm STRIP = $(CROSS_COMPILE)stripOBJCOPY = $(CROSS_COMPILE)objcopyOBJDUMP = $(CROSS_COMPILE)objdumpexport AS LD CC CPP AR NMexport STRIP OBJCOPY OBJDUMP# 2.定义编译选项并声明(警告信息、优化等级、gdb调试、指定本程序头文件路径)CFLAGS := -Wall -Werror -O2 -gCFLAGS += -I $(shell pwd)/includeexport CFLAGS# 3.定义链接选项并声明(数学库、LibJPEG库)LDFLAGS := -lm -ljpegexport LDFLAGS# 4.定义顶层目录路径并声明(shell命令实现)TOPDIR := $(shell pwd)export TOPDIR# 5.程序目标文件TARGET := video2lcd# 6.使用\"obj-y\"表示各个目标文件,即过程中的所有.o文件(包含当前路径文件和当前路径下的文件夹)obj-y += main.oobj-y += video/obj-y += convert/obj-y += process/obj-y += display/# 7. 目标all:# 7.1在-C指定目录下,执行指定路径下的文件(即在本路径执行Makefile.build)# 7.2依赖\"built-in.o\"生成最终的目标文件all : make -C ./ -f $(TOPDIR)/Makefile.build $(CC) -o $(TARGET) built-in.o $(LDFLAGS)# 8.目标clean:清除所有的.o文件和目标文件clean: rm -f $(shell find -name \"*.o\") rm -f $(TARGET)# 9.目标distclean:清除所有的.o文件、.d文件(依赖文件)和目标文件distclean: rm -f $(shell find -name \"*.o\") rm -f $(shell find -name \"*.d\") rm -f $(TARGET) 2.顶层目录的Makefile.build把某个目录及它的所有子目录中、需要编进程序去的文件都编译出来，打包为built-in.o； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 1.定义\"PHONY\"表示目标(目前包含一个目标:__build)PHONY := __build# 2.定义目标\"__build\"内容是下面的所有操作__build:# 3.定义\"obj-y\"表示当前路径的目标文件,定义\"subdir-y\"表示当前路径下目录的目标文件obj-y :=subdir-y :=# 4.包含当前路径的Makefile(为了获取\"obj-y\"的内容)include Makefile# 5. 得到当前路径下各目录名# 5.1filter函数从obj-y中筛选出含\"/\"的内容,即目录# 5.2patsubst函数将上述结果中的\"/\"替换为空,subdir-y即为当前路径的目录名(不含\"/\")__subdir-y := $(patsubst %/,%,$(filter %/, $(obj-y)))subdir-y += $(__subdir-y)#实测结果:第一次为[video convert process display],后面每次都为空#$(warning ------debug info:subdir-y=$(subdir-y)------)# 6.把\"obj-y\"都加上\"/built-in.o\"后缀subdir_objs := $(foreach f,$(subdir-y),$(f)/built-in.o)#实测结果:第一次为[video/built-in.o convert/built-in.o ……],后面每次都为空#$(warning ------debug info:subdir_objs=$(subdir_objs)------)# 7.得到\"obj-y\"中的非文件夹文件(即各个.o文件)cur_objs := $(filter-out %/, $(obj-y))# 8. 得到依赖文件(.d文件)# 8.1foreach把前面的*.o文件变为.*.o.d(这是当前目录Makefile提供的数据)# 8.2wildcard根据这些.d名字在当前路径查找,得到真正存在的.d文件dep_files := $(foreach f,$(cur_objs),.$(f).d)dep_files := $(wildcard $(dep_files))# 9.如果\"dep_files\"不为空,则包含(即包含了.d依赖文件,保证头文件修改后程序会重新编译)ifneq ($(dep_files),) include $(dep_files)endif# 10.新增目标(目前包含两个目标:__build和subdir-y的各个成员)PHONY += $(subdir-y)# 11.目标__build依赖于subdir-y各个成员和built-in.o__build : $(subdir-y) built-in.o# 12.对subdir-y的每个成员(即目录),都调用Makefile.build$(subdir-y): make -C $@ -f $(TOPDIR)/Makefile.build# 13.built-in.o依赖当前路径下的.o和目录下的built-in.o(即将当前路径下的.o链接成built-in.o)built-in.o : $(cur_objs) $(subdir_objs) $(LD) -r -o $@ $^# 14.定义dep_file为所有的依赖dep_file = .$@.d# 15.所有的.o依赖于所有的.c,编译过程生成对应.d文件%.o : %.c $(CC) $(CFLAGS) -Wp,-MD,$(dep_file) -c -o $@ $&lt;# 16.声明$(PHONY)是个假想目标.PHONY : $(PHONY) 3.各级子目录的Makefile指定当前目录下需要编进程序去的文件； 1234567# 1.指定当前目录下需要编进程序去的文件obj-y += color.oobj-y += yuv2rgb.oobj-y += rgb2rgb.oobj-y += mjpeg2rgb.oobj-y += jdatasrc-tj.oobj-y += convert_manager.o 4.实际编译过程①执行make，调用顶层Makefile，调用make -C ./ -f /work/drv/code/Makefile.build，执行Makefile.build； ②Makefile.build里调用make -C $@ -f $(TOPDIR)/Makefile.build对每个目录都执行Makefile.build； ③以video目录为例，调用Makefile.build，会执行以下操作： - 编译每一个.c： arm-linux-gnueabihf-gcc -Wall -Werror -O2 -g -I /work/drv/code/include -Wp,-MD,.v4l2.o.d -c -o v4l2.o v4l2.c - 将所有.o链接成built-in.o： arm-linux-gnueabihf-ld -r -o built-in.o v4l2.o video_manager.o ④完成对当前目录的内容编译后，再对当前路径的.c文件编译：arm-linux-gnueabihf-gcc -Wall -Werror -O2 -g -I /work/drv/code/include -Wp,-MD,.main.o.d -c -o main.o main.c ⑤将各子目录生成的built-in.o与main.o链接生成新built-in.o； ⑥最后依赖built-in.o输出目标文件arm-linux-gnueabihf-gcc -o video2lcd built-in.o -lm -ljpeg 9. 实测效果及源码 实测效果： 源码：所有源码见GitHub。 参考文章：Linux内核C语言中的面向对象韦东山第三期项目视频_摄像头 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"LCD","slug":"LCD","permalink":"http://yoursite.com/tags/LCD/"},{"name":"摄像头","slug":"摄像头","permalink":"http://yoursite.com/tags/摄像头/"},{"name":"UVC","slug":"UVC","permalink":"http://yoursite.com/tags/UVC/"},{"name":"Linux环境编程","slug":"Linux环境编程","permalink":"http://yoursite.com/tags/Linux环境编程/"}]},{"title":"Linux摄像头驱动2——UVC","date":"2018-04-22T12:18:08.000Z","path":"2018/04/22/Linux摄像头驱动2——UVC/","text":"Linux摄像头驱动学习第二篇，对USB摄像头驱动USB video class(UVC)进行详细分析、编写。这次要写一个真正的摄像头驱动，内容有点多。先简单的介绍了USB接口，了解Linux中USB设备描述符的意义。然后再移植内核自带的USB摄像头驱动，同时也验证了摄像头的可用。最后为了学习，逐句写一个摄像头驱动，再总结。 1.UVC基础UVC是USB video class的简写，也就是USB接口的视频设备。UVC其实很好理解，就是V4L2+USB。前面的虚拟摄像头驱动，数据的来源是自己构造的虚拟数据，现在V4L2的数据来源则是通过USB传进来的真实摄像头视频数据。除了视频数据，摄像头还把自己的特性(比如支持哪几种分辨率)告诉驱动，驱动则要配置摄像头(指定何种分辨率)。 1.1 USB基础知识USB分主从系统，一般而言，PC中的USB系统就是作主系统，而一般的USB鼠标、U盘则是典型的USB从系统。为了方便开发，USB定义了一套标准，只要是支持USB的主机，就可以支持任何一个厂商的USB鼠标、U盘，只要是被USB系统包含的设备，只要这些设备支持相应的标准，就无需重新设计驱动而直接使用。下面简单的列出了USB设备类型，理想情况的USB系统要对这些设备作完整的支持，设备也必须符合USB规范中的要求。 Base Class Descriptor Usage Description 00h Device Use class information in the Interface Descriptors 01h Interface Audio 02h Both Communications and CDC Control(通讯设备) 03h Interface HID (Human Interface Device) 05h Interface Physical 06h Interface Image 07h Interface Printer 08h Interface Mass Storage(存储) 09h Device Hub 0Ah Interface CDC-Data 0Bh Interface Smart Card 0Dh Interface Content Security 0Eh Interface Video 0Fh Interface Personal Healthcare 10h Interface Audio/Video Devices 11h Device Billboard Device Class 12h Interface USB Type-C Bridge Class DCh Both Diagnostic Device E0h Interface Wireless Controller EFh Both Miscellaneous FEh Interface Application Specific FFh Both Vendor Specific 其中UVC就是Video类。 为了更好地描述USB设备的特征，USB提出了设备架构的概念。从这个角度来看，可以认为USB设备是由一些配置，接口和端点；即一个USB设备可以含有一个或多个配置，在每个配置中可含有一个或多个接口，在每个接口中可含有若干个端点。 此外，驱动是绑定到USB接口上，而不是整个设备。 体现到驱动上，就是一个一个的结构体，对应设备、配置、接口、端点。其中USB video class它是在在标准的USB协议上进行了扩展，扩展的部分称为Class Specific。 标准的设备描述符： 123456789101112131415161718typedef struct Device_Descriptor &#123; uchar bLength; //设备描述符的字节数 uchar bDescriptorType; //设备描述符类型编号 uint bcdUSB; //USB版本号 uchar bDeviceClass; //USB分配的设备类 uchar bDeviceSubClass; //USB分配的设备子类 uchar bDeviceProtocol; //USB分配的设备协议代码 uchar bMaxPacketSize0; //端点0的最大包大小 uint idVendor; //厂商编号 uint idProduct; //产品编号 uint bcdDevice; //设备出厂编号 uchar iManufacturer; //设备厂商字符串索引 uchar iProduct; //产品字符串索引 uchar iSerialNumber; //设备序列号索引 uchar bNumConfigurations; //可能的配置数 &#125;Device_Descriptor,*pDevice_Descriptor; 配置描述符： 123456789101112typedef struct Configuration_Descriptor &#123; uchar bLength; //配置描述符 的字节数 uchar bDescriptorType; //配置描述符类型编号 uint wTotalLength; //此配置返回的所有数据大小 uchar bNumInterfaces; //此配置支持的接口数量 uchar bConfigurationValue;//Set_Configuration命令所需要的参数 uchar iConfiguration; //描述该配置的字符串索引 uchar bmAttributes; //供电模式的选择 uchar bMaxPower; //设备从总线获取的最大电流 &#125;Configuration_Descriptor,*pConfiguration_Descriptor; 接口描述符： 123456789101112typedef struct Interface_Descriptor &#123; uchar bLength; //接口描述符的字节数 uchar bDescriptorType; //接口描述符的类型编号 uchar bInterfaceNumber; //该接口的编号 uchar bAlternateSetting; //备用的接口描述符的编号 uchar bNumEndPoints; //该接口使用 的端点数，不包括端点0 uchar bInterfaceClass; //接口类 uchar bInterfaceSubClass; //接口子类 uchar bInterfaceProtocol; //接口类协议 uchar iInterface; //描述该接口的字符串索引值 &#125;Interface_Descriptor,*pInterface_Descriptor; 端点描述符： 12345678910typedef struct EndPoint_Descriptor &#123; uchar bLength; //端点描述符字节数 uchar bDescriptorType; //端点描述符类型编号 uchar bEndpointAddress; //端点地址及输入输出类型 uchar bmAtrributes; //端点的传输类型 uint wMaxPacketSize; //端点收发的最大包大小 uchar bInterval; //主机查询端点的时间间隔 &#125;EndPoint_Descriptor,*pEndPoint_Descriptor; 1.2 UVC硬件模型首先从USB官网下载标准协议相关资料：Video Class -&gt; Video Class 1.5 document set (.zip format, size 6.58MB)。在USB_Video_Example 1.5.pdf里，可以得知硬件模型分为两部分：VC interface和VS interface。VC interface用于控制，内部又分为多个unit和terminal，unit用于内部处理，terminal用于内外链接；VS interface用于传输，内部包括视频数据传输的端点以及摄像头支持的视频格式等信息； 每个视频有且仅有一个Vieo Control接口和可有多个Video Streaming接口; 一个接口，就相当于一个逻辑上的USB设备。现在，想象一下当USB摄像头插上主机，就相当于同时插上了两个设备，可通过函数去选中其中一个设备，从而去操作它。一个设备用于控制，比如设置亮度等；一个设备用于获取数据，选择所支持的某个格式等；这样就基本把控制和数据分开，要控制则操作控制接口，要数据则通过数据接口。 VideoControl Interface用于控制，比如设置亮度。它内部有多个Unit/Terminal(在程序里Unit/Terminal都称为entity)可以通过uvc_query_ctrl类似的函数来访问: 1ret = uvc_query_ctrl(dev /*哪一个USB设备*/, SET_CUR, ctrl-&gt;entity-&gt;id /*哪一个unit/terminal*/, dev-&gt;intfnum /*哪一个接口:VC interface*/, ctrl-&gt;info-&gt;selector, uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT), ctrl-&gt;info-&gt;size); VideoStreaming Interface用于获得视频数据，也可以用来选择fromat/frame(VS可能有多种format,一个format支持多种frame,frame用来表示分辨率等信息)可以通过__uvc_query_ctrl类似的函数来访问： 1ret = __uvc_query_ctrl(video-&gt;dev /*哪一个USB设备*/, SET_CUR, 0, video-&gt;streaming-&gt;intfnum /*哪一个接口: VS*/, probe ? VS_PROBE_CONTROL : VS_COMMIT_CONTROL, data, size, uvc_timeout_param); 这里的参数VS_PROBE_CONTROL只是枚举尝试，并不是设置，真正要设置需要使用参数VS_COMMIT_CONTROL。 1.3 USB描述符前面提到摄像头要把自己的特性(比如支持哪几种分辨率)告诉驱动，这个特性就是被放在USB描述符里面。在前面下载的USB_Video_Example 1.5.pdf文档里，有个UVC描述符层次结构例子：将USB插在Ubuntu主机上，执行lsusb可以看到当前的USB设备：123Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 002 Device 012: ID 1b3b:2977 iPassion Technology Inc. Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub 可根据厂家名字iPassion Technology Inc知道ID为1b3b:2977的USB设备就是摄像头。再使用-v(显示USB设备的详细信息)和-d(仅显示指定厂商和产品编号的设备)获取指定设备的详细信息：1lsusb -v -d 1b3b:2977 此时会打印出许多信息，精简去掉详细的数据，只留下大致框架如下：1234567891011121314151617181920212223242526272829Device Descriptor: Configuration Descriptor: Interface Association: Interface Descriptor: VideoControl Interface Descriptor: VideoControl Interface Descriptor: Endpoint Descriptor: Interface Descriptor: VideoStreaming Interface Descriptor: VideoStreaming Interface Descriptor: Interface Descriptor: Endpoint Descriptor: Interface Descriptor: Endpoint Descriptor: Interface Association: Interface Descriptor: AudioControl Interface Descriptor: AudioControl Interface Descriptor: Interface Descriptor: AudioStreaming Interface Descriptor: AudioStreaming Interface Descriptor: Endpoint Descriptor: AudioControl Endpoint Descriptor: Interface Descriptor: AudioStreaming Interface Descriptor: AudioStreaming Interface Descriptor: Endpoint Descriptor: AudioControl Endpoint Descriptor: 可以看到设备描述符下有一个配置描述符，配置描述符下有两个联合接口(IAD)，一个是视频的，一个是音频的。同级的还有若干接口描述符，接口描述符下有若干VC、VS和端点，与前面的框架是完全对应的。 任取其中一个描述符：123456789101112131415VideoStreaming Interface Descriptor: bLength 30 bDescriptorType 36 bDescriptorSubtype 7 (FRAME_MJPEG) bFrameIndex 1 bmCapabilities 0x01 Still image supported wWidth 640 wHeight 480 dwMinBitRate 2304000 dwMaxBitRate 2304000 dwMaxVideoFrameBufferSize 76800 dwDefaultFrameInterval 333333 bFrameIntervalType 1 dwFrameInterval( 0) 333333 就可以得知该摄像头支持一种叫FRAME_MJPEG的格式，分辨率为640*480等信息。因此，从上面的一系列描述符，就可完全得知摄像头的特征，后面驱动用用到具体的特性再说明。 2.内核摄像头驱动对UVC进行学习，步骤大致如下:首先分析内核自带的UVC是如何实现的;然后让手里的摄像头工作起来，可能内核自带的驱动可以直接用，也可能需要移植；最后再尝试写一个精简版的UVC驱动，深入理解。 2.1分析内核摄像头驱动在4.13.9内核中，UVC驱动在drivers/media/usb/uvc/文件夹里，下面对uvc_driver.c进行分析。a.构造usb_driver12345678910111213141516struct uvc_driver &#123; struct usb_driver driver;&#125;;struct uvc_driver uvc_driver = &#123; .driver = &#123; .name = \"uvcvideo\", .probe = uvc_probe, .disconnect = uvc_disconnect, .suspend = uvc_suspend, .resume = uvc_resume, .reset_resume = uvc_reset_resume, .id_table = uvc_ids, .supports_autosuspend = 1, &#125;,&#125;;其中.id_table里列举了驱动支持哪些USB设备。 b.设置usb_driver12345678910uvc_probe kzalloc //分配video_device uvc_register_chains uvc_register_terms uvc_register_video vdev-&gt;v4l2_dev = &amp;dev-&gt;vdev; //设置video_device vdev-&gt;fops = &amp;uvc_fops; vdev-&gt;ioctl_ops = &amp;uvc_ioctl_ops; vdev-&gt;release = uvc_release; video_register_device //注册video_device c.注册usb_driver12uvc_init usb_register 可以看到，probe()函数里面的操作就是前面vivid驱动里一样的操作方式。然后在外面加了一个usb的“壳”。 驱动的核心还是fops和ioctl_ops。下面对这两个操作函数的实现进行分析。首先是v4l2_file_operations:123456789101112131415const struct v4l2_file_operations uvc_fops = &#123; .owner = THIS_MODULE, .open = uvc_v4l2_open, .release = uvc_v4l2_release, .unlocked_ioctl = video_ioctl2,#ifdef CONFIG_COMPAT .compat_ioctl32 = uvc_v4l2_compat_ioctl32,#endif .read = uvc_v4l2_read, .mmap = uvc_v4l2_mmap, .poll = uvc_v4l2_poll,#ifndef CONFIG_MMU .get_unmapped_area = uvc_v4l2_get_unmapped_area,#endif&#125;;里面有open()、release()、ioctl2、read、mmap、poll，这点和前面的虚拟驱动一样。 这其中最重要的就是ioctl2，它使用video_usercopy()获得用户空间传进来的参数，调用__video_do_ioctl()在v4l2_ioctls[]数组里找到对应的uvc_ioctl_ops。 uvc_ioctl_ops每个函数的实现放在后面写代码里，逐个讲解。 UVC驱动的重点在于： 对描述符的解析； 属性的控制: 通过VideoControl Interface来设置； 格式的选择：通过VideoStreaming Interface来设置； 数据的获得：通过VideoStreaming Interface的URB来获得； 2.2移植内核摄像头驱动我手里使用的是百问网提供的二合一摄像头，它既有CMOS接口，也有USB接口。使用USB接口时，上面有一个DSP芯片，可以将原始的YUV数据转换成MJPEG的压缩数据。 它基本是符合UVC规范的，但有些小差别，厂家提供的文档里面有说明，按着说明修改即可。主要添加了usb_device_id和修改了数据的处理。详细参考补丁，修改后的代码在Github。编译完成后，先加载内核自带的uvcvideo及依赖，然后移除内核自带的驱动，安装修改后的驱动，运行xawtv应用程序：1234sudo modprobe uvcvideosudo rmmod uvcvideosudo insmod uvcvideo.koxawtv -noalsa 效果： 3.编写UVC驱动UVC的驱动有点长，我尽量根据功能将其分解若干部分，逐一编写。当USB插上主机，就会产生两个接口(VC和VS)，然后获取到USB描述符并解析，从而设置摄像头(比如分辨率、格式)；然后分配缓冲区，启动摄像头，便从USB得到摄像头采集数据，保存到缓冲区供应用程序使用。整个流程就大致这样，因此将其分为了6个部分进行编写。 1.注册(USB和Video) 2.数据格式设置相关 3.缓冲区操作相关 4.属性相关(以亮度控制为例) 5.URB 6.启动/停止 7.其它操作函数(mmap和poll) 8.测试/效果 3.1 注册(USB和Video)在入口函数先“套”一个USB驱动的框架，首先分配一个usb_driver：123456static struct usb_driver my_uvc_driver = &#123; .name = \"my_uvc\", .probe = my_uvc_probe, .disconnect = my_uvc_disconnect, .id_table = my_uvc_ids,&#125;;其中的id_table只包含我们所需的VC和VS，这样摄像头的Audio接口，就不会被识别：1234567static struct usb_device_id my_uvc_ids[] =&#123; /* Generic USB Video Class */ &#123; USB_INTERFACE_INFO(USB_CLASS_VIDEO, 1, 0) &#125;, /* VideoControl Interface */ &#123; USB_INTERFACE_INFO(USB_CLASS_VIDEO, 2, 0) &#125;, /* VideoStreaming Interface */ &#123;&#125;&#125;;这里USB_INTERFACE_INFO宏参数分别是前面接口描述符里的bInterfaceClass(接口类)，bInterfaceSubClass(接口子类)，bInterfaceProtocol(接口类协议)。12345#define USB_INTERFACE_INFO(cl, sc, pr) \\ .match_flags = USB_DEVICE_ID_MATCH_INT_INFO, \\ .bInterfaceClass = (cl), \\ .bInterfaceSubClass = (sc), \\ .bInterfaceProtocol = (pr)这里传入的第一个参数都是video类，第二个分别是VC和VS，第三个参数都是无协议。这些设置的依据来自于摄像头的USB描述符：12345678910111213Interface Descriptor: …… bInterfaceClass 14 Video bInterfaceSubClass 1 Video Control bInterfaceProtocol 0 …… Interface Descriptor: …… bInterfaceClass 14 Video bInterfaceSubClass 2 Video Streaming bInterfaceProtocol 0 …… 这里驱动的usb_device_id和摄像头提供的一旦匹配后，就会调用probe()函数，这里两个接口，就会调用两次。 在probe()函数里，需要先得到usb_device，用于对usb设备的操作，以及分别得到两个接口的编号，用于后面分别调用每个接口。再在probe()函数里做常规的分配、设置、注册video_device。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static int my_uvc_probe(struct usb_interface *intf, const struct usb_device_id *id)&#123; static int cnt = 0; int ret; printk(\"enter %s\\n\", __func__); //usb_device_id会使probe()调用两次,然而创建video_device只需要一次 cnt++; my_uvc_udev = interface_to_usbdev(intf); //获取usb设备 if (cnt == 1) //获取编号 my_uvc_control_intf = intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber; else if (cnt == 2) my_uvc_streaming_intf = intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber; if (cnt == 2) &#123; /* 1.分配一个video_device结构体 */ my_uvc_vdev = video_device_alloc(); if (NULL == my_uvc_vdev) &#123; printk(\"Faile to alloc video device (%d)\\n\", ret); return -ENOMEM; &#125; /* 2.设置 */ my_uvc_vdev-&gt;release = my_uvc_release; my_uvc_vdev-&gt;fops = &amp;my_uvc_fops; my_uvc_vdev-&gt;ioctl_ops = &amp;my_uvc_ioctl_ops; my_uvc_vdev-&gt;v4l2_dev = &amp;v4l2_dev; /* 3. 注册 */ ret = video_register_device(my_uvc_vdev, VFL_TYPE_GRABBER, -1); if (ret &lt; 0) &#123; printk(\"Faile to video_register_device.\\n\"); return ret; &#125; else printk(\"video_register_device ok.\\n\"); /* 为了确定带宽,使用哪一个setting */ my_uvc_try_streaming_params(&amp;my_uvc_params); //测试参数 my_uvc_get_streaming_params(&amp;my_uvc_params); //取出参数 my_uvc_set_streaming_params(&amp;my_uvc_params); //设置参数 &#125; return 0;&#125; 对应的disconnect也会被调用两次，但只做一次释放操作：12345678910111213static void my_uvc_disconnect(struct usb_interface *intf)&#123; static int cnt = 0; printk(\"enter %s\\n\", __func__); cnt++; if (cnt == 2) &#123; video_unregister_device(my_uvc_vdev); video_device_release(my_uvc_vdev); &#125;&#125; 现在，就完成了USB设备和Video设备的注册。且为Video设备绑定了操作函数，后续的工作就是完善操作函数。 3.2 数据格式设置相关前面Video设备绑定了fops，这里主要有五个操作函数：123456789static const struct v4l2_file_operations my_uvc_fops =&#123; .owner = THIS_MODULE, .open = my_uvc_open, .release = my_uvc_close, .mmap = my_uvc_mmap, .unlocked_ioctl = video_ioctl2, /* V4L2 ioctl handler */ .poll = my_uvc_poll,&#125;; open()和close()没什么好说的，常规操作：123456789101112131415static int my_uvc_open(struct file *file)&#123; printk(\"enter %s\\n\", __func__); return 0;&#125;static int my_uvc_close(struct file *file)&#123; printk(\"enter %s\\n\", __func__); my_uvc_vidioc_streamoff(NULL, NULL, 0); return 0;&#125;关闭的时候，顺手调用vidioc_streamoff关闭数据采集。 mmap()和poll()涉及buf的操作，后面再讲。先讲ioctl里面几个稍微简单点的操作函数。 首先是vidioc_querycap()，用于表明本设备是一个摄像头设备。需要对v4l2_capability结构体的driver命名，card命名，version指定版本号，capabilities指定支持的功能，device_caps通过节点访问的功能。12345678910111213141516static int my_uvc_vidioc_querycap(struct file *file, void *priv, struct v4l2_capability *cap)&#123; struct video_device *vdev = video_devdata(file); printk(\"enter %s\\n\", __func__); strlcpy(cap-&gt;driver, \"my_uvc_video\", sizeof(cap-&gt;driver)); strlcpy(cap-&gt;card, vdev-&gt;name, sizeof(cap-&gt;card)); cap-&gt;version = 4; cap-&gt;capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING | V4L2_CAP_DEVICE_CAPS; cap-&gt;device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING | V4L2_CAP_DEVICE_CAPS; return 0;&#125; 然后是vidioc_enum_fmt_vid_cap()，用于列举摄像头支持的格式。从USB摄像头的设备描述符可知，本摄像头只支持一种MJPEG格式，通过index来限定只接受一种格式。需要设置v4l2_fmtdesc结构体的description(格式名字)、pixelformat(格式对应的像素格式)和type(v4l2_buf_type)。1234567891011121314static int my_uvc_vidioc_enum_fmt_vid_cap(struct file *file, void *priv, struct v4l2_fmtdesc *f)&#123; printk(\"enter %s\\n\", __func__); /* 根据摄像头的设备描述符可知,只支持一种格式:VS_FORMAT_MJPEG */ if(f-&gt;index &gt;= 1) return -EINVAL; strcpy(f-&gt;description, MY_UVC_FMT); //支持格式 f-&gt;pixelformat = V4L2_PIX_FMT_MJPEG; f-&gt;type = V4L2_BUF_TYPE_VIDEO_CAPTURE; return 0;&#125; 之后是获取摄像头数据格式vidioc_g_fmt_vid_cap()操作函数。这个比较简单，直接返回my_uvc_format即可。12345678static int my_uvc_vidioc_g_fmt_vid_cap(struct file *file, void *priv, struct v4l2_format *f)&#123; printk(\"enter %s\\n\", __func__); memcpy(f, &amp;my_uvc_format, sizeof(my_uvc_format)); return 0;&#125; 再是vidioc_try_fmt_vid_cap()，用于尝试设置摄像头数据的格式。先判断传入的v4l2_format结构体里的type和pixelformat是不是正确的格式。再设置v4l2_pix_format结构体的width(宽)、height(高)和filed(数据扫描方式:不交错)。以及sizeimage(每帧图像大小)，这里的值大小的确定是通过probe()里打印的dwMaxVideoFrameSize值，这里每帧的理论大小是width*height=320*240=76800小于dwMaxVideoFrameSize=77312，估计最大每帧图像还会包含其它数据。大多数网络摄像头的colorspace(颜色空间)都是V4L2_COLORSPACE_SRGB。priv(私有数据)由pixelformat决定。这里的所有设置的值，理论上都来自对USB设备描述符的解析，这里简化了代码解析的过程，直接赋值，实际开发中为了适配多个摄像头，应该读取后解析。1234567891011121314151617181920212223static int my_uvc_vidioc_try_fmt_vid_cap(struct file *file, void *priv, struct v4l2_format *f)&#123; printk(\"enter %s\\n\", __func__); if (f-&gt;type != V4L2_BUF_TYPE_VIDEO_CAPTURE || f-&gt;fmt.pix.pixelformat != V4L2_PIX_FMT_MJPEG) return -EINVAL; /* 调整format的width, height */ f-&gt;fmt.pix.width = my_uvc_wWidth; //设备描述符里支持的分辨率:640x480,320x240,160x120 f-&gt;fmt.pix.height = my_uvc_wHeight; f-&gt;fmt.pix.field = V4L2_FIELD_NONE; /* 计算bytesperline, sizeimage */ //bBitsPerPixel = my_uvc_bBitsPerPixel; //lsusb:bBitsPerPixel //f-&gt;fmt.pix.bytesperline = (f-&gt;fmt.pix.width * bBitsPerPixel) &gt;&gt; 3; f-&gt;fmt.pix.sizeimage = dwMaxVideoFrameSize; //f-&gt;fmt.pix.height * f-&gt;fmt.pix.bytesperline; f-&gt;fmt.pix.colorspace = V4L2_COLORSPACE_SRGB; f-&gt;fmt.pix.priv = 0; /* private data, depends on pixelformat */ return 0;&#125; 最后是设置摄像头的数据的格式vidioc_s_fmt_vid_cap()。先参数设置传入的v4l2_format，如果不支持返回错误。支持的话，直接赋值给my_uvc_format。1234567891011121314static int my_uvc_vidioc_s_fmt_vid_cap(struct file *file, void *priv, struct v4l2_format *f)&#123; int ret; printk(\"enter %s\\n\", __func__); ret = my_uvc_vidioc_try_fmt_vid_cap(file, NULL, f); if (ret &lt; 0) return ret; memcpy(&amp;my_uvc_format, f, sizeof(my_uvc_format)); return 0;&#125;至此，就完成了对摄像头数据格式my_uvc_format的设置。应用层就可以对摄像头数据格式进行操作，比如选择何种数据格式、何种分辨率等，当然，这里的驱动没有提供选择，全都直接赋值了。 3.3 缓冲区操作相关buf操作是一个难点，容易出问题的地方。首先是申请缓冲区vidioc_reqbufs()，应用层ioctl调用此函数，让其分配若干个buf，应用层后面将从这些buf读取视频数据。驱动先从传入的v4l2_requestbuffers结构体获得count(buf数量)，每个buf的大小是前面my_uvc_format的sizeimage(每帧图像大小)，且长度页对齐。 PAGE_ALIGNPAGE_ALIGN在内核里作用是将数据以4K页大小上界对齐。举个例子：假如传入的数据大小是4000字节，那么结果得到4096字节；假如传入的数据大小是4096字节，那么结果得到4096字节；假如传入的数据大小是5000字节，那么结果得到8192字节； 源码：#define PAGE_SIZE 4096#define PAGE_MASK (~(PAGE_SIZE-1))#define PAGE_ALIGN(x) ((x + PAGE_SIZE - 1) &amp; PAGE_MASK) 实质:PAGE_ALIGN(x) = ((x + 4095) &amp; (~4095)) 然后再判断my_uvc_queue结构体里的mem(内存地址)是否为空，非空的话说明原来已经分配了buf，需要先释放内存、清空my_uvc_queue。如果传入需要的buf数量为0，则表明不需要分配，直接退出。然后就分配buf，将所有buf作为一个整体一次性分配，大小也就是nbuffers * bufsize，如果分配失败，减小buf数量，再尝试。现在就有了一整块buf，对应的起始地址是mem，再清空my_uvc_queue进行初始化。再初始化两个队列(双向链表)，mainqueue用于供应用层读取数据用，irqqueue用于供驱动产生数据用。再依次设置每个buf的v4l2_buffer结构体的index(索引)、m.offset(偏移)、length(大小)、type(类型)、sequence(序列计数)、field(扫描方式)、memory(内存类型)、flags(标志)，再设置my_uvc_buffer的state(状态)和初始化等待队列wait。最后再设置my_uvc_q，记录buf首地址、数量和大小。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* APP调用该ioctl让驱动程序分配若干个buf, APP将从这些buf中读到视频数据 */static int my_uvc_vidioc_reqbufs(struct file *file, void *priv, struct v4l2_requestbuffers *p)&#123; unsigned int i; void *mem = NULL; int nbuffers = p-&gt;count; //buf数量 int bufsize = PAGE_ALIGN(my_uvc_format.fmt.pix.sizeimage); //buf大小,且长度页对齐 printk(\"enter %s\\n\", __func__); if (my_uvc_q.mem) //如果原来分配了buf,先释放原来的buf &#123; vfree(my_uvc_q.mem); memset(&amp;my_uvc_q, 0, sizeof(my_uvc_q)); my_uvc_q.mem = NULL; &#125; if (nbuffers == 0) //没有需要分配的,直接退出 return 0; for (; nbuffers &gt; 0; --nbuffers) //依次减少buf数量，直到分配成功 &#123; mem = vmalloc_32(nbuffers * bufsize); //这些buf是一次性作为一个整体来分配的 if (mem != NULL) break; &#125; if (mem == NULL) return -ENOMEM; memset(&amp;my_uvc_q, 0, sizeof(my_uvc_q)); //清空my_uvc_q,初始化 INIT_LIST_HEAD(&amp;my_uvc_q.mainqueue); //初始化两个队列,my_uvc_vidioc_qbuf INIT_LIST_HEAD(&amp;my_uvc_q.irqqueue); for (i = 0; i &lt; nbuffers; ++i) &#123; my_uvc_q.buffer[i].buf.index = i; //索引 my_uvc_q.buffer[i].buf.m.offset = i * bufsize; //偏移 my_uvc_q.buffer[i].buf.length = my_uvc_format.fmt.pix.sizeimage; //原始大小;实测PAGE_ALIGN对齐,也没问题 my_uvc_q.buffer[i].buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; //视频捕获设备 my_uvc_q.buffer[i].buf.sequence = 0; my_uvc_q.buffer[i].buf.field = V4L2_FIELD_NONE; my_uvc_q.buffer[i].buf.memory = V4L2_MEMORY_MMAP; my_uvc_q.buffer[i].buf.flags = 0; my_uvc_q.buffer[i].state = VIDEOBUF_IDLE; //分配完更新状态为空闲 init_waitqueue_head(&amp;my_uvc_q.buffer[i].wait); //初始化一个等待队列 &#125; my_uvc_q.mem = mem; my_uvc_q.count = nbuffers; my_uvc_q.buf_size = bufsize; return nbuffers;&#125;这样，我们就得到一个my_uvc_queue结构体，这个结构体里面的my_uvc_buffer结构体数组，存放了每个buf的信息。示意如下： 接下来是vidioc_querybuf()，用于查询buf，获得buf的地址信息等。先判断传入的v4l2_buffer结构体中的index是否超出了buf数量范围。然后将my_uvc_q中的对应的v4l2_buffer传给传入的v4l2_buf。再判断my_uvc_buffer中的vma_use_count是否表示被mmap()，对应修改标准位。最后再将uvc的state flags转换成V4L2的state flags，其实它们的值都是一样的，1234567891011121314151617181920212223242526272829303132333435363738/* 查询缓存状态, 比如地址信息(APP可以用mmap进行映射) */static int my_uvc_vidioc_querybuf(struct file *file, void *priv, struct v4l2_buffer *v4l2_buf)&#123; int ret = 0; printk(\"enter %s\\n\", __func__); if (v4l2_buf-&gt;index &gt;= my_uvc_q.count) &#123; ret = -EINVAL; goto done; &#125; memcpy(v4l2_buf, &amp;my_uvc_q.buffer[v4l2_buf-&gt;index].buf, sizeof(*v4l2_buf)); if (my_uvc_q.buffer[v4l2_buf-&gt;index].vma_use_count) //更新flags v4l2_buf-&gt;flags |= V4L2_BUF_FLAG_MAPPED;#if 0 switch (my_uvc_q.buffer[v4l2_buf-&gt;index].state) //将uvc flags转换成V4L2 flags &#123; case VIDEOBUF_ERROR: case VIDEOBUF_DONE: v4l2_buf-&gt;flags |= V4L2_BUF_FLAG_DONE; break; case VIDEOBUF_QUEUED: case VIDEOBUF_ACTIVE: v4l2_buf-&gt;flags |= V4L2_BUF_FLAG_QUEUED; break; case VIDEOBUF_IDLE: default: break; &#125;#endifdone: return ret;&#125;这样，就将对应的v4l2_buffer相关信息传给了应用层，应用层就通过此函数查询各个buf信息。 vidioc_qbuf()是将前面的buf放入到队列中。首先是判断传入的v4l2_buffer的类型、内存种类、节点是否超过最大数量和my_uvc_q的my_uvc_buffer状态是否处于空闲。然后修改my_uvc_q的my_uvc_buffer状态为处于队列中VIDEOBUF_QUEUED，初始化v4l2_buffer中的bytesused(缓冲区中数据的大小)为0。然后把对应buf的stream和irq分别加到队列mainqueue和队列irqqueue尾部。 队列mainqueue：供应用层使用，当队列中缓冲区有数据时, 应用层从mainqueue队列中取出数据； 队列irqqueue：供产生数据的函数使用，当采集到数据时,从irqqueue队列中取出首个缓冲区,存入数据;123456789101112131415161718192021222324252627282930/* 把传入的缓冲区放入队列, 底层的硬件操作函数将会把数据放入这个队列的缓存 */static int my_uvc_vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *v4l2_buf)&#123; printk(\"enter %s\\n\", __func__); /* 0. APP传入的v4l2_buf可能有问题, 要做判断 */ if (v4l2_buf-&gt;type != V4L2_BUF_TYPE_VIDEO_CAPTURE || v4l2_buf-&gt;memory != V4L2_MEMORY_MMAP) return -EINVAL; if (v4l2_buf-&gt;index &gt;= my_uvc_q.count) return -EINVAL; if (my_uvc_q.buffer[v4l2_buf-&gt;index].state != VIDEOBUF_IDLE) return -EINVAL; /* 1. 修改状态 */ my_uvc_q.buffer[v4l2_buf-&gt;index].state = VIDEOBUF_QUEUED; my_uvc_q.buffer[v4l2_buf-&gt;index].buf.bytesused = 0; /* 2. 放入2个队列 */ //队列1: 供应用层使用 //当队列中缓冲区有数据时, 应用层从mainqueue队列中取出数据 list_add_tail(&amp;my_uvc_q.buffer[v4l2_buf-&gt;index].stream, &amp;my_uvc_q.mainqueue); //队列2: 供产生数据的函数使用 //当采集到数据时,从irqqueue队列中取出首个缓冲区,存入数据 list_add_tail(&amp;my_uvc_q.buffer[v4l2_buf-&gt;index].irq, &amp;my_uvc_q.irqqueue); return 0;&#125; 通过此函数，就将传入的v4l2_buffer放在了两个队列中。 最后是将数据从队列取出vidioc_dqbuf()。这里是应用层想得到数据，因此是从mainqueue队列获取。首先判断mainqueue是否是空队列，然后以my_uvc_q.mainqueue作为头节点，搜索my_uvc_buffer结构体中的stream，得到队列中第一个my_uvc_buffer的地址。再把my_uvc_buffer的state(状态)改为VIDEOBUF_IDLE(空闲)。、再将该节点从队列删除，最后返回v4l2_buf。12345678910111213141516171819202122232425262728293031/* APP通过poll/select确定有数据后,把buf从mainqueue队列中取出来 */static int my_uvc_vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *v4l2_buf)&#123; struct my_uvc_buffer *get_buf; printk(\"enter %s\\n\", __func__); if (list_empty(&amp;my_uvc_q.mainqueue)) return -EINVAL; get_buf = list_first_entry(&amp;my_uvc_q.mainqueue, struct my_uvc_buffer, stream); //取出buf switch (get_buf-&gt;state) //修改状态 &#123; case VIDEOBUF_ERROR: return -EIO; case VIDEOBUF_DONE: get_buf-&gt;state = VIDEOBUF_IDLE; break; case VIDEOBUF_IDLE: case VIDEOBUF_QUEUED: case VIDEOBUF_ACTIVE: default: return -EINVAL; &#125; list_del(&amp;get_buf-&gt;stream); //从队列删除 memcpy(v4l2_buf, &amp;get_buf-&gt;buf, sizeof *v4l2_buf); //复制返回数据 return 0;&#125; 至此，对buf的基本操作就完成了，包括buf的申请、查询、放入/取出到队列。其中，队列的变化如下：初始状态，队列mainqueue和队列irqqueue串连起了传进来的buf。产生数据的时候，buf[0]装入数据，且断开与队列irqqueue的连接，此时buf[1]是队列irqqueue的第一个节点。取出数据的时候，buf[0]取出数据，且断开与队列mainqueue的连接，此时buf[1]是队列mainqueue的第一个节点。待数据处理完成，buf[0]将被再次放入队列，此时在队列尾部。周而复始完成放入、取出队列。 3.4 属性相关(以亮度控制为例)接下来是操作摄像头属性，以亮度控制为例，查询、获取、设置摄像头的亮度属性。从前面的UVC硬件模型中可以得知，VC interface是用于控制摄像头的，其中PU单元用于属性的控制。在UVC 1.5 Class specification.pdf文档里，找到Processing Unit Descriptor，其中的bmControls表示摄像头支持属性的含义：123456789101112A bit set to 1 indicates that the mentioned Control is supported for the video stream.D0: BrightnessD1: ContrastD2: HueD3: SaturationD4: SharpnessD5: GammaD6: White Balance TemperatureD7: White Balance ComponentD8: Backlight CompensationD9: Gain…… 再找到本摄像头USB描述符中VC interface Descriptor的PROCESSING_UNIT中的bmControls，其值是0x0000053f，对应支持的属性也就是其下面的几个属性，Brightness(亮度)控制是支持的。123456789101112131415161718VideoControl Interface Descriptor: bLength 11 bDescriptorType 36 bDescriptorSubtype 5 (PROCESSING_UNIT)Warning: Descriptor too short bUnitID 3 bSourceID 1 wMaxMultiplier 0 bControlSize 2 bmControls 0x0000053f Brightness Contrast Hue Saturation Sharpness Gamma Backlight Compensation Power Line Frequency 在代码中，UVC规范定义的属性在uvc_ctrl.c里的一个uvc_control_info结构体类型的vc_ctrls数组里。123456789101112131415161718&#123; .entity = UVC_GUID_UVC_PROCESSING, //属于哪个entity(比如PU) .selector = UVC_PU_BRIGHTNESS_CONTROL, //用于亮度 .index = 0, //对应Processing Unit Descriptor的bmControls[0] .size = 2, //数据长度为2字节 .flags = UVC_CTRL_FLAG_SET_CUR //支持SET_CUR、GET_RANGE(GET_CUR、GET_MIN、GET_MAX)等 | UVC_CTRL_FLAG_GET_RANGE | UVC_CTRL_FLAG_RESTORE,&#125;,&#123; .entity = UVC_GUID_UVC_PROCESSING, .selector = UVC_PU_CONTRAST_CONTROL, .index = 1, .size = 2, .flags = UVC_CTRL_FLAG_SET_CUR | UVC_CTRL_FLAG_GET_RANGE | UVC_CTRL_FLAG_RESTORE,&#125;,现在，文档、硬件、代码三者都找到了对应。 此外，uvc_control_mapping结构体类型的uvc_ctrl_mappings数组更加细致地描述属性。1234567891011121314151617181920&#123; .id = V4L2_CID_BRIGHTNESS, //应用层根据ID来找到对应属性 .name = \"Brightness\", //名字 .entity = UVC_GUID_UVC_PROCESSING, //属于哪了个entity(比如PU) .selector = UVC_PU_BRIGHTNESS_CONTROL, //用于亮度控制 .size = 16, //数据占多少位 .offset = 0, //从哪位开始 .v4l2_type = V4L2_CTRL_TYPE_INTEGER, //属性类别(整数) .data_type = UVC_CTRL_DATA_TYPE_SIGNED, //数据类型(有符号整数)&#125;,&#123; .id = V4L2_CID_CONTRAST, .name = \"Contrast\", .entity = UVC_GUID_UVC_PROCESSING, .selector = UVC_PU_CONTRAST_CONTROL, .size = 16, .offset = 0, .v4l2_type = V4L2_CTRL_TYPE_INTEGER, .data_type = UVC_CTRL_DATA_TYPE_UNSIGNED,&#125;, 因此，属性控制的准备工作有： 1.获取摄像头的设备描述符，根据PU的描述符的bmControls，得知它支持哪些属性；2.从uvc_ctrls数组中根据entity和index找到对应属性，得知其支持的操作(SET_CUR、GET_CUR等)；3.从uvc_ctrl_mappings数组中根据ID找到对应属性，得知其更加详细信息(整数等); 首先是查询属性vidioc_queryctrl()，应用层传入一个v4l2_queryctrl结构体，驱动设置其参数返回。需要设置的参数有id(ID)、type(类型)、name(名字)、flags(标志)、minimum(最小值)、maximum(最大值)、step(步长)、default_value(典型值)，其中前面几个是根据前面的准备工作得知的值，直接赋值，后面的几个需要使用usb_control_msg()函数向摄像头发起USB传输，获取对应值。 usb_control_msg()功能：发送一个简单的控制消息到指定的端点，并等待消息完成或超时；参数： dev:指向控制消息所发送的目标USB设备(usb_device)的指针； &lt;这里是在probe()里获取的my_uvc_udev&gt; pipe:控制消息所发送的目标USB设备的特定端点，调用usb_sndctrlpipe(把指定USB设备的指定端点设置为一个控制OUT端点)或usb_rcvctrlpipe(把指定USB设备的指定端点设置为一个控制IN端点)来创建的; &lt;这里把my_uvc_udev设置为接收端点&gt; request:控制消息的USB请求值； &lt;这里分别是需要的GET_MIN、GET_MAX、GET_RES、GET_DEF&gt; requesttype:控制消息的USB请求类型值； &lt;这里为USB_TYPE_CLASS(1&lt;","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"摄像头","slug":"摄像头","permalink":"http://yoursite.com/tags/摄像头/"}]},{"title":"iMX6ULL上手体验","date":"2018-03-28T06:12:36.000Z","path":"2018/03/28/iMX6ULL上手体验/","text":"第一次接触NXP/Freescale的SOC，记录拿到板子后快速上手的技巧和思维的方式。iMX6ULL感觉还是很有优势的，除了之前接触的NanoPi(全志H3)，就没见过几个运行Linux，只卖100多元的开发板。Cortex-A7架构，主频528MHz，一些普通的嵌入式Linux应用领域足够了。感觉未来几年，运行Linux的板子会越来越便宜，嵌入式Linux会越来越普及。 1.准备资料对于一个陌生的SOC，首先就是要准备相关的资料，核心的就是参考手册和电路图。资料的来源无非有三个： 芯片官网官网是参考手册的来源；NXP的官网做得还是比较清晰，很容易就找到了i.MX6ULL提供的文档。 开发板提供厂家开发板厂家一般都提供所有的资料，包括参考手册、电路图、使用手册、工具、系统等；我这使用的是米尔科技的板子，官网的资料路径不好找，直接问客服要资料链接更快。 网络Google/Baidu用于搜索相关博文的一些细节资料，比如某一块别人的分析。随便提一下，科学上网是基本素养。 2.观察开发板拿到一个板子，首先是观察板子上大致有什么资源。比如看到SOC附近有两个芯片，一般一个是RAM，一个Flash；有个TF卡接口和拨动开关，多半是TF卡启动和Flash的启动选择；一个网口、USB接口、Micro USB接口、电源接口，USB接口可能用于下载或串口或供电；三组排针，其中三针上的丝印有RX、TX、GND，肯定是串口接口；两个按键和几个LED灯，背后还有一个FPC插座，多半是接显示屏；以及我的是IOT版，还有一个WIFI天线。 再查看厂家提供的资料，验证一些猜想。 上面的猜想几乎八九不离十，现在知道了可以通过“Boot Select”来TF/Nand启动。 现在有三个方向， 一是做应用，比如搞个微型服务器，此时插上电源、串口、网络，基本就可以直接使用了，无需再关心板子硬件细节； 二是做驱动，比如试试写个iMX6ULL的LED驱动，这就需要部署开发环境，在Ubuntu里安装交叉编译工具链、编译提供内核、编写驱动等； 三是做裸机，比如试试在裸机上点个LED灯，这就需要编写裸机程序，然后启动验证； 其实，这三个领域，都能玩，但都比较尴尬， 做应用，感觉没有好项目，树莓派还在吃灰； 做驱动，手里的Tiny4412还在研究，没必要另起炉灶，也没工作的需求； 做裸机，应该没人拿跑Linux的板子做裸机吧，单片机可选的一大堆； 既然这样，就做无任何资料的裸机吧，开启hard模式。 3.系统更新确定了方向，先是做裸机，首先就需要知道如何将裸机代码放到存储介质(Nand或TF卡)，然后启动裸机代码。 如何下手呢？我也不知道，跟着厂家提供的资料，重新烧写一遍系统，这个过程中肯定包含Uboot，Uboot就是一个大裸机程序，只要炮制Uboot的烧写方式烧写裸机即可。 i.MX6ULL系统更新使用两种方法，MfgTool更新和SD卡更新。 MFGTools MFGTools是NXP官方推荐的一个使用OTG来升级镜像的软件。可以用来升级Linux、升级Android；单独刷写某一系统分区，如 android的boot.img分区等；独立地刷写spi nor、emmc 等等；操作方式按着厂商的操作即可。 另外，MfgTool的文件更新有两个部分：firmware和files。firmware是烧写系统的镜像文件(作为媒介用途的镜像)，路径为”MYS-6ULXmfgtools/Profiles/Linux/OS Firmware/firmware/“。files目录下为烧写的目标镜像文件(真正烧录到emmc或者nand的镜像文件)，路径为”MYS-6ULX-mfgtools/Profiles/Linux/OSFirmware/files/“。之所以存着这两种镜像，是因为MFGTools的烧写原理是先将媒介镜像下载到到ddr内存里面，然后启动linux，再通过这个启动的linux把目标镜像固化到emmc或者nand里因此，当更新系统的分区大小或烧写方式时才需要更新firmware中的文件。 更新完，重新启动开开发板即是新系统。 SD卡更新和前面的原理类似，即先将一个媒介镜像烧写到SD卡上，SD卡启动后，再通过SD卡的系统烧写Nand，从而更新系统。因此需要先做一个“用于SD启动更新的镜像”，使用厂商提供的build-sdcard.sh脚本即可。同样的，“firmware”目录下是烧写系统的镜像文件(作为媒介用途的镜像)，一般情况下不需要修改。”mfgimages-mys-imx6ull-ddr256m-nand256m“目录下是烧写的目标镜像文件(真正烧录到emmc或者nand的镜像文件)。使用脚本后，会生成一个.sdcard后缀的文件，即是“用于SD启动更新的镜像”，下面需要将它烧到SD卡上，可以使用Linux下的dd命令。1sudo dd if=mys6ull-xx.rootfs.sdcard of=/dev/sdb conv=fsync 然后改为SD卡启动，就可以进入SD卡的系统，并在系统里自动的烧写Nand。完成后，改为Nand启动，即可进入新系统。 综上两个方法，都可以实现烧写Uboot到Nand上，但却都是通过进入“媒介系统”完成的烧写，看来直接烧写裸机到Nand是比较麻烦的。反观SD卡启动，是通过先使用脚本制作一个.sdcard后缀的文件，再通过dd命令，完整的复制到SD卡上。因此只需要分析下脚本如何操作即可。 通过过脚本build-sdcard.sh进行分析:1dd if=$&#123;FIRMWARE_DIR&#125;/u-boot-$&#123;MACHINE&#125;.$&#123;UBOOT_SUFFIX_SDCARD&#125; of=$&#123;SDCARD&#125; conv=notrunc seek=2 bs=512 以及博客参考。确定了Uboot是被放在了SD卡开始的512x2=1K处。即，裸机代码必须放在SD卡的偏移地址1K位置处。 4.裸机文件加头这时候，按理说下一步是编写个LED裸机程序，使用dd命令放在偏移地址1K位置处。但是，如厂商提供资料文档里说的： 由于i.MX6ULL/i.MX6UL烧写bootloaer时需要使用kobs-ng工具添加头部信息，需要在操作系统上才可以烧写。 同时，Uboot文件名为*.imx后缀，因此这里的裸机文件还需要先加一个头。 那么问题来了，这个头怎么加？肯定还是从Uboot切入，使用厂家提供Uboot，重新编译生成Uboot，在这个过程中，肯定会将u-boot.bin变为u-boot.imx。 编译Uboot的过程参考厂家文档，先安装交叉编译工具链，再指定配置文件编译即可。这里编译完后，是不会有什么提示信息的，这里就需要--just-print编译参数，将整个编译过程打印出来：1make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- --just-print &gt; 123.txt 在生成的123.txt里搜索u-boot.bin，很快就能定位到加头操作附近：1echo &apos; MKIMAGE u-boot.imx&apos;; ./tools/mkimage -n board/myir/mys_imx6ull/imximage.cfg.cfgtmp -T imximage -e 0x87800000 -d u-boot.bin u-boot.imx &gt;/dev/null; 这里的./tools/mkimage -n board/myir/mys_imx6ull/imximage.cfg.cfgtmp -T imximage -e 0x87800000 -d u-boot.bin u-boot.imx命令就是加头操作。需要mkimage工具和imximage.cfg.cfgtmp配置文件，而且这几个文件路径也可以从命令得知。 此时，将编译好的u-boot.bin，使用上面的命令完成加头操作，得到自己的u-boot.imx，尝试烧到SD卡上，看能否启动。 这里的烧写有一个坑，当使用dd命令进行烧写：1sudo dd if=u-boot.imx of=/dev/sdb bs=512 seek=2 conv=fsync 还是先介绍下dd命令，dd是对块进行操作，cp是对文件操作，比如复制一个数据从A-&gt;B，dd是放在指定的位置，cp是放在空闲的位置。 同时结合SD卡的分区简图： 可以看出，烧写到SD卡上，是无法直观的从SD上得知是否烧写成功的，烧写的偏移地址1K位置处，无法从SD卡的分区剩余大小上判断。 解决方法是，通过dd命令读取出数据，再将读取的数据和烧写的数据进行简单比较，因此烧写完成后，要使用以下命令进行检查，判断是否烧写成功：1234sudo dd if=/dev/sdb of=read_uboot.bin bs=512 skip=2 count=2hexdump u-boot.imx | morehexdump read_uboot.bin | more 比较两者前面部分数据相同即可。 然后把SD卡插上开发板，设置为SD卡启动，成功启动Uboot，且打印的Uboot生成日期是当前日期，证明裸机文件加头的方式是正确的。 5.运行LED知道了怎么加头，怎么烧写到SD卡，就可以编写裸机程序了，第一个裸机当然是最简单的点灯。在点灯之前，一般都需要关看门狗、初始化时钟、初始化SDRAM/DDR等。上面的操作不一定都是必须的，比如看门狗可能默认时间很长，对于点灯来说，无所谓。又比如SDRAM/DDR在点灯这个小程序上，没必要用到。 因此，最基本的肯定是设置GPIO引脚，控制LED灯。点灯一般需要使能引脚时钟、设置引脚功能为GPIO功能、引脚设值等。在设置了引脚方向寄存器和引脚数据寄存器后，抱着试一试的心态编译、加头后烧写了进去，居然成功亮灯。确实很惊讶，这应该是遇到的步骤最少的亮灯代码。看门狗、时钟什么的，猜测应该被初始化了。 而且，还有更大的惊喜。在前面加头的操作，就很纳闷有个参数是-e 0x87800000，应该是个地址，这个地址处于：12Start address End address Size Description8000_0000 FFFF_FFFF 2048 MB MMDC—x16 DDR Controller. 也就是DDR的位置，难道DDR也被初始化了?写个测试函数，尝试读写DDR所在的0x80000000：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define DDR_ADDRESS (*(volatile unsigned long *)0x80000000) //P175 ARM Platform Memory Map#define DDR_ADDR(offset) (*(volatile unsigned long *)(0x80000000+offset)) #define TEST_SIZE (1024*1024)void test_ddr(void)&#123; int i; unsigned int offset; int equal_flag = 1; //写寄存器 offset = 0; for(i=0; i&lt;TEST_SIZE; i++) &#123; DDR_ADDR(offset) = i; offset = offset + 4; &#125; //读寄存器并判断 offset = 0; for(i=0; i&lt;TEST_SIZE; i++) &#123; if( i != DDR_ADDR(offset) ) &#123; equal_flag = 0; break; &#125; offset = offset + 4; &#125; //显示 /* if(equal_flag) led_mode(3); else led_mode(2); */ if(DDR_ADDR(0) == 1) led_mode(1); else if(DDR_ADDR(4*8) == 8) led_mode(3); else led_mode(2);&#125;结果发现居然能正确读取出来，看来DDR也被初始化了。 不得不说，很强，很完美。(●’◡’●) 倒回来想，不应能初始化DDR，不同的板子，DDR型号不一定相同，不可能做到适配所有的DDR。整个过程，就做了加头操作，答案应该在加头操作里面。 打开imximage.cfg.cfgtmp可以看到一堆寄存器：1234…………DATA 4 0x021B0000 0x84180000DATA 4 0x021B0890 0x00400000………… 这里的0x021B0000刚好是DDR的寄存器：MMDC Core Control Register (MMDC_MDCTL)；其上电复位值是0x00，尝试读取寄存器值是不是为0，就知道是否真的被设置了：123456789101112131415void read_ddr_reg(void)&#123; unsigned int reg_value = 0; reg_value = MMDC_MDCTL; if (reg_value &amp; (0x01&lt;&lt;30)) //SDE_1 led_mode(1); if (reg_value &amp; (0x01&lt;&lt;31)) //SDE_0 led_mode(2);//结果亮 while(1);&#125;结果其31位，还真是1，和imximage.cfg.cfgtmp的DATA 4 0x021B0000 0x84180000里的10x84180000 = ‭10000100000110000000000000000000‬ 最高为1是吻合的。 6.移植串口点灯很轻松的被解决了，其它常规的初始化也被完成了。尝试加点难度，移植下串口，为什么是移植呢？不想从头去看参考手册的详细说明，直接移植Uboot里的串口操作即可。 Uboot里面一堆start.S，哪一个才是本开发板的呢？笨方法是根据芯片型号分类去慢慢找，聪明的方法是一个命令解决：1find -name start.o 得到：1./arch/arm/cpu/armv7/start.o 因为前面根据本开发板配置文件编译过Uboot，理论上现在生成的所有*.o文件都是本开发板所使用的，这样就可以直接找到用到的start.S。 对start.S进行分析，没发现里面有串口相关的调用操作。 茫茫代码，如何找到需要的“uart”相关代码呢。既然所有*.o才是用到的，就先找出所有*.o，再在对应的C文件搜索uart即可。1find -name &quot;.o&quot; 将得到的结果里面所有的文件名改为.*，再作为参数传给grep:123456grep -nr &quot;uart&quot; ./test/dm/cmd_dm.* \\./test/dm/built-in.* \\./test/built-in.* \\./common/image-fdt.* \\./common/env_attr.* \\………… 可以得到如下结果：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960./common/console.c:10:#include &lt;debug_uart.h&gt;./board/myir/mys_imx6ull/mys_imx6ull.c:330:static iomux_v3_cfg_t const uart1_pads[] = &#123;./board/myir/mys_imx6ull/mys_imx6ull.c:400:static void setup_iomux_uart(void)./board/myir/mys_imx6ull/mys_imx6ull.c:402: imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));./board/myir/mys_imx6ull/mys_imx6ull.c:850: setup_iomux_uart();./tools/kwbimage.c:34: &#123; 0x69, &quot;uart&quot; &#125;,./arch/arm/cpu/armv7/mx6/soc.c:448:static void set_uart_from_osc(void)./arch/arm/cpu/armv7/mx6/soc.c:452: /* set uart clk to OSC */./arch/arm/cpu/armv7/mx6/soc.c:578: set_uart_from_osc();./arch/arm/cpu/armv7/mx6/clock.c:132:void enable_uart_clk(unsigned char enable)./arch/arm/cpu/armv7/mx6/clock.c:412:static u32 get_uart_clk(void)./arch/arm/cpu/armv7/mx6/clock.c:414: u32 reg, uart_podf;./arch/arm/cpu/armv7/mx6/clock.c:426: uart_podf = reg &gt;&gt; MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET;./arch/arm/cpu/armv7/mx6/clock.c:428: return freq / (uart_podf + 1);./arch/arm/cpu/armv7/mx6/clock.c:1049:u32 imx_get_uartclk(void)./arch/arm/cpu/armv7/mx6/clock.c:1051: return get_uart_clk();./arch/arm/cpu/armv7/mx6/clock.c:1269: return get_uart_clk();./arch/arm/cpu/armv7/mx6/clock.su:3:clock.c:412:12:get_uart_clk 16 static./arch/arm/cpu/armv7/mx6/clock.su:10:clock.c:132:6:enable_uart_clk 8 static./arch/arm/cpu/armv7/mx6/clock.su:20:clock.c:1049:5:imx_get_uartclk 0 static./drivers/serial/serial_mxc.c:145: u32 clk = imx_get_uartclk();./drivers/serial/serial_mxc.c:241:struct mxc_uart &#123;./drivers/serial/serial_mxc.c:270: struct mxc_uart *const uart = plat-&gt;reg;./drivers/serial/serial_mxc.c:271: u32 clk = imx_get_uartclk();./drivers/serial/serial_mxc.c:273: writel(4 &lt;&lt; 7, &amp;uart-&gt;fcr); /* divide input clock by 2 */./drivers/serial/serial_mxc.c:274: writel(0xf, &amp;uart-&gt;bir);./drivers/serial/serial_mxc.c:275: writel(clk / (2 * baudrate), &amp;uart-&gt;bmr);./drivers/serial/serial_mxc.c:278: &amp;uart-&gt;cr2);./drivers/serial/serial_mxc.c:279: writel(UCR1_UARTEN, &amp;uart-&gt;cr1);./drivers/serial/serial_mxc.c:287: struct mxc_uart *const uart = plat-&gt;reg;./drivers/serial/serial_mxc.c:289: writel(0, &amp;uart-&gt;cr1);./drivers/serial/serial_mxc.c:290: writel(0, &amp;uart-&gt;cr2);./drivers/serial/serial_mxc.c:291: while (!(readl(&amp;uart-&gt;cr2) &amp; UCR2_SRST));./drivers/serial/serial_mxc.c:292: writel(0x704 | UCR3_ADNIMP, &amp;uart-&gt;cr3);./drivers/serial/serial_mxc.c:293: writel(0x8000, &amp;uart-&gt;cr4);./drivers/serial/serial_mxc.c:294: writel(0x2b, &amp;uart-&gt;esc);./drivers/serial/serial_mxc.c:295: writel(0, &amp;uart-&gt;tim);./drivers/serial/serial_mxc.c:296: writel(0, &amp;uart-&gt;ts);./drivers/serial/serial_mxc.c:304: struct mxc_uart *const uart = plat-&gt;reg;./drivers/serial/serial_mxc.c:306: if (readl(&amp;uart-&gt;ts) &amp; UTS_RXEMPTY)./drivers/serial/serial_mxc.c:309: return readl(&amp;uart-&gt;rxd) &amp; URXD_RX_DATA;./drivers/serial/serial_mxc.c:315: struct mxc_uart *const uart = plat-&gt;reg;./drivers/serial/serial_mxc.c:317: if (!(readl(&amp;uart-&gt;ts) &amp; UTS_TXEMPTY))./drivers/serial/serial_mxc.c:320: writel(ch, &amp;uart-&gt;txd);./drivers/serial/serial_mxc.c:328: struct mxc_uart *const uart = plat-&gt;reg;./drivers/serial/serial_mxc.c:329: uint32_t sr2 = readl(&amp;uart-&gt;sr2);./drivers/serial/serial.c:143:serial_initfunc(mxs_auart_initialize);./drivers/serial/serial.c:156:serial_initfunc(uartlite_serial_initialize);./drivers/serial/serial.c:234: mxs_auart_initialize();./drivers/serial/serial.c:247: uartlite_serial_initialize();./drivers/serial/serial.c:525: * uart_post_test() - Test the currently selected serial port using POST./drivers/serial/serial.c:535:/* Mark weak until post/cpu/.../uart.c migrate over */./drivers/serial/serial.c:537:int uart_post_test(int flags) 可以看到分别是初始化uart引脚、时钟、设置相关寄存器等函数。非常的清晰，很容易就移植过来：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091static void uart1_clock_enable(void)&#123; //uart时钟 CCM_CSCDR1 |= (0x01&lt;&lt;6); //P676 Selector for the UART clock multiplexor:1 derive clock from osc_clk CCM_CCGR5 |= (0x03&lt;&lt;24); //uart1 clock (uart1_clk_enable)&#125;static void uart1_iomux(void)&#123; //uart引脚复用 IOMUXC_UART1_TX |= (0x01&lt;&lt;16 | 0x02&lt;&lt;14 | 0x01&lt;&lt;13 | 0x01&lt;&lt;12 | 0x02&lt;&lt;6 | 0x06&lt;&lt;3 | 0x01&lt;&lt;0); IOMUXC_UART1_RX |= (0x01&lt;&lt;16 | 0x02&lt;&lt;14 | 0x01&lt;&lt;13 | 0x01&lt;&lt;12 | 0x02&lt;&lt;6 | 0x06&lt;&lt;3 | 0x01&lt;&lt;0); IOMUXC_UART1_TX &amp;= ~(0x0F&lt;&lt;0); //P1578 0000 ALT0 — Select mux mode: ALT0 mux port: UART1_TX of instance: uart1 IOMUXC_UART1_RX &amp;= ~(0x0F&lt;&lt;0); //P1579 0000 ALT0 — Select mux mode: ALT0 mux port: UART1_RX of instance: uart1&#125;void raise (int sig_nr)&#123; ;&#125;unsigned int get_uart_clk(void)&#123; unsigned int reg, uart_podf; unsigned int freq, div; //div = CCM_ANALOG_PLL_USB1; div = CCM_CACRR; div &amp;= 0x00000003; freq = 26000000 * (20 + (div &lt;&lt; 1)); reg = CCM_CSCDR1; if (reg &amp; (1&lt;&lt;6)) freq = 26000000; reg &amp;= 0x3F; uart_podf = reg &gt;&gt; 0; return freq / (uart_podf + 1);&#125;//uart配置static void uart1_config(void)&#123; unsigned int clk; UART1_UCR1 = 0; UART1_UCR2 = 0; while(!(UART1_UCR2 &amp; (1&lt;&lt;0))); UART1_UCR3 = (0x704 | (1&lt;&lt;7)); UART1_UCR4 = (0x8000); UART1_UESC = (0x2b); UART1_UTIM = (0); UART1_UTS = (0); clk = get_uart_clk(); //实测是25952384 UART1_UFCR = (4&lt;&lt;7 | 2&lt;&lt;10 | 1&lt;&lt;0); //UART1_UFCR = (4&lt;&lt;7); UART1_UBIR = (0xf); UART1_UBMR = (clk / (2 * 125000));//115200 - 9.42 125000 - 8.75 UART1_UCR2 = (1&lt;&lt;5 | 1&lt;&lt;14 | 1&lt;&lt;1 | 1&lt;&lt;2 | 1&lt;&lt;0); UART1_UCR1 = (1&lt;&lt;0);&#125;void uart_init()&#123; uart1_clock_enable(); uart1_iomux(); uart1_config();&#125;void uart_PutChar(char c)&#123; UART1_UTXD = c; while(!(UART1_UTS &amp; (1&lt;&lt;6)));&#125;void uart_PutString(char *ptr)&#123; while(*ptr != '\\0') &#123; uart_PutChar(*ptr++); &#125;&#125;这里的移植后遇到两个问题：1.程序里打印45，实际打印出tu，通过ASCLL表和逻辑分析仪发现数据有点错位，代码里的115200波特率对应的脉宽宽了，这里直接把程序里的波特率改为125000，再用逻辑分析仪看就很“正”了。 2.前面的get_uart_clk()函数涉及到了除法，交叉编译工具链是不支持硬件除法的。解决方法有两个： 在Makefile添加含除法的GCC库 12# Add GCC libPLATFORM_LIBS += -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -lgcc 打印出get_uart_clk()的返回值，直接赋值。 7.重定位前面的uart程序，后面实测发现一些问题，很大概率打印的数据是错误或者无法打印，研究后发现，是没有重定位的原因。 原来，开发板上电后，会从Flash中复制代码到SRAM，在SRAM里面一句一句的执行指令(此时运行的地址是硬件决定的)。实际上，我们更多的是希望他在SDRAM上运行，因为SDRAM的空间更大，于是在链接脚本中，指定它应该运行的地址。于是代码开始时实际运行的地址和期望运行的地址一般是不一样的，就需要重定位代码到链接脚本指定的地址。不然的话，假如一个数据，在链接脚本里指定放在了高地址某处，但实际代码运行在低地址附近。代码执行时，需要读取高地址位置的数据，但高地址的数据并没有任何东西，一但读取就很可能发生异常。 首先编写链接脚本：[imx6ul.lds]link123456789101112131415SECTIONS &#123; . = 0x80000000; .text : &#123; start.o(.text) main.o(.text) led.o(.text) uart.o(.text) printf.o(.text) *(.text) &#125; .rodata ALIGN(4) : &#123;*(.rodata*)&#125; .data ALIGN(4) : &#123; *(.data) &#125; __bss_start = .; .bss ALIGN(4) : &#123; *(.bss) *(COMMON) &#125; __bss_end = .;&#125;这是一个比较通用的链接脚本，指定了代码段、只读数据段、数据段、BSS段等的位置。开始的0x80000000就是我们期望它运行的地址，一般都是SDRAM中的某个地址，如果这个地址和代码实际运行的地址相同，就没必要重定位了。 然后在start.S里重定位操作：[start.S]link1234567891011121314151617181920212223242526272829303132333435363738394041424344.text.global _start_start: @设置栈 ldr sp,=0x90000000 @设置栈 bl relocate @重定位 @bl clean_bss @清BSS段 @adr r0, _start @可用于获取当前代码的地址,作为参数传给main,main里面再打印出来&quot;int main(int addr)&quot; @ldr pc, =main @如果没重定位,这样直接跳到main代码的位置(链接脚本的期望地址),那个位置的数据未知,肯定出错 bl main @bl相对跳转,不管有没有重定位,都能到main的位置halt: b halt relocate: adr r0, _start @r0:代码当前被放在的位置,由硬件特性决定 ldr r1, =_start @r1:代码期望被放在的位置,即链接脚本里的地址,用户想放在的位置,比如SDRAM @当两者相同则不用重定位,否则需要重定位 cmp r0, r1 @比较r0和r1 moveq pc,lr @相等则pc=lr,即跳回到调用relocate的位置;不相等跳过执行下面的指令 ldr r2, =__bss_start @r2等于链接脚本里的__bss_start,即代码段、只读数据段、数据段的结束位置cpy: ldr r3, [r0], #4 @将r0地址的数据放到r3,r0往后再移动一个字节 str r3, [r1], #4 @将r3的数据放到r1,r1往后再移动一个字节 @这两句完成了代码从当前位置复制到期望的链接地址位置的操作 cmp r1, r2 @判断是不是复制完了 bne cpy @不相等继续复制 mov pc, lr @pc=lr,即跳回到调用relocate的位置; clean_bss: ldr r0, =__bss_start @r0=bss段开始位置 ldr r1, =__bss_end @r1=bss段结束位置 mov r2, #0 @r0=0,填充0用clean_loop: str r2, [r0], #4 @将0写到bss段开始位置,并r0向后移一个字节 cmp r0, r1 @比较bss段是不是完了 bne clean_loop @不相等则继续清0 mov pc, lr @pc=lr,即跳回到调用clean_bss的位置; 开始的栈地址，选择SDRAM的最高地址即可。其它没什么说的了，注释写的很清楚，目的就是把当前位置的代码(一般是SRAM)复制到期望运行的地址(一般是SDRAM)。 8.移植printf移植printf就很简单了，搞定了uart打印字符的函数后，利用以下框架即可： 复制提供的printf.c和printf.h； 将printf.h里定义的__out_putchar宏改为uart里打印字符的函数即可； 实测效果： 9.其它以上就是拿到一个全新的板子，如何快速上手板子的过程。 将以上思路，应用于RK3288，发现完全适用，也是先编译Uboot，得知加头的方式，然后得知下载方式，点灯，重定位，仅仅半天就可以实现串口的打印。对RK3288的操作就不详细写了，思路上是完全一摸一样的，相关代码在文章最后。 后续有时间的话，可能会尝试去移植Nand，这些后续再看情况。 对iMX6ULL的初步上手就差不多了，感觉这SOC做得还是很不错，上手很快，价格低廉。 相关代码Github地址：IMX6ULLRK3288 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"裸机","slug":"裸机","permalink":"http://yoursite.com/tags/裸机/"},{"name":"i.MX6ULL","slug":"i-MX6ULL","permalink":"http://yoursite.com/tags/i-MX6ULL/"}]},{"title":"Linux摄像头驱动1——vivid","date":"2018-03-08T07:59:30.000Z","path":"2018/03/08/Linux摄像头驱动1——vivid/","text":"Linux摄像头驱动学习第一篇，对虚拟视频驱动Virtual Video Driver(vivid)进行测试、分析、编写。 V4L2(Video for Linux two)是Linux内核中关于视频设备的内核驱动框架，为上层的访问底层的视频设备提供了统一的接口。 V4L2可以支持多种设备,它可以有以下几种接口: Video capture interface(视频采集接口):从摄像头等设备上获取视频数据,是V4L2设计最初功能； Video output interface(视频输出接口):驱动计算机的外围视频、图像显示设备； Video overlay interface(直接传输视频接口):把从视频采集设备采集过来的信号直接输出到输出设备之上,而不用经过CPU； Video output overlay device(视频输出覆盖设备):也被称为OSD(On-Screen Display),即在显示画面上叠加一层显示，比如菜单设置界面； VBI interface(视频间隔消隐信号接口):提供对VBI(Vertical Blanking Interval)数据的控制,它可以使应用可以访问传输消隐期的视频信号； Radio interface(收音机接口):处理从AM或FM高频头设备接收来的音频流； 1.V4L2框架分析 2.测试vivid这里目的先加载vivid驱动，然后运行应用程序调用vivid驱动，初步体验效果。 2.1加载驱动先在Ubuntu16.04上输入uname -a，可以得到当前Ubuntu内核版本号：1Linux ubuntu 4.4.0-116-generic #140-Ubuntu SMP Mon Feb 12 21:23:04 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux 当前内核版本是4.4.0-116-generic，然后去Linux内核官网下载对应的内核，提取出其中的linux-4.13.9/drivers/media/文件夹。 修改media/platform/vivid/下的Makefile:12345678910111213141516KERN_DIR = /usr/src/linux-headers-4.4.0-116-genericvivid-objs := vivid-core.o vivid-ctrls.o vivid-vid-common.o vivid-vbi-gen.o \\ vivid-vid-cap.o vivid-vid-out.o vivid-kthread-cap.o vivid-kthread-out.o \\ vivid-radio-rx.o vivid-radio-tx.o vivid-radio-common.o \\ vivid-rds-gen.o vivid-sdr-cap.o vivid-vbi-cap.o vivid-vbi-out.o \\ vivid-osd.o vivid-tpg.o vivid-tpg-colors.o all: make -C $(KERN_DIR) M=`pwd` modules clean: make -C $(KERN_DIR) M=`pwd` modules clean rm -rf modules.orderobj-$(CONFIG_VIDEO_VIVID) += vivid.o 然后执行make编译，获得vivid.ko此时加载模块sudo insmod vivid.ko，发现报错如下：1insmod: ERROR: could not insert module vivid.ko: Unknown symbol in module 原因是模块中的一些依赖函数的模块，没有加载，通过dmesg命令，可以看到很多函数：12345678[ 488.786285] vivid: Unknown symbol vb2_queue_init (err 0)[ 488.786295] vivid: Unknown symbol v4l2_ctrl_poll (err 0)[ 488.786304] vivid: Unknown symbol v4l2_enum_dv_timings_cap (err 0)[ 488.786314] vivid: Unknown symbol video_ioctl2 (err 0)[ 488.786364] vivid: Unknown symbol v4l2_get_timestamp (err 0)[ 488.786389] vivid: Unknown symbol v4l2_device_put (err 0)[ 488.786418] vivid: Unknown symbol vb2_ioctl_streamoff (err 0)………… 需要先加载这些函数所在的模块才行。这里有两个方法：一是找到函数对应的文件，修改Makefile，编译出来，先加载。二是找到函数对应的文件，其实模块都已经编译好了，路径在/lib/modules/4.4.0-116-generic/kernel/drivers/media/v4l2-core/里面，直接加载即可。 这两种方式都需要慢慢找对应的文件，比较麻烦，直接:123sudo modprobe vivid //安装自带vivid及依赖sudo rmmod vivid //卸载自带的vividsudo insmod ./vivid.ko //安装自己编译的vivid.ko 这里先使用modprobr加载vivid，会将其依赖一并加载，然后再卸载vivid，最后加载上我们编译的vivid.ko。 这里为什么使用自己编译的vivid.ko，而不使用自带的？因为后面修改vivid源码后，重新加载修改后的驱动，才知道修改后的效果。 2.2应用程序Linux摄像头测试软件webcam、spcaview、luvcview、xawtv等，经测试，luvcview和xawtv比较靠谱。 luvcview 1234luvcview -h //帮助信息luvcview -d /dev/videoX //指定设备luvcview -L //查询当前摄像头所支持的所有数据格式以及分辨率信息 luvcview //运行摄像头 xawtv 1234xawtv -h //帮助信息xawtv -c /dev/videoX //指定设备xawtv -noalsa //关闭声卡启动xawtv //运行摄像头 这里加载vivid驱动后，运行xawtv效果如下： 3.分析vivid第一次接触V4L2，直接对内核提供的Virtual Video Driver(vivid)进行分析，只要熟悉了vivid，后续再对摄像头再进行分析，就会轻松很多。 vivid是内核提供的一个虚拟机的视频设备驱动，内核提供的vivid源码在linux-4.13.9/drivers/media/platform/vivid/。 3.1 初始化、注册分析在vivid_init()里分别注册了vivid_pdev和vivid_pdrv，注册后，由于两者name一致，则会调用probe()。在probe()里面主要进行初始化、注册等相关流程。 可以看到，在probe()里，会调用vivid_create_instance()，让后在里面先分配一个video_device，然后设置video_device，包括操作函数ops，ioctl操作函数，设备等。然后对ctrl属性进行详细的设置，最后注册video_device，和进行常规的字符设备注册。 因此，写摄像头驱动程序的流程如下: 分配video_device:video_device_alloc()或kzalloc()； 设置video_device:.fops、.ioctl_ops、dev； 注册video_device: video_register_device()； 3.2 操作函数分析再来看看操作函数是如何调用的： 当应用层open()/read()/write()操作/dev/videox时，先找到v4l2_fops，然后调用v4l2_open/v4l2_read/v4l2_write(drivers/media/v4l2-core/v4l2-dev.c)，再通过video_devdata根据次设备号从数组中得到video_device，再找到vivid_fops里对应的操作函数。 ioctl的前面流程类似，后面通过video_usercopy()获取传入的ioctl类型，找到对应ioctl_ops，调用不同的ioctl。 3.3 ioctl_ops分析摄像头驱动有众多的ioctl，这些ioctl实现了对设备的控制：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122static const struct v4l2_ioctl_ops vivid_ioctl_ops = &#123; /* 表示它是一个摄像头设备 */ .vidioc_querycap = vidioc_querycap, /* 摄像头数据格式的操作 */ .vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid, //列举格式 .vidioc_g_fmt_vid_cap = vidioc_g_fmt_vid_cap, //获取格式 .vidioc_try_fmt_vid_cap = vidioc_try_fmt_vid_cap, //测试格式 .vidioc_s_fmt_vid_cap = vidioc_s_fmt_vid_cap, //设置格式 /* 支持multi-planar */ .vidioc_enum_fmt_vid_cap_mplane = vidioc_enum_fmt_vid_mplane, .vidioc_g_fmt_vid_cap_mplane = vidioc_g_fmt_vid_cap_mplane, .vidioc_try_fmt_vid_cap_mplane = vidioc_try_fmt_vid_cap_mplane, .vidioc_s_fmt_vid_cap_mplane = vidioc_s_fmt_vid_cap_mplane, /* 数据输出操作 */ .vidioc_enum_fmt_vid_out = vidioc_enum_fmt_vid, //枚举输出格式 .vidioc_g_fmt_vid_out = vidioc_g_fmt_vid_out, //获取输出格式 .vidioc_try_fmt_vid_out = vidioc_try_fmt_vid_out, //测试输出格式 .vidioc_s_fmt_vid_out = vidioc_s_fmt_vid_out, //设置输出格式 /* 支持multi-planar */ .vidioc_enum_fmt_vid_out_mplane = vidioc_enum_fmt_vid_mplane, .vidioc_g_fmt_vid_out_mplane = vidioc_g_fmt_vid_out_mplane, .vidioc_try_fmt_vid_out_mplane = vidioc_try_fmt_vid_out_mplane, .vidioc_s_fmt_vid_out_mplane = vidioc_s_fmt_vid_out_mplane, .vidioc_g_selection = vidioc_g_selection, //获取选择矩形 .vidioc_s_selection = vidioc_s_selection, //设置选择矩形 .vidioc_cropcap = vidioc_cropcap, //查询裁剪限制 .vidioc_g_fmt_vbi_cap = vidioc_g_fmt_vbi_cap, //获取指向原始数据VBI的指针 .vidioc_try_fmt_vbi_cap = vidioc_g_fmt_vbi_cap, .vidioc_s_fmt_vbi_cap = vidioc_s_fmt_vbi_cap, .vidioc_g_fmt_sliced_vbi_cap = vidioc_g_fmt_sliced_vbi_cap, .vidioc_try_fmt_sliced_vbi_cap = vidioc_try_fmt_sliced_vbi_cap, .vidioc_s_fmt_sliced_vbi_cap = vidioc_s_fmt_sliced_vbi_cap, .vidioc_g_sliced_vbi_cap = vidioc_g_sliced_vbi_cap, .vidioc_g_fmt_vbi_out = vidioc_g_fmt_vbi_out, .vidioc_try_fmt_vbi_out = vidioc_g_fmt_vbi_out, .vidioc_s_fmt_vbi_out = vidioc_s_fmt_vbi_out, .vidioc_g_fmt_sliced_vbi_out = vidioc_g_fmt_sliced_vbi_out, .vidioc_try_fmt_sliced_vbi_out = vidioc_try_fmt_sliced_vbi_out, .vidioc_s_fmt_sliced_vbi_out = vidioc_s_fmt_sliced_vbi_out, .vidioc_enum_fmt_sdr_cap = vidioc_enum_fmt_sdr_cap, .vidioc_g_fmt_sdr_cap = vidioc_g_fmt_sdr_cap, .vidioc_try_fmt_sdr_cap = vidioc_try_fmt_sdr_cap, .vidioc_s_fmt_sdr_cap = vidioc_s_fmt_sdr_cap, .vidioc_overlay = vidioc_overlay, .vidioc_enum_framesizes = vidioc_enum_framesizes, .vidioc_enum_frameintervals = vidioc_enum_frameintervals, .vidioc_g_parm = vidioc_g_parm, .vidioc_s_parm = vidioc_s_parm, .vidioc_enum_fmt_vid_overlay = vidioc_enum_fmt_vid_overlay, .vidioc_g_fmt_vid_overlay = vidioc_g_fmt_vid_overlay, .vidioc_try_fmt_vid_overlay = vidioc_try_fmt_vid_overlay, .vidioc_s_fmt_vid_overlay = vidioc_s_fmt_vid_overlay, .vidioc_g_fmt_vid_out_overlay = vidioc_g_fmt_vid_out_overlay, .vidioc_try_fmt_vid_out_overlay = vidioc_try_fmt_vid_out_overlay, .vidioc_s_fmt_vid_out_overlay = vidioc_s_fmt_vid_out_overlay, .vidioc_g_fbuf = vidioc_g_fbuf, .vidioc_s_fbuf = vidioc_s_fbuf, /* 缓冲区操作 */ .vidioc_reqbufs = vb2_ioctl_reqbufs, //申请 .vidioc_create_bufs = vb2_ioctl_create_bufs, //创建 .vidioc_prepare_buf = vb2_ioctl_prepare_buf, //准备 .vidioc_querybuf = vb2_ioctl_querybuf, //查询 .vidioc_qbuf = vb2_ioctl_qbuf, //放入 .vidioc_dqbuf = vb2_ioctl_dqbuf, //取出 .vidioc_expbuf = vb2_ioctl_expbuf, //导出 .vidioc_streamon = vb2_ioctl_streamon, //启动 .vidioc_streamoff = vb2_ioctl_streamoff, //停止 /* 输入源操作 */ .vidioc_enum_input = vidioc_enum_input, //枚举输入源 .vidioc_g_input = vidioc_g_input, //获取输入源 .vidioc_s_input = vidioc_s_input, //设置输入源 .vidioc_s_audio = vidioc_s_audio, //设置音频 .vidioc_g_audio = vidioc_g_audio, //获取音频 .vidioc_enumaudio = vidioc_enumaudio, //枚举音频 .vidioc_s_frequency = vidioc_s_frequency, //设置频率 .vidioc_g_frequency = vidioc_g_frequency, //获取输入源 .vidioc_s_tuner = vidioc_s_tuner, //设置调谐器 .vidioc_g_tuner = vidioc_g_tuner, //获取调谐器 .vidioc_s_modulator = vidioc_s_modulator, //设置调制器 .vidioc_g_modulator = vidioc_g_modulator, //获取调制器 .vidioc_s_hw_freq_seek = vidioc_s_hw_freq_seek, //硬件频率搜索 .vidioc_enum_freq_bands = vidioc_enum_freq_bands, //枚举调谐器或调制器支持的频段 /* 输出端操作 */ .vidioc_enum_output = vidioc_enum_output, //枚举视频输出端 .vidioc_g_output = vidioc_g_output, //获取视频输出 .vidioc_s_output = vidioc_s_output, //设置视频输出 .vidioc_s_audout = vidioc_s_audout, //设置音频输出 .vidioc_g_audout = vidioc_g_audout, //获取音频输出 .vidioc_enumaudout = vidioc_enumaudout, //枚举视频输出端 /* 制式操作 */ .vidioc_querystd = vidioc_querystd, //查询制式 .vidioc_g_std = vidioc_g_std, //获取制式 .vidioc_s_std = vidioc_s_std, //设置制式 .vidioc_s_dv_timings = vidioc_s_dv_timings, //设置DV时序 .vidioc_g_dv_timings = vidioc_g_dv_timings, //获取DV时序 .vidioc_query_dv_timings = vidioc_query_dv_timings, //查询DV时序 .vidioc_enum_dv_timings = vidioc_enum_dv_timings, //枚举DV时序 .vidioc_dv_timings_cap = vidioc_dv_timings_cap, //查询DV应用程序功能 .vidioc_g_edid = vidioc_g_edid, //获取EDID数据块 .vidioc_s_edid = vidioc_s_edid, //设置EDID数据块 /* 调试操作 */ .vidioc_log_status = vidioc_log_status, //输出设备状态到内核日志 .vidioc_subscribe_event = vidioc_subscribe_event, //订阅V4L2事件 .vidioc_unsubscribe_event = v4l2_event_unsubscribe, //取消订阅V4L2事件&#125;; 提取出11个必须的ioctl:12345678910111213141516/* 表示它是一个摄像头设备 */.vidioc_querycap = vidioc_querycap, /* 摄像头数据格式的操作 */.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid, //列举格式.vidioc_g_fmt_vid_cap = vidioc_g_fmt_vid_cap, //获取格式.vidioc_try_fmt_vid_cap = vidioc_try_fmt_vid_cap, //测试格式.vidioc_s_fmt_vid_cap = vidioc_s_fmt_vid_cap, //设置格式/* 缓冲区操作 */.vidioc_reqbufs = vb2_ioctl_reqbufs, //申请.vidioc_querybuf = vb2_ioctl_querybuf, //查询.vidioc_qbuf = vb2_ioctl_qbuf, //放入.vidioc_dqbuf = vb2_ioctl_dqbuf, //取出.vidioc_streamon = vb2_ioctl_streamon, //启动.vidioc_streamoff = vb2_ioctl_streamoff, //停止 3.4 数据获取过程分析1.请求分配缓冲区12app:ioctl(fd, VIDIOC_REQBUFS, xx) videobuf_reqbufs(vdev-&gt;queue, p-&gt;memory, &amp;p-&gt;count);//没分配真正buf 2.查询映射缓冲区12345678app:ioctl(fd, VIDIOC_QUERYBUF, xx) videobuf_querybuf //获得buf的数据格式、大小、每一行长度、高度 v4l2_mmap vb2_fop_mmap videobuf_mmap_mapper __videobuf_mmap_mapper mem-&gt;vaddr = vmalloc_user(pages); //这里分配buf 3.把缓冲区放入队列12345app:ioctl(fd, VIDIOC_QBUF, xx) videobuf_qbuf q-&gt;ops-&gt;buf_prepare(q, buf, field); //调用驱动程序提供的函数做预处理 list_add_tail(&amp;buf-&gt;stream, &amp;q-&gt;stream); //把缓冲区放入队列的尾部 q-&gt;ops-&gt;buf_queue(q, buf); //用驱动程序提供的&quot;入队列函数&quot; 4.启动摄像头 123app:ioctl(fd, VIDIOC_STREAMON, xx) videobuf_streamon q-&gt;streaming = 1; 5.用select查询是否有数据123456789101112v4l2_poll vdev-&gt;fops-&gt;poll(); vivi_poll videobuf_poll_stream buf = list_entry(); //从队列的头部获得buf poll_wait(); //如果没有数据则休眠 vivid_thread_vid_cap //内核进程唤醒 vivid_thread_vid_cap_tick vivid_fillbuff //构造数据 vb2_buffer_done wake_up(); //唤醒进程 6.有数据后,从队列取出缓冲区12345app:ioctl(fd, VIDIOC_DQBUF, xx) //使用VIDIOC_DQBUF获取buf状态 videobuf_dqbuf stream_next_buffer //在队列里获得有数据的缓冲区 list_del //把它从队列中删掉 videobuf_status //把这个缓冲区的状态返回给APP 7.读取对应地址缓冲区应用程序根据VIDIOC_DQBUF所得到缓冲区状态，知道是哪一个缓冲区有数据,就去读对应的地址(该地址来自前面的mmap) 调试技巧: 1.得到xawtv进行了哪些系统调用:sudo strace -o xawtv.log xawtv2.在串口终端下，修改打印等级：sudo echo &quot;8 4 1 7&quot; &gt;/proc/sys/kernel/printk3.当无串口，即前面方法无效时，在SSH登陆时：tail -f /var/log/kern.log &amp;可实现内核打印增量显示。 4.编写vivid根据前面的分析，简单记录下虚拟视频驱动的编写流程： 1.注册平台设备和驱动；2.probe()函数： a.分配video_device； b.设置video_device，包括：release、fops、ioctl_ops、v4l2_dev； c.注册设置video_device； d.其它：定义/初始化自旋锁/定时器；3.填充操作函数v4l2_file_operations: a.open()：初始buf化队列和设置定时器； b.close():删除定时器和释放buf队列； c.mmap():调用videobuf_mmap_mapper开辟虚拟内存； d.poll():调用videobuf_poll_stream实现poll机制非阻塞访问；4.填充操作函数v4l2_ioctl_ops： 前面介绍的11个必须ioctl，几乎都是调用内核提供的API；5.填充操作函数videobuf_queue_ops： 对buf进行一些操作；6.填充数据: 利用定时器，不断产生数据并唤醒进程，实现获取到图像采集数据； [my_vivid.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494#include &lt;linux/module.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/sched.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/vmalloc.h&gt;#include &lt;linux/font.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/videodev2.h&gt;#include &lt;linux/v4l2-dv-timings.h&gt;#include &lt;media/videobuf2-vmalloc.h&gt;#include &lt;media/videobuf2-dma-contig.h&gt;#include &lt;media/v4l2-dv-timings.h&gt;#include &lt;media/v4l2-ioctl.h&gt;#include &lt;media/v4l2-fh.h&gt;#include &lt;media/v4l2-event.h&gt;#include &lt;media/v4l2-device.h&gt;#include &lt;media/videobuf-core.h&gt;#include &lt;media/videobuf-vmalloc.h&gt;#include \"fillbuf.c\"/* 队列操作a: 定义自旋锁、定时器、buf队列 */static spinlock_t my_vivid_queue_slock;static struct timer_list my_vivid_timer;static struct videobuf_queue my_vivid_vb_vidqueue;static struct list_head my_vivid_vb_local_queue;static void my_vivid_timer_function(unsigned long data)&#123; struct videobuf_buffer *vb; void *vbuf; struct timeval ts; printk(\"enter %s\\n\", __func__); /* 1. 构造数据: 从队列头部取出第1个videobuf, 填充数据 */ /* 1.1 从本地队列取出第1个videobuf */ if (list_empty(&amp;my_vivid_vb_local_queue)) &#123; goto out; &#125; vb = list_entry(my_vivid_vb_local_queue.next, struct videobuf_buffer, queue); /* Nobody is waiting on this buffer, return */ if (!waitqueue_active(&amp;vb-&gt;done)) goto out; /* 1.2 填充数据 */ vbuf = videobuf_to_vmalloc(vb); //memset(vbuf, 0xFF, vb-&gt;size); my_vivid_fillbuff(vb); vb-&gt;field_count++; do_gettimeofday(&amp;ts); vb-&gt;ts = ts; vb-&gt;state = VIDEOBUF_DONE; /* 1.3 把videobuf从本地队列中删除 */ list_del(&amp;vb-&gt;queue); /* 2. 唤醒进程: 唤醒videobuf-&gt;done上的进程 */ wake_up(&amp;vb-&gt;done);out: /* 3. 修改timer的超时时间 : 30fps, 1秒里有30帧数据 * 每1/30 秒产生一帧数据 */ mod_timer(&amp;my_vivid_timer, jiffies + HZ / 30);&#125;/* 参考documentations/video4linux/v4l2-framework.txt: drivers\\media\\video\\videobuf-core.c ops-&gt;buf_setup - calculates the size of the video buffers and avoid they to waste more than some maximum limit of RAM; ops-&gt;buf_prepare - fills the video buffer structs and calls videobuf_iolock() to alloc and prepare mmaped memory; ops-&gt;buf_queue - advices the driver that another buffer were requested (by read() or by QBUF); ops-&gt;buf_release - frees any buffer that were allocated. *//* videobuf operations *///APP调用ioctl VIDIOC_REQBUFS时会导致此函数被调用,它重新调整count和sizestatic int my_vivid_buffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)&#123; printk(\"enter %s\\n\", __func__); *size = my_vivid_format.fmt.pix.sizeimage; if (0 == *count) *count = 32; return 0;&#125;//APP调用ioctlVIDIOC_QBUF时导致此函数被调用,它会填充video_buffer结构体并调用videobuf_iolock来分配内存static int my_vivid_buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb, enum v4l2_field field)&#123; printk(\"enter %s\\n\", __func__); /* 1. 设置videobuf */ vb-&gt;size = my_vivid_format.fmt.pix.sizeimage; vb-&gt;bytesperline = my_vivid_format.fmt.pix.bytesperline; vb-&gt;width = my_vivid_format.fmt.pix.width; vb-&gt;height = my_vivid_format.fmt.pix.height; vb-&gt;field = field; /* 2. 做些准备工作 */ my_vivid_precalculate_bars(0); /* 3. 设置状态 */ vb-&gt;state = VIDEOBUF_PREPARED; return 0;&#125;/* APP调用ioctl VIDIOC_QBUF时: * 1. 先调用buf_prepare进行一些准备工作 * 2. 把buf放入stream队列 * 3. 调用buf_queue(起通知、记录作用) */static void my_vivid_buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)&#123; printk(\"enter %s\\n\", __func__); vb-&gt;state = VIDEOBUF_QUEUED; /* 把videobuf放入本地一个队列尾部 * 定时器处理函数就可以从本地队列取出videobuf */ list_add_tail(&amp;vb-&gt;queue, &amp;my_vivid_vb_local_queue);&#125;/* APP不再使用队列时, 用它来释放内存 */static void my_vivid_buffer_release(struct videobuf_queue *vq, struct videobuf_buffer *vb)&#123; printk(\"enter %s\\n\", __func__); videobuf_vmalloc_free(vb); vb-&gt;state = VIDEOBUF_NEEDS_INIT;&#125;static struct videobuf_queue_ops my_vivid_video_qops =&#123; .buf_setup = my_vivid_buffer_setup, /* 计算大小以免浪费 */ .buf_prepare = my_vivid_buffer_prepare, .buf_queue = my_vivid_buffer_queue, .buf_release = my_vivid_buffer_release,&#125;;/* v4l2_file_operations */static int my_vivid_open(struct file *file)&#123; printk(\"enter %s\\n\", __func__); //队列操作c:初始化 videobuf_queue_vmalloc_init(&amp;my_vivid_vb_vidqueue, &amp;my_vivid_video_qops, NULL, &amp;my_vivid_queue_slock, V4L2_BUF_TYPE_VIDEO_CAPTURE, V4L2_FIELD_INTERLACED, sizeof(struct videobuf_buffer), NULL, NULL); /* 倒数第3个参数是buffer的头部大小 */ my_vivid_timer.expires = jiffies + 1; add_timer(&amp;my_vivid_timer); return 0;&#125;static int my_vivid_close(struct file *file)&#123; printk(\"enter %s\\n\", __func__); del_timer(&amp;my_vivid_timer); videobuf_stop(&amp;my_vivid_vb_vidqueue); videobuf_mmap_free(&amp;my_vivid_vb_vidqueue); return 0;&#125;static int my_vivid_mmap(struct file *file, struct vm_area_struct *vma)&#123; printk(\"enter %s\\n\", __func__); return videobuf_mmap_mapper(&amp;my_vivid_vb_vidqueue, vma);&#125;static unsigned int my_vivid_poll(struct file *file, struct poll_table_struct *wait)&#123; printk(\"enter %s\\n\", __func__); return videobuf_poll_stream(file, &amp;my_vivid_vb_vidqueue, wait);&#125;/* v4l2_ioctl_ops */static int my_vivid_vidioc_querycap(struct file *file, void *priv, struct v4l2_capability *cap)&#123; printk(\"enter %s\\n\", __func__); strcpy(cap-&gt;driver, \"my_vivid\"); strcpy(cap-&gt;card, \"my_vivid\"); cap-&gt;version = 0x0001; cap-&gt;device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING | V4L2_CAP_DEVICE_CAPS; cap-&gt;capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING | V4L2_CAP_DEVICE_CAPS; return 0;&#125;static int my_vivid_vidioc_enum_fmt_vid_cap(struct file *file, void *priv, struct v4l2_fmtdesc *f)&#123; printk(\"enter %s\\n\", __func__); if (f-&gt;index &gt;= 1) return -EINVAL; strcpy(f-&gt;description, \"4:2:2, packed, YUYV\"); f-&gt;pixelformat = V4L2_PIX_FMT_YUYV; return 0;&#125;static int my_vivid_vidioc_g_fmt_vid_cap(struct file *file, void *priv, struct v4l2_format *f)&#123; printk(\"enter %s\\n\", __func__); memcpy(f, &amp;my_vivid_format, sizeof(my_vivid_format)); return 0;&#125;static int my_vivid_vidioc_try_fmt_vid_cap(struct file *file, void *priv, struct v4l2_format *f)&#123; unsigned int maxw, maxh; enum v4l2_field field; printk(\"enter %s\\n\", __func__); if (f-&gt;fmt.pix.pixelformat != V4L2_PIX_FMT_YUYV) return -EINVAL; field = f-&gt;fmt.pix.field; if (field == V4L2_FIELD_ANY) &#123; field = V4L2_FIELD_INTERLACED; &#125; else if (V4L2_FIELD_INTERLACED != field) &#123; return -EINVAL; &#125; maxw = 1024; maxh = 768; /* 调整format的width, height, * 计算bytesperline, sizeimage */ v4l_bound_align_image(&amp;f-&gt;fmt.pix.width, 48, maxw, 2, &amp;f-&gt;fmt.pix.height, 32, maxh, 0, 0); f-&gt;fmt.pix.bytesperline = (f-&gt;fmt.pix.width * 16) &gt;&gt; 3; f-&gt;fmt.pix.sizeimage = f-&gt;fmt.pix.height * f-&gt;fmt.pix.bytesperline; return 0;&#125;static int my_vivid_vidioc_s_fmt_vid_cap(struct file *file, void *priv, struct v4l2_format *f)&#123; int ret; printk(\"enter %s\\n\", __func__); ret = my_vivid_vidioc_try_fmt_vid_cap(file, NULL, f); if (ret &lt; 0) return ret; memcpy(&amp;my_vivid_format, f, sizeof(my_vivid_format)); return ret;&#125;static int my_vivid_vidioc_reqbufs(struct file *file, void *priv, struct v4l2_requestbuffers *p)&#123; printk(\"enter %s\\n\", __func__); return (videobuf_reqbufs(&amp;my_vivid_vb_vidqueue, p));&#125;static int my_vivid_vidioc_querybuf(struct file *file, void *priv, struct v4l2_buffer *p)&#123; printk(\"enter %s\\n\", __func__); return (videobuf_querybuf(&amp;my_vivid_vb_vidqueue, p));&#125;static int my_vivid_vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)&#123; printk(\"enter %s\\n\", __func__); return (videobuf_qbuf(&amp;my_vivid_vb_vidqueue, p));&#125;static int my_vivid_vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)&#123; printk(\"enter %s\\n\", __func__); return (videobuf_dqbuf(&amp;my_vivid_vb_vidqueue, p, file-&gt;f_flags &amp; O_NONBLOCK));&#125;static int my_vivid_vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)&#123; printk(\"enter %s\\n\", __func__); return videobuf_streamon(&amp;my_vivid_vb_vidqueue);&#125;static int my_vivid_vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)&#123; printk(\"enter %s\\n\", __func__); videobuf_streamoff(&amp;my_vivid_vb_vidqueue); return 0;&#125;static const struct v4l2_ioctl_ops my_vivid_ioctl_ops =&#123; // 表示它是一个摄像头设备 .vidioc_querycap = my_vivid_vidioc_querycap, /* 用于列举、获得、测试、设置摄像头的数据的格式 */ .vidioc_enum_fmt_vid_cap = my_vivid_vidioc_enum_fmt_vid_cap, .vidioc_g_fmt_vid_cap = my_vivid_vidioc_g_fmt_vid_cap, .vidioc_try_fmt_vid_cap = my_vivid_vidioc_try_fmt_vid_cap, .vidioc_s_fmt_vid_cap = my_vivid_vidioc_s_fmt_vid_cap, /* 缓冲区操作: 申请/查询/放入队列/取出队列 */ .vidioc_reqbufs = my_vivid_vidioc_reqbufs, .vidioc_querybuf = my_vivid_vidioc_querybuf, .vidioc_qbuf = my_vivid_vidioc_qbuf, .vidioc_dqbuf = my_vivid_vidioc_dqbuf, // 启动/停止 .vidioc_streamon = my_vivid_vidioc_streamon, .vidioc_streamoff = my_vivid_vidioc_streamoff,&#125;;static const struct v4l2_file_operations my_vivid_fops =&#123; .owner = THIS_MODULE, .open = my_vivid_open, .release = my_vivid_close, .mmap = my_vivid_mmap, .unlocked_ioctl = video_ioctl2, /* V4L2 ioctl handler */ .poll = my_vivid_poll,&#125;;static struct video_device *my_vivid_dev;static struct v4l2_device v4l2_dev;static void my_vivid_dev_release(struct video_device *vdev)&#123; printk(\"enter %s\\n\", __func__);&#125;static int my_vivid_probe(struct platform_device *pdev)&#123; int ret; printk(\"enter %s\\n\", __func__); /* 1.分配一个video_device结构体 */ my_vivid_dev = video_device_alloc(); if (NULL == my_vivid_dev) &#123; printk(\"Failed to alloc video device (%d)\\n\", ret); return -ENOMEM; &#125; /* 2.设置 */ my_vivid_dev-&gt;release = my_vivid_dev_release; my_vivid_dev-&gt;fops = &amp;my_vivid_fops; my_vivid_dev-&gt;ioctl_ops = &amp;my_vivid_ioctl_ops; my_vivid_dev-&gt;v4l2_dev = &amp;v4l2_dev; //队列操作b:初始化自旋锁 spin_lock_init(&amp;my_vivid_queue_slock); /* 3.注册 */ ret = video_register_device(my_vivid_dev, VFL_TYPE_GRABBER, -1); if (ret) &#123; printk(\"Failed to register as video device (%d)\\n\", ret); goto err_register_dev; &#125; //用定时器产生数据并唤醒进程 init_timer(&amp;my_vivid_timer); my_vivid_timer.function = my_vivid_timer_function; INIT_LIST_HEAD(&amp;my_vivid_vb_local_queue); return 0;err_register_dev: video_device_release(my_vivid_dev); return -ENODEV;&#125;static int my_vivid_remove(struct platform_device *pdev)&#123; printk(\"enter %s\\n\", __func__); v4l2_device_unregister(my_vivid_dev-&gt;v4l2_dev); video_device_release(my_vivid_dev); return 0;&#125;static void my_vivid_pdev_release(struct device *dev)&#123; printk(\"enter %s\\n\", __func__);&#125;static struct platform_device my_vivid_pdev =&#123; .name = \"my_vivid\", .dev.release = my_vivid_pdev_release,&#125;;static struct platform_driver my_vivid_pdrv =&#123; .probe = my_vivid_probe, .remove = my_vivid_remove, .driver = &#123; .name = \"my_vivid\", &#125;,&#125;;static int my_vivid_init(void)&#123; int ret; printk(\"enter %s\\n\", __func__); ret = platform_device_register(&amp;my_vivid_pdev); if (ret) return ret; ret = platform_driver_register(&amp;my_vivid_pdrv); if (ret) platform_device_unregister(&amp;my_vivid_pdev); return ret;&#125;static void my_vivid_exit(void)&#123; printk(\"enter %s\\n\", __func__); platform_driver_unregister(&amp;my_vivid_pdrv); platform_device_unregister(&amp;my_vivid_pdev);&#125;module_init(my_vivid_init);module_exit(my_vivid_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"A Virtual Video Test Code For Learn.\");MODULE_ALIAS(\"My vivid\");MODULE_VERSION(\"V1.0\"); 5.测试效果重新编译驱动，加载新驱动：123sudo modprobe vivid sudo rmmod vivid sudo insmod my_vivid.ko 实测还差两个驱动依赖：12sudo insmod /lib/modules/4.4.0-116-generic/kernel/drivers/media/v4l2-core/videobuf-core.ko sudo insmod /lib/modules/4.4.0-116-generic/kernel/drivers/media/v4l2-core/videobuf-vmalloc.ko 运行xawtv： 参考资料：韦东山第三期项目视频_摄像头 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"摄像头","slug":"摄像头","permalink":"http://yoursite.com/tags/摄像头/"}]},{"title":"博客一周年","date":"2018-03-01T05:02:26.000Z","path":"2018/03/01/博客一周年/","text":"2017-2018，博客一周年数据统计。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Linux电源管理","date":"2018-01-18T06:32:20.000Z","path":"2018/01/18/Linux电源管理/","text":"探究Linux电源管理模型，并为Tiny4412的LCD驱动添加电源管理。这是2018的第一篇博客，选了一个几乎没有接触过的角度作为开篇，希望2018年学习更多，记录更多。 1.电源管理的两种模型以往接触的Linux驱动，没遇到使用电池供电的情况，因此几乎没关注电源的管理。然而实际中，不少使用电池供电的硬件平台，例如手机、POS机等，就需要对电源进行管理，比如在不使用设备的时候，休眠屏幕省电。 Linux电源管理模型有两种：系统睡眠模型suspend和Runtime电源管理模型。 1.1系统睡眠模型Suspend On (on) S0 - WorkingStandby (standby） S1 - CPU and RAM are powered but not executedSuspend to RAM (mem) S3 - RAM is powered and the running content is saved to RAMSuspend to Disk, Hibernation (disk) S4 - All content is saved to Disk and power down S3 aka STR(suspend to ram),挂起到内存，简称待机。计算机将目前的运行状态等数据存放在内存，关闭硬盘、外设等设备，进入等待状态。此时内存仍然需要电力维持其数据，但整机耗电很少。恢复时计算机从内存读出数据，回到挂起前的状态，恢复速度较快。对DDR的耗电情况进行优化是S3性能的关键，大多数手持设备都是用S3待机。 S4 aka STD(suspend to disk),挂起到硬盘，简称休眠。把运行状态等数据存放在硬盘上某个文件或者某个特定的区域，关闭硬盘、外设等设备，进入关机状态。此时计算机完全关闭，不耗电。恢复时计算机从休眠文件/分区中读出数据，回到休眠前的状态，恢复速度较慢。 系统休眠模型给我的感觉是以整机角度进行省电。S3类似电脑的睡眠，在教长时间不使用电脑后，电脑黑屏，再次敲击键盘迅速显示桌面，原来的工作内容仍不变。S4类似电脑的休眠，在长时间不使用电脑后，电脑黑屏，再次敲击键盘无反应，按下电源键，开机，原来的工作内容仍不变。 对于嵌入式设备，更多的是使用S3，将数据暂时放在内存里，以实现快速恢复，就像手机的电源键按下黑屏，再次按下迅速亮屏。 在Linux中，通过cat /sys/power/state可以得知当前设备支持的节能模式，一般情况有如下选项： freeze:不涉及具体的Hardware或Driver，只是冻结所有的进程，包括用户空间进程及内核线程，能节省的能量较少，使用场景不多； standby:前面的S1状态，CPU处于浅睡眠模式，主要针对CPU功耗； mem:前面的S3状态，Suspend to RAM； disk:前面的S4状态，Suspend to Disk； 需要设置以上模式，只需echo mem &gt; /sys/power/state即可。 1.2 Runtime电源管理模型Runtime电源管理模型给我的感觉是以模块角度进行省电。某种程度上是“高内聚和低耦合”的体现。每个设备（包括CPU）都处理好自身的电源管理工作，尽量以最低的能耗完成交代的任务，尽量在不需要工作的时候进入低功耗状态，尽量不和其它模块有过多耦合。每个设备都是最节省的话，整个系统一定是最节省的。 2. 系统睡眠模型suspend2.1 Suspend流程分析suspend的流程还是挺复杂的，向/sys/power/state写入命令后再到唤醒，将进行以下流程： 对源码进行分析，其休眠过程如下：驱动程序里休眠相关的电源管理函数的调用过程:prepare—&gt;suspend—&gt;suspend_late—&gt;suspend_noirq 对源码进行分析，其唤醒过程如下：驱动程序里唤醒相关的电源管理函数的调用过程:resume_noirq—&gt;resume_early—&gt;resume-&gt;complete 对于驱动程序，我们主要关心Device PM(针对每一个驱动)和少量Platform dependent PM(针对CPU芯片相关)的内容。 2.2 使用Suspend功能首先将suspend功能加入内核：12Power management options ---&gt; [*] Suspend to RAM and standby 这里默认是勾选上了的，就不管了。 进入Tiny4412内核，尝试休眠echo mem &gt; /sys/power/state，系统提示No wake-up sources!。可见，要进入休眠，必须要有唤醒源，没有唤醒源，休眠也没有意义。 2.2.1 设置唤醒源唤醒源最常见的就是按键中断，就如同手机进入锁屏状态下，按下电源键唤醒一样，因此先写一个按键驱动。 原理图：底板上有四个按键，分别连在GPX3_2、GPX3_3、GPX3_4、GPX3_5，引脚状态常高，按键按下变低电平。 设备树： 1234567button_interrupt: button_interrupt &#123; compatible = &quot;tiny4412,button_interrupt&quot;; tiny4412,gpx3_2 = &lt;&amp;gpx3 2 GPIO_ACTIVE_HIGH&gt;; tiny4412,gpx3_3 = &lt;&amp;gpx3 3 GPIO_ACTIVE_HIGH&gt;; tiny4412,gpx3_4 = &lt;&amp;gpx3 4 GPIO_ACTIVE_HIGH&gt;; tiny4412,gpx3_5 = &lt;&amp;gpx3 5 GPIO_ACTIVE_HIGH&gt;;&#125;; 按键驱动： 12//设置为中断唤醒源irq_set_irq_wake(irq, 1); usb4604驱动：前面的Exynos4412——网卡移植和NFS启动里面，移植USB4604驱动时，删除了电源管理的代码，实际测试中唤醒时USB设备会报错，添加上电源管理相关代码即可： 123456789101112131415161718192021222324#ifdef CONFIG_PM_SLEEPstatic int usb4604_i2c_suspend(struct device *dev)&#123; struct i2c_client *client = to_i2c_client(dev); struct usb4604 *hub = i2c_get_clientdata(client); usb4604_switch_mode(hub, USB4604_MODE_STANDBY); return 0;&#125;static int usb4604_i2c_resume(struct device *dev)&#123; struct i2c_client *client = to_i2c_client(dev); struct usb4604 *hub = i2c_get_clientdata(client); usb4604_switch_mode(hub, hub-&gt;mode); return 0;&#125;#endifstatic SIMPLE_DEV_PM_OPS(usb4604_i2c_pm_ops, usb4604_i2c_suspend, usb4604_i2c_resume); 2.2.2 休眠唤醒(未成功)加入中断源后，休眠过程不再提示No wake-up sources!，看样子休眠应该成功了。此时，按下按键，板子并未唤醒，琢磨了一阵，初步怀疑有以下原因： 唤醒的时候，应该需要uboot配合，uboot读取某个寄存器来判断是正常启动还是唤醒； Exynos4412的PMU特性没摸透，可能需要其它额外的操作； Exynos4412启动时的BL1和BL2，可能也有影响； 这里先卡住，继续后面。 2.3 使驱动支持Suspend2.3.1 通知Notifier前面的suspend流程分析里面，在冻结APP之前,使用pm_notifier_call_chain(PM_SUSPEND_PREPARE)来通知驱动程序;在重启APP之后,使用pm_notifier_call_chain(PM_POST_SUSPEND)来通知驱动程序; 因此，如果驱动程序有事情在上述时机要处理，可以使用notifier机制。使用步骤： a.定义notifier_block结构体123static struct notifier_block lcd_pm_notif_block = &#123; .notifier_call = lcd_suspend_notifier,&#125;; b.notifier操作函数1234567891011121314static int lcd_suspend_notifier(struct notifier_block *nb, unsigned long event, void *dummy)&#123; switch (event) &#123; case PM_SUSPEND_PREPARE: printk(&quot;lcd suspend notifiler test: PM_SUSPEND_PREPARE\\n&quot;); return NOTIFY_OK; case PM_POST_SUSPEND: printk(&quot;lcd suspend notifiler test: PM_POST_SUSPEND\\n&quot;); return NOTIFY_OK; default: return NOTIFY_DONE; &#125;&#125; c.注册notifier在驱动init()或probe()里注册：12345ret = register_pm_notifier(&amp;lcd_pm_notif_block); if(ret) &#123; printk(&quot;failed to register pm notifier.\\n&quot;); return -EINVAL; &#125; 在前面LCD驱动上修改lcd_drv.c，测试如下： 2.3.2 Suspend和Resume前面的notifier只是通知，在冻结APP之前和重启APP之后通知，而电源管理应该刚好相反，是在冻结APP之后和重启APP之前对驱动的电源进行控制，这就需要suspend和resume来实现。 a.在platform_driver里的driver里添加pm结构体: 12345678910static struct platform_driver lcd_driver =&#123; .driver = &#123; .name = &quot;lcd_s702&quot;, .pm = &amp;lcd_pm, .of_match_table = of_match_ptr(lcd_dt_ids), &#125;, .probe = lcd_probe, .remove = lcd_remove,&#125;; b.设置pm成员函数： 1234static struct dev_pm_ops lcd_pm = &#123; .suspend = s702_lcd_suspend, .resume = s702_lcd_resume, &#125;; c.编写成员函数: 12345678910111213141516171819202122232425262728static int s702_lcd_suspend(struct device *dev)&#123; //lcd休眠操作 //Direct Off: ENVID and ENVID_F are set to \"0\" simultaneously. unsigned int temp; printk(\"enter %s\\n\", __func__); temp = readl(lcd_regs_base + VIDCON0); temp &amp;= ~(0x01 &lt;&lt; 1 | 0x01 &lt;&lt; 0); writel(temp, lcd_regs_base + VIDCON0); return 0;&#125;static int s702_lcd_resume(struct device *dev)&#123; //lcd唤醒操作 //Display On: ENVID and ENVID_F are set to \"1\". unsigned int temp; printk(\"enter %s\\n\", __func__); temp = readl(lcd_regs_base + VIDCON0); writel(temp | (0x01 &lt;&lt; 1) | (0x01 &lt;&lt; 0), lcd_regs_base + VIDCON0); return 0;&#125; 这里只是简单的关闭/打开显示，理论上的操作应该是：休眠时先备份所有LCD相关寄存器，恢复时再恢复所有寄存器，以及其它可能操作，比如重新开启时钟等。 同理，因为LCD显示和backlight是分开的，因此需要在backlight里也进行类似操作。 3.Runtime电源管理模型前面的suspend系统睡眠模型是将整个系统进行休眠，但如果需要在系统运行时，单独对某个模块进行休眠，就需要Runtime电源管理模型，这两个模型互相协作，才能最大的发挥电源管理的效果。 Runtime电源管理模型的原理比较简单，就是计数，当该设备驱动被使用时就加1，放弃使用时就减1，计数大于1时，就打开该设备的电源，等于0时就关闭电源。 Runtime PM相关的函数：a. 使能/禁止 Runtime PM：pm_runtime_enable / pm_runtime_disable (修改disable_depth变量)b. 增加计数/减少计数：pm_runtime_get_sync / pm_runtime_put_sync (修改usage_count变量)c. 回调函数 暂停/恢复/空闲：runtime_suspend / runtime_resume / runtime_idle 3.1 Runtime流程分析 调用pm_runtime_get_sync去增加使用次数以及恢复的流程如下： 调用pm_runtime_put_sync去减少使用次数以及暂停的流程如下： 前面的两个流程，只看到了runtime_resume和runtime_idle的调用，没有看到runtime_suspend，实际上，如果设备不提供runtime_idle, 则最终会调用runtime_suspend。 3.2 使用Runtime功能首先将Runtime功能加入内核，但本内核4.13.9里没找到相关选项，应该默认已经加入到内核里面了。 调用方式一：驱动程序提供接口, APP来调用。在驱动函数的open()、close()里，增加和减少引用计数。APP调用驱动的时候就能相应的恢复、暂停设备。 调用方式二：直接操作应用层文件：恢复： 1echo on &gt; /sys/devices/.../power/control 流程：control_store(drivers\\base\\power\\sysfs.c) -&gt; pm_runtime_forbid -&gt; atomic_inc -&gt; rpm_resume 暂停：1echo auto &gt; /sys/devices/.../power/control 流程：control_store(drivers\\base\\power\\sysfs.c) -&gt; pm_runtime_allow -&gt; atomic_dec_and_test -&gt; rpm_idle 3.3 使驱动支持Runtime a.在platform_driver里的driver里添加pm结构体:(和前面的一样，这里就无需操作) 12345678910static struct platform_driver lcd_driver =&#123; .driver = &#123; .name = &quot;lcd_s702&quot;, .pm = &amp;lcd_pm, .of_match_table = of_match_ptr(lcd_dt_ids), &#125;, .probe = lcd_probe, .remove = lcd_remove,&#125;; b.设置pm成员函数： 1234567static struct dev_pm_ops lcd_pm =&#123; .suspend = s702_lcd_suspend, .resume = s702_lcd_resume, .runtime_suspend = s702_lcd_suspend, .runtime_resume = s702_lcd_resume,&#125;; 添加runtime_suspend和runtime_resume，runtime和suspend的暂停配置是一样的，直接使用前面的。 c.编写成员函数:(和前面的一样，这里就无需操作) 12345678910111213141516171819202122232425262728static int s702_lcd_suspend(struct device *dev)&#123; //lcd休眠操作 //Direct Off: ENVID and ENVID_F are set to \"0\" simultaneously. unsigned int temp; printk(\"enter %s\\n\", __func__); temp = readl(lcd_regs_base + VIDCON0); temp &amp;= ~(0x01 &lt;&lt; 1 | 0x01 &lt;&lt; 0); writel(temp, lcd_regs_base + VIDCON0); return 0;&#125;static int s702_lcd_resume(struct device *dev)&#123; //lcd唤醒操作 //Display On: ENVID and ENVID_F are set to \"1\". unsigned int temp; printk(\"enter %s\\n\", __func__); temp = readl(lcd_regs_base + VIDCON0); writel(temp | (0x01 &lt;&lt; 1) | (0x01 &lt;&lt; 0), lcd_regs_base + VIDCON0); return 0;&#125; d.使能Runtime:对于Runtime PM,默认状态下设备的状态是Suspended,如果硬件上它是运行状态,需要调用pm_runtime_set_active()来修改它的状态,然后调用pm_runtime_enable()来使能Runtime PM。 在probe()函数的后面添加：12pm_runtime_set_active(&amp;pdev-&gt;dev);pm_runtime_enable(&amp;pdev-&gt;dev); 反之，还要在remove()里禁止：1pm_runtime_disable(&amp;pdev-&gt;dev); e.修改计数:一般在open()和release()里面增加和减少引用计数： 1234567891011121314151617181920212223242526272829303132333435363738static int s702_lcd_open(struct fb_info *info, int user)&#123; struct device *dev = info-&gt;dev; int ret; printk(\"enter %s\\n\", __func__); ret = pm_runtime_get_sync(dev); if (ret &lt; 0 &amp;&amp; ret != -EACCES) &#123; pm_runtime_put_sync(dev); return ret; &#125; return 0;&#125;static int s702_lcd_release(struct fb_info *info, int user)&#123; struct device *dev = info-&gt;dev; printk(\"enter %s\\n\", __func__); pm_runtime_put_sync(dev); return 0;&#125;static struct fb_ops tiny4412_lcdfb_ops =&#123; .owner = THIS_MODULE, .fb_setcolreg = cfb_setcolreg, //设置调色板，实现伪颜色表 .fb_fillrect = cfb_fillrect, //填充矩形 .fb_copyarea = cfb_copyarea, //数据复制 .fb_imageblit = cfb_imageblit, //图形填充 .fb_open = s702_lcd_open, .fb_release = s702_lcd_release&#125;; f.优化——加入延时机制:现在的程序基本完成，测试的时候，先加载backlight驱动insmod backlight_drv.ko，运行背光应用程序设置亮度./app 200；然后加载LCD驱动insmod lcd_drv.ko，运行图片显示应用程序jpg_rgb显示图像./jpg_rgb cq.jpg，结果并没有显示图像，手动的echo on &gt; /sys/devices/platform/11c00000.lcd_s702/power/control才正常显示图像。 上述流程中，运行图片显示应用程序时，先open()了一次，引用计数加1，程序调用完又马上close，引用计数减1，导致看不到显示，重新操作/sys/devices/platform/11c00000.lcd_s702/power/control就立即显示了图像。 对于正常的使用情景是，运行应用程序，立即图片显示，然后维持显示一段时间，如果有操作继续显示，没有的话再自己熄灭。因此，想要实现上面的功能，还需要加入自动休眠。 在之前的probe()中加入pm_runtime_use_autosuspend():123456//Runtimepm_runtime_use_autosuspend(&amp;pdev-&gt;dev);//add autosleeppm_runtime_set_autosuspend_delay(&amp;pdev-&gt;dev, 5000);pm_runtime_set_active(&amp;pdev-&gt;dev);pm_runtime_enable(&amp;pdev-&gt;dev); 同时，release()也要修改:1234567891011121314151617181920212223242526272829static int s702_lcd_open(struct fb_info *info, int user)&#123; struct device *dev = info-&gt;dev; int ret; printk(\"enter %s\\n\", __func__); ret = pm_runtime_get_sync(dev); if (ret &lt; 0 &amp;&amp; ret != -EACCES) &#123; pm_runtime_put_sync(dev); return ret; &#125; return 0;&#125;static int s702_lcd_release(struct fb_info *info, int user)&#123; struct device *dev = info-&gt;dev; printk(\"enter %s\\n\", __func__); //pm_runtime_put_sync(dev); pm_runtime_mark_last_busy(dev); pm_runtime_put_sync_autosuspend(dev); return 0;&#125; 此时，加载驱动后，运行应用程序，屏幕显示，5s后，屏幕自动熄灭，再次运行程序或者修改control来重新显示。 通过函数pm_runtime_set_autosuspend_delay()或修改echo xx &gt; /sys/devices/.../power/autosuspend_delay_ms来修改自动休眠时间。 完整代码见Github。 4.regulator系统前面的两个电源管理模型偏“软”，regulator系统偏“硬”，在复杂的单板中，有专门的电源管理芯片控制各个模块电源，regulator系统就是为这个电源芯片编写驱动，实现电源管理。 4.1 regulator框架 ①Regulator(稳定器):指可以自动维持恒定电压(voltage)或电流(current)的装置，一般指电源芯片。在嵌入式设备中，基本上每一种电压，都是经过regulator输出的；②③Consumer(使用者):使用电源的装置，Regulator是给Consumer供电的；④Machine(单板):使用软件语言(struct regulator_init_data)，静态的描述regulator在板级的物理现状，包含： a.级联关系:Regulator A的输出是Regulator B的输入，Regulator A就是Supply regulator，B是Consumer regulator； b.约束限制:Regulator Constraints，比如电压/电流最大值/最小值、允许的操作等； 从设备驱动的角度看，regulator系统比较简单，Machine提供Supply与Consumer的对应关系、单板相关的约束条件(device)；Regulator提供电源芯片的控制函数，如使能/去能、设置电压/电流等(driver)；Consumer调用Regulator相关函数控制电源的开关、调节(use)；即一个描述关系,一个提供相关函数，一个调用相关函数。 4.2 regulator流程 4.3 regulator驱动regulator系统仍然是采用总线设备驱动模型。device采用c文件或设备树的形式，提供硬件相关信息;driver加载后，一但和device名字匹配，就调用probe()函数注册register，并绑定操作函数； 后面将使用两种实现regulator驱动。这两种方式的核心都是一样的，device先提供Supply与Consumer的对应关系、单板相关的约束条件;driver提供电源芯片的控制函数，如使能/去能、设置电压/电流等。 4.3.1 C文件方式 device:在一个单板C文件里，提供级联关系regulator_consumer_supply,约束条件regulator_init_data: [machine.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/err.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/regulator/driver.h&gt;#include &lt;linux/mfd/core.h&gt;#include &lt;linux/regulator/machine.h&gt;#if 1static struct regulator_consumer_supply tiny4412_regulator_supplies[] =&#123; REGULATOR_SUPPLY(\"VCC_LCD\", \"11c00000.lcd_s702\"),//consumer的电源引脚名称;consumer的名字&#125;;#elsestatic struct regulator_consumer_supply tiny4412_regulator_supplies[] =&#123; REGULATOR_SUPPLY(\"VCC_LCD\", \"lcd_s702\"),&#125;;#endifstatic struct regulator_init_data tiny4412_regulator_init_data =&#123; .constraints = &#123; //.name = \"tiny4412_regulator\", .min_uV = 1000000, .max_uV = 1000000, .valid_modes_mask = REGULATOR_MODE_NORMAL, .valid_ops_mask = REGULATOR_CHANGE_STATUS, .boot_on = 0, .always_on = 0, &#125;, .num_consumer_supplies = 1, .consumer_supplies = tiny4412_regulator_supplies,&#125;;static void tiny4412_regulator_release(struct device *dev)&#123;&#125;static struct platform_device tiny4412_regulator_dev =&#123; .name = \"tiny4412_regulator\", .id = -1, .dev = &#123; .release = tiny4412_regulator_release, .platform_data = &amp;tiny4412_regulator_init_data, &#125;,&#125;;static int tiny4412_regulator_machine_init(void)&#123; printk(\"enter %s\\n\", __func__); platform_device_register(&amp;tiny4412_regulator_dev); return 0;&#125;static void tiny4412_regulator_machine_exit(void)&#123; printk(\"enter %s\\n\", __func__); platform_device_unregister(&amp;tiny4412_regulator_dev);&#125;module_init(tiny4412_regulator_machine_init);module_exit(tiny4412_regulator_machine_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"Tiny4412 machine driver.\");MODULE_ALIAS(\"Exynos4412_machine\");MODULE_VERSION(\"V1.0\"); driver提供操作函数并注册regulator: [regulator.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/err.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/regulator/driver.h&gt;#include &lt;linux/mfd/core.h&gt;#include &lt;linux/io.h&gt;static int regulator_states = 0;static int tiny4412_regulator_enable(struct regulator_dev *rdev)&#123; printk(\"enter %s\\n\", __func__); printk(\"------LCD Power Open.------\\n\"); regulator_states = 1; return 0;&#125;static int tiny4412_regulator_disable(struct regulator_dev *rdev)&#123; printk(\"enter %s\\n\", __func__); printk(\"------LCD Power Close.------\\n\"); regulator_states = 0; return 0;&#125;static int tiny4412_regulator_is_enabled(struct regulator_dev *rdev)&#123; printk(\"enter %s\\n\", __func__); printk(\"------LCD Power Test.------\\n\"); if (regulator_states) return 1; else return 0;&#125;static struct regulator_ops tiny4412_regulator_ops =&#123; .enable = tiny4412_regulator_enable, .disable = tiny4412_regulator_disable, .is_enabled = tiny4412_regulator_is_enabled,&#125;;static struct regulator_desc tiny4412_regulator_desc =&#123; .name = \"tiny4412_regulator\", .ops = &amp;tiny4412_regulator_ops, .type = REGULATOR_VOLTAGE,//电压源 .id = 0, .owner = THIS_MODULE, .n_voltages = 1,//能提供的电压数量&#125;;static struct regulator_dev *tiny4412_regulator_dev;static int tiny4412_regulator_probe(struct platform_device *pdev)&#123; struct regulator_config config = &#123; &#125;; config.dev = &amp;pdev-&gt;dev; config.init_data = dev_get_platdata(&amp;pdev-&gt;dev); printk(\"enter %s\\n\", __func__); tiny4412_regulator_dev = devm_regulator_register(&amp;pdev-&gt;dev, &amp;tiny4412_regulator_desc, &amp;config); if (IS_ERR(tiny4412_regulator_dev)) &#123; printk(\"devm_regulator_register error!\\n\"); return PTR_ERR(tiny4412_regulator_dev); &#125; return 0;&#125;static int tiny4412_regulator_remove(struct platform_device *pdev)&#123; printk(\"enter %s\\n\", __func__); devm_regulator_unregister(&amp;pdev-&gt;dev, tiny4412_regulator_dev); return 0;&#125;struct platform_driver tiny4412_regulator_drv =&#123; .probe = tiny4412_regulator_probe, .remove = tiny4412_regulator_remove, .driver = &#123; .name = \"tiny4412_regulator\", &#125;&#125;;static int tiny4412_regulator_init(void)&#123; printk(\"enter %s\\n\", __func__); platform_driver_register(&amp;tiny4412_regulator_drv); return 0;&#125;static void tiny4412_regulator_exit(void)&#123; printk(\"enter %s\\n\", __func__); platform_driver_unregister(&amp;tiny4412_regulator_drv);&#125;module_init(tiny4412_regulator_init);module_exit(tiny4412_regulator_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"Tiny4412 regulator driver.\");MODULE_ALIAS(\"Exynos4412_regulator\");MODULE_VERSION(\"V1.0\"); lcd_drv加载前面的machine.ko和regulator.ko，名字匹配后调用probe()注册regulator。在LCD驱动中，若想使用regulator系统，需要先在LCD驱动的probe()根据名字获取对应regulator： 1234567//regulatortiny4412_regulator = regulator_get(&amp;pdev-&gt;dev, &quot;VCC_LCD&quot;);if (IS_ERR(tiny4412_regulator))&#123; printk(&quot;regulator_get error!\\n&quot;); return -EIO;&#125; 再在suspend()和resume()封面便调用regulator_disable()和regulator_enable()。 此时，如果使用 系统睡眠模型 或 Runtime电源模型 进行休眠操作，就会调用到regulator系统的操作函数，实现电源管理芯片的关闭。 使用完后，释放regulator：12345678910111213141516171819static int lcd_remove(struct platform_device *pdev)&#123; //Direct Off: ENVID and ENVID_F are set to &quot;0&quot; simultaneously. unsigned int temp; temp = readl(lcd_regs_base + VIDCON0); temp &amp;= ~(0x01 &lt;&lt; 1 | 0x01 &lt;&lt; 0); writel(temp, lcd_regs_base + VIDCON0); regulator_put(tiny4412_regulator); pm_runtime_disable(&amp;pdev-&gt;dev); unregister_framebuffer(tiny4412_lcd); dma_free_writecombine(NULL, tiny4412_lcd-&gt;fix.smem_len, tiny4412_lcd-&gt;screen_base, tiny4412_lcd-&gt;fix.smem_start); framebuffer_release(tiny4412_lcd); return 0;&#125; 4.3.2 设备树方式与前面的操作几乎一样，只不过是在dts实现device。 dts在regulators节点下添加新的regulator，设置约束条件：1234567891011121314151617181920regulators &#123; compatible = &quot;simple-bus&quot;; #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;; mmc_reg: regulator@0&#123; compatible = &quot;regulator-fixed&quot;; reg = &lt;0&gt;; regulator-name = &quot;VMEM_VDD_2.8V&quot;; regulator-min-microvolt = &lt;2800000&gt;; regulator-max-microvolt = &lt;2800000&gt;; &#125;; lcd_reg: regulator@1&#123; compatible = &quot;tiny4412,lcd_regulator&quot;; regulator-name = &quot;VCC_LCD&quot;; regulator-min-microvolt = &lt;1200000&gt;; regulator-max-microvolt = &lt;1200000&gt;; &#125;;&#125;; 在lcd节点下，添加级联关系：12345678910lcd_s702@11C00000 &#123; compatible = &quot;tiny4412, lcd_s702&quot;; reg = &lt;0x11C00000 0x20c0 0x10010210 0x08 0x10023c80 0x04 0x1003c000 0x1000&gt;; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;lcd_s702&gt;; clocks = &lt;&amp;clock CLK_FIMD0 &amp;clock CLK_ACLK160&gt;; clock-names = &quot;fimd0&quot;,&quot;aclk160&quot;; vlcd-supply = &lt;&amp;lcd_reg&gt;; status = &quot;okay&quot;;&#125;; 其中vlcd-supply与前面的regulator联系了起来。 driver提供操作函数及注册： [regulator.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/err.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/regulator/driver.h&gt;#include &lt;linux/mfd/core.h&gt;#include &lt;linux/io.h&gt;#include &lt;linux/of.h&gt;static int regulator_states = 0;static int tiny4412_regulator_enable(struct regulator_dev *rdev)&#123; printk(\"enter %s\\n\", __func__); printk(\"------LCD Power Open.------\\n\"); regulator_states = 1; return 0;&#125;static int tiny4412_regulator_disable(struct regulator_dev *rdev)&#123; printk(\"enter %s\\n\", __func__); printk(\"------LCD Power Close.------\\n\"); regulator_states = 0; return 0;&#125;static int tiny4412_regulator_is_enabled(struct regulator_dev *rdev)&#123; printk(\"enter %s\\n\", __func__); printk(\"------LCD Power Test.------\\n\"); if (regulator_states) return 1; else return 0;&#125;static struct regulator_ops tiny4412_regulator_ops =&#123; .enable = tiny4412_regulator_enable, .disable = tiny4412_regulator_disable, .is_enabled = tiny4412_regulator_is_enabled,&#125;;static struct regulator_desc tiny4412_regulator_desc =&#123; .name = \"tiny4412_regulator_dev\", .ops = &amp;tiny4412_regulator_ops, .type = REGULATOR_VOLTAGE,//电压源 .id = 0, .owner = THIS_MODULE, .n_voltages = 1,//能提供的电压数量&#125;;static struct regulator_dev *tiny4412_regulator_dev;static int tiny4412_regulator_probe(struct platform_device *pdev)&#123; struct regulator_config config = &#123; &#125;; config.dev = &amp;pdev-&gt;dev; config.init_data = dev_get_platdata(&amp;pdev-&gt;dev); printk(\"enter %s\\n\", __func__); tiny4412_regulator_dev = devm_regulator_register(&amp;pdev-&gt;dev, &amp;tiny4412_regulator_desc, &amp;config); if (IS_ERR(tiny4412_regulator_dev)) &#123; printk(\"devm_regulator_register error!\\n\"); return PTR_ERR(tiny4412_regulator_dev); &#125; return 0;&#125;static int tiny4412_regulator_remove(struct platform_device *pdev)&#123; printk(\"enter %s\\n\", __func__); devm_regulator_unregister(&amp;pdev-&gt;dev, tiny4412_regulator_dev); return 0;&#125;static const struct of_device_id regulators_of_match[] =&#123; &#123; .compatible = \"tiny4412,lcd_regulator\" &#125;, &#123; &#125;,&#125;;MODULE_DEVICE_TABLE(of, regulators_of_match);struct platform_driver tiny4412_regulator_drv =&#123; .probe = tiny4412_regulator_probe, .remove = tiny4412_regulator_remove, .driver = &#123; .name = \"tiny4412_regulator_drv\", .of_match_table = of_match_ptr(regulators_of_match), &#125;&#125;;static int tiny4412_regulator_init(void)&#123; printk(\"enter %s\\n\", __func__); platform_driver_register(&amp;tiny4412_regulator_drv); return 0;&#125;static void tiny4412_regulator_exit(void)&#123; printk(\"enter %s\\n\", __func__); platform_driver_unregister(&amp;tiny4412_regulator_drv);&#125;module_init(tiny4412_regulator_init);module_exit(tiny4412_regulator_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"Tiny4412 regulator driver.\");MODULE_ALIAS(\"Exynos4412_regulator\");MODULE_VERSION(\"V1.0\"); lcd_drv和前面的使用完全一致。 参考资料：韦东山第三期项目视频_电源管理蜗窝科技 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"Exynos4412","slug":"Exynos4412","permalink":"http://yoursite.com/tags/Exynos4412/"},{"name":"电源管理","slug":"电源管理","permalink":"http://yoursite.com/tags/电源管理/"}]},{"title":"嵌入式Linux网络编程——TCP/UDP","date":"2017-12-30T01:55:13.000Z","path":"2017/12/30/嵌入式Linux网络编程——TCP_UDP/","text":"本文主要记录TCP/UDP网络编程的基础知识，采用TCP/UDP实现宿主机和目标机之间的网络通信。回想去年校招那会，笔试题老是出现TCP/UDP相关的内容。那时候的我，熟悉点硬件，勉强会点STM32，哪知道什么TCP/UDP……渐渐的，TCP/UDP似乎就成了一个挥之不去的阴影。赶在今年年底，简单的入下门，明年估计会用上。 1.目标暂时想不出什么好的应用场景，目前想到目标就是实现让两个设备通过网络传输数据，比如开发板和Linux主机之间传数据，以后就可以实现开发板通过网络上报数据或者主机通过网络控制开发板。 此外，暂时不想关心具体的网络模型，更注重于网络相关函数的直接使用。 2.Linux网络编程基础2.1 嵌套字多个TCP连接或者多个应用程序进程 可能需要同一个TCP端口传输数据。为了区分不同应用程序进程和连接，许多计算机操作系统为应用程序与TCP/IP交互提供了称为嵌套字(Socket)的接口。Linux中的网络编程正是通过Socket接口实现的，Socket是一种文件描述符。 常用的TCP/IP有以下三种类型的嵌套字： 流式嵌套字（SOCK_STREAM）用于提供面向连接的、可靠的数据传输服务，即使用TCP进行传输。 数据报嵌套字（SOCK_DGRAM）用于提供无连接的服务，即使用UDP进行传输。 原始嵌套字（SOCK_RAW）可以读写内核没有处理的IP数据报，而流式嵌套字只能读取TCP的数据，数据报嵌套字只能读取UDP的数据。 因此，如果要访问其它协议发送的数据必须使用原始嵌套字，它允许对底层协议(如IP或ICMP)直接访问。 2.2 端口TCP/IP协议中的端口，端口号的范围从0~65535。一类是由互联网指派名字和号码公司ICANN负责分配给一些常用的应用程序固定使用的“周知的端口”，其值一般为0~1023。例如http的端口号是80，FTP为21，SSH为22，Telnet为23等。还有一类是用户自己定义的，通常是大于1024的整型值。 2.3 网络地址网络通信，归根到底还是进程间的通信(不同计算机上的进程间通信)。在网络中，每一个节点(计算机或路由)都有一个网络地址，如192.168.1.4，也就是IP地址。两个进程通信时，首先要确定各自所在的网络节点的网络地址。 但是，网络地址只能确定进程所在的计算机，而一台计算机上很可能同时运行着多个进程，所以仅凭网络地址还不能确定到底是和网络中的哪一个进程进行通信，因此套接口中还需要包括其他的信息，也就是端口号（PORT）。在一台计算机中，一个端口号一次只能分配给一个进程，也就是说，在一台计算机中，端口号和进程之间是一一对应关系。 所以，使用端口号和网络地址的组合可以唯一的确定整个网络中的一个网络进程。 例如，如网络中某一台计算机的IP为192.168.1.4，操作系统分配给计算机中某一应用程序进程的端口号为1500，则此时192.168.1.4 1500就构成了一个套接口。 2.3.1 网络地址的格式在Socket程序设计中，struct sockaddr用于记录网络地址，其格式如下：12345struct sockaddr&#123; unsigned short sa_family; /*协议族，采用AF_XXX的形式，例如AF_INET(IPv4协议族)*/ char sa_data[14]; /*14字节的协议地址，包含该socket的IP地址和端口号。*/&#125;;但在实际编程中，并不针对sockaddr数据结构进行操作，而是用与其等价的sockaddr_in数据结构：1234567struct sockaddr_in&#123; short int sa_family; /*地址族*/ unsigned short int sin_port; /*端口号*/ struct in_addr sin_addr; /*IP地址*/ unsigned char sin_zero[8]; /*填充0 以保持与struct sockaddr同样大小*/&#125;; 2.3.2 网络地址的转换IP地址通常用数字加点(如192.168.1.4)表示，而在struct in_addr中使用的式32位整数表示。因此，Linux提供如下函数进行两者之间的转换： inet_aton()函数： 所需要头文件：#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;函数格式：int inet_aton(const char *cp, struct in_addr *inp);函数功能：将a.b.c.d字符串形式的IP地址转换成32位网络序号IP地址；*cp:存放字符串形式的IP地址的指针*inp:存放32位的网络序号IP地址返回值：转换成功，返回非0，否则返回0； inet_ntoa()函数：客户机端: 所需要头文件：#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;函数格式：char *inet_ntoa(struct in_addr in);函数功能：将32位网络序号IP地址转换成a.b.c.d字符串形式的IP地址；in：Internet主机地址的结构返回值：转换成功，返回一个字符指针，否则返回NULL； 2.4 字节序不同的CPU采用对变量的字节存储顺序可能不同。常用的X86结构是小端模式，很多的ARM，DSP都为小端模式，即内存的低地址存储数据的低字节，高地址存储数据的高字节。而KEIL C51则为大端模式，内存的高地址存储数据的低字节，低地址存储数据高字节。 对于网络传输来说，数据顺序必须是一致的，网络字节顺序采用大端字节序方式。下面是四个常用的转换函数： 主机转网络： htons()函数： 所需要头文件：#include &lt;netinet/in.h&gt;函数格式：unsigned short int htons(unsigned short int hostshort)函数功能：将参数指定的16位主机(host)字符顺序转换成网络(net)字符顺序；hostshort：待转换的16位主机字符顺序数返回值：返回对应的网络字符顺序数； htonl()函数： 所需要头文件：#include &lt;netinet/in.h&gt;函数格式：unsigned long int htons(unsigned long int hostlong)函数功能：将参数指定的32位主机(host)字符顺序转换成网络(net)字符顺序；hostlong：待转换的32位主机字符顺序数返回值：返回对应的网络字符顺序数； 网络转主机： ntohs()函数： 所需要头文件：#include &lt;netinet/in.h&gt;函数格式：unsigned short int ntohs(unsigned short int netshort)函数功能：将参数指定的16位网络(net)字符顺序转换成主机(host)字符顺序；netshort：待转换的16位网络字符顺序数返回值：返回对应的主机字符顺序数； ntohl()函数： 所需要头文件：#include &lt;netinet/in.h&gt;函数格式：unsigned long int ntohl(unsigned long int netlong)函数功能：将参数指定的32位网络(net)字符顺序转换成主机(host)字符顺序；netshort：待转换的32位网络字符顺序数返回值：返回对应的主机字符顺序数； 3.TCPTCP有专门的传递保证机制，收到数据时会自动发送确认消息，发送方收到确认消息后才会继续发送消息，否则继续等待。这样的好处是传输的数据是可靠的，此外它是有连接的传输，大多数网络传输都是用的TCP。 3.1 TCP流程图 3.2 TCP步骤分析程序分为服务器端和客户机端，先从服务器端开始分析。 服务器端:a. 创建socket123456sock_fd = socket(AF_INET, SOCK_STREAM, 0);//AF_INET:IPV4;SOCK_STREAM:TCPif (-1 == sock_fd)&#123; fprintf(stderr,\"socket error:%s\\n\\a\", strerror(errno)); exit(1);&#125; 所需要头文件：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数格式：int socket(int domain, int type, int protocol);函数功能：创建一个套接字；domain:协议域(族)，决定了套接字的地址类型，例如AF_INET决定了要用IPv4地址(32位)与端口号(16位)的组合。常见的协议族有：AF_INET、AF_INET6、AF_LOCAL(或称AF_UNIX)、AF_ROUTE等；type：指定套接字类型，SOCK_STREAM(TCP)、SOCK_DGRAM(UDP)、SOCK_RAWprotocol:指定socket所使用的传输协议编号，通常为0返回值：若成功，返回一个套接字描述符，否则返回-1； Socket就是一种文件描述符，和普通的打开文件一样，需要检测其返回结果。 b. 设置socket1234memset(&amp;server_addr, 0, sizeof(struct sockaddr_in));//clearserver_addr.sin_family = AF_INET;server_addr.sin_addr.s_addr = htonl(INADDR_ANY);//INADDR_ANY:This machine all IPserver_addr.sin_port = htons(PORT_NUMBER);设置何种协议族，设置本机IP和端口，也就有了唯一性。 c. 绑定socket1234567ret = bind(sock_fd, (struct sockaddr *)(&amp;server_addr), sizeof(struct sockaddr));if(-1 == ret)&#123; fprintf(stderr,\"bind error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1);&#125; 所需要头文件：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数格式：int bind(int sockfd, struct sockaddr *addr, int addrlen);函数功能：把套接字绑定到本地计算机的某一个端口上；sockfd:待绑定的套接字描述符addr：一个struct sockaddr *指针，指定要绑定给sockfd的协议地址。内容结构由前面的协议族决定。addrlen:地址的长度返回值：若成功，返回0，否则返回-1，错误信息存在errno中； d. 开始监听1234567ret = listen(sock_fd, BACKLOG);if (-1 == ret)&#123; fprintf(stderr,\"listen error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1);&#125; 所需要头文件：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数格式：int listen(int sockfd, int backlog);函数功能：使服务器的这个端口和IP处于监听状态，等待网络中某一客户机的连接请求，最大连接数量为backlog≤128；sockfd:待监听的套接字描述符backlog：最大可监听和连接的客户端数量返回值：若成功，返回0，否则返回-1； e. 阻塞，等待连接12345678addr_len = sizeof(struct sockaddr);new_fd = accept(sock_fd, (struct sockaddr *)&amp;client_addr, &amp;addr_len);if (-1 == new_fd)&#123; fprintf(stderr,\"accept error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1);&#125; 所需要头文件：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数格式：int accept(int sockfd, struct sockaddr *addr, int *addrlen);函数功能：接受连接请求，建立起与客户机之间的通信连接。服务器处于监听状态时，如果某时刻获得客户机的连接请求，此时并不是立即处理这个请求，而是将这个请求放在等待队列中，当系统空闲时再处理客户机的连接请求；当accept函数接受一个连接时，会返回一个新的socket标识符，以后的数据传输和读取就要通过这个新的socket编号来处理，原来参数中的socket也可以继续使用，继续监听其它客户机的连接请求；accept连接成功时，参数addr所指的结构体会填入所连接机器的地址数据；sockfd:待监听的套接字描述符addr:指向struct sockaddr的指针，用于返回客户端的协议地址addrlen:协议地址的长度返回值：若成功，返回一个由内核自动生成的一个全新描述字，代表与返回客户的TCP连接，否则返回-1，错误信息存在errno中； f. 接收数据123456789101112recv_len = recv(new_fd, recv_buf, 999, 0);if (recv_len &lt;= 0)&#123; fprintf(stderr, \"recv error:%s\\n\\a\", strerror(errno))； close(new_fd); exit(1);&#125;else&#123; recv_buf[recv_len] = '\\0'; printf(\"Get msg from client%d: %s\\n\", client_num, recv_buf);&#125; 所需要头文件：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数格式：int recv(int sockfd, void *buf, size_t len, int flags);函数功能：用新的套接字来接收远端主机传来的数据，并把数据存到由参数buf指向的内存空间；sockfd:sockfd为前面accept的返回值，即new_fd，也就是新的套接字buf:指明一个缓冲区len:指明缓冲区的长度flags:通常为0返回值：若成功，返回接收到的字节数，另一端已关闭则返回0，否则返回-1，错误信息存在errno中； g. 关闭socket12close(sock_fd);exit(0); 为了应对多个连接，并保证它们之间相互独立，实际编程中往往还要加入多进程fork()。让子进程接收数据，父进程继续监听新的连接。 客户机端: a. 创建socket123456sock_fd = socket(AF_INET, SOCK_STREAM, 0);//AF_INET:IPV4;SOCK_STREAM:TCPif (-1 == sock_fd)&#123; fprintf(stderr,\"socket error:%s\\n\\a\", strerror(errno)); exit(1);&#125; b. 设置socket123memset(&amp;server_addr, 0, sizeof(struct sockaddr_in));//clearserver_addr.sin_family = AF_INET;server_addr.sin_port = htons(PORT_NUMBER);其中注意的是，这里设置的socket内容是指 希望连接的服务器IP和端口号信息，IP地址来自用户的输入，并转换格式得到。因此，这里的设置和服务器的设置，要保持内容上的一致。1234567ret = inet_aton(argv[1], &amp;server_addr.sin_addr);if(0 == ret)&#123; fprintf(stderr,\"server_ip error.\\n\"); close(sock_fd); exit(1);&#125; c. 连接1234567ret = connect(sock_fd, (const struct sockaddr *)&amp;server_addr, sizeof(struct sockaddr)); if (-1 == ret)&#123; fprintf(stderr,\"connect error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1);&#125; 所需要头文件：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数格式：int connect (int sockfd, struct sockaddr *serv_addr, int addrlen);函数功能：用来请求连接远程服务器，将参数sockfd的socket连至参数serv_addr所指定的服务器IP和端口号上去；sockfd:客户端的socket套接字serv_addr:一个struct sockaddr类型的结构体指针变量，存储着远程服务器的IP与端口号信息addrlen:结构体变量的长度返回值：若成功，返回0，否则返回-1，错误信息存在errno中； d. 发送1234567send_buf = send(sock_fd, send_buf, strlen(send_buf), 0);if (send_buf &lt;= 0)&#123; fprintf(stderr,\"send error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1);&#125; 所需要头文件：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数格式：int send(int sockfd, const void *buf, int len, int flags);函数功能：用来发送数据给指定的远端主机；sockfd:客户端的socket套接字buf:指明一个缓冲区len:指明缓冲区的长度flags:通常为0返回值：若成功，返回发送的字节数，否则返回-1，错误信息存在errno中 d. 关闭socket12close(sock_fd);exit(0); 3.3 TCP完整代码[tcp_server.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** tcp_server.c# Copyright (C) 2017 hceng, &lt;huangcheng.job@foxmail.com&gt;# Licensed under terms of GPLv2## This program is used for TCP / UDP learning.# https://hceng.cn/*/#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#define PORT_NUMBER 8888#define BACKLOG 10/* socket-&gt;bind-&gt;listen-&gt;accept-&gt;send/recv-&gt;close*/int main(int argc, char **argv)&#123; int sock_fd, new_fd; struct sockaddr_in server_addr; struct sockaddr_in client_addr; int ret; int addr_len; int recv_len; unsigned char recv_buf[1000]; int client_num = -1; signal(SIGCHLD,SIG_IGN); /* socket */ sock_fd = socket(AF_INET, SOCK_STREAM, 0);//AF_INET:IPV4;SOCK_STREAM:TCP if (-1 == sock_fd) &#123; fprintf(stderr,\"socket error:%s\\n\\a\", strerror(errno)); exit(1); &#125; /* set server sockaddr_in */ memset(&amp;server_addr, 0, sizeof(struct sockaddr_in));//clear server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = htonl(INADDR_ANY);//INADDR_ANY:This machine all IP server_addr.sin_port = htons(PORT_NUMBER); /* bind */ ret = bind(sock_fd, (struct sockaddr *)(&amp;server_addr), sizeof(struct sockaddr)); if(-1 == ret) &#123; fprintf(stderr,\"bind error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1); &#125; /* listen */ ret = listen(sock_fd, BACKLOG); if (-1 == ret) &#123; fprintf(stderr,\"listen error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1); &#125; /* accept */ while(1) &#123; addr_len = sizeof(struct sockaddr); new_fd = accept(sock_fd, (struct sockaddr *)&amp;client_addr, &amp;addr_len); if (-1 == new_fd) &#123; fprintf(stderr,\"accept error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1); &#125; client_num++; fprintf(stderr, \"Server get connetion form client%d: %s\\n\", client_num, inet_ntoa(client_addr.sin_addr)); if (!fork()) &#123; /* Child process */ while (1) &#123; /* recv */ recv_len = recv(new_fd, recv_buf, 999, 0); if (recv_len &lt;= 0) &#123; fprintf(stderr, \"recv error:%s\\n\\a\", strerror(errno)); close(new_fd); exit(1); &#125; else &#123; recv_buf[recv_len] = '\\0'; printf(\"Get msg from client%d: %s\\n\", client_num, recv_buf); &#125; &#125; close(new_fd); &#125; &#125; /* close */ close(sock_fd); exit(0); &#125; [tcp_client.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** tcp_client.c# Copyright (C) 2017 hceng, &lt;huangcheng.job@foxmail.com&gt;# Licensed under terms of GPLv2## This program is used for TCP / UDP learning.# https://hceng.cn/*/#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;netdb.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#define PORT_NUMBER 8888/* socket-&gt;connect-&gt;send-&gt;close*/int main(int argc, char *argv[])&#123; int sock_fd; struct sockaddr_in server_addr; int ret; unsigned char send_buf[1000]; int send_len; if(argc != 2) &#123; fprintf(stderr, \"Usage:%s hostname\\n\\a\", argv[0]); exit(1); &#125; /* socket */ sock_fd = socket(AF_INET, SOCK_STREAM, 0);//AF_INET:IPV4;SOCK_STREAM:TCP if (-1 == sock_fd) &#123; fprintf(stderr,\"socket error:%s\\n\\a\", strerror(errno)); exit(1); &#125; /* set sockaddr_in parameter*/ memset(&amp;server_addr, 0, sizeof(struct sockaddr_in));//clear server_addr.sin_family = AF_INET; server_addr.sin_port = htons(PORT_NUMBER); ret = inet_aton(argv[1], &amp;server_addr.sin_addr); if(0 == ret) &#123; fprintf(stderr,\"server_ip error.\\n\"); close(sock_fd); exit(1); &#125; /* connect */ ret = connect(sock_fd, (const struct sockaddr *)&amp;server_addr, sizeof(struct sockaddr)); if (-1 == ret) &#123; fprintf(stderr,\"connect error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1); &#125; while (1) &#123; if (fgets(send_buf, 999, stdin)) &#123; /* send */ send_len = send(sock_fd, send_buf, strlen(send_buf), 0); if (send_len &lt;= 0) &#123; fprintf(stderr,\"send error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1); &#125; &#125; &#125; /* close */ close(sock_fd); exit(0);&#125; 3.4 测试结果先在Ubuntu主机上交叉编译服务器端代码，再在Ubuntu主机上编译客户端代码。在开发板上运行服务器端代码，在Ubuntu主机先启动tmux分屏，再分别运行客户端代码。 服务器端 客户机端 4.UDPUDP没有传递保证机制，如果传输中数据丢失，协议不会有任何的检测或提示。这样的好处是传输的数据是持续的，此外它是无连接的传输，比如实时视频时，如果采用TCP，中途有一点点数据出错都会卡住，进行等待，产生延时。加入使用UDP，尽管有少量的丢帧，但数据是实时的。 4.1 UDP流程图 4.2 UDP步骤分析从流程图可以看出，UDP比TCP的步骤少多了。 服务器端: a. 创建socket123456sock_fd = socket(AF_INET, SOCK_DGRAM, 0);//AF_INET:IPV4;SOCK_DGRAM:UDPif (-1 == sock_fd)&#123; fprintf(stderr,\"socket error:%s\\n\\a\", strerror(errno)); exit(1);&#125;协议族改成SOCK_DGRAM。 b. 设置socket1234memset(&amp;server_addr, 0, sizeof(struct sockaddr_in));//clearserver_addr.sin_family = AF_INET;server_addr.sin_addr.s_addr = htonl(INADDR_ANY);//INADDR_ANY:This machine all IPserver_addr.sin_port = htons(PORT_NUMBER);和前面的TCP设置还是一样的。 c. 绑定socket1234567ret = bind(sock_fd, (struct sockaddr *)(&amp;server_addr), sizeof(struct sockaddr));if(-1 == ret)&#123; fprintf(stderr,\"bind error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1);&#125;绑定的操作也没有变。 d. 接收数据12345678910111213addr_len = sizeof(struct sockaddr);recv_len = recvfrom(sock_fd, recv_buf, 999, 0, (struct sockaddr *)&amp;server_addr, &amp;addr_len);if (recv_len &lt;= 0)&#123; fprintf(stderr, \"recvfrom error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1);&#125;else&#123; recv_buf[recv_len] = '\\0'; printf(\"Get msg from client%d: %s\\n\", client_num, recv_buf);&#125; 所需要头文件：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数格式：int recvfrom(int sockfd, char FAR *buf, int len, int flags, struct sockaddr FAR *from, int FAR *fromlen);函数功能：从套接字上接收一个数据报并保存源地址；sockfd:标识一个已连接套接字的描述符buf:接收数据缓冲区len:接收数据缓冲区长度flags:调用操作方式，由以下零个或多个组成 flags 说明 recv send MSG_DONTROUTE 绕过路由表查找 • MSG_DONTWAIT 仅本操作非阻塞 • • MSG_OOB 发送或接收带外数据 • • MSG_PEEK 窥看外来消息 • MSG_WAITALL 等待所有数据 • from:(可选)指针，指向装有源地址的缓冲区fromlen:(可选)指针，指向from缓冲区长度值返回值：若成功，返回读入的字节数，否则返回0； e. 关闭12close(sock_fd);exit(0); 客户机端: a. 创建socket123456sock_fd = socket(AF_INET, SOCK_DGRAM, 0);//AF_INET:IPV4;SOCK_DGRAM:UDPif (-1 == sock_fd)&#123; fprintf(stderr,\"socket error:%s\\n\\a\", strerror(errno)); exit(1);&#125;协议族改成SOCK_DGRAM。 b. 设置socket12345678910memset(&amp;server_addr, 0, sizeof(struct sockaddr_in));//clearserver_addr.sin_family = AF_INET;server_addr.sin_port = htons(PORT_NUMBER);ret = inet_aton(argv[1], &amp;server_addr.sin_addr);if(0 == ret)&#123; fprintf(stderr,\"server_ip error.\\n\"); close(sock_fd); exit(1);&#125; c. 发送数据12345678addr_len = sizeof(struct sockaddr);send_len = sendto(sock_fd, send_buf, strlen(send_buf), 0, (const struct sockaddr *)&amp;server_addr, addr_len);if (send_len &lt;= 0)&#123; fprintf(stderr,\"send error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1);&#125; 所需要头文件：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数格式：int sendto(int sockfd, char FAR *buf, int len, int flags, struct sockaddr FAR *to, int FAR *tolen);函数功能：向一指定目的地发送数据；sockfd:一个标识套接字的描述字buf:发送数据缓冲区len:发送数据缓冲区长度flags:调用方式标志位to:(可选)指针，指向目的的套接字的地址tolen:目的套接字地址的长度返回值：若成功，返回发送的字节数，如果连接已中止，返回0，如果发生错误，返回-1； d. 关闭12close(sock_fd);exit(0);UDP传输的客户端少了connect()，原本该在connect()函数里传入服务器地址相关信息，现在变成了在sendto()里传入。 4.3 UDP完整代码[udp_client.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** udp_server.c# Copyright (C) 2017 hceng, &lt;huangcheng.job@foxmail.com&gt;# Licensed under terms of GPLv2## This program is used for TCP / UDP learning.# https://hceng.cn/*/#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#define PORT_NUMBER 8888/* socket-&gt;bind-&gt;recvfrom/sendto-&gt;close */int main(int argc, char **argv)&#123; int sock_fd; struct sockaddr_in server_addr; struct sockaddr_in client_addr; int ret; int addr_len; int recv_len; unsigned char recv_buf[1000]; /* socket */ sock_fd = socket(AF_INET, SOCK_DGRAM, 0);//AF_INET:IPV4;SOCK_DGRAM:UDP if (-1 == sock_fd) &#123; fprintf(stderr,\"socket error:%s\\n\\a\", strerror(errno)); exit(1); &#125; /* set sockaddr_in parameter*/ memset(&amp;server_addr, 0, sizeof(struct sockaddr_in));//clear server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = htonl(INADDR_ANY);//INADDR_ANY:This machine all IP server_addr.sin_port = htons(PORT_NUMBER); /* bind */ ret = bind(sock_fd, (struct sockaddr *)(&amp;server_addr), sizeof(struct sockaddr)); if(-1 == ret) &#123; fprintf(stderr,\"bind error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1); &#125; while (1) &#123; /* recvfrom */ addr_len = sizeof(struct sockaddr); recv_len = recvfrom(sock_fd, recv_buf, 999, 0, (struct sockaddr *)&amp;client_addr, &amp;addr_len); if (recv_len &lt;= 0) &#123; fprintf(stderr, \"recvfrom error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1); &#125; else &#123; recv_buf[recv_len] = '\\0'; printf(\"Get msg from client:%s: %s\\n\", inet_ntoa(client_addr.sin_addr), recv_buf); &#125; &#125; /* close */ close(sock_fd); exit(0); &#125; [udp_client.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** udp_client.c# Copyright (C) 2017 hceng, &lt;huangcheng.job@foxmail.com&gt;# Licensed under terms of GPLv2## This program is used for TCP / UDP learning.# https://hceng.cn/*/#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;netdb.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#define PORT_NUMBER 8888/* socket-&gt;bind-&gt;recvfrom/sendto-&gt;close */int main(int argc, char *argv[])&#123; int sock_fd; struct sockaddr_in server_addr; int ret; unsigned char send_buf[1000]; int send_len; int addr_len; if(argc != 2) &#123; fprintf(stderr, \"Usage:%s hostname\\n\\a\", argv[0]); exit(1); &#125; /* socket */ sock_fd = socket(AF_INET, SOCK_DGRAM, 0);//AF_INET:IPV4;SOCK_DGRAM:UDP if (-1 == sock_fd) &#123; fprintf(stderr,\"socket error:%s\\n\\a\", strerror(errno)); exit(1); &#125; /* set sockaddr_in parameter*/ memset(&amp;server_addr, 0, sizeof(struct sockaddr_in));//clear server_addr.sin_family = AF_INET; server_addr.sin_port = htons(PORT_NUMBER); ret = inet_aton(argv[1], &amp;server_addr.sin_addr); if(0 == ret) &#123; fprintf(stderr,\"server_ip error.\\n\"); close(sock_fd); exit(1); &#125; while (1) &#123; if (fgets(send_buf, 999, stdin)) &#123; /* sendto */ addr_len = sizeof(struct sockaddr); send_len = sendto(sock_fd, send_buf, strlen(send_buf), 0, \\(const struct sockaddr *)&amp;server_addr, addr_len); if (send_len &lt;= 0) &#123; fprintf(stderr,\"send error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1); &#125; &#125; &#125; /* close */ close(sock_fd); exit(0);&#125; 4.4 测试结果和前面TCP测试方式一样，先在Ubuntu主机上交叉编译服务器端代码，再在Ubuntu主机上编译客户端代码。在开发板上运行服务器端代码，在Ubuntu主机先启动tmux分屏，再分别运行客户端代码。 服务器端 客户机端 参考资料：博客：很全的linux网络编程技巧王粉花. 2016. 嵌入式Linux编程与实践教程.北京: 科学出版社.韦东山第三期项目:第1课第6.1节_一小时学会网络编程_两个简单例子_tcp_udp 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux环境编程","slug":"Linux环境编程","permalink":"http://yoursite.com/tags/Linux环境编程/"},{"name":"TCP/UDP","slug":"TCP-UDP","permalink":"http://yoursite.com/tags/TCP-UDP/"}]},{"title":"Exynos4412——触摸屏驱动","date":"2017-12-26T01:34:47.000Z","path":"2017/12/26/Exynos4412——触摸屏驱动/","text":"移植Exynos4412的I2C接口触摸屏驱动。这应该是Exynos4412 LCD部分的最后一部分了。为了去探索LCD驱动，前面做了一系列的准备工作，最后终于完成了LCD驱动，现在只剩下触摸屏这个最后的“尾巴”。 1.工作原理前面LCD之backligth部分说了，友善之臂这个屏，为了改善大尺寸四线电阻触摸屏的性能，外加了一个低成本的MCU去控制专业的触控芯片，将滤波后的稳定数据通过GPIO传回到ARM上。但我的板子LCD是电容屏，查阅相关资料后得知，是通过一个FT5406触摸屏芯片实现的电容触摸功能。 根据FT5x06.pdf手册可得知其工作的框架：当触摸屏上发生触摸操作时，通过TXn(Transmit output pin)和RXn(Receiver input pins)传输给FT5406，FT5406经过处理后，将坐标信息通过Serial Interface(I2C or SPI)发给Host(开发板)。 查阅FT5x06.pdf，可以看到FT5x06对外有如下接口： I2C/SPI：与主机进行数据交换的接口INT：中断信号接口，通知主处理器触摸数据准备好读取WAKE：主机将FT5x06从休眠模式切换到主动模式的中断信号RST：外部低电平信号复位芯片 因此，开发板至少的有I2C/SPI和INT与FT5x06相连。 2.原理图 Tiny4412-1412-Schematic.pdf：I2C使用I2C1，INT使用GPX1_6引脚。 Tiny4412SDK-1506-Schematic.pdf：在底板上经过一次电平转换引出到LCD1接口上。 LCD-S702-1509.pdf：LCD上并没有FT5x06的相关信息，只提供了一个CON5接口。友善之臂封装好了LCD和触摸屏，对外只提供I2C接口。 对于驱动来说，触摸屏就是一个带中断的信号的I2C设备。 3. 设备树文件ft5406 作为 i2c_1 的子节点。12345678910111213&amp;i2c_1 &#123; samsung,i2c-sda-delay = &lt;100&gt;; samsung,i2c-max-bus-freq = &lt;400000&gt;; status = &quot;okay&quot;; polytouch: edt-ft5x06@38 &#123; compatible = &quot;edt,edt-ft5406&quot;, &quot;edt,edt-ft5x06&quot;; reg = &lt;0x38&gt;; interrupt-parent = &lt;&amp;gpx1&gt;; interrupts = &lt;6 IRQ_TYPE_EDGE_FALLING&gt;; touchscreen-size-x = &lt;800&gt;; touchscreen-size-y = &lt;480&gt;; &#125;; &#125;; 内核已经有了ft5x06驱动，所有对应的也会有设备树的描述文件：linux-4.13.9/Documentation/devicetree/bindings/input/touchscreen/edt-ft5x06.txtlinux-4.13.9/Documentation/devicetree/bindings/input/touchscreen/touchscreen.txt详细介绍了设备树的必要参数和非必要参数。 4. 驱动程序内核中ft5x06驱动所在路径：linux-4.13.9/drivers/input/touchscreen/edt-ft5x06.c 这块的内容，暂时不想分析，涉及I2C子系统和输入子系统，回头再慢慢分析。 5. 测试程序[app.c]link12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;linux/input.h&gt; int main() &#123; int keys_fd; char ret[2]; struct input_event t; keys_fd = open(\"/dev/input/event0\", O_RDONLY); //打开TP设备 if(keys_fd&lt;=0)&#123; printf(\"open /dev/input/event0 device error!\\n\"); return 0; &#125; while(1) &#123; if(read(keys_fd, &amp;t, sizeof(t))==sizeof(t)) &#123; if (t.type == EV_KEY) &#123; printf(\" type: EV_KEY, event = %s, value = %d \\r\\n\", t.code == BTN_TOUCH ? \"BTN_TOUCH\" : \"Unkown\", t.value); &#125; else if(t.type == EV_ABS) &#123; printf(\" type: EV_ABS, event = %s, value = %d \\r\\n\", t.code == ABS_X ? \"ABS_X\" : t.code == ABS_Y ? \"ABS_Y\" : t.code == ABS_PRESSURE ? \"ABS_PRESSURE\" :\"Unkown\", t.value); &#125; &#125; &#125; close(keys_fd); return 0; &#125; 参考博客：Linux和android下测试键盘和触摸屏 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"Exynos4412","slug":"Exynos4412","permalink":"http://yoursite.com/tags/Exynos4412/"},{"name":"触摸屏","slug":"触摸屏","permalink":"http://yoursite.com/tags/触摸屏/"}]},{"title":"Exynos4412——LCD驱动","date":"2017-12-22T12:15:29.000Z","path":"2017/12/22/Exynos4412——LCD驱动/","text":"Exynos4412的LCD驱动。终于迎来了LCD驱动，本该10月初就搞定的事，一直拖到了12月份。不过，晚来总比不来好，完成这个心结，才好进入下一个阶段。 1. 基础知识开发板的液晶屏型号S702，7寸电容型TFT触摸屏，分辨率为800X480。 先记录下一些图像显示的基本知识。 1.1 颜色的量化显示器的颜色一般采用RGB标准，通过对红(RED)、绿(GREEN)，蓝(BLUE)三个颜色相互叠加得到各种不同的颜色。1）通过对颜色的编码来对颜色进行量化（即转换成数字量，RGB是一种编码方式）；2）每种颜色根据RGB格式不同，每种颜色的量化位不相同；3) 常见的RGB格式有RGB565/RGB888，即: RGB565: red :5 green : 6 blue:5（16BPP） RGB888: red :8 green : 8 blue:8（24BPP）4）有的还会有个alpha参数，用于实现图形渐变效果，以及半透明效果，0xFFF=全透明，0x0=不透明； 1.2 图像的构成像素：显示的最小单位；用若干位数据来表示一个像素，比如使用R8、G8、B8共24位来表示一个像素，这个也称为像素深度，单位为BPP 常见的有16BPP/24BPP；像素越高，则一个像素点所显示的颜色就越多，所显示的颜色更广； 帧：一幅图像被称为一帧，每帧里面由行列排列的像素组成； 调色板：画油画的时候，通常先在调色板里配好想要的颜色，再用画笔沾到画布上作画。LCD控制器里也借用了这个概念，从FrameBuffer获得数据，这个数据作为索引从调色板获得对应数据，再发给电子枪显示出来。 如图，假如是16BPP的数据，LCD控制器从FB取出16bit数据，显示到LCD上。当如果想节约内存，对颜色要求也没那么高，就可以采用调色板的方式，调色板里存放了256个16bit的数据，FB只存放每个像素的索引，根据索引去调色板找到对应的数据传给LCD控制器，再通过电子枪显示出来。 1.3 LCD显示原理常见的TFT显示屏幕都会有如下控制信号：1)使用HSYNC信号来控制一行的显示；2)使用VSYNC信号来控制一帧(列)的显示；3)使用VCLK信号来控制一个像素的显示；4)使用VDEN信号来控制数据的输出；想象每个像素点是由电子枪发射出来的，电子枪依次扫描整个LCD界面，就显示了一副完整的图像。当发出一个HSYNC信号后，电子枪就会从行末花费HBP时长移动到行首；然后在VCLK时钟下，在图中阴影区域显示像素；等到了行末后，再等待HFP时长待HSYNC信号到来，再移动到行首，如此往复。因此，HBP和HFP分别决定了左边和右边的黑框。同理，当发出一个VSYNC信号后，电子枪就会从列末花费VBP时长移动到列首；然后在VCLK时钟下，在图中阴影区域显示像素；等到了列末后，再等待VFP时长待VSYNC信号到来，再移动到列首，如此往复。因此，VBP和VFP分别决定了上边和下边的黑框。真实显示区域为图中阴影部分。 1.4 LCD硬件控制思路 查看LCD芯片手册，查看相关的时间参数、分辨率、引脚极性等； 根据以上信息设置LCD控制器寄存器，让其发出正确信号； 在内存里面分配一个FrameBuffer，在里面用若干位表示一个像素，再把首地址告诉LCD控制器； 之后LCD控制器就能周而复始取出FrameBuffer里面的像素数据，配合其它控制信号，发送给电子枪，电子枪再让在LCD上显示出来。以后我们想显示图像，只需要编写程序向FrameBuffer填入相应数据即可，硬件会自动的完成显示操作。 1.5 LCD驱动框架LCD框架的fbmem.c已经帮我们完成了日常驱动程序的工作，如：注册字符设备、分配设备号、创建类等。也有了操作函数fb_fops，但它只是一个框架，在具体执行的时候需要知道硬件具体的一些参数，比如分辨率、数据基地址等信息。因此，我们要利用这一框架，就得构造一个fb_info结构体，完成硬件初始化，设置相关参数等操作，再使用register_framebuffer()将fb_info向上注册。这样，fbmem.c就可以从registered_fb[]这个数组获得fb_info参数，进行相关的硬件操作。比如：应用层app想read()，就会调用fbmem.c的fb_read()，在fb_read里面会先尝试使用xxfb.c提供的read()操作函数，如果没有，再根据fb_info信息得到数据基地址，将基地址开始的数据，返回给应用层，实现读操作。 2. 原理图 Tiny4412SDK-1506-Schematic.pdf： 从上到下，接口依次是： 接口 引脚 含义 1. 图像数据信号接口 B[0:7] 蓝色数据信号线 - G[0:7] 绿色数据信号线 - R[0:7] 红色数据信号线 2. “一线触摸”接口 XEINT10_OUT 用于 触摸/背光 控制 3. 时序信号控制接口 DEN 数据使能信号 - VSYNC 垂直同步信号 - HSYNC 水平同步信号 - VLCK LCD时钟信号 4. I2C接口 i2cSCL1_OUT/i2cSDA1_OUT 用于实现I2C接口的触摸屏驱动 Tiny4412-1412-Schematic.pdf：LCD数据和控制部分使用了GPF0_0-GPF0_7、GPF1_0-GPF1_7、GPF2_0-GPF2_7、GPF3_0-GPF3_5，共3*8+4=28个引脚。 3. 设备树文件123456789101112131415161718192021lcd_s702@11C00000 &#123; compatible = &quot;tiny4412, lcd_s702&quot;; reg = &lt;0x11C00000 0x20c0 0x10010210 0x08 0x10023c80 0x04 0x1003c000 0x1000&gt;; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;lcd_s702&gt;; clocks = &lt;&amp;clock CLK_FIMD0 &amp;clock CLK_ACLK160&gt;; clock-names = &quot;fimd0&quot;,&quot;aclk160&quot;;&#125;;&amp;pinctrl_0 &#123; lcd_s702:lcd &#123; samsung,pins = &quot;gpf0-0&quot;, &quot;gpf0-1&quot;, &quot;gpf0-2&quot;, &quot;gpf0-3&quot;, &quot;gpf0-4&quot;, &quot;gpf0-5&quot;, &quot;gpf0-6&quot;,&quot;gpf0-7&quot;, &quot;gpf1-0&quot;, &quot;gpf1-1&quot;, &quot;gpf1-2&quot;, &quot;gpf1-3&quot;, &quot;gpf1-4&quot;, &quot;gpf1-5&quot;, &quot;gpf1-6&quot;, &quot;gpf1-7&quot;, &quot;gpf2-0&quot;, &quot;gpf2-1&quot;, &quot;gpf2-2&quot;, &quot;gpf2-3&quot;, &quot;gpf2-4&quot;, &quot;gpf2-5&quot;, &quot;gpf2-6&quot;,&quot;gpf2-7&quot;, &quot;gpf3-0&quot;, &quot;gpf3-1&quot;, &quot;gpf3-2&quot;, &quot;gpf3-3&quot;; samsung,pin-function = &lt;2&gt;; samsung,pin-pud = &lt;0&gt;; samsung,pin-drv = &lt;0&gt;; &#125;;&#125;; 其中，0x11C00000是LCD寄存器基地址；0x10010210是LCD时钟寄存器基地址；0x10023c80是LCD时钟寄存器基地址；0x10023c80是LCD时钟寄存器基地址； Samsung GPIO and Pin Mux/Config controller摘录： “samsung,pins” property of the child node. The following pin configuration properties are supported. samsung,pin-val: Initial value of pin output buffer. samsung,pin-pud: Pull up/down configuration. samsung,pin-drv: Drive strength configuration. samsung,pin-pud-pdn: Pull up/down configuration in power down mode. samsung,pin-drv-pdn: Drive strength configuration in power down mode. 4. 驱动分析LCD驱动也属于字符驱动，框架和其它字符驱动差不多，难点是LCD的众多硬件配置。 和以往的框架一样，加载驱动后调用lcd_init()函数，然后lcd_init()调用platform_driver_register(&amp;lcd_driver)注册平台设备，lcd_driver结构体里面的.compatible与设备树里面的compatible进行字符串比较，匹配成功则调用核心的lcd_probe()函数。下面对lcd_probe()函数里面的内容进行详细介绍。 4.1 lcd_probelcd_probe()需要的配置如下： 1.分配一个fb_info2.设置fb_info 2.1 设置 fix 固定的参数 2.2 设置 var 可变的参数 2.3 设置操作函数 2.4 其他的设置3.硬件相关的操作 3.1 配置GPIO用于LCD 3.2 根据LCD手册设置LCD控制器, 比如VCLK的频率等 3.3 分配显存(framebuffer), 并把地址告诉LCD控制器4.注册fb_info 4.1.1 分配一个fb_info1234tiny4412_lcd = framebuffer_alloc(0, NULL); //不要额外空间设置私有数据if(!tiny4412_lcd) &#123; return -ENOMEM;&#125; 4.1.2 设置fb_info4.1.2.1 设置 fix 固定的参数12345strcpy(tiny4412_lcd-&gt;fix.id, \"s702\"); //设置fix名称tiny4412_lcd-&gt;fix.smem_len = LCD_LENTH*LCD_WIDTH*BITS_PER_PIXEL/8; //显存的长度=分辨率*每象素字节数tiny4412_lcd-&gt;fix.type = FB_TYPE_PACKED_PIXELS; //类型:填充式像素(常用在TFT屏幕)tiny4412_lcd-&gt;fix.visual = FB_VISUAL_TRUECOLOR; //TFT 真彩色tiny4412_lcd-&gt;fix.line_length = LCD_LENTH*BITS_PER_PIXEL/8; //每行的长度，以字节为单位 4.1.2.2 设置 var 可变的参数123456789101112131415tiny4412_lcd-&gt;var.xres = LCD_LENTH; //x方向分辨率tiny4412_lcd-&gt;var.yres = LCD_WIDTH; //y方向分辨率tiny4412_lcd-&gt;var.xres_virtual = LCD_LENTH; //x方向虚拟分辨率tiny4412_lcd-&gt;var.yres_virtual = LCD_WIDTH; //y方向虚拟分辨率tiny4412_lcd-&gt;var.xoffset = 0; //x方向真实值和虚拟值得差值tiny4412_lcd-&gt;var.yoffset = 0; //y方向真实值和虚拟值得差值tiny4412_lcd-&gt;var.bits_per_pixel = BITS_PER_PIXEL; //每个像素占多少位/* RGB:888 */tiny4412_lcd-&gt;var.red.length = 8;tiny4412_lcd-&gt;var.red.offset = 16; //红tiny4412_lcd-&gt;var.green.length = 8;tiny4412_lcd-&gt;var.green.offset = 8; //绿tiny4412_lcd-&gt;var.blue.length = 8;tiny4412_lcd-&gt;var.blue.offset = 0; //蓝tiny4412_lcd-&gt;var.activate = FB_ACTIVATE_NOW; //使设置的值立即生效 4.1.2.3 设置操作函数1tiny4412_lcd-&gt;fbops = &amp;tiny4412_lcdfb_ops; //绑定操作函数 这里的绑定的操作函数有：12345678static struct fb_ops tiny4412_lcdfb_ops =&#123; .owner = THIS_MODULE, .fb_setcolreg = cfb_setcolreg, //设置RGB颜色，实现伪颜色表 .fb_fillrect = cfb_fillrect, //矩形填充 .fb_copyarea = cfb_copyarea, //数据复制 .fb_imageblit = cfb_imageblit, //图形填充&#125;;除了cfb_setcolreg()，其它三个函数内核都提供了具体的实现。 4.1.2.4 其他的设置12tiny4412_lcd-&gt;pseudo_palette = pseudo_palette; //存放调色板所调颜色的数组tiny4412_lcd-&gt;screen_size = LCD_LENTH * LCD_WIDTH * BITS_PER_PIXEL / 8; //显存大小 4.1.3 硬件相关的操作4.1.3.1 配置GPIO用于LCD在设备树中，将 GPF0_0-GPF0_7、GPF1_0-GPF1_7、GPF2_0-GPF2_7、GPF3_0-GPF3_3配置为了复用第二功能(LCD)，禁止内部上拉，驱动强度配置设置为0，因此这里就不需要任何设置了。 4.1.3.2 根据LCD手册设置LCD控制器, 比如VCLK的频率等a. 首先是获取设备树中的寄存器资源，并进行映射：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 res0 = platform_get_resource(pdev, IORESOURCE_MEM, 0); if (res0 == NULL) &#123; printk(\"platform_get_resource error.\\n\"); return -EINVAL; &#125; lcd_regs_base = devm_ioremap_resource(&amp;pdev-&gt;dev, res0); if (lcd_regs_base == NULL) &#123; printk(\"devm_ioremap_resource error.\\n\"); return -EINVAL; &#125; res1 = platform_get_resource(pdev, IORESOURCE_MEM, 1); if (res1 == NULL) &#123; printk(\"platform_get_resource error.\\n\"); return -EINVAL; &#125; lcdblk_regs_base = devm_ioremap_resource(&amp;pdev-&gt;dev, res1); if (lcdblk_regs_base == NULL) &#123; printk(\"devm_ioremap_resource error.\\n\"); return -EINVAL; &#125; res2 = platform_get_resource(pdev, IORESOURCE_MEM, 2); if (res2 == NULL) &#123; printk(\"platform_get_resource error.\\n\"); return -EINVAL; &#125; //bug： /* devm_ioremap()和devm_ioremap_resource()区别： devm_ioremap()可以重复map相同的地址空间，devm_ioremap_resource()不可以。 一般SoC的中，各个硬件模块各自的memory region都有严格的划分(比如说USB host的地址空间绝对不会和flash host冲突)， 所以一般的driver使用devm_ioremap()和devm_ioremap_resource()都行。 但这里，应该系统已经映射过一次了，所以使用devm_ioremap_resource()会报错。 */ //lcd0_configuration = devm_ioremap_resource(&amp;pdev-&gt;dev, res2); lcd0_configuration = devm_ioremap(&amp;pdev-&gt;dev, res2-&gt;start, resource_size(res2)); if (lcd0_configuration == NULL) &#123; printk(\"devm_ioremap_resource error.\\n\"); return -EINVAL; &#125; *(unsigned long *)lcd0_configuration = 7; //Reset Value = 0x00000007 res3 = platform_get_resource(pdev, IORESOURCE_MEM, 3); if (res3 == NULL) &#123; printk(\"platform_get_resource error.\\n\"); return -EINVAL; &#125; //clk_regs_base = devm_ioremap_resource(&amp;pdev-&gt;dev, res3);clk_regs_base = devm_ioremap(&amp;pdev-&gt;dev, res3-&gt;start, resource_size(res3)); if (clk_regs_base == NULL) &#123; printk(\"devm_ioremap_resource error.\\n\"); return -EINVAL; &#125;这里后期测试出一个bug: devm_ioremap()和devm_ioremap_resource()区别：devm_ioremap()可以重复map相同的地址空间，devm_ioremap_resource()不可以。一般SoC的中，各个硬件模块各自的memory region都有严格的划分(比如说USB host的地址空间绝对不会和flash host冲突)，所以一般的driver使用devm_ioremap()和devm_ioremap_resource()都行。但这里，应该系统已经映射过一次了，所以使用devm_ioremap_resource()会报错。 b. 设置时钟时钟部分还是有点乱，没有从头开始去分析，当这里的目的是生成VCLK，因此配置出VCLK即可：12345678910111213141516171819202122232425262728293031323334353637383940414243//时钟源选择\\使能时钟//Selects clock source for LCD_BLK//FIMD0_SEL:bit[3:0]=0110=SCLKMPLL_USER_T=800Mtemp = readl(clk_regs_base + CLK_SRC_LCD0);temp &amp;= ~(0x0F&lt;&lt;0);temp |= (0x3&lt;&lt;1);writel(temp, clk_regs_base + CLK_SRC_LCD0);//Clock source mask for LCD_BLK //FIMD0_MASK:Mask output clock of MUXFIMD0 (1=Unmask)temp = readl(clk_regs_base + CLK_SRC_MASK_LCD);temp |= (0x01&lt;&lt;0);writel(temp, clk_regs_base + CLK_SRC_MASK_LCD);//Clock source mask for LCD_BLK //SCLK_FIMD0 = MOUTFIMD0/(FIMD0_RATIO + 1),分频比 1/1temp = readl(clk_regs_base + CLK_DIV_LCD);temp &amp;= ~(0x0F&lt;&lt;0);writel(temp, clk_regs_base + CLK_DIV_LCD);//Controls IP clock gating for LCD_BLK //CLK_FIMD0:Gating all clocks for FIMD0 (1=Pass)temp = readl(clk_regs_base + CLK_GATE_IP_LCD);temp |= (0x01&lt;&lt;0);writel(temp, clk_regs_base + CLK_GATE_IP_LCD);//FIMDBYPASS_LBLK0:FIMD of LBLK0 Bypass Selection (1=FIMD Bypass)temp = readl(lcdblk_regs_base + LCDBLK_CFG);temp |= (0x01&lt;&lt;1);writel(temp, lcdblk_regs_base + LCDBLK_CFG);//MIE0_DISPON:MIE0_DISPON: PWM output control (1=PWM outpupt enable)temp = readl(lcdblk_regs_base + LCDBLK_CFG2);temp |= (0x01&lt;&lt;0);writel(temp, lcdblk_regs_base + LCDBLK_CFG2);mdelay(1000);//LCD时钟: VCLK=FIMD*SCLK/(CLKVAL+1), where CLKVAL&gt;=1//800/(19+1) == 40M&lt;80Mtemp = readl(lcd_regs_base + VIDCON0);temp |= (19&lt;&lt;6);writel(temp, lcd_regs_base + VIDCON0);思路就是选择时钟源，然后启用时钟源，再分频得到所需VCLK。 c. 设置引脚极性和时序 LCD手册“S702-AT070TN92.pdf”中的时序图和时间参数：(PS:手册图片做得真烂，源PDF都模糊)上半部分为水平输入时序图，下半部分为垂直方向输入时序图。 然后是图中的时间参数： Exynos 4412手册“Exynos 4412 SCP_Users Manual.pdf”中的时序图： 我的经验就是结合LCD的时序图和控制器的时序图，对比两者的时序得出关系式和极性。因此，可以得出：极性方面：VS与VSYNC极性相反，HS与HSYNC极性相反，DE与VDEN极性一致，DCLK是在上升沿触发。 对于寄存器VIDCON1：12345678910/* * VIDTCON1: * [5]:IVSYNC ===&gt; 1 : Inverted(反转) * [6]:IHSYNC ===&gt; 1 : Inverted(反转) * [7]:IVCLK ===&gt; 1 : Fetches video data at VCLK rising edge (上降沿触发) * [10:9]:FIXVCLK ====&gt; 01 : VCLK running */temp = readl(lcd_regs_base + VIDCON1);temp |= (1 &lt;&lt; 9) | (1 &lt;&lt; 7) | (1 &lt;&lt; 5) | (1 &lt;&lt; 6);writel(temp, lcd_regs_base + VIDCON1); 时序方面：12345678VSPW+1=tvpw=1~20(暂取11) --&gt; VSPW=10VBPD+1=tvb-tvpw=23-11=12 --&gt; VBPD=11VFPD+1=tvfp=22 --&gt; VFPD=21HSPW+1=hpw=1~40(暂取21) --&gt; HSPW=20HBPD+1=thb-hpw=46-21=25 --&gt; HBPD=24HOZVAL+1=thd=800 --&gt; HOZVAL=799HFPD+1=thfp=210 --&gt; HFPD=209 对于寄存器VIDTCON0：123456789/* * VIDTCON0: * [23:16]: VBPD+1=tvb-tvpw=23-11=12 --&gt; VBPD=11 * [15:8] : VFPD+1=tvfp=22 --&gt; VFPD=21 * [7:0] : VSPW+1=tvpw=1~20(暂取11) --&gt; VSPW=10 */temp = readl(lcd_regs_base + VIDTCON0);temp |= (11 &lt;&lt; 16) | (21 &lt;&lt; 8) | (10 &lt;&lt; 0);writel(temp, lcd_regs_base + VIDTCON0); 对于寄存器VIDTCON1：123456789/* * VIDTCON1: * [23:16]: HBPD+1=thb-hpw=46-21=25 --&gt; HBPD=24 * [15:8] : HFPD+1=thfp=210 --&gt; HFPD=209 * [7:0] : HSPW+1=hpw=1~40(暂取21) --&gt; HSPW=20 */temp = readl(lcd_regs_base + VIDTCON1);temp |= (24 &lt;&lt; 16) | (209 &lt;&lt; 8) | (20 &lt;&lt; 0);writel(temp, lcd_regs_base + VIDTCON1); d. 设置分辨率1234567/* * HOZVAL = (Horizontal display size) - 1 and LINEVAL = (Vertical display size) - 1. * Horizontal(水平) display size : 800 * Vertical(垂直) display size : 480 */temp = ((LCD_WIDTH-1) &lt;&lt; 11) | (LCD_LENTH &lt;&lt; 0);writel(temp, lcd_regs_base + VIDTCON2); e. 设置数据格式如前面可变参数所设置的一样，本次采用的是24BPP格式，每个像素占用32位(实际使用24位)。当使能字节交换时(BSWP=0, HWSWP=0, WSWP=1)，则低位像素存放在低字节，即[23:0]放像素1，[31:24]空，[55:32]放第二个像素，[63:56]空，依次类推，这种存放方式更符合日常习惯。12345678910/* * WINCON0: * [15]:Specifies Word swap control bit. 1 = Enables swap 低位像素存放在低字节 * [5:2]: Selects Bits Per Pixel (BPP) mode for Window image : 1101 ===&gt; Unpacked 25 BPP (non-palletized A:1-R:8-G:8-B:8) * [0]:Enables/disables video output 1 = Enables */temp = readl(lcd_regs_base + WINCON0);temp &amp;= ~(0x0F &lt;&lt; 2);temp |= (0X01 &lt;&lt; 15) | (0x0D &lt;&lt; 2) | (0x01&lt;&lt;0);writel(temp, lcd_regs_base + WINCON0); f. 设置/使能显示窗口12345678910//Enables Channel 0.temp = readl(lcd_regs_base + SHADOWCON);writel(temp | 0x01, lcd_regs_base + SHADOWCON);//Selects Channel 0temp = readl(lcd_regs_base + WINCHMAP2);temp &amp;= ~(7 &lt;&lt; 16);temp |= (0x01 &lt;&lt; 16);//CH0FISEL:Selects Channel 0's channel.001 = Window 0temp &amp;= ~(7 &lt;&lt; 0);temp |= (0x01 &lt;&lt; 0);//W0FISEL:Selects Window 0's channel.001 = Channel 0writel(temp, lcd_regs_base + WINCHMAP2); g. 设置OSD功能 注：OSD是on-screen display的简称，即屏幕菜单式调节方式。即在当前显示上叠加一层显示，就像显示器的调节菜单。 1234567891011121314//设置OSD显示大小//Window Size For example. Height * Width (number of word)temp = (LCD_LENTH * LCD_WIDTH) &gt;&gt; 1;writel(temp, lcd_regs_base + VIDOSD0C);/* * bit0-10 : 指定OSD图像左上像素的垂直屏幕坐标 * bit11-21: 指定OSD图像左上像素的水平屏幕坐标 */writel(0, lcd_regs_base + VIDOSD0A);/* * bit0-10 : 指定OSD图像右下像素的垂直屏幕坐标 * bit11-21: 指定OSD图像右下像素的水平屏幕坐标 */writel(((LCD_LENTH-1) &lt;&lt; 11) | (LCD_WIDTH-1), lcd_regs_base + VIDOSD0B); f. 启动显示 Display On: ENVID and ENVID_F are set to “1”.Direct Off: ENVID and ENVID_F are set to “0” simultaneously.Per Frame Off: ENVID_F is set to “0” and ENVID is set to “1”. 123//Display On: ENVID and ENVID_F are set to \"1\".temp = readl(lcd_regs_base + VIDCON0);writel(temp | (0x01&lt;&lt;0) | (0x01&lt;&lt;1), lcd_regs_base + VIDCON0); 4.1.3.3 分配显存(framebuffer), 并把地址告诉LCD控制器这里因为分配的显存要是连续的，因此不能使用传统的kalloc()函数，这里使用dma_alloc_writecombine()。先用物理地址映射出一块虚拟内存，以后对该虚拟内存操作，就等同于对物理地址数据进行操作。然后把物理地址的起始/结束地址告诉LCD控制器，以后LCD控制器就会去物理地址不断获取显示数据。这样就实现了操作虚拟内存，更新图像数据的效果。12345678// tiny4412_lcd-&gt;screen_base 显存虚拟地址// tiny4412_lcd-&gt;fix.smem_len 显存大小，前面计算的// tiny4412_lcd-&gt;fix.smem_start 显存物理地址tiny4412_lcd-&gt;screen_base = dma_alloc_writecombine(NULL, tiny4412_lcd-&gt;fix.smem_len, (dma_addr_t *)&amp;tiny4412_lcd-&gt;fix.smem_start, GFP_KERNEL);//显存起始地址writel(tiny4412_lcd-&gt;fix.smem_start, lcd_regs_base + VIDW00ADD0B0);//显存结束地址writel(tiny4412_lcd-&gt;fix.smem_start + tiny4412_lcd-&gt;fix.smem_len, lcd_regs_base + VIDW00ADD1B0); 4.1.4 注册fb_info12ret = register_framebuffer(tiny4412_lcd);return ret; 4.2 cfb_setcolreg前面绑定的操作函数中，cfb_fillrect()，cfb_copyarea()、cfb_imageblit()都在内核的其它文件中实现了，无需再构造，剩下的cfb_setcolreg()是和调色板相关的函数，是为了兼容8BPP模式。我们这里一直使用的24BPP，不提供这个函数的实现也行。调色板的介绍前面说过了，就是为了减少数据量，fb只存放数据索引，根据索引再去内存找到对应的颜色数据传给LCD控制器，LCD控制器再控制时序和数据在LCD上显示出来。123456789101112131415161718192021static inline unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)&#123; chan &amp;= 0xFFFF;//保留低16位 chan &gt;&gt;= 16 - bf-&gt;length;//保留高bf-&gt;length位 return chan &lt;&lt; bf-&gt;offset;//返回保留的位，且在原位置&#125;static int cfb_setcolreg(unsigned int regno, unsigned int red, unsigned int green, unsigned int blue, unsigned int transp, struct fb_info *info)&#123; unsigned int color = 0; uint32_t *p; color = chan_to_field(red, &amp;info-&gt;var.red); color |= chan_to_field(green, &amp;info-&gt;var.green); color |= chan_to_field(blue, &amp;info-&gt;var.blue); p = info-&gt;pseudo_palette; p[regno] = color; return 0;&#125; 4.3 lcd_remove需要关闭LCD，注销和释放framebuffer，释放显存：12345678910111213static int lcd_remove(struct platform_device *pdev)&#123; //Direct Off: ENVID and ENVID_F are set to \"0\" simultaneously. unsigned int temp; temp = readl(lcd_regs_base + VIDCON0); temp &amp;= ~(0x01&lt;&lt;1 | 0x01&lt;&lt;0); writel(temp, lcd_regs_base + VIDCON0); unregister_framebuffer(tiny4412_lcd); dma_free_writecombine(NULL, tiny4412_lcd-&gt;fix.smem_len, tiny4412_lcd-&gt;screen_base, tiny4412_lcd-&gt;fix.smem_start); framebuffer_release(tiny4412_lcd); return 0;&#125; 4.4 完整驱动代码[lcd_drv.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/mm.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/fb.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/dma-mapping.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/workqueue.h&gt;#include &lt;linux/wait.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/clk.h&gt;#include &lt;linux/io.h&gt;#include &lt;asm/io.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;asm/div64.h&gt;#include &lt;asm/mach/map.h&gt;#include &lt;linux/fb.h&gt;#include &lt;asm/types.h&gt;#define VIDCON0 0x00#define VIDCON1 0x04#define VIDTCON0 0x10#define VIDTCON1 0x14#define VIDTCON2 0x18#define WINCON0 0x20#define VIDOSD0C 0x48#define SHADOWCON 0x34#define WINCHMAP2 0x3c#define VIDOSD0A 0x40#define VIDOSD0B 0x44#define VIDW00ADD0B0 0xA0#define VIDW00ADD1B0 0xD0#define CLK_SRC_LCD0 0x234#define CLK_SRC_MASK_LCD 0x334#define CLK_DIV_LCD 0x534#define CLK_GATE_IP_LCD 0x934#define LCDBLK_CFG 0x00#define LCDBLK_CFG2 0x04#define LCD_LENTH 800#define LCD_WIDTH 480#define BITS_PER_PIXEL 32static struct fb_info *tiny4412_lcd;static volatile void __iomem *lcd_regs_base;static volatile void __iomem *lcdblk_regs_base;static volatile void __iomem *lcd0_configuration;//Configures power mode of LCD0.0x10020000+0x3C80static volatile void __iomem *clk_regs_base;static u32 pseudo_palette[16];static struct resource *res0, *res1, *res2, *res3;/* from pxafb.c */static inline unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)&#123; chan &amp;= 0xFFFF;//保留低16位 chan &gt;&gt;= 16 - bf-&gt;length;//保留高bf-&gt;length位 return chan &lt;&lt; bf-&gt;offset;//返回保留的位，且在原位置&#125;static int cfb_setcolreg(unsigned int regno, unsigned int red, unsigned int green, unsigned int blue, unsigned int transp, struct fb_info *info)&#123; unsigned int color = 0; uint32_t *p; color = chan_to_field(red, &amp;info-&gt;var.red); color |= chan_to_field(green, &amp;info-&gt;var.green); color |= chan_to_field(blue, &amp;info-&gt;var.blue); p = info-&gt;pseudo_palette; p[regno] = color; return 0;&#125;static struct fb_ops tiny4412_lcdfb_ops =&#123; .owner = THIS_MODULE, .fb_setcolreg = cfb_setcolreg, //设置调色板，实现伪颜色表 .fb_fillrect = cfb_fillrect, //填充矩形 .fb_copyarea = cfb_copyarea, //数据复制 .fb_imageblit = cfb_imageblit, //图形填充&#125;; static int lcd_probe(struct platform_device *pdev)&#123; int ret; unsigned int temp; /* 1. 分配一个fb_info */ tiny4412_lcd = framebuffer_alloc(0, NULL); //不要额外空间设置私有数据 if(!tiny4412_lcd) &#123; return -ENOMEM; &#125; /* 2. 设置 */ /* 2.1 设置 fix 固定的参数 */ strcpy(tiny4412_lcd-&gt;fix.id, \"s702\"); //设置fix名称 tiny4412_lcd-&gt;fix.smem_len = LCD_LENTH*LCD_WIDTH*BITS_PER_PIXEL/8; //显存的长度=分辨率*每象素字节数 tiny4412_lcd-&gt;fix.type = FB_TYPE_PACKED_PIXELS; //类型:填充式像素(常用在TFT屏幕) tiny4412_lcd-&gt;fix.visual = FB_VISUAL_TRUECOLOR; //TFT 真彩色 tiny4412_lcd-&gt;fix.line_length = LCD_LENTH*BITS_PER_PIXEL/8; //每行的长度，以字节为单位 /* 2.2 设置 var 可变的参数 */ tiny4412_lcd-&gt;var.xres = LCD_LENTH; //x方向分辨率 tiny4412_lcd-&gt;var.yres = LCD_WIDTH; //y方向分辨率 tiny4412_lcd-&gt;var.xres_virtual = LCD_LENTH; //x方向虚拟分辨率 tiny4412_lcd-&gt;var.yres_virtual = LCD_WIDTH; //y方向虚拟分辨率 tiny4412_lcd-&gt;var.xoffset = 0; //x方向真实值和虚拟值得差值 tiny4412_lcd-&gt;var.yoffset = 0; //y方向真实值和虚拟值得差值 tiny4412_lcd-&gt;var.bits_per_pixel = BITS_PER_PIXEL; //每个像素占多少位 /* RGB:888 */ tiny4412_lcd-&gt;var.red.length = 8; tiny4412_lcd-&gt;var.red.offset = 16; //红 tiny4412_lcd-&gt;var.green.length = 8; tiny4412_lcd-&gt;var.green.offset = 8; //绿 tiny4412_lcd-&gt;var.blue.length = 8; tiny4412_lcd-&gt;var.blue.offset = 0; //蓝 tiny4412_lcd-&gt;var.activate = FB_ACTIVATE_NOW; //使设置的值立即生效 /* 2.3 设置操作函数 */ tiny4412_lcd-&gt;fbops = &amp;tiny4412_lcdfb_ops; //绑定操作函数 /* 2.4 其他的设置 */ tiny4412_lcd-&gt;pseudo_palette = pseudo_palette; //存放调色板所调颜色的数组 tiny4412_lcd-&gt;screen_size = LCD_LENTH * LCD_WIDTH * BITS_PER_PIXEL / 8; //显存大小 /* 3. 硬件相关的操作 */ /* 3.1 配置GPIO用于LCD */ //在设备树中，将 GPF0_0-GPF0_7、GPF1_0-GPF1_7、GPF2_0-GPF2_7、GPF3_0-GPF3_3 //配置为了复用第二功能(LCD)，禁止内部上拉，驱动强度配置设置为0; /* 3.2 根据LCD手册设置LCD控制器, 比如VCLK的频率等 */ //寄存器映射 res0 = platform_get_resource(pdev, IORESOURCE_MEM, 0); if (res0 == NULL) &#123; printk(\"platform_get_resource error.\\n\"); return -EINVAL; &#125; lcd_regs_base = devm_ioremap_resource(&amp;pdev-&gt;dev, res0); if (lcd_regs_base == NULL) &#123; printk(\"devm_ioremap_resource error.\\n\"); return -EINVAL; &#125; res1 = platform_get_resource(pdev, IORESOURCE_MEM, 1); if (res1 == NULL) &#123; printk(\"platform_get_resource error.\\n\"); return -EINVAL; &#125; lcdblk_regs_base = devm_ioremap_resource(&amp;pdev-&gt;dev, res1); if (lcdblk_regs_base == NULL) &#123; printk(\"devm_ioremap_resource error.\\n\"); return -EINVAL; &#125; res2 = platform_get_resource(pdev, IORESOURCE_MEM, 2); if (res2 == NULL) &#123; printk(\"platform_get_resource error.\\n\"); return -EINVAL; &#125; //bug： /* devm_ioremap()和devm_ioremap_resource()区别： devm_ioremap()可以重复map相同的地址空间，devm_ioremap_resource()不可以。 一般SoC的中，各个硬件模块各自的memory region都有严格的划分(比如说USB host的地址空间绝对不会和flash host冲突)， 所以一般的driver使用devm_ioremap()和devm_ioremap_resource()都行。 但这里，应该系统已经映射过一次了，所以使用devm_ioremap_resource()会报错。 */ //lcd0_configuration = devm_ioremap_resource(&amp;pdev-&gt;dev, res2); lcd0_configuration = devm_ioremap(&amp;pdev-&gt;dev, res2-&gt;start, resource_size(res2)); if (lcd0_configuration == NULL) &#123; printk(\"devm_ioremap_resource error.\\n\"); return -EINVAL; &#125; *(unsigned long *)lcd0_configuration = 7; //Reset Value = 0x00000007 res3 = platform_get_resource(pdev, IORESOURCE_MEM, 3); if (res3 == NULL) &#123; printk(\"platform_get_resource error.\\n\"); return -EINVAL; &#125; //clk_regs_base = devm_ioremap_resource(&amp;pdev-&gt;dev, res3); clk_regs_base = devm_ioremap(&amp;pdev-&gt;dev, res3-&gt;start, resource_size(res3)); if (clk_regs_base == NULL) &#123; printk(\"devm_ioremap_resource error.\\n\"); return -EINVAL; &#125; //时钟源选择\\使能时钟 //Selects clock source for LCD_BLK //FIMD0_SEL:bit[3:0]=0110=SCLKMPLL_USER_T=800M temp = readl(clk_regs_base + CLK_SRC_LCD0); temp &amp;= ~(0x0F&lt;&lt;0); temp |= (0x3&lt;&lt;1); writel(temp, clk_regs_base + CLK_SRC_LCD0); //Clock source mask for LCD_BLK //FIMD0_MASK:Mask output clock of MUXFIMD0 (1=Unmask) temp = readl(clk_regs_base + CLK_SRC_MASK_LCD); temp |= (0x01&lt;&lt;0); writel(temp, clk_regs_base + CLK_SRC_MASK_LCD); //Clock source mask for LCD_BLK //SCLK_FIMD0 = MOUTFIMD0/(FIMD0_RATIO + 1),分频比 1/1 temp = readl(clk_regs_base + CLK_DIV_LCD); temp &amp;= ~(0x0F&lt;&lt;0); writel(temp, clk_regs_base + CLK_DIV_LCD); //Controls IP clock gating for LCD_BLK //CLK_FIMD0:Gating all clocks for FIMD0 (1=Pass) temp = readl(clk_regs_base + CLK_GATE_IP_LCD); temp |= (0x01&lt;&lt;0); writel(temp, clk_regs_base + CLK_GATE_IP_LCD); //FIMDBYPASS_LBLK0:FIMD of LBLK0 Bypass Selection (1=FIMD Bypass) temp = readl(lcdblk_regs_base + LCDBLK_CFG); temp |= (0x01&lt;&lt;1); writel(temp, lcdblk_regs_base + LCDBLK_CFG); //MIE0_DISPON:MIE0_DISPON: PWM output control (1=PWM outpupt enable) temp = readl(lcdblk_regs_base + LCDBLK_CFG2); temp |= (0x01&lt;&lt;0); writel(temp, lcdblk_regs_base + LCDBLK_CFG2); mdelay(1000); //LCD时钟: VCLK=FIMD*SCLK/(CLKVAL+1), where CLKVAL&gt;=1 //800/(19+1) == 40M&lt;80M temp = readl(lcd_regs_base + VIDCON0); temp |= (19&lt;&lt;6); writel(temp, lcd_regs_base + VIDCON0); /* * VIDTCON1: * [5]:IVSYNC ===&gt; 1 : Inverted(反转) * [6]:IHSYNC ===&gt; 1 : Inverted(反转) * [7]:IVCLK ===&gt; 1 : Fetches video data at VCLK rising edge (上降沿触发) * [10:9]:FIXVCLK ====&gt; 01 : VCLK running */ temp = readl(lcd_regs_base + VIDCON1); temp |= (1 &lt;&lt; 9) | (1 &lt;&lt; 7) | (1 &lt;&lt; 5) | (1 &lt;&lt; 6); writel(temp, lcd_regs_base + VIDCON1); /* * VIDTCON0: * [23:16]: VBPD+1=tvb-tvpw=23-11=12 --&gt; VBPD=11 * [15:8] : VFPD+1=tvfp=22 --&gt; VFPD=21 * [7:0] : VSPW+1=tvpw=1~20(暂取11) --&gt; VSPW=10 */ temp = readl(lcd_regs_base + VIDTCON0); temp |= (11 &lt;&lt; 16) | (21 &lt;&lt; 8) | (10 &lt;&lt; 0); writel(temp, lcd_regs_base + VIDTCON0); /* * VIDTCON1: * [23:16]: HBPD+1=thb-hpw=46-21=25 --&gt; HBPD=24 * [15:8] : HFPD+1=thfp=210 --&gt; HFPD=209 * [7:0] : HSPW+1=hpw=1~40(暂取21) --&gt; HSPW=20 */ temp = readl(lcd_regs_base + VIDTCON1); temp |= (24 &lt;&lt; 16) | (209 &lt;&lt; 8) | (20 &lt;&lt; 0); writel(temp, lcd_regs_base + VIDTCON1); /* * HOZVAL = (Horizontal display size) - 1 and LINEVAL = (Vertical display size) - 1. * Horizontal(水平) display size : 800 * Vertical(垂直) display size : 480 */ temp = ((LCD_WIDTH-1) &lt;&lt; 11) | (LCD_LENTH &lt;&lt; 0); writel(temp, lcd_regs_base + VIDTCON2); /* * WINCON0: * [15]:Specifies Word swap control bit. 1 = Enables swap 低位像素存放在低字节 * [5:2]: Selects Bits Per Pixel (BPP) mode for Window image : 1101 ===&gt; Unpacked 25 BPP (non-palletized A:1-R:8-G:8-B:8) * [0]:Enables/disables video output 1 = Enables */ temp = readl(lcd_regs_base + WINCON0); temp &amp;= ~(0x0F &lt;&lt; 2); temp |= (0X01 &lt;&lt; 15) | (0x0D &lt;&lt; 2) | (0x01&lt;&lt;0); writel(temp, lcd_regs_base + WINCON0); //Enables Channel 0. temp = readl(lcd_regs_base + SHADOWCON); writel(temp | 0x01, lcd_regs_base + SHADOWCON); //Selects Channel 0 temp = readl(lcd_regs_base + WINCHMAP2); temp &amp;= ~(7 &lt;&lt; 16); temp |= (0x01 &lt;&lt; 16);//CH0FISEL:Selects Channel 0's channel.001 = Window 0 temp &amp;= ~(7 &lt;&lt; 0); temp |= (0x01 &lt;&lt; 0);//W0FISEL:Selects Window 0's channel.001 = Channel 0 writel(temp, lcd_regs_base + WINCHMAP2); //设置OSD显示大小 //Window Size For example. Height * Width (number of word) temp = (LCD_LENTH * LCD_WIDTH) &gt;&gt; 1; writel(temp, lcd_regs_base + VIDOSD0C); /* * bit0-10 : 指定OSD图像左上像素的垂直屏幕坐标 * bit11-21: 指定OSD图像左上像素的水平屏幕坐标 */ writel(0, lcd_regs_base + VIDOSD0A); /* * bit0-10 : 指定OSD图像右下像素的垂直屏幕坐标 * bit11-21: 指定OSD图像右下像素的水平屏幕坐标 */ writel(((LCD_LENTH-1) &lt;&lt; 11) | (LCD_WIDTH-1), lcd_regs_base + VIDOSD0B); //Display On: ENVID and ENVID_F are set to \"1\". temp = readl(lcd_regs_base + VIDCON0); writel(temp | (0x01&lt;&lt;1) | (0x01&lt;&lt;0), lcd_regs_base + VIDCON0); /* 3.3 分配显存(framebuffer), 并把地址告诉LCD控制器 */ // tiny4412_lcd-&gt;screen_base 显存虚拟地址 // tiny4412_lcd-&gt;fix.smem_len 显存大小，前面计算的 // tiny4412_lcd-&gt;fix.smem_start 显存物理地址 tiny4412_lcd-&gt;screen_base = dma_alloc_writecombine(NULL, tiny4412_lcd-&gt;fix.smem_len, (dma_addr_t *)&amp;tiny4412_lcd-&gt;fix.smem_start, GFP_KERNEL); //显存起始地址 writel(tiny4412_lcd-&gt;fix.smem_start, lcd_regs_base + VIDW00ADD0B0); //显存结束地址 writel(tiny4412_lcd-&gt;fix.smem_start + tiny4412_lcd-&gt;fix.smem_len, lcd_regs_base + VIDW00ADD1B0); /* 4. 注册 */ ret = register_framebuffer(tiny4412_lcd); return ret;&#125;static int lcd_remove(struct platform_device *pdev)&#123; //Direct Off: ENVID and ENVID_F are set to \"0\" simultaneously. unsigned int temp; temp = readl(lcd_regs_base + VIDCON0); temp &amp;= ~(0x01&lt;&lt;1 | 0x01&lt;&lt;0); writel(temp, lcd_regs_base + VIDCON0); unregister_framebuffer(tiny4412_lcd); dma_free_writecombine(NULL, tiny4412_lcd-&gt;fix.smem_len, tiny4412_lcd-&gt;screen_base, tiny4412_lcd-&gt;fix.smem_start); framebuffer_release(tiny4412_lcd); return 0;&#125;static const struct of_device_id lcd_dt_ids[] =&#123; &#123; .compatible = \"tiny4412, lcd_s702\", &#125;, &#123;&#125;,&#125;;MODULE_DEVICE_TABLE(of, lcd_dt_ids);static struct platform_driver lcd_driver =&#123; .driver = &#123; .name = \"lcd_s702\", .of_match_table = of_match_ptr(lcd_dt_ids), &#125;, .probe = lcd_probe, .remove = lcd_remove,&#125;;static int lcd_init(void)&#123; int ret; printk(\"enter %s\\n\", __func__); ret = platform_driver_register(&amp;lcd_driver); if (ret) &#123; printk(KERN_ERR \"lcd: probe fail: %d\\n\", ret); &#125; return ret;&#125;static void lcd_exit(void)&#123; printk(\"enter %s\\n\", __func__); platform_driver_unregister(&amp;lcd_driver);&#125;module_init(lcd_init);module_exit(lcd_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"Tiny4412 LCD driver.\");MODULE_ALIAS(\"Exynos4412_s702\");MODULE_VERSION(\"V1.0\"); 参考博客：设备树学习之（十二）LCD驱动 5.测试程序5.1 图像显示前面完成了驱动，要想显示内容，只需要mmap()一块内存，然后向里面写数据即可。但这种操作一般显示用于显示几何图形，像色块，圆形，矩形等，实用性不大，显示一张图片似乎更有意思。显示图片没那么容易了，像常见的JPEG格式图片，它是一个“压缩文件”，需要解压得到RGB数据。 这就要用到libjpeg-turbo，一个用C语言写的JPEG图像解码器。 5.1.1 移植libjpeg下载目前最新的libjpeg-turbo源码libjpeg-turbo-1.5.3.tar.gz。a. 解压1sudo tar xzf libjpeg-turbo-1.5.3.tar.gz b.设置配置文件--prefix=:指定安装路径--host==:指定目标程序运行主机类型1234567cd libjpeg-turbo-1.5.3 mkdir tmp //创建临时安装路径cd .../configure --prefix=/work/drv/2_lcd/libjpeg_new/libjpeg-turbo-1.5.3/tmp --host=arm-none-linux-gnueabimakemamake install 5.1.2 编写应用程序这块几乎全是参考韦东山老师第三期视频的电子相册项目。 解压操作过程如下:1、分配jpeg对象结构体空间，并初始化2、指定解压数据源3、获取解压文件信息4、为解压设定参数，包括图像大小和颜色空间5、开始解压缩6、取数据并显示7、解压完毕8、释放资源和退出程序 1、分配jpeg对象结构体空间、并初始化解压缩过程中使用的JPEG对象是一个jpeg_decompress_struct的结构体。同时还需要定义一个用于错误处理的结构体对象，IJG中标准的错误结构体是jpeg_error_mgr。12struct jpeg_decompress_struct cinfo;struct jpeg_error_mgr jerr; 绑定jerr错误结构体至jpeg对象结构体。1cinfo.err = jpeg_std_error(&amp;jerr); 这个标准的错误处理结构将使程序在出现错误时调用exit()退出程序，如果不希望使用标准的错误处理方式，则可以通过自定义退出函数的方法自定义错误处理结构。 初始化cinfo结构体。1jpeg_create_decompress(&amp;cinfo); 2、指定解压数据源1234567 FILE * infile;if ((infile = fopen(argv[1], \"rb\")) == NULL) &#123; fprintf(stderr, \"can't open %s\\n\", argv[1]); return -1;&#125;jpeg_stdio_src(&amp;cinfo, infile); 3、获取解压文件信息将图像的缺省信息填充到cinfo结构中以便程序使用。1jpeg_read_header(&amp;cinfo, TRUE);此时，常见的可用信息包括图像的：宽cinfo.image_width，高cinfo.image_height，色彩空间cinfo.jpeg_color_space，颜色通道数cinfo.num_components等。 4、为解压设定参数，包括图像大小和颜色空间比如可以设定解出来的图像的大小，也就是与原图的比例。使用scale_num和scale_denom两个参数，解出来的图像大小就是scale_num/scale_denom，但是IJG当前仅支持1/1, 1/2, 1/4,和1/8这几种缩小比例。123printf(\"enter scale M/N:\\n\");scanf(\"%d/%d\", &amp;cinfo.scale_num, &amp;cinfo.scale_denom);printf(\"scale to : %d/%d\\n\", cinfo.scale_num, cinfo.scale_denom);假如想让图片变为原来的一般，只需要输入1/2即可。 也可以设定输出图像的色彩空间，即cinfo.out_color_space，可以把一个原本彩色的图像由真彩色JCS_RGB变为灰度JCS_GRAYSCALE。1cinfo.out_color_space=JCS_GRAYSCALE; 5、开始解压缩根据设定的解压缩参数进行图像解压缩操作。1jpeg_start_decompress(&amp;cinfo); 在完成解压缩操作后，会将解压后的图像信息填充至cinfo结构中。比如，输出图像宽度cinfo.output_width，输出图像高度cinfo.output_height，每个像素中的颜色通道数cinfo.output_components（比如灰度为1，全彩色为3）等。 一般情况下，这些参数是在jpeg_start_decompress后才被填充到cinfo中的，如果希望在调用jpeg_start_decompress之前就获得这些参数，可以通过调用jpeg_calc_output_dimensions()的方法来实现。 6、取数据并显示解开的数据是按照行取出的，数据像素按照scanline来存储，scanline是从左到右，从上到下的顺序，每个像素对应的各颜色或灰度通道数据是依次存储。比如一个24-bit RGB真彩色的图像中，一个scanline中的数据存储模式是R,G,B,R,G,B,R,G,B,…，每条scanline是一个JSAMPLE类型的数组，一般来说就是 unsigned char，定义于jmorecfg.h中。除了JSAMPLE，图像还定义了JSAMPROW和JSAMPARRAY，分别表示一行JSAMPLE和一个2D的JSAMPLE数组。 在此，我定义一个JSAMPARRAY(unsigned char)类型的缓冲区变量buffer来存放图像数据。123456789101112131415int row_stride;unsigned char *buffer;// 然后是计算每行需要的空间大小，比如RGB图像就是宽度×3，灰度图就是宽度×1row_stride = cinfo.output_width * cinfo.output_components;buffer = malloc(row_stride);// 循环调用jpeg_read_scanlines来一行一行地获得解压的数据while (cinfo.output_scanline &lt; cinfo.output_height) &#123; (void) jpeg_read_scanlines(&amp;cinfo, &amp;buffer, 1);//每次读取1行 // 写到LCD去 fb_show_line(0, cinfo.output_width, cinfo.output_scanline, buffer);&#125; 然后需要实现函数fb_show_line()显示每行数据，要实现fb_show_line()还得先实现每个像素点的描绘fb_show_pixel()。因此需要先初始化fb，获取LCD参数信息，如分辨率，多少BPP。再实现显示每个像素点，最后实现每一行的显示。 初始化：1234567891011121314151617181920212223242526272829303132333435363738394041static int fb_device_init(void)&#123; int ret; fd = open(FB_DEVICE_NAME, O_RDWR); if (fd &lt; 0) &#123; printf(\"Can't open %s\\n\", FB_DEVICE_NAME); return -1; &#125; //获取可变信息 ret = ioctl(fd, FBIOGET_VSCREENINFO, &amp;fb_var); if (ret &lt; 0) &#123; printf(\"Can't get fb's var\\n\"); return -1; &#125; //获取固定信息 ret = ioctl(fd, FBIOGET_FSCREENINFO, &amp;fb_fix); if (ret &lt; 0) &#123; printf(\"Can't get fb's fix\\n\"); return -1; &#125; //映射fb screen_size = fb_var.xres * fb_var.yres * fb_var.bits_per_pixel / 8; fb_mem = (unsigned char *)mmap(NULL , screen_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if (fb_mem &lt; 0) &#123; printf(\"Can't mmap\\n\"); return -1; &#125; line_width = fb_var.xres * fb_var.bits_per_pixel / 8; pixel_width = fb_var.bits_per_pixel / 8; return 0;&#125; 显示每个像素点：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static int fb_show_pixel(int x, int y, unsigned int color)&#123; unsigned char *fb_show; unsigned short *fb_show_16bpp; unsigned int *fb_show_32bpp; unsigned short fb_show_16bpp_new; /* 565 */ int red; int green; int blue; if ((x &gt;= fb_var.xres) || (y &gt;= fb_var.yres)) &#123; printf(\"Out of region\\n\"); return -1; &#125; fb_show = fb_mem + line_width * y + pixel_width * x;//定位 fb_show_16bpp = (unsigned short *)fb_show; fb_show_32bpp = (unsigned int *)fb_show; switch (fb_var.bits_per_pixel) &#123; case 8: &#123; *fb_show = (unsigned char)color; break; &#125; case 16: &#123; red = (color &gt;&gt; (16+3)) &amp; 0x1F; green = (color &gt;&gt; (8+2)) &amp; 0x3F; blue = (color &gt;&gt; 3) &amp; 0x1F; fb_show_16bpp_new = (red &lt;&lt; 11) | (green &lt;&lt; 5) | blue; *fb_show_16bpp = fb_show_16bpp_new; break; &#125; case 32: &#123; *fb_show_32bpp = color; break; &#125; default : &#123; printf(\"Can't support %d bpp\\n\", fb_var.bits_per_pixel); return -1; &#125; &#125; return 0;&#125; 显示每行：1234567891011121314151617181920212223242526static int fb_show_line(int x_start, int x_end, int y, unsigned char *color_array)&#123; int i = x_start * 3; int x; unsigned int color; if (y &gt;= fb_var.yres) return -1; if (x_start &gt;= fb_var.xres) return -1; if (x_end &gt;= fb_var.xres) &#123; x_end = fb_var.xres; &#125; for (x = x_start; x &lt; x_end; x++) &#123; /* 0xRRGGBB */ color = (color_array[i]&lt;&lt;16) + (color_array[i+1]&lt;&lt;8) + (color_array[i+2]&lt;&lt;0); i += 3; fb_show_pixel(x, y, color); &#125; return 0;&#125; 除此之外，每次显示前还需要清除原来的显示信息，也就是清空显示信息一次。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static int fb_clean_screen(unsigned int back_color)&#123; unsigned char *fb_show; unsigned short *fb_show_16bpp; unsigned int *fb_show_32bpp; unsigned short fb_show_16bpp_new; /* 565 */ int red; int green; int blue; int i = 0; fb_show = fb_mem; fb_show_16bpp = (unsigned short *)fb_show; fb_show_32bpp = (unsigned int *)fb_show; switch (fb_var.bits_per_pixel) &#123; case 8: &#123; memset(fb_mem, back_color, screen_size); break; &#125; case 16: &#123; red = (back_color &gt;&gt; (16+3)) &amp; 0x1F; green = (back_color &gt;&gt; (8+2)) &amp; 0x3F; blue = (back_color &gt;&gt; 3) &amp; 0x1F; fb_show_16bpp_new = (red &lt;&lt; 11) | (green &lt;&lt; 5) | blue; while (i &lt; screen_size) &#123; *fb_show_16bpp = fb_show_16bpp_new; fb_show_16bpp++; i += 2; &#125; break; &#125; case 32: &#123; while (i &lt; screen_size) &#123; *fb_show_32bpp = back_color; fb_show_32bpp++; i += 4; &#125; break; &#125; default : &#123; printf(\"Can't support %d bpp\\n\", fb_var.bits_per_pixel); return -1; &#125; &#125; return 0;&#125; 7、解压完毕1jpeg_finish_decompress(&amp;cinfo); 8、释放资源和退出程序123free(buffer);jpeg_destroy_decompress(&amp;cinfo); fclose(infile); 参考博客：libjpeg库的简单使用使用—-jpeg图片解压 5.1.3 完整应用程序[jpg_rgb.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include &lt;stdio.h&gt;#include \"jpeglib.h\"#include &lt;setjmp.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;linux/fb.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define FB_DEVICE_NAME \"/dev/fb0\"static int fd;static struct fb_var_screeninfo fb_var;static struct fb_fix_screeninfo fb_fix; static unsigned char *fb_mem;static unsigned int screen_size;static unsigned int line_width;static unsigned int pixel_width;static int fb_device_init(void)&#123; int ret; fd = open(FB_DEVICE_NAME, O_RDWR); if (fd &lt; 0) &#123; printf(\"Can't open %s\\n\", FB_DEVICE_NAME); return -1; &#125; //获取可变信息 ret = ioctl(fd, FBIOGET_VSCREENINFO, &amp;fb_var); if (ret &lt; 0) &#123; printf(\"Can't get fb's var\\n\"); return -1; &#125; //获取固定信息 ret = ioctl(fd, FBIOGET_FSCREENINFO, &amp;fb_fix); if (ret &lt; 0) &#123; printf(\"Can't get fb's fix\\n\"); return -1; &#125; //映射fb screen_size = fb_var.xres * fb_var.yres * fb_var.bits_per_pixel / 8; fb_mem = (unsigned char *)mmap(NULL , screen_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if (fb_mem &lt; 0) &#123; printf(\"Can't mmap\\n\"); return -1; &#125; line_width = fb_var.xres * fb_var.bits_per_pixel / 8; pixel_width = fb_var.bits_per_pixel / 8; return 0;&#125;//color:0x00RRGGBBstatic int fb_show_pixel(int x, int y, unsigned int color)&#123; unsigned char *fb_show; unsigned short *fb_show_16bpp; unsigned int *fb_show_32bpp; unsigned short fb_show_16bpp_new; /* 565 */ int red; int green; int blue; if ((x &gt;= fb_var.xres) || (y &gt;= fb_var.yres)) &#123; printf(\"Out of region\\n\"); return -1; &#125; fb_show = fb_mem + line_width * y + pixel_width * x;//定位 fb_show_16bpp = (unsigned short *)fb_show; fb_show_32bpp = (unsigned int *)fb_show; switch (fb_var.bits_per_pixel) &#123; case 8: &#123; *fb_show = (unsigned char)color; break; &#125; case 16: &#123; red = (color &gt;&gt; (16+3)) &amp; 0x1F; green = (color &gt;&gt; (8+2)) &amp; 0x3F; blue = (color &gt;&gt; 3) &amp; 0x1F; fb_show_16bpp_new = (red &lt;&lt; 11) | (green &lt;&lt; 5) | blue; *fb_show_16bpp = fb_show_16bpp_new; break; &#125; case 32: &#123; *fb_show_32bpp = color; break; &#125; default : &#123; printf(\"Can't support %d bpp\\n\", fb_var.bits_per_pixel); return -1; &#125; &#125; return 0;&#125;static int fb_clean_screen(unsigned int back_color)&#123; unsigned char *fb_show; unsigned short *fb_show_16bpp; unsigned int *fb_show_32bpp; unsigned short fb_show_16bpp_new; /* 565 */ int red; int green; int blue; int i = 0; fb_show = fb_mem; fb_show_16bpp = (unsigned short *)fb_show; fb_show_32bpp = (unsigned int *)fb_show; switch (fb_var.bits_per_pixel) &#123; case 8: &#123; memset(fb_mem, back_color, screen_size); break; &#125; case 16: &#123; red = (back_color &gt;&gt; (16+3)) &amp; 0x1F; green = (back_color &gt;&gt; (8+2)) &amp; 0x3F; blue = (back_color &gt;&gt; 3) &amp; 0x1F; fb_show_16bpp_new = (red &lt;&lt; 11) | (green &lt;&lt; 5) | blue; while (i &lt; screen_size) &#123; *fb_show_16bpp = fb_show_16bpp_new; fb_show_16bpp++; i += 2; &#125; break; &#125; case 32: &#123; while (i &lt; screen_size) &#123; *fb_show_32bpp = back_color; fb_show_32bpp++; i += 4; &#125; break; &#125; default : &#123; printf(\"Can't support %d bpp\\n\", fb_var.bits_per_pixel); return -1; &#125; &#125; return 0;&#125;static int fb_show_line(int x_start, int x_end, int y, unsigned char *color_array)&#123; int i = x_start * 3; int x; unsigned int color; if (y &gt;= fb_var.yres) return -1; if (x_start &gt;= fb_var.xres) return -1; if (x_end &gt;= fb_var.xres) &#123; x_end = fb_var.xres; &#125; for (x = x_start; x &lt; x_end; x++) &#123; /* 0xRRGGBB */ color = (color_array[i]&lt;&lt;16) + (color_array[i+1]&lt;&lt;8) + (color_array[i+2]&lt;&lt;0); i += 3; fb_show_pixel(x, y, color); &#125; return 0;&#125;/* * Uage: jpg_rgb &lt;jpg_file&gt; */int main(int argc, char **argv)&#123; //1、分配jpeg对象结构体空间、并初始化 struct jpeg_decompress_struct cinfo; struct jpeg_error_mgr jerr; FILE * infile; int row_stride; unsigned char *buffer; if (argc != 2) &#123; printf(\"Usage: \\n\"); printf(\"%s &lt;jpg_file&gt;\\n\", argv[0]); return -1; &#125; if (fb_device_init()) &#123; return -1; &#125; fb_clean_screen(0); //绑定jerr错误结构体至jpeg对象结构体 cinfo.err = jpeg_std_error(&amp;jerr); //初始化cinfo结构体 jpeg_create_decompress(&amp;cinfo); //2、指定解压数据源 if ((infile = fopen(argv[1], \"rb\")) == NULL) &#123; fprintf(stderr, \"can't open %s\\n\", argv[1]); return -1; &#125; jpeg_stdio_src(&amp;cinfo, infile); //3、获取解压文件信息 jpeg_read_header(&amp;cinfo, TRUE); /* 源信息 */ printf(\"image_width = %d\\n\", cinfo.image_width); printf(\"image_height = %d\\n\", cinfo.image_height); printf(\"num_components = %d\\n\", cinfo.num_components); //4、为解压设定参数，包括图像大小和颜色空间 printf(\"enter scale M/N:\\n\"); scanf(\"%d/%d\", &amp;cinfo.scale_num, &amp;cinfo.scale_denom); printf(\"scale to : %d/%d\\n\", cinfo.scale_num, cinfo.scale_denom); //5、开始解压缩 jpeg_start_decompress(&amp;cinfo); /* 输出的图象的信息 */ printf(\"output_width = %d\\n\", cinfo.output_width); printf(\"output_height = %d\\n\", cinfo.output_height); printf(\"output_components = %d\\n\", cinfo.output_components); //6、取数据并显示 //一行的数据长度 row_stride = cinfo.output_width * cinfo.output_components; buffer = malloc(row_stride); // 循环调用jpeg_read_scanlines来一行一行地获得解压的数据 while (cinfo.output_scanline &lt; cinfo.output_height) &#123; (void) jpeg_read_scanlines(&amp;cinfo, &amp;buffer, 1); // 写到LCD去 fb_show_line(0, cinfo.output_width, cinfo.output_scanline, buffer); &#125; //7、解压完毕 jpeg_finish_decompress(&amp;cinfo); //8、释放资源和退出程序 free(buffer); jpeg_destroy_decompress(&amp;cinfo); return 0;&#125; 5.1.4 交叉编译应用程序方法一：jpg_rgb.c要想在开发板上运行，就得先交叉编译，里面用到了一非系统的头文件和函数，因此还需要指定头文件和库路径。-I:指定头文件路径-L:指定库路径-i:指定具体哪个库1234arm-none-linux-gnueabi-gcc -o jpg_rgb jpg_rgb.c \\-I /work/drv/2_lcd/libjpeg_new/libjpeg-turbo-1.5.3/tmp/include \\-L /work/drv/2_lcd/libjpeg_new/libjpeg-turbo-1.5.3/tmp/lib \\-ljpeg 方法二：前面的方法，每次编译都要指定一堆路径，比较麻烦，解决方法是将头文件和库复制到交叉编译工具链所在的路径：12345678910//拷贝头文件cd /work/drv/2_lcd/show_jpeg/libjpeg-turbo-1.5.3/tmp/include/cp * /work/arm-2014.05/arm-none-linux-gnueabi/libc/usr/include//拷贝库cd /work/drv/2_lcd/show_jpeg/libjpeg-turbo-1.5.3/tmp/lib/cp * /work/arm-2014.05/arm-none-linux-gnueabi/libc/lib//编译arm-none-linux-gnueabi-gcc -o jpg_rgb jpg_rgb.c -ljpeg 5.1.5 运行应用程序a. 先把应用程序和动态库拷贝到开发板上：12cp jpg_rgb /work/nfs_rootfs/cp libjpeg-turbo-1.5.3/tmp/lib/*so* /work/nfs_rootfs/lib/ -d b. 加载背光和LCD驱动：12insmod backlight_drv.koinsmod lcd_drv.ko c. 开启背光：1./app 200 d. 运行应用程序：1./jpg_rgb cq.jpg 5.1.6 实际效果 5.2移除左上角光标现在已经实现了图片的显示，仔细观察，发现左上角有个小光标一直在闪烁。查阅了相关资料，解决方案如下: 修改Linux内核中的文件：drivers/video/console/fbcon.c 去掉光标闪烁：将函数static void fbcon_cursor(struct vc_data *vc, int mode)改为空函数即可。 去掉光标显示：将函数static void fb_flashcursor(struct work_struct *work) 改为空函数即可。 再重新编译、烧写内核。 6.总结 Beautiful Chongqing. 总算搞完了LCD，真累。拖拖拉拉了差不多一个月。对LCD这块，不管是基础知识、驱动还是应用程序，都有了一个新的认识，也除去了LCD这块拦路虎的“心结”，有信心去迎接更复杂的模块。 后续的话，搞定电容屏驱动，就可以考虑学习下摄像头驱动了。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"Exynos4412","slug":"Exynos4412","permalink":"http://yoursite.com/tags/Exynos4412/"},{"name":"LCD","slug":"LCD","permalink":"http://yoursite.com/tags/LCD/"}]},{"title":"Exynos4412——LCD之backligth","date":"2017-11-22T11:27:44.000Z","path":"2017/11/22/Exynos4412——LCD之backligth/","text":"Exynos4412的背光驱动，采用友善之臂的“一线触摸”。 1.背景 关于一线触摸友善之臂官方说明：LCD-S702/zh 在大部分的ARM主控板中，我们发现，直接使用CPU自带的ADC转换器并不能很好的支持大尺寸(7寸以上)的四线电阻触摸屏，市面上一般采用更加专业的USB或串口触摸屏扩展模块来解决。为了节省ARM主控芯片的有限资源以及减少外扩，我们专门开发了只使用一个普通GPIO就可以实现专业触摸效果的替代方案，并把它集成到我们的LCD模块驱动板中，我们称之为“一线触摸(1-Wire)”。它的基本原理是，使用一个低成本的MCU连接一个专业的触控芯片(在此我们使用的是ADS7843或兼容芯片)，采集并处理四线电阻模拟信号，并把滤波(未校准)后的稳定原始数据通过GPIO送给ARM主控，经我们长期反复测试，即使在19寸这样大的电阻触摸屏上，也可以实现非常精准的触摸效果，不会出现漂移抖动的现象。 另外，当今12寸以内的LCD显示屏，大都采用了LED背光，我们顺便也把背光调节部分也交给MCU来处理，并设置了统一的调节数值区间，最后通过“一线触摸”的GPIO传给ARM主控，这样在ARM端就可以非常方便的来设置背光了。 与此同时，我们还为我们设计开发的每一款带“一线触摸”的LCD模块设置了编号存储在MCU中，这样通过一线通讯读取到的编号，就可以知道这个LCD模块的具体类型了，也就可以在bootloader和内核中自动匹配相应的LCD驱动参数，以此来实现无需修改任何配置，即插即用带”一线触摸”的LCD模块。 在电容触摸LCD模块中，我们则去掉了电阻触控芯片，而保留了背光调节和存储LCD类型编号这2个功能，因此电容触摸通讯依然是标准的I2C接口。 需要注意的是，我们实现的“一线触摸”的通讯，和通常所说的单总线接口是不同的。在ARM主控端内部，我们实际采用了一路pwm timer(不是pwm管脚哦)来实现固定的通讯频率(9600Hz)，详细请查看驱动源代码。 也就是说友善之臂为了改善大尺寸四线电阻触摸屏的性能，外加了一个低成本的MCU去控制专业的触控芯片，将滤波后的稳定数据通过GPIO传回到ARM上。这是和触摸屏相关的，本次不深究，而且我的板子LCD是电容屏，以上的改进几乎不关我的事。但，他们把背光调节部分也交给了那个低成本MCU来处理，并通过“一线触摸”来控制，这就坑了。记得以前的都是ARM的一个PWM引脚就完成LCD的背光的控制，现在由于硬件上并不能直接PWM控制，不得不采用“一线触摸”。 2.原理图 Tiny4412SDK-1506-Schematic.pdf： Tiny4412-1412-Schematic.pdf：Exynos4412的GPX1_2与LCD相连，作为“一线触摸”引脚，也就是背光控制引脚。 3.设备树文件123456789101112131415161718192021222324252627282930313233343536373839--- exynos4412-tiny4412.dts 2017-11-22 01:43:28.922397104 -0800+++ linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dts 2017-11-22 01:42:47.459525364 -0800@@ -91,6 +91,18 @@ clock-frequency = &lt;24000000&gt;; &#125;; &#125;;++ backlight@139D0000&#123;+ compatible = &quot;tiny4412,backlight&quot;;+ reg = &lt;0x139D0000 0x14&gt;;+ tiny4412,backlight = &lt;&amp;gpx1 2 GPIO_ACTIVE_HIGH&gt;;+ pinctrl-names = &quot;backlight_out&quot;,&quot;backlight_in&quot;;+ pinctrl-0 = &lt;&amp;backlight_out&gt;;+ pinctrl-1 = &lt;&amp;backlight_in&gt;;+ interrupts = &lt;0 40 0&gt;;+ clocks = &lt;&amp;clock CLK_PWM&gt;;+ clock-names = &quot;timers&quot;;+ &#125;; &#125;; &amp;rtc &#123;@@ -151,4 +163,21 @@ &#125;;+&amp;pinctrl_1 &#123;+ backlight_out: backlight_out&#123;+ samsung,pins = &quot;gpx1-2&quot;;+ samsung,pin-function = &lt;1&gt;;+ samsung,pin-pud = &lt;0&gt;;+ samsung,pin-drv = &lt;0&gt;;+ &#125;;+ backlight_in: backlight_in&#123;+ samsung,pins = &quot;gpx1-2&quot;;+ samsung,pin-function = &lt;0&gt;;+ samsung,pin-pud = &lt;0&gt;;+ samsung,pin-drv = &lt;0&gt;;+ &#125;;+&#125;; 本来想认真分析的，真分析起来，发现没什么看的，0x139D0000是PWMer定时器的基地址，还将gpx1_2设置成了两种模式：backlight_out（输出引脚）和backlight_in（输入引脚）。这里为什么要用到定时器，不是很明白，文末的第二个博客说“开发板和 CPLD 通讯使用了特殊的协议，设置一次背光值，需要读写 IO 多次，因此，需要使用定时器功能”，但看原理图感觉和CPLD(EPM240T100)关系不是很大。以上就是设备树文件的一些设置，后续驱动会用到。 4.驱动简析驱动完整代码如下：[backlight_drv.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/device.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_gpio.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/bitops.h&gt;#include &lt;linux/clk.h&gt;#include &lt;linux/export.h&gt;#include &lt;linux/err.h&gt;#include &lt;linux/io.h&gt;#include &lt;linux/pwm.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/spinlock.h&gt;#include &lt;linux/time.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/delay.h&gt;/* PWM 时钟频率 100M 100M / 250 / 4 = 100000 1/100000 = 10us*/static int major;static struct cdev backlight_cdev;static struct class *cls;static struct pinctrl *pctrl;static struct pinctrl_state *pstate_in;static struct pinctrl_state *pstate_out;static int one_write_pin;struct TIMER_BASE&#123; unsigned int TCFG0; unsigned int TCFG1; unsigned int TCON; unsigned int TCNTB0; unsigned int TCMPB0; unsigned int TCNTO0; unsigned int TCNTB1; unsigned int TCMPB1; unsigned int TCNTO1; unsigned int TCNTB2; unsigned int TCMPB2; unsigned int TCNTO2; unsigned int TCNTB3; unsigned int TCMPB3; unsigned int TCNTO3; unsigned int TCNTB4; unsigned int TCBTO4; unsigned int TINT_CSTAT;&#125;;volatile static struct TIMER_BASE *timer = NULL;static volatile unsigned int io_bit_count;static volatile unsigned int io_data;enum&#123; IDLE, START, REQUEST, WAITING, RESPONSE, STOPING,&#125; one_wire_status = IDLE;static inline void stop_timer_for_1wire(void)&#123; unsigned long tcon; tcon = timer-&gt;TCON; tcon &amp;= ~(1 &lt;&lt; 16); timer-&gt;TCON = tcon;&#125;static irqreturn_t timer_for_1wire_interrupt(int irq, void *dev_id)&#123; unsigned int tint; tint = timer-&gt;TINT_CSTAT; tint |= 0x100; timer-&gt;TINT_CSTAT = tint; //printk(\"timer_for_1wire_interrupt\\n\"); io_bit_count--; switch (one_wire_status) &#123; case START: if (io_bit_count == 0) &#123; io_bit_count = 16; one_wire_status = REQUEST; &#125; break; case REQUEST: gpio_set_value(one_write_pin, io_data &amp; (1U &lt;&lt; 31)); io_data &lt;&lt;= 1; if (io_bit_count == 0) &#123; io_bit_count = 2; one_wire_status = WAITING; &#125; break; case WAITING: if (io_bit_count == 0) &#123; io_bit_count = 32; one_wire_status = RESPONSE; &#125; if (io_bit_count == 1) &#123; pinctrl_select_state(pctrl, pstate_in); gpio_set_value(one_write_pin, 1); &#125; break; case RESPONSE: io_data = (io_data &lt;&lt; 1) | gpio_get_value(one_write_pin); if (io_bit_count == 0) &#123; io_bit_count = 2; one_wire_status = STOPING; gpio_set_value(one_write_pin, 1); pinctrl_select_state(pctrl, pstate_out); //one_wire_session_complete(one_wire_request, io_data); &#125; break; case STOPING: if (io_bit_count == 0) &#123; one_wire_status = IDLE; stop_timer_for_1wire(); &#125; break; default: stop_timer_for_1wire(); &#125; return IRQ_HANDLED;&#125;static const unsigned char crc8_tab[] =&#123; 0x00, 0x07, 0x0E, 0x09, 0x1C, 0x1B, 0x12, 0x15, 0x38, 0x3F, 0x36, 0x31, 0x24, 0x23, 0x2A, 0x2D, 0x70, 0x77, 0x7E, 0x79, 0x6C, 0x6B, 0x62, 0x65, 0x48, 0x4F, 0x46, 0x41, 0x54, 0x53, 0x5A, 0x5D, 0xE0, 0xE7, 0xEE, 0xE9, 0xFC, 0xFB, 0xF2, 0xF5, 0xD8, 0xDF, 0xD6, 0xD1, 0xC4, 0xC3, 0xCA, 0xCD, 0x90, 0x97, 0x9E, 0x99, 0x8C, 0x8B, 0x82, 0x85, 0xA8, 0xAF, 0xA6, 0xA1, 0xB4, 0xB3, 0xBA, 0xBD, 0xC7, 0xC0, 0xC9, 0xCE, 0xDB, 0xDC, 0xD5, 0xD2, 0xFF, 0xF8, 0xF1, 0xF6, 0xE3, 0xE4, 0xED, 0xEA, 0xB7, 0xB0, 0xB9, 0xBE, 0xAB, 0xAC, 0xA5, 0xA2, 0x8F, 0x88, 0x81, 0x86, 0x93, 0x94, 0x9D, 0x9A, 0x27, 0x20, 0x29, 0x2E, 0x3B, 0x3C, 0x35, 0x32, 0x1F, 0x18, 0x11, 0x16, 0x03, 0x04, 0x0D, 0x0A, 0x57, 0x50, 0x59, 0x5E, 0x4B, 0x4C, 0x45, 0x42, 0x6F, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7D, 0x7A, 0x89, 0x8E, 0x87, 0x80, 0x95, 0x92, 0x9B, 0x9C, 0xB1, 0xB6, 0xBF, 0xB8, 0xAD, 0xAA, 0xA3, 0xA4, 0xF9, 0xFE, 0xF7, 0xF0, 0xE5, 0xE2, 0xEB, 0xEC, 0xC1, 0xC6, 0xCF, 0xC8, 0xDD, 0xDA, 0xD3, 0xD4, 0x69, 0x6E, 0x67, 0x60, 0x75, 0x72, 0x7B, 0x7C, 0x51, 0x56, 0x5F, 0x58, 0x4D, 0x4A, 0x43, 0x44, 0x19, 0x1E, 0x17, 0x10, 0x05, 0x02, 0x0B, 0x0C, 0x21, 0x26, 0x2F, 0x28, 0x3D, 0x3A, 0x33, 0x34, 0x4E, 0x49, 0x40, 0x47, 0x52, 0x55, 0x5C, 0x5B, 0x76, 0x71, 0x78, 0x7F, 0x6A, 0x6D, 0x64, 0x63, 0x3E, 0x39, 0x30, 0x37, 0x22, 0x25, 0x2C, 0x2B, 0x06, 0x01, 0x08, 0x0F, 0x1A, 0x1D, 0x14, 0x13, 0xAE, 0xA9, 0xA0, 0xA7, 0xB2, 0xB5, 0xBC, 0xBB, 0x96, 0x91, 0x98, 0x9F, 0x8A, 0x8D, 0x84, 0x83, 0xDE, 0xD9, 0xD0, 0xD7, 0xC2, 0xC5, 0xCC, 0xCB, 0xE6, 0xE1, 0xE8, 0xEF, 0xFA, 0xFD, 0xF4, 0xF3,&#125;;#define crc8_init(crc) ((crc) = 0XACU)#define crc8(crc, v) ( (crc) = crc8_tab[(crc) ^(v)])static void start_one_wire_session(unsigned char req)&#123; unsigned int tcon; printk(\"backlight_write\\n\"); one_wire_status = START; gpio_set_value(one_write_pin, 1); pinctrl_select_state(pctrl, pstate_out); // IDLE to START &#123; unsigned char crc; crc8_init(crc); crc8(crc, req); io_data = (req &lt;&lt; 8) + crc; io_data &lt;&lt;= 16; &#125; io_bit_count = 1; pinctrl_select_state(pctrl, pstate_out); timer-&gt;TCNTB3 = 650; //init tranfer and start timer tcon = timer-&gt;TCON; tcon &amp;= ~(0xF &lt;&lt; 16); tcon |= (1 &lt;&lt; 17); timer-&gt;TCON = tcon; tcon |= (1 &lt;&lt; 16); tcon |= (1 &lt;&lt; 19); tcon &amp;= ~(1 &lt;&lt; 17); timer-&gt;TCON = tcon; timer-&gt;TINT_CSTAT |= 0x08; gpio_set_value(one_write_pin, 0);&#125;static ssize_t backlight_write(struct file *file, const char __user *buf, size_t count, loff_t *off)&#123; unsigned char reg, ret; ret = copy_from_user(&amp;reg, buf, 1); printk(\"kernel: reg = %d\", reg); //printk(\"buf = %d\", *buf); if (ret &lt; 0) &#123; printk(\"%s copy_from_user error\\n\", __func__); &#125; /*if (reg &gt; 127) &#123; reg = 127; &#125; start_one_wire_session(reg + 0x80); */ start_one_wire_session(reg); return 1;&#125;static int backlight_open(struct inode *inode, struct file *file)&#123; printk(\"backlight_open\\n\"); return 0;&#125;static int backlight_release(struct inode *inode, struct file *file)&#123; printk(\"backlight_exit\\n\"); return 0;&#125;static struct file_operations backlight_fops =&#123; .owner = THIS_MODULE, .open = backlight_open, .release = backlight_release, .write = backlight_write,&#125;;static struct device *dev;static struct clk *base_clk;static struct resource *res = NULL, *irq = NULL;static int backlight_probe(struct platform_device *pdev)&#123; int ret; dev_t devid; dev = &amp;pdev-&gt;dev; printk(\"enter %s\\n\", __func__); pctrl = devm_pinctrl_get(dev); if (pctrl == NULL) &#123; printk(\"devm_pinctrl_get error\\n\"); return -EINVAL; &#125; pstate_in = pinctrl_lookup_state(pctrl, \"backlight_in\"); pstate_out = pinctrl_lookup_state(pctrl, \"backlight_out\"); if (pstate_in == NULL || pstate_out == NULL) &#123; printk(\"pinctrl_lookup_state error\\n\"); return -EINVAL; &#125; one_write_pin = of_get_named_gpio(dev-&gt;of_node, \"tiny4412,backlight\", 0); if (!one_write_pin) &#123; printk(\"of_get_named_gpio error\\n\"); return -EINVAL; &#125; devm_gpio_request_one(dev, one_write_pin, GPIOF_OUT_INIT_HIGH, \"one_write\"); //pinctrl_select_state(pctrl, pstate); res = platform_get_resource(pdev, IORESOURCE_MEM, 0); if (res == NULL) &#123; printk(\"platform_get_resource error\\n\"); return -EINVAL; &#125; base_clk = devm_clk_get(&amp;pdev-&gt;dev, \"timers\"); if (IS_ERR(base_clk)) &#123; dev_err(dev, \"failed to get timer base clk\\n\"); return PTR_ERR(base_clk); &#125; ret = clk_prepare_enable(base_clk); if (ret &lt; 0) &#123; dev_err(dev, \"failed to enable base clock\\n\"); return ret; &#125; timer = devm_ioremap_resource(&amp;pdev-&gt;dev, res); if (timer == NULL) &#123; printk(\"devm_ioremap_resource error\\n\"); return -EINVAL; &#125; printk(\"timer: %x\\n\", (unsigned int)timer); timer-&gt;TCFG0 = 0xF00; timer-&gt;TCFG1 = 0x10004; irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0); if (irq == NULL) &#123; printk(\"platform_get_resource irq error\\n\"); return -EINVAL; &#125; ret = devm_request_irq(dev, irq-&gt;start, timer_for_1wire_interrupt , IRQF_TIMER, \"backlight\", NULL); if (ret) &#123; dev_err(dev, \"unable to request irq\\n\"); return -EINVAL; &#125; start_one_wire_session(0x60); if (alloc_chrdev_region(&amp;devid, 0, 1, \"backlight\") &lt; 0) &#123; printk(\"%s ERROR\\n\", __func__); return -EINVAL; &#125; major = MAJOR(devid); cdev_init(&amp;backlight_cdev, &amp;backlight_fops); cdev_add(&amp;backlight_cdev, devid, 1); cls = class_create(THIS_MODULE, \"onewire_backlight\"); device_create(cls, NULL, MKDEV(major, 0), NULL, \"tiny4412_backlight\"); return 0;&#125;static int backlight_remove(struct platform_device *pdev)&#123; printk(\"enter %s\\n\", __func__); device_destroy(cls, MKDEV(major, 0)); class_destroy(cls); cdev_del(&amp;backlight_cdev); unregister_chrdev_region(MKDEV(major, 0), 1); devm_pinctrl_put(pctrl); devm_free_irq(dev, irq-&gt;start, NULL); clk_disable_unprepare(base_clk); devm_gpio_free(dev, one_write_pin); return 0;&#125;static const struct of_device_id backlight_dt_ids[] =&#123; &#123; .compatible = \"tiny4412,backlight\", &#125;, &#123;&#125;,&#125;;MODULE_DEVICE_TABLE(of, backlight_dt_ids);static struct platform_driver backlight_driver =&#123; .driver = &#123; .name = \"tiny4412_backlight\", .of_match_table = of_match_ptr(backlight_dt_ids), &#125;, .probe = backlight_probe, .remove = backlight_remove,&#125;;static int backlight_init(void)&#123; int ret; printk(\"enter %s\\n\", __func__); ret = platform_driver_register(&amp;backlight_driver); if (ret) &#123; printk(KERN_ERR \"Tiny4412 backlight: probe faid backlight: %d\\n\", ret); &#125; return ret;&#125;static void backlight_exit(void)&#123; printk(\"enter %s\\n\", __func__); platform_driver_unregister(&amp;backlight_driver);&#125;module_init(backlight_init);module_exit(backlight_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"Tiny4412 LCD backlight driver.\");MODULE_ALIAS(\"Exynos4412_backlight\");MODULE_VERSION(\"V1.0\"); 首先insmod该驱动，会调用backlight_init(),注册平台设备platform_driver_register(&amp;backlight_driver)。backlight_driver结构体里面的.compatible与设备树文件里的compatible完全匹配上后，即调用最核心的backlight_probe()函数。在backlight_probe()函数里获取设备树的各种信息、地址映射、设置时钟等，最后再申请设备号、注册设备、创建类、创建设备。在backlight_fops操作函数里，主要的是写函数，它获取用户层的数据，然后调用start_one_wire_session()实现背光的修改。这里的start_one_wire_session()就不太好分析了，协议是友善自定的。 5.测试程序[app.c]link123456789101112131415161718192021222324252627282930313233#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#define msleep(x) usleep(x*1000)int main(int argc, char **argv)&#123; int fd; int val; if (argc != 2) &#123; printf(\"%s+val\\n\",argv[0]); return -1; &#125; fd = open(\"/dev/tiny4412_backlight\", O_RDWR); if (fd &lt; 0) &#123; printf(\"can't open /dev/tiny4412_backlight\\n\"); return 0; &#125; val = strtoul(argv[1], NULL, 0); printf(\"app: val = %d\",val); write(fd, &amp;val, 1); return 0; &#125; 6.实测结果 参考博客：学习设备树之（十一）Backlight(20）设备树LCD背光驱动 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"Exynos4412","slug":"Exynos4412","permalink":"http://yoursite.com/tags/Exynos4412/"}]},{"title":"Exynos4412——SD卡启动","date":"2017-11-07T10:36:29.000Z","path":"2017/11/07/Exynos4412——SD卡启动/","text":"实现Tiny4412从SD卡的启动内核与根文件系统。前面启动开发板时，需要从SD卡启动Uboot，然后从DNW下载内核和根文件系统到RAM，或者NFS挂载根文件系统。Uboot应该是支持SD卡的，可以从SD卡读取内核。Uboot把控制权交给内核后，内核必须要支持SD卡，才能访问SD卡的根文件系统，因此需要移植SD卡驱动。 1.关于启动的理解嵌入式Linux开发一般需要至少三个文件：Bootloader(Uboot)、Kernel(uImage)、根文件系统（rootfs）。Kernel-3.x加入设备树后，又多了个DTB设备树文件。因此，本次要准备四个文件：Uboot、Kernel、rootfs、DTB。 一般开发板上有多个存储介质，如：Nand Flash、Nor Flash、mmc、emmc、SD卡、网络也算特殊的一种。 前面的四个文件，理论上可以放在板上的任一存储介质里面，然后给SOC信号（开发板上的启动顺序拨码开关），告诉它从哪个存储介质读取相应文件。但由于一些特殊原因，往往有所限制。比如，Nor Flash比较小，一般只放Uboot，放不下rootfs。好像也没有支持网络NFS启动的Uboot，至少我目前没遇到过。因此，一般常见的方式是把Uboot放在Nor Flash，其它的放在Nand Flash，就像JZ2440；或者全都放在SD卡/TF卡，就像Ti的AM437X；又或者都放在emmc，像Tiny4412；总之就是以上的存储介质组合，根据实际情况而定。需要一提的是，很多SOC现在都在Uboot前封装了一层代码，或者搞了一个其它什么机制，上电后马上初始化了存储介质相关的寄存器，其次才加载用户的第一行代码。 开发板上电后，先内部固化代码先初始化一些必要的东西（有的SOC没有这一机制），然后根据启动引脚的电平，读取相应的存储介质上的Uboot到RAM，启动Uboot后，根据用户传的参数加载内核、设备树、根文件系统到RAM。这一过程的Uboot所处的存储介质受限比较大，要根据SOC所支持的启动方式来选择。后面Uboot启动后，Uboot会初始化更多的硬件存储介质，也就有了更多的选择。 启动过程其实是先将要启动的文件从存储位置拷贝到内存空间，再在内存中运行。因此所谓不同位置启动，也就是从不同位置拷贝而已。 2.移植SD卡驱动SD卡移植的工作内容很少，仅对其设备树文件arch/arm/boot/dts/exynos4412-tiny4412.dts添加了一行代码即可：12345678910-- /work/tools/linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dts 2017-10-21 08:55:07.000000000 -0700+++ /work/linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dts 2017-10-31 03:34:04.609606802 -0700@@ -79,6 +101,7 @@ bus-width = &lt;4&gt;; pinctrl-0 = &lt;&amp;sd2_clk &amp;sd2_cmd &amp;sd2_cd &amp;sd2_bus4&gt;; pinctrl-names = &quot;default&quot;;+ vmmc-supply = &lt;&amp;mmc_reg&gt;; status = &quot;okay&quot;; &#125;; 然后奇迹般就可以了。。懵逼。 3.制作SD卡先将SD卡分为两个区，一个格式为fat32用于放内核和dtb，一个格式为ext3/4用于存放根文件系统。可以使用fdisk命令分区，mkfs命令进行格式化。这里使用如下的mkcard.sh脚本更方便，原脚本里面的sfdisk是2.26版本的，在Ubuntu14.04运行正常，在Ubuntu16.04是无法运行的，Ubuntu16.014sfdisk的版本是2.27.1。顺便修改了下分区大小，看起来更舒服点，修改后的脚本如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#! /bin/sh# mkcard.sh v0.4# (c) Copyright 2009 Graeme Gregory &lt;dp@xora.org.uk&gt;# Licensed under terms of GPLv2## Parts of the procudure base on the work of Denys Dmytriyenko# http://wiki.omap.com/index.php/MMC_Boot_FormatLC_ALL=Cif [ $# -ne 1 ]; then echo \"Usage: $0 &lt;drive&gt;\" exit 1;fiDRIVE=$1dd if=/dev/zero of=$DRIVE bs=1024 count=1024SIZE=`fdisk -l $DRIVE | grep Disk | awk '&#123;print $5&#125;'`echo DISK SIZE - $SIZE bytesCYLINDERS=`echo $SIZE/255/63/512 | bc`echo CYLINDERS - $CYLINDERS# 将SD卡分成2个区sfdisk --no-reread $DRIVE &lt;&lt; EOF1024,1024000,0x0C,*1024100,,,-EOF# 格式化第1分区为fat32格式, 并且命名为bootif [ -b $&#123;DRIVE&#125;1 ]; then mkfs.vfat -F 32 -n \"boot\" $&#123;DRIVE&#125;1else if [ -b $&#123;DRIVE&#125;p1 ]; then mkfs.vfat -F 32 -n \"boot\" $&#123;DRIVE&#125;p1 else echo \"Cant find boot partition in /dev\" fifi# 格式化第2分区为ext3格式, 并且命名为rootfsif [ -b $&#123;DRIVE&#125;2 ]; then mke2fs -j -L \"rootfs\" $&#123;DRIVE&#125;2else if [ -b $&#123;DRIVE&#125;p2 ]; then mke2fs -j -L \"rootfs\" $&#123;DRIVE&#125;p2 else echo \"Cant find rootfs partition in /dev\" fifisyncsudo partprobe $DRIVE sync 参考博客(需梯子) 执行1sudo ./mkcard.sh /dev/mmcblk0 等待一会，使用命令sudo fdisk -l查看分区，如果脚本工作完后，看起来没有分区成功，重启系统再来一次，有点莫名其妙的。 搞定后，此时就会有两个分别名叫boot和rootfs的分区。再使用制作Uboot的sd_fusing.sh脚本。12cd work/uboot_tiny4412_0929/sd_fuse/tiny4412 sudo ./sd_fusing.sh /dev/mmcblk0 简单看了看sd_fusing.sh脚本，脑补了下此时的SD卡分布：此时在boot和rootfs分区看不到相关文件的原因可能就是不在分区内。 最后依次将uImage、DTB、rootfs复制到SD卡即可：1234sudo cp /work/linux-4.13.9/arch/arm/boot/uImage /media/hceng/boot/sudo cp /work/linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dtb /media/hceng/boot/sudo cp -rd /work/nfs_rootfs/* /media/hceng/rootfs/ 4.Uboot参数设置刚开始测试的时候，老是卡在Starting kernel ...，查找了一下午原因，最后发现是Uboot参数设置的时候连写命令所致。Uboot启动参数设置如下： SD卡启动： 1234567setenv bootargs &apos;root=/dev/mmcblk0p2 rw console=ttySAC0,115200 init=/linuxrc&apos;saveenvsetenv bootcmd fatload mmc 0:1 0x40000000 uImage\\;fatload mmc 0:1 0x42000000 exynos4412-tiny4412.dtb\\;bootm 0x40000000 - 0x42000000saveenvboot NFS启动： 1234567setenv bootargs &apos;root=/dev/nfs rw nfsroot=192.168.1.226:/work/fs_mini_mdev_new ethmac=00:40:5c:26:0a:5b ip=192.168.1.225:192.168.1.226:192.168.1.1:255.255.255.0::eth0:off console=ttySAC0,115200 init=/linuxrc&apos;saveenvsetenv bootcmd fatload mmc 0:1 0x40000000 uImage\\;fatload mmc 0:1 0x42000000 exynos4412-tiny4412.dtb\\;bootm 0x40000000 - 0x42000000saveenvboot 5.实际效果 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Exynos4412","slug":"Exynos4412","permalink":"http://yoursite.com/tags/Exynos4412/"},{"name":"SD卡","slug":"SD卡","permalink":"http://yoursite.com/tags/SD卡/"},{"name":"Uboot","slug":"Uboot","permalink":"http://yoursite.com/tags/Uboot/"}]},{"title":"Exynos4412——网卡移植和NFS启动","date":"2017-10-31T12:27:52.000Z","path":"2017/10/31/Exynos4412——网卡移植和NFS启动/","text":"为Exynos 4412移植好网卡驱动，并采用NFS挂载根文件系统启动。玩Exynos4412的第一个目标是想弄下LCD驱动。在开始流畅的写驱动前，前期的准备工作又多又繁琐。 上次移植好了内核，内核和根文件系统都是在RAM进行进行加载的，后面写驱动的时候，肯定不方便。就以往的经验来看，uboot、kernel都应该在SD卡或者eMMC上，这样断电才不会丢失。根文件系统在调试驱动的时候应该是nfs挂载，调试完成了再烧写到SD卡或者eMMC上。 因此，写驱动前至少还要移植好SD卡驱动、网卡驱动。eMMC可暂时不管。 本次就先移植好网卡驱动，并尝试NFS挂载根文件系统。 1.硬件结构JZ2440中的网卡芯片是DM9000，采用的是内存接口。 Tiny4412的网卡芯片是DM9621，采用的是USB接口。而且该芯片并没有直接接在SOC的USB上，而是接在USB4604这个HUB芯片上。USB4604通过HSIC接口(XuhostSTROBE1和XuhostDATA1)接在SOC上。框架如下： 因此，需要重点关注USB4604和DM9621。查看这两块的原理图： USB4604： DM9621： 发现USB4604的一些功能并没有使用，如外接SPI/I2C设备等。除了数据端口，还能控制的就是复位引脚。 DM9621的驱动在本内核的drivers/net/usb/dm9601.c已经实现，但为了支持识别bootargs中的mac地址的功能，需要稍微修改dm9601.c，添加解析mac地址的功能，并且还需要将解析到的有效的mac地址设置到dm9621中，否则网络不能用。 USB4604的驱动在本内核的drivers/usb/misc/usb4604.c已经实现，但由于没有外接SPI/I2C，需要删除一些，可以参考drivers/usb/misc/usb3503.c或者博客里的代码。我直接用的博客里面的代码。 此外，还需在设备树使能将要用到的外设：hsi、ehci、otg等。 2.移植网卡驱动目前需要修改的文件有：（1）设备树文件：arch/arm/boot/dts/exynos4412-tiny4412.dts；（2）DM9621驱动：drivers/net/usb/dm9601.c；（3）USB4604驱动：drivers/usb/misc/usb4604.c；（4）USB4604驱动头文件：include/linux/platform_data/usb4604.h（新建）；（5）设备树头文件：include/dt-bindings/usb4640/usb4604.h（新建）；（6）DM9621驱动加入内核；（7）USB4604驱动加入内核； 2.1 修改设备树文件主要添加了usb-hub的复位引脚信息和使能了一些外设。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273--- /work/tools/linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dts 2017-10-21 08:55:07.000000000 -0700+++ /work/linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dts 2017-10-30 02:34:10.363297869 -0700@@ -14,6 +14,7 @@ /dts-v1/; #include \"exynos4412.dtsi\" #include &lt;dt-bindings/gpio/gpio.h&gt;+#include &lt;dt-bindings/usb4604/usb4604.h&gt; / &#123; model = \"FriendlyARM TINY4412 board based on Exynos4412\";@@ -21,6 +22,7 @@ chosen &#123; stdout-path = &amp;serial_0;+ bootargs = \"root=/dev/ram0 rw rootfstype=ext4 console=ttySAC0,115200 init=/linuxrc earlyprintk\"; &#125;; memory@40000000 &#123;@@ -28,6 +30,12 @@ reg = &lt;0x40000000 0x40000000&gt;; &#125;; + usb-hub &#123;+ compatible = \"smsc,usb4604\";+ reset-gpios = &lt;&amp;gpm2 4 GPIO_ACTIVE_LOW&gt;;+ initial-mode = &lt;USB4604_MODE_HUB&gt;;+ &#125;;+ leds &#123; compatible = \"gpio-leds\"; @@ -79,7 +87,7 @@ bus-width = &lt;4&gt;; pinctrl-0 = &lt;&amp;sd2_clk &amp;sd2_cmd &amp;sd2_cd &amp;sd2_bus4&gt;; pinctrl-names = \"default\";- status = \"okay\";+ status = \"disabled\"; &#125;; &amp;serial_0 &#123;@@ -97,3 +105,32 @@ &amp;serial_3 &#123; status = \"okay\"; &#125;;+++&amp;exynos_usbphy &#123;+ status = \"okay\";+&#125;;++&amp;ehci &#123;+ status = \"okay\";+ port@0 &#123;+ status = \"okay\";+ &#125;;+ port@1 &#123;+ status = \"okay\";+ &#125;;+ port@2 &#123;+ status = \"okay\";+ &#125;;+&#125;;++&amp;ohci &#123;+ status = \"okay\";+ port@0 &#123;+ status = \"okay\";+ &#125;;+&#125;;++&amp;hsotg &#123;+ status = \"okay\";+&#125;; 2.2 修改DM9621驱动主要是添加解析mac地址的功能，并且还需要将解析到的有效的mac地址设置到dm9621中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384--- /work/tools/linux-4.13.9/drivers/net/usb/dm9601.c 2017-10-21 08:55:07.000000000 -0700+++ /work/linux-4.13.9/drivers/net/usb/dm9601.c 2017-10-30 02:06:54.319597116 -0700@@ -58,6 +58,39 @@ #define DM_RX_OVERHEAD 7 /* 3 byte header + 4 byte crc tail */ #define DM_TIMEOUT 1000 +/* Setup ethernet address */+static u8 param_addr[ETH_ALEN];++static int __init dm9601_set_mac(char *str) &#123;+ u8 addr[ETH_ALEN];+ uint val;+ int idx = 0;+ char *p = str, *end;++ while (*p &amp;&amp; idx &lt; ETH_ALEN) &#123;+ val = simple_strtoul(p, &amp;end, 16);+ if (end &lt;= p) &#123;+ break;+ &#125; else &#123;+ addr[idx++] = val;+ p = end;+ if (*p == ':'|| *p == '-') &#123;+ p++;+ &#125; else &#123;+ break;+ &#125;+ &#125;+ &#125;++ if (idx == ETH_ALEN) &#123;+ printk(\"Setup ethernet address to %pM\\n\", addr);+ memcpy(param_addr, addr, ETH_ALEN);+ &#125;++ return 1;+&#125;+__setup(\"ethmac=\", dm9601_set_mac);+ static int dm_read(struct usbnet *dev, u8 reg, u16 length, void *data) &#123; int err;@@ -190,8 +223,6 @@ return dm_read_shared_word(dev, 0, offset, value); &#125; -- static int dm9601_get_eeprom_len(struct net_device *dev) &#123; return DM_EEPROM_LEN;@@ -281,9 +312,9 @@ .set_msglevel = usbnet_set_msglevel, .get_eeprom_len = dm9601_get_eeprom_len, .get_eeprom = dm9601_get_eeprom,+// .get_settings = usbnet_get_settings,+// .set_settings = usbnet_set_settings, .nway_reset = usbnet_nway_reset,- .get_link_ksettings = usbnet_get_link_ksettings,- .set_link_ksettings = usbnet_set_link_ksettings, &#125;; static void dm9601_set_multicast(struct net_device *net)@@ -343,7 +374,6 @@ .ndo_start_xmit = usbnet_start_xmit, .ndo_tx_timeout = usbnet_tx_timeout, .ndo_change_mtu = usbnet_change_mtu,- .ndo_get_stats64 = usbnet_get_stats64, .ndo_validate_addr = eth_validate_addr, .ndo_do_ioctl = dm9601_ioctl, .ndo_set_rx_mode = dm9601_set_multicast,@@ -390,7 +420,11 @@ /* * Overwrite the auto-generated address only with good ones. */- if (is_valid_ether_addr(mac))+ if (is_valid_ether_addr(param_addr)) &#123;+ /* write MAC to dm9621 */+ memcpy(dev-&gt;net-&gt;dev_addr, param_addr, ETH_ALEN);+ __dm9601_set_mac_address(dev);+ &#125; else if (is_valid_ether_addr(mac)) memcpy(dev-&gt;net-&gt;dev_addr, mac, ETH_ALEN); else &#123; printk(KERN_WARNING 2.3 修改USB4604驱动这个几乎就全改了，应该原来的那个稍微改改也能用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152/* * Driver for SMSC USB4604 USB 2.0 hub controller driver */#include &lt;linux/gpio.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/of_gpio.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/platform_data/usb4604.h&gt;struct usb4604 &#123; enum usb4604_mode mode; struct device *dev; int gpio_reset;&#125;;static int usb4604_reset(struct usb4604 *hub, int state)&#123; if (gpio_is_valid(hub-&gt;gpio_reset)) gpio_set_value_cansleep(hub-&gt;gpio_reset, state); /* Wait 1ms for hub logic to stabilize */ if (state) usleep_range(1, 10); return 0;&#125;static int usb4604_connect(struct usb4604 *hub)&#123; struct device *dev = hub-&gt;dev; usb4604_reset(hub, 1); hub-&gt;mode = USB4604_MODE_HUB; dev_info(dev, \"switched to HUB mode\\n\"); return 0;&#125;static int usb4604_switch_mode(struct usb4604 *hub, enum usb4604_mode mode)&#123; struct device *dev = hub-&gt;dev; int err = 0; switch (mode) &#123; case USB4604_MODE_HUB: err = usb4604_connect(hub); break; case USB4604_MODE_STANDBY: usb4604_reset(hub, 0); dev_info(dev, \"switched to STANDBY mode\\n\"); break; default: dev_err(dev, \"unknown mode is requested\\n\"); err = -EINVAL; break; &#125; return err;&#125;static int usb4604_probe(struct usb4604 *hub)&#123; struct device *dev = hub-&gt;dev; struct usb4604_platform_data *pdata = dev_get_platdata(dev); struct device_node *np = dev-&gt;of_node; int err; u32 mode = USB4604_MODE_HUB; if (pdata) &#123; hub-&gt;gpio_reset = pdata-&gt;gpio_reset; hub-&gt;mode = pdata-&gt;initial_mode; &#125; else if (np) &#123; hub-&gt;gpio_reset = of_get_named_gpio(np, \"reset-gpios\", 0); if (hub-&gt;gpio_reset == -EPROBE_DEFER) return -EPROBE_DEFER; of_property_read_u32(np, \"initial-mode\", &amp;mode); hub-&gt;mode = mode; &#125; if (gpio_is_valid(hub-&gt;gpio_reset)) &#123; err = devm_gpio_request_one(dev, hub-&gt;gpio_reset, GPIOF_OUT_INIT_LOW, \"usb4604 reset\"); if (err) &#123; dev_err(dev, \"unable to request GPIO %d as reset pin (%d)\\n\", hub-&gt;gpio_reset, err); return err; &#125; &#125; usb4604_switch_mode(hub, hub-&gt;mode); dev_info(dev, \"%s: probed in %s mode\\n\", __func__, (hub-&gt;mode == USB4604_MODE_HUB) ? \"hub\" : \"standby\"); return 0;&#125;static int usb4604_platform_probe(struct platform_device *pdev)&#123; struct usb4604 *hub; hub = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(struct usb4604), GFP_KERNEL); if (!hub) return -ENOMEM; hub-&gt;dev = &amp;pdev-&gt;dev; return usb4604_probe(hub);&#125;#ifdef CONFIG_OFstatic const struct of_device_id usb4604_of_match[] = &#123; &#123; .compatible = \"smsc,usb4604\", &#125;, &#123;&#125;,&#125;;MODULE_DEVICE_TABLE(of, usb4604_of_match);#endifstatic struct platform_driver usb4604_platform_driver = &#123; .driver = &#123; .name = USB4604_NAME, .of_match_table = of_match_ptr(usb4604_of_match), &#125;, .probe = usb4604_platform_probe,&#125;;static int __init usb4604_init(void)&#123; int err; err = platform_driver_register(&amp;usb4604_platform_driver); if (err != 0) pr_err(\"usb4604: Failed to register platform driver: %d\\n\", err); return 0;&#125;module_init(usb4604_init);static void __exit usb4604_exit(void)&#123; platform_driver_unregister(&amp;usb4604_platform_driver);&#125;module_exit(usb4604_exit);MODULE_DESCRIPTION(\"USB4604 USB HUB driver\");MODULE_LICENSE(\"GPL\"); 2.4 USB4604驱动头文件枚举usb模式。1234567891011121314151617#ifndef __USB4604_H__#define __USB4604_H__#define USB4604_NAME \"usb4604\"enum usb4604_mode &#123; USB4604_MODE_UNKNOWN = 1, USB4604_MODE_HUB, USB4604_MODE_STANDBY,&#125;;struct usb4604_platform_data &#123; enum usb4604_mode initial_mode; int gpio_reset;&#125;;#endif 2.5 设备树头文件提供usb-hub的工作模式宏。1234567#ifndef _DT_BINDINGS_USB4604#define _DT_BINDINGS_USB4604#define USB4604_MODE_UNKNOWN 1#define USB4604_MODE_HUB 2#define USB4604_MODE_STANDBY 3#endif 2.6 DM9621驱动加入内核进入配置界面：1make menuconfig 将DM9621驱动加入内核 2.7 USB4604驱动加入内核将USB4604驱动加入内核 2.8 重新编译、烧写、测试 编译： 12make uImage LOADADDR=0x40008000 make dtbs 烧写：在开发板uboot界面输入： 1dnw 0x40600000;dnw 0x41000000;dnw 0x42000000 在Ubuntu依次输入：123sudo ./dnw /work/linux-4.13.9/arch/arm/boot/uImagesudo ./dnw /work/ramdisk/ramdisk.imgsudo ./dnw /work/linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dtb 最后再开发板启动：123sudo ./dnw /work/linux-4.13.9/arch/arm/boot/uImagesudo ./dnw /work/ramdisk/ramdisk.imgsudo ./dnw /work/linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dtb 测试：设置网卡ip1ifconfig eth0 192.168.1.225 ping主机：1ping -c4 192.168.1.226 3.NFS启动这里的根文件系统直接使用的是韦老大第三期项目视频的根文件系统，之前在JZ2440上也能运行，就直接拿来用了。此外修改了根文件系统、的etc/init.d/rcS，加入了ifconfig eth0 192.168.1.225设置静态IP。 设置uboot参数：1setenv bootargs &apos;root=/dev/nfs rw nfsroot=192.168.1.226:/work/fs_mini_mdev_new ethmac=00:40:5c:26:0a:5b ip=192.168.1.225:192.168.1.226:192.168.1.1:255.255.255.0::eth0:off console=ttySAC0,115200 init=/linuxrc&apos;; saveenv 开发板下载及启动：1dnw 0x40000000;dnw 0x42000000;bootm 0x40000000 - 0x42000000 Ubuntu下载：12sudo ./dnw /work/linux-4.13.9/arch/arm/boot/uImagesudo ./dnw /work/linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dtb NFS启动效果： 4.心得感谢摩斯电码的博客，很多的参考他的，节约了很多时间。 下一步移植完SD卡的驱动，将uboot和内核都放在SD卡上，根文件系统挂在nfs上，就可以搞LCD了。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"Exynos4412","slug":"Exynos4412","permalink":"http://yoursite.com/tags/Exynos4412/"},{"name":"网卡驱动","slug":"网卡驱动","permalink":"http://yoursite.com/tags/网卡驱动/"},{"name":"NFS","slug":"NFS","permalink":"http://yoursite.com/tags/NFS/"}]},{"title":"Exynos4412——内核移植","date":"2017-10-26T09:48:19.000Z","path":"2017/10/26/Exynos4412——内核移植/","text":"Exynos 4412移植最新的Kernel-4.13.9。话说最近应该不会接触AM437x了，原因有多种，但学习不能停。手头还有买来没开过几次机的Tiny4412，本想买来学Android驱动的。Exynos4412与S3C2240差别相对AM437x小很多，因此过渡应该会更顺滑一点。要学习的还很多，进度有点慢，先在板子上跑起Linux再说吧。 1.设置交叉编译工具链使用的交叉编译工具链是：arm-none-linux-gnueabi-gcc （gcc version 4.8.3 20140320）下载好后，放在Ubuntu中，解压：1tar xjf arm-2014.05-29-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 记下交叉编译工具链的位置：/work/arm-2014.05/bin修改环境变量：1sudo vim /etc/environment 添加交叉编译工具链的路径：1PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/work/arm-2014.05/bin&quot; 更新环境变量：1source /etc/environment 检测：1arm-none-linux-gnueabi-gcc -v 一些关于gcc的扩充资料 2.修改、编译uboot开始的时候使用的是Tiny4412光盘的uboot，但后续的做完了才发现不行。原来是友善的tiny4412标准版有新旧之分，差别就是更换了不同eMMC，所以导致了有些没有更新eMMC控制器配置的uboot无法启动。因此下了新版的uboot_tiny4412_0929.tar.gz即可。参考链接 目前首先需要实现如下功能：用u-boot引导uImage或者zImage，同时将设备信息以设备树的形式传递给Linux内核，而根文件系统以ramdisk的形式传递给内核，因为目前SD卡驱动、eMMC驱动和usb网卡驱动都没有移植。 2.1 关闭MMU1vim include/configs/tiny4412.h 将#define CONFIG_ENABLE_MMU改为#undef CONFIG_ENABLE_MMU; 2.2 修改u-boot的链接地址1vim board/samsung/tiny4412/config.mk 将CONFIG_SYS_TEXT_BASE = 0xc3e00000修改为CONFIG_SYS_TEXT_BASE = 0x43e00000; 2.3 使uboot可以引导uImage1vim common/cmd_bootm.c ①在boot_os_fn *boot_fn;后添加：1int iszImage = 0; ②在images.legacy_hdr_valid = 1;后添加：1iszImage = 1; ③修改12images.os.os = hdr-&gt;ih_os;images.ep = image_get_ep (&amp;images.legacy_hdr_os_copy); 为1234if(iszImage) &#123; images.os.os = hdr-&gt;ih_os; images.ep = image_get_ep (&amp;images.legacy_hdr_os_copy); &#125; 2.4 支持设备树1vim include/configs/tiny4412.h 添加如下两个宏：12#define CONFIG_OF_LIBFDT#define CONFIG_SYS_BOOTMAPSZ (20 &lt;&lt; 20) 2.5 修改uboot的Makefile将原来的：123ifeq ($(HOSTARCH),$(ARCH))CROSS_COMPILE ?=endif 改为123ifeq ($(ARCH),arm)CROSS_COMPILE ?=/work/arm-2014.05/bin/arm-none-linux-gnueabi-endif 2.6 编译uboot123make distcleanmake tiny4412_configmake 3.移植、编译内核3.1 下载最新内核下载的当前最新的内核Kernel-4.13.9。解压12xz -d linux-4.13.9.tar.xztar xf linux-4.13.9.tar 3.2 修改Makefile将12ARCH ?= $(SUBARCH)CROSS_COMPILE ?= $(CONFIG_CROSS_COMPILE:&quot;%&quot;=%) 改为12ARCH ?= armCROSS_COMPILE ?= /work/arm-2014.05/bin/arm-none-linux-gnueabi- 3.3 修改设备树文件1vim arch/arm/boot/dts/exynos4412-tiny4412.dts 在stdout-path = &amp;serial_0;添加启动参数：1bootargs = &quot;root=/dev/ram0 rw rootfstype=ext4 console=ttySAC0,115200 init=/linuxrc earlyprintk&quot;; 将sdhci_2节点下的1status = &quot;okay&quot;; 改为:1status = &quot;disabled&quot;; 3.4 编译内核Kernel-4.13.9对Exynos 4412支持还不错，直接就有配置文件，使用即可。123make distcleanmake ARCH=arm exynos_defconfigmake uImage LOADADDR=0x40008000 这里实测出现错误，显示找不到mkimage。mkimage是/work/uboot_tiny4412_0929/tools里面的，加入环境变量即可。解决参考 1sudo vim /etc/bash.bashrc 加入:1export PATH=/work/uboot_tiny4412_0929/tools:$PATH 更新:1source /etc/bash.bashrc 重新编译：1make uImage LOADADDR=0x40008000 生成uImage在arch/arm/boot。 3.5 编译设备树文件1make dtbs 生成exynos4412-tiny4412.dtb在arch/arm/boot/dts/。 4.下载到开发板4.1 准备SD卡制作SD卡的工具在uboot_tiny4412_0929里面，先编译下。12cd sd_fusemake 插上SD卡，查看当前SD卡挂载位置。1sudo fdisk -l 我的是/dev/sdb。 4.2 制作SD卡，烧uboot12cd tiny4412./sd_fusing.sh /dev/sdb 制作好了，插上开发板，选择SD卡启动，在串口上即可有打印信息。 4.3 烧写内核、根文件系统、设备树文件这里的根文件系统用的网友做好的ramdisk镜像由于tiny4412的uboot目前还不支持usb网卡，只能使用dnw来下载，并且tiny4412的u-boot中已经自带了dnw命令了，Ubuntu上使用网友的dnw。 ①下载uImage在u-boot里执行下载uImage的命令:1dnw 0x40600000 (这个地址不唯一) 在Ubuntu中执行：1sudo ./dnw /work/linux-4.13.9/arch/arm/boot/uImage ②下载ramdisk在u-boot里执行下载uImage的命令:1dnw 0x41000000 (这个地址不唯一) 在开发机中执行：1sudo ./dnw /work/ramdisk/ramdisk.img ③下载设备树镜像在u-boot里执行下载uImage的命令:1dnw 0x42000000 (这个地址不唯一) 在开发机中执行：1sudo ./dnw /work/linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dtb 4.4 启动开发板继续输入1bootm 0x40600000 0x41000000 0x42000000 不要重启，现在数据都在RAM里面的，掉电就没了。 5.实际效果 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Exynos4412","slug":"Exynos4412","permalink":"http://yoursite.com/tags/Exynos4412/"},{"name":"内核移植","slug":"内核移植","permalink":"http://yoursite.com/tags/内核移植/"}]},{"title":"QT应用设计——HexoBlogClient","date":"2017-10-12T01:29:04.000Z","path":"2017/10/12/QT应用设计——HexoBlogClient/","text":"本文主要记录采用QT开发的hexo博客管理客户端——HexoBlogClient。 0.初衷做嵌入式这行，如果做界面，几乎只有两个选择：Qt和Android。所以感觉学习下Qt还是很有必要的，顺便回忆点C++。 国庆节前打了鸡血一样疯狂的学了一周Qt，学了后想做个简单的东西练练手。所做的东西一定要是能解决我的某些痛点的，这样才会让我动力去做。 思来想去，每次写博客，需要打开Git Bash，输入创建命令、构建、本地预览、发布、备份……虽说之前GitHub+Hexo搭建及优化——5-5脚本自动化中采用了bat脚本一键完成清理、构建、发布这些操作，但每次要打开Git Bash，进入指定路径，输入脚本运行，还是挺麻烦的。 So，搞个博客客户端一键操作似乎更方便点 = = 1.设计思路写博客，我一般的完整步骤是： 新建博客-&gt;编辑博客-&gt;如果有图片需上传到图床、有代码需上传到GitHub-&gt;清理原来博客的生成的静态页面-&gt;生成新的静态页面-&gt;本地预览-&gt;根据预览效果继续编辑-&gt;满意后再次清理、生成静态页面-&gt;发布博客(GitHub和Coding)-&gt;备份本地的所有源文件到Coding私有库-&gt;访问博客查看。 因此博客客户端首先应该很流畅的实现上面的工作流，其次才是锦上添花的添加其它功能。 a:本地界面 a1:打开这个客户端，首先这个页面应该显示出我的文章列表； a2:实现新建博客文章、编辑博客文章等对文章的常用操作； a3:实现常用的清理、生成、预览、发布、备份等功能； b:图床界面 b1:博客文章采用的Markdwon格式，图片需要先保存到图床，然后引用链接。现在的图床方案是上传到七牛。 b2:在这个界面，需要将图片 通过拖拽/资源管理器 的方式上传到七牛空间，并且按照当前的日期，指定路径格式，如：image/blog/170915/1.jpg； b3:返回链接地址； b4:能够管理已上传的图片(比如跳转到七牛的存储空间)； c:代码界面 c1:显示出本地代码，通过拖拽/资源管理器 的方式增减/编辑代码； c2:上传到GitHub; c3:打开GitHub、Coding； d:设置界面 d1:设置相关的路径，比如博客路径； d2:设置图床的配置文件； e:关于界面 e1:版本、版权信息； e2:主页跳转； e3:获取指定文件； f:其它 f1:修改应用图标 2.程序代码设计创建好Qt工程后，工程项目下会有四类文件：pro工程文件、头文件、源文件、界面文件。直接打开界面文件的mainwindow.ui,在上面拖动控件，实现界面的设计，再在源文件mainwindow.cpp编辑代码，完成功能的设计。 2.1 修改应用程序图标先做个简单的，修改应用程序的图标。图标显示有两个，一个是打开程序后，在程序左上角显示的图标，一个是在资源管理显示代表该程序的图标。 首先要准备个ico图片文件，然后把图片加入到工程项目中。在项目中，点击该工程，右键，添加新文件。选择Qt的Qt Resource File，名字写image，之后就会在工程项目生成一个资源文件：image.qrc。再选中image.qrc右键，添加现有文件，选择准备的hexoblogclient.ico图标，这样就将图标添加进了工程。 a:修改程序左上角图标修改源代码mainwindow.cpp，设置打开程序后左上角的图标和显示的文字： 123456789MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); this-&gt;setWindowIcon(QIcon(\"://image/hexoblogclient.ico\"));//设置图标 this-&gt;setWindowTitle(\"HexoBlogClient\");//设置名字&#125; b:修改应用程序图标在工程目录下创建一个appicon.rc文件，文件内容如下： 1IDI_ICON1 ICON DISCARDABLE &quot;image/hexoblogclient.ico&quot; 再在HexoBlogClient.pro文件添加如下代码：12RC_FILE += \\ appicon.rc 此时重新编译，应用程序图标也变成了ico图案。 2.2 本地界面 界面设计 使用tabWidget控件作为每个界面的容器； 使用treeView控件显示文章列表； 使用pushButton控件作为按键； 使用label控件显示当前文章总数和时间； 效果如下： 功能设计实例化一个QFileSystemModel类，筛选出*.md文件，指定文件路径，隐藏其它Column（也就是只显示文件名，不显示大小、日期等信息），然后以日期为标准，降序排列，最后将信息显示到treeView上。123456789101112131415QFileSystemModel *model1 = new QFileSystemModel();model1-&gt;setRootPath(\"E:/hceng blog/blog/source/_posts\");QStringList nameFilter1;nameFilter1 &lt;&lt; \"*.md\";model1-&gt;setNameFilterDisables(false);model1-&gt;setNameFilters(nameFilter1);//筛选文件类型ui-&gt;treeView1-&gt;setModel(model1);ui-&gt;treeView1-&gt;setRootIndex(model1-&gt;index(\"E:/hceng blog/blog/source/_posts\"));//指定路径ui-&gt;treeView1-&gt;setColumnHidden(1,true);//隐藏显示ui-&gt;treeView1-&gt;setColumnHidden(2,true);ui-&gt;treeView1-&gt;setColumnHidden(3,true);ui-&gt;treeView1-&gt;setSortingEnabled(true);//使能排序ui-&gt;treeView1-&gt;sortByColumn(3, Qt::DescendingOrder);//以时间作为依据排序；升序：Qt::AscendingOrder 降序：Qt::DescendingOrder 接下来是8个功能按键，很多是直接调用的bat脚本实现功能的。 首先是“新建”按钮，获取输入的标题，然后判断是否为空以及是否按下“确定”，这里直接创建了个新的Markdwon文件，然后写入基本的模板格式。12345678910111213141516171819202122232425262728293031323334353637383940void MainWindow::on_pushButton11_clicked()&#123; bool ok; QString text = QInputDialog::getText(this, tr(\"新建博客\"),tr(\"请输入标题:\"), QLineEdit::Normal,NULL, &amp;ok); if ( ok &amp;&amp; !text.isEmpty() ) &#123; /* --- title: \"格式\" date:2017-10-11 15:11:33 tags: - xx toc: true --- summary &lt;!-- more --&gt; */ QDateTime time = QDateTime::currentDateTime(); QString strTime = time.toString(\"yyyy-MM-dd hh:mm:ss \"); QFile namefile(\"E:\\\\hceng blog\\\\blog\\\\source\\\\_posts\\\\\"+text+\".md\"); //qDebug()&lt;&lt;strTime; if (!namefile.open(QIODevice::WriteOnly | QIODevice::Truncate)) return; QTextStream out(&amp;namefile); out&lt;&lt;\"---\"&lt;&lt;'\\n'&lt;&lt;\"title: \\\"\"+text+\"\\\"\"&lt;&lt;'\\n'&lt;&lt;\"date: \"&lt;&lt;strTime&lt;&lt;'\\n'; out&lt;&lt;\"tags: \"&lt;&lt;'\\n'&lt;&lt;\" - xx\"&lt;&lt;'\\n'&lt;&lt;\"toc: true\"&lt;&lt;'\\n'&lt;&lt;\"---\"&lt;&lt;'\\n'; out&lt;&lt;\"summary\"&lt;&lt;'\\n'&lt;&lt;\"&lt;!-- more --&gt;\"&lt;&lt;'\\n'; namefile.close(); &#125; else if(ok &amp;&amp; text.isEmpty() ) &#123; QMessageBox::information(this,\"信息\",\"请输入标题.\"); &#125; else &#123; return; &#125;&#125; 然后是“编辑”按键，先获得当前treeView选择的文件，再通过桌面服务使用默认程序打开该文件。12345678910void MainWindow::on_pushButton12_clicked()&#123; QString currentFilePath = model1-&gt;filePath(ui-&gt;treeView1-&gt;currentIndex()); if (!currentFilePath.isEmpty()) &#123; qDebug()&lt;&lt;\"file://\"+currentFilePath; QDesktopServices::openUrl(QUrl(\"file:///\"+currentFilePath)); //QDesktopServices::openUrl(QUrl(\"file:///E:/hceng blog/blog/source/_posts/测试文章.md\")); &#125;&#125; “清理&amp;重构”按键调用的脚本执行，等同执行的hexo c &amp; hexo g，最后使用QMessageBox显示截取的部分数据；调用cmd.exe的时候，在纠结使用startDetached还是start，前者是完全独立的启动，后者类似调用。执行脚本需要一定时间，通常都是数秒以上，使用start会出现未响应的情况，但如果使用startDetached可能会多次按该按键，导致启动多次，不知道什么时候完成。最后还是选的start。 123456789101112131415161718192021222324void MainWindow::on_pushButton13_clicked()&#123; ui-&gt;pushButton13-&gt;setText(\"请等待……\"); QTime dieTime = QTime::currentTime().addMSecs(100);//延时0.1s while( QTime::currentTime() &lt; dieTime ) QCoreApplication::processEvents(QEventLoop::AllEvents, 100); QProcess *process=new QProcess(this); //process-&gt;startDetached(\"cmd.exe\", QStringList() &lt;&lt; \"/c\" &lt;&lt; \"D:\\\\git\\\\qt\\\\HexoBlogClient\\\\bat\\\\clean_creat.bat\"); process-&gt;start(\"cmd.exe\", QStringList() &lt;&lt; \"/c\" &lt;&lt; \"D:\\\\git\\\\qt\\\\HexoBlogClient\\\\bat\\\\clean_creat.bat\"); process-&gt;waitForFinished(); ui-&gt;pushButton13-&gt;setText(\"清理&amp;&amp;重构\"); QString strTemp=QString::fromLocal8Bit(process-&gt;readAllStandardOutput()); //strTemp = strTemp.section('O',-1,-1); strTemp = strTemp.section('l',-2,-1); qDebug()&lt;&lt;strTemp; QMessageBox testMassage; testMassage.setText(strTemp); testMassage.exec();&#125; “预览/停止”按键也是调用的脚本的命令：hexo s，关闭的时候通过读取进程列表，关闭指定端口的进程。实测中，有一定概率误关掉整个浏览器。1234567891011121314151617181920212223242526void MainWindow::on_pushButton14_clicked()&#123; if(pushButton14Flag == 0) &#123; QProcess *process=new QProcess(this); process-&gt;start(\"cmd.exe\", QStringList() &lt;&lt; \"/c\" &lt;&lt; \"D:\\\\git\\\\qt\\\\HexoBlogClient\\\\bat\\\\view.bat\"); process-&gt;waitForFinished(); /* QTime dieTime = QTime::currentTime().addMSecs(1000);//延时1s while( QTime::currentTime() &lt; dieTime ) QCoreApplication::processEvents(QEventLoop::AllEvents, 100); */ QDesktopServices::openUrl(QUrl(\"http://localhost:4000/\")); ui-&gt;pushButton14-&gt;setText(\"停止\"); pushButton14Flag = 1; &#125; else &#123; QProcess *process=new QProcess(this); process-&gt;start(\"cmd.exe\", QStringList() &lt;&lt; \"/c\" &lt;&lt; \"D:\\\\git\\\\qt\\\\HexoBlogClient\\\\bat\\\\stop_view.bat\"); process-&gt;waitForFinished(); ui-&gt;pushButton14-&gt;setText(\"预览\"); pushButton14Flag = 0; &#125;&#125; “发布”也比较花时间，也是调用脚本的命令：hexo d1234567891011121314void MainWindow::on_pushButton15_clicked()&#123; ui-&gt;pushButton15-&gt;setText(\"请等待……\"); QTime dieTime = QTime::currentTime().addMSecs(100);//延时0.1s while( QTime::currentTime() &lt; dieTime ) QCoreApplication::processEvents(QEventLoop::AllEvents, 100); QProcess *process=new QProcess(this); process-&gt;start(\"cmd.exe\", QStringList() &lt;&lt; \"/c\" &lt;&lt; \"D:\\\\git\\\\qt\\\\HexoBlogClient\\\\bat\\\\deploy.bat\"); process-&gt;waitForFinished(); ui-&gt;pushButton15-&gt;setText(\"发布\");&#125; “备份”是将整个工程上传到Coding的私有库，原理还是git。1234567891011121314void MainWindow::on_pushButton16_clicked()&#123; ui-&gt;pushButton16-&gt;setText(\"请等待……\"); QTime dieTime = QTime::currentTime().addMSecs(100);//延时0.1s while( QTime::currentTime() &lt; dieTime ) QCoreApplication::processEvents(QEventLoop::AllEvents, 100); QProcess *process=new QProcess(this); process-&gt;start(\"cmd.exe\", QStringList() &lt;&lt; \"/c\" &lt;&lt; \"D:\\\\git\\\\qt\\\\HexoBlogClient\\\\bat\\\\bak.bat\"); process-&gt;waitForFinished(); ui-&gt;pushButton16-&gt;setText(\"备份\");&#125; “发布&amp;备份”是前面两个的结合。1234567891011121314void MainWindow::on_pushButton17_clicked()&#123; ui-&gt;pushButton17-&gt;setText(\"请等待……\"); QTime dieTime = QTime::currentTime().addMSecs(100);//延时0.1s while( QTime::currentTime() &lt; dieTime ) QCoreApplication::processEvents(QEventLoop::AllEvents, 100); QProcess *process=new QProcess(this); process-&gt;start(\"cmd.exe\", QStringList() &lt;&lt; \"/c\" &lt;&lt; \"D:\\\\git\\\\qt\\\\HexoBlogClient\\\\bat\\\\deploy_bak.bat\"); process-&gt;waitForFinished(); ui-&gt;pushButton17-&gt;setText(\"发布&amp;&amp;备份\");&#125; “访问”就仅仅是打开博客链接，不用再在浏览器里翻了。1234void MainWindow::on_pushButton18_clicked()&#123; QDesktopServices::openUrl(QUrl(\"https://hceng.cn/\"));&#125; 最下面的统计文件数量和显示当前时间，是个定时任务，每秒都刷新这两个label。文件数量是获取博客文章路径的fileInfoList,然后获得文件数量，再转换成字符类型追加到label中。1234//timeshowQTimer *timer = new QTimer(this);connect(timer,SIGNAL(timeout()),this,SLOT(timerUpdate()));timer-&gt;start(1000); 123456789101112131415161718void MainWindow::timerUpdate(void)&#123; QDateTime time = QDateTime::currentDateTime(); QString strTime = time.toString(\"yyyy-MM-dd dddd hh:mm:ss \"); ui-&gt;label1-&gt;setText(strTime); QDir *dir=new QDir(\"E:/hceng blog/blog/source/_posts\"); QStringList filter; filter&lt;&lt;\"*.md\"; dir-&gt;setNameFilters(filter); //QList&lt;QFileInfo&gt; *fileInfo=new QList&lt;QFileInfo&gt;(dir-&gt;entryInfoList(filter)); QFileInfoList fileInfoList=dir-&gt;entryInfoList(filter);//在qt中有typedef QList&lt;QFileInfo&gt; QFileInfoList;所以两者等价 QString fileCount = QString::number(fileInfoList.count(), 10); QString strCount = \"文章总数：\"; strCount.append(fileCount); ui-&gt;label2-&gt;setText(strCount);&#125; 2.3 图床界面2.4 代码界面2.5 设置界面2.6 关于界面3.计划最近有点忙/懒，图床部分，看了下，要研究下七牛的API，暂时没那个精力。试着用了下客户端，还是比较满意的，不用打开资源管理器和git-bash了，上传图片和代码，还是和原来一样，觉得不流畅，后面有时间，有精力了再研究。后面最想做的有两个： 实现配置文件的读取/写入； 获取服务器指定图片； 加上国庆，话说有半个月没摸驱动了，Qt暂停下，先玩玩驱动。目前只完成了第一个主界面，后面的几乎没做，如果有志同道合的朋友可以交流下，一起完成。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"QT","slug":"QT","permalink":"http://yoursite.com/tags/QT/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Photoshop基础2——工具","date":"2017-09-23T09:29:23.000Z","path":"2017/09/23/Photoshop基础2——工具/","text":"本文主要记录Photoshop相关理论基础第二部分：工具。 1.修饰工具可用于局部修复。 1.1 污点修复工具 污点修复画笔(去斑) 修复画笔(取代图章工具,色彩完好) 修补(无缝复制另外一块区域,亮度色彩融合最佳) 红眼(非常方便,大小图象都可适用) 1.2 图章工具 仿制图章：用得较少，一般用 修复画笔 代替； 图案图章：1.定义图章：选择区域→编辑→定义图案；2.生成图章：滤镜→图案生成器→选择区域→生成（不满意点击再次生成）;3.使用图章：填充图案，选择区域，CTRL+G或者使用油漆桶填充图案; 1.3 橡皮擦工具 背景橡皮擦：智能擦除背景颜色,效果类似抠图； 魔术橡皮擦：魔术棒+橡皮擦工具的使用； 1.4 模糊工具 模糊工具：选中区域变模糊； 锐化工具：非常谨慎的使用，非常容易出现杂色； 涂抹工具：效果不好，一般选择滤镜→液化实现效果； 1.5 减淡工具 减淡工具：提升亮度，减少颜色（改变肤色），类似滤色效果； 加深工具：降低亮度，加重颜色（显瘦）； 海棉工具：有加色和减色模式，色相不变，增加饱和度，减色相反； 2.绘画工具可用于局部修饰。 2.1 画笔工具画笔工具的核心概念:模式选择 模式可以分为6组： A组:正常 溶解 背后 清除 B组:变暗 正片叠低 颜色加深 线性加深 深色 C组:变亮 滤色 颜色减淡 线性减淡 浅色 注:b组和c组是数值对立的 D组:叠加 柔光 强光 亮光 线性光 点光 实色混合 注:都是光,变化不大,很微妙,有共同点 E组:差值 排除 减去 划分 注:两者是反值;负片效果 F组:色相 饱和度 颜色 明度 注:基于人眼的视觉效果HSB模式,多了一个颜色模式 模式解释 A组: 溶解：根据画笔硬度画出 扩散溶解效果，硬度越高溶解越少，硬度越低溶解越大（越虚）； 背后：后画的笔画是画在上一笔的背后,即下一层；表示被当住了画后面的；两次绘画不同颜色的画笔即可看出效果； 清除：类似橡皮擦工具； 背后的使用特点：1.使用背后的前提条件是 必须同一个图层之中存在透明区域（用魔术棒选中删了），否则无法显示，因为是在像素之后绘画；2.使用背后，可以很容易的在后面做出光晕等好看的效果，不会损害前面的象素； B组 vs C组: 变暗：以前景色为基础，前景色与画面中笔触的颜色作为背景色做对比，画面中比前景色亮的颜色都变成前景色,比前景色暗的颜色不发生变化;即以一种颜色作为整个画面最亮的色，降低了整个画面亮度； 变亮：与变暗相反，所有比前景色亮的都不变,与前景色暗的地方都变成前景色； 正片叠底：颜色加深，对色调进行修改。是RGB模式和CMYK模式中加色与减色的应用，这里对应CMYK的减色模式，即用RGB叠加，越加越暗，直到黑色； 滤色：颜色提亮，和正片叠底相反，对应加色模式，即用RGB颜色叠加，越加越亮，直到白色；混和技巧:加亮时用滤色，变暗时用正片叠底；滤色用黑色前景时无效果，正片叠底时用白色无效果（即不允许存在）;照片去黑色背景或白色背景时直接使用（在图层中）滤色或正片叠底；参考前面的：Photoshop基础1——色彩 颜色加深：查看每个通道中的颜色信息，增加对比度使基色变暗以反映混合色，如果与白色混合的话将不会产生变化，”颜色加深”模式创建的效果和“正片叠底”模式创建的效果比较类似; 颜色减淡：查看每个通道中的颜色信息，通过减小对比度使基色变亮以反映混合色，与黑色混合则不发生变化。除了指定在这个模式的层上边缘区域更尖锐，以及在这个模式下着色的笔划之外，“颜色减淡”模式类似于“滤色”模式创建的效果； 线性加深：查看每个通道中的颜色信息通过减小亮度使“基色”变暗以反映混合色，如果“混合色”与“基色”上的白色混合后将不会产生变化； 线性减淡：查看每个通道中的颜色信息通过增加亮度使“基色”变亮以反映混合色，如果“混合色”与“基色”上的黑色混合后将不会产生变化； 深色：比较混合色和基色的所有通道值的总和并显示值较小的颜色，即较深色的颜色。“深色”不会生成第三种颜色（可以通过“变暗”混合获得），因为它将从基色和混合色中选择最小的通道值来创建结果颜色； 浅色：和深色相反，显示较浅的颜色； D组: 叠加：亮度不变,颜色重叠； 柔光：屏蔽中性灰度,颜色取中间值； 线性光：光线不随距离减弱； 点光：光线随着距离逐渐减弱； E组: 差值：负片效果，使用画笔时直接转换为负片（所画为互补色=色环上对面的颜色）； 排除：也是负片效果,只是淡一些； F组: 色相：锁定前景色HSB模式中颜色的值，即H值，只涂抹颜色;与S、B无关； 饱和度：同上只锁定饱和度S； 亮度：同上只锁定亮度B； 颜色：给黑白片着色使用，亮度不变只改变颜色和饱和度，如果用 正常 的话会把亮度饱和也改变了（黑白图无色相，无饱和度）； 2.2 替换颜色工具比抽出更改更方便，选择相应的模式：色相、饱和度、明度、颜色，可以方便的替换颜色,不用担心边缘被更改； 2.3 历史记录画笔配合历史记录调板使用，做了特效后部分恢复，局部修饰；裁剪时部分无法使用历史绘画笔时，重新定义记录状态（把画笔位置放在裁切位置就可以用了）; 2.4 历史记录艺术画笔在恢复时增加笔触效果，菜单下面可以选择样式与模式，可以做出很有特色的艺术效果； 2.5 渐变工具有5种类型：线性渐变、径向渐变、锥性渐变、对称渐变、菱形渐变； 上面表示透明度，下面表示颜色。可以任意添加油漆桶，两个油漆桶之间的菱形表示过渡位置； 渐变编辑器里调节渐变类型时可以选择杂色渐变，同时可以选择限制色彩范围；填充时并且可以选择混合模式，如在背后模式中选择锥形渐变可以画出强烈的光照效果；油漆桶可以选择图案填充模式； 参考资料：Photoshop 用户指南——工具库 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"设计","slug":"设计","permalink":"http://yoursite.com/tags/设计/"},{"name":"Photoshop","slug":"Photoshop","permalink":"http://yoursite.com/tags/Photoshop/"}]},{"title":"Photoshop基础1——色彩","date":"2017-09-15T09:29:23.000Z","path":"2017/09/15/Photoshop基础1——色彩/","text":"本文主要记录Photoshop相关理论基础第一部分：色彩。 又开始折腾了，在驱动的世界稍微能喘上口气，就又闲不住了。最近兼职了当了下美工，又燃起了对设计的热情，抽空余时间，学下设计基础。 1.色彩模式色彩模式常用的有四种： ①HSB:基于人眼视觉的颜色模式；②RGB:基于光色的颜色模式，是加色模式，两者组合变亮；③CMYK:基于印刷颜料的颜色模式，是减色模式，两者组合变暗；④Lab:基于人对颜色的感觉，与设备无关，色域宽阔； （1） HSB： (色相H(Hue)：在0~360°的标准色环上，按照角度值标识。比如红是0°、橙色是30°等，黑白无色相; 饱和度S(Saturation)：是指颜色的强度或纯度。饱和度表示色相中彩色成分所占的比例，用从0%(灰色)~100%(完全饱和)的百分比来度量; 亮度B(Brightness)：是颜色的明暗程度，通常是从0(暗)~100%(亮)的百分比来度量的; （2）RGB： R(Red)：0~255阶,一共256阶色; G(Green)：0~255阶,一共256阶色; B(Blue)：0~255阶,一共256阶色;其中：白色：R G B:255 255 255；黑色：R G B:0 0 0； （3）CMYK： C(Cyan青色)：0~100%; M(Magenta品红色)：0~100%; Y(Yellow黄色)：0~100%; K(Key Plate黑墨印刷版)：0~100%;CMKK放在一起可以综合出其他的色彩，前3种都是0%的时候印刷成无色,即白色；都为100%的时候印不出纯黑色，工艺达不到，有杂质,所以加入K黑色用来印刷纯黑色; （4）Lab： L(Luminosity亮度)：0~100%; a：表示从洋红色至绿色的范围，+127~-128; b：表示从黄色至蓝色的范围，+127~-128;当a=0、b=0时显示灰色,同时L=100时为白色,L=0时为黑色; 在表达色彩范围上，最全的是Lab模式，其次是RGB模式，最窄的是CMYK模式。也就是说Lab模式所定义的色彩最多，且与光线及设备无关，并且处理速度与RGB模式同样快，比CMYK模式快数倍。因此，可放心大胆的在图像编辑中使用Lab模式，而且，Lab模式保证在转换成CMYK模式时色彩最少丢失或被替代。因此，从理论上讲最佳避免色彩损失的方法是：应用Lab模式编辑图像，再转换CMYK模式打印。 2.加色/减色模式在RGB模式中，如果RGB的值为（0,0,0），那么就是黑色，如果是（255,255,255）就是白色。这很容易理解，试想一下一个黑屋子里什么灯都不打开，就是漆黑一片；相反如果红灯、绿灯、蓝灯都开到最亮，那么屋子里就是一片明亮。 而在CMYK模式中，如果在印刷的时候，把CMYK的值设为（0,0,0,0），那么就等于什么颜料都没上，纸还是白色的；如果把油墨设为（100%,100%,100%,100%），所有颜料都浓浓地刷上一遍，印出来的就是黑色。由于颜色来自于光线，那么黑色自然就是什么颜色都没有，而白色则包含了很多种颜色。 因此，RGB模式被称之为加色模式，CMYK被被称之为减色模式。 之所以会有这两种模式，还是因为它们对应的颜色表现媒介的不同。在加色模式中，颜色是由光线直接照射产生的，所以只要有光线叠加，颜色就会越来越亮，最终成为白色。而减色模式中，颜色是通过颜料吸收光线来产生的，要表现一种颜色，就要想办法把光线中其他的颜色过滤掉，也就是减掉，如果什么颜料都不上，光线就被全部反射，看到的依然是白光。 那么加色模式和减色模式到底有什么用？ 简单来讲，加色模式就是使颜色变亮，减色模式使颜色变暗。 在PS中，经常用到的加色和减色工具分别是滤色和正片叠底。例如，想要去掉一张图片的黑色背景效果，就可以将图层混合模式设为滤色，相反，如果要去掉白色背景，则选择正片叠底。另外，也可以将画笔工具设为加色和减色属性，对图片进行局部的修饰。这样做的好处是，避免了做选区的大量工作，而且修饰起来比做选区要更加精准和美观。 3.分辨率PS中，分辨的单位有 像素/英寸 和 像素/厘米 ，一般默认使用前者。 一般显示器采用72DPI,印刷品采用300DPI。 分辨率越高画面放大越清晰，但是图像文件大小也越大；可以通过 重新采样 改变原始分辨率，当这种方式是通过算法来扩展像素，就目前来看，大多数情况都不太好。 重新采样的算法主要有：邻近、两次线性、两次立方。这三个算法参考周围的像素依次增多，因此理论上两次立方的效果是最好的。但当图片比较简单时，选择邻进，会让线条更加清晰，不发虚，相对效果更好。 参考资料：Photoshop 用户指南——颜色模式 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"设计","slug":"设计","permalink":"http://yoursite.com/tags/设计/"},{"name":"Photoshop","slug":"Photoshop","permalink":"http://yoursite.com/tags/Photoshop/"}]},{"title":"AM437x——I2C驱动","date":"2017-09-11T06:30:36.000Z","path":"2017/09/11/AM437x——I2C驱动/","text":"记录AM437x的I2C适配器驱动和I2C设备驱动，以及去除am437x EEPROM验证ID功能。 1.I2C驱动在Linux中，I2C驱动有I2C适配器驱动（就是SOC的I2C控制器驱动）和I2C设备驱动（就是I2C设备，比如AT24C256）。 本次写驱动的过程，先是利用内核自带的I2C适配器驱动写了I2C设备驱动，待I2C设备驱动验证好了，再写的I2C适配器驱动。因此记录的顺序也是先是I2C设备驱动，再是I2C适配器驱动。 2.去除am437x EEPROM验证ID功能前面裸机的对EEPROM随意的测试读写，改变了里面的一些数据。Ti发布的SDK需要在不更改代码的情况下运行在Ti不同的EVM上，所以Ti在代码中会添加对EVM板上EEPROM内部ID的判断。这就尴尬了，没人给我说过不能改啊 = = 。验证ID的数据被我改了，现在Uboot没法引导内核了。= = 没办法，要么改回EEPROM的数据，要么去除Uboot的验证，权衡后，选择了后者。通过查阅和测试，相关代码在：~/ti-processor-sdk-linux-am437x-evm-01.00.00.03/board-support/u-boot-2014.07+gitAUTOINC+fb6ab76dad-gfb6ab76/board/ti/am43xx/路径下的board.c和board.h。 修改原理是，屏蔽掉去读eeprom的数据，手动指定板子和版本信息。在read_eeprom()函数中,注释掉原来的验证，在后面的strncpy()函数中指定板子信息。修改后该部分代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * Read header information from EEPROM into global structure. */static int read_eeprom(struct am43xx_board_id *header)&#123;#if 0 /* Check if baseboard eeprom is available */ if (i2c_probe(CONFIG_SYS_I2C_EEPROM_ADDR)) &#123; printf(\"Could not probe the EEPROM at 0x%x\\n\", CONFIG_SYS_I2C_EEPROM_ADDR); return -ENODEV; &#125; /* read the eeprom using i2c */ if (i2c_read(CONFIG_SYS_I2C_EEPROM_ADDR, 0, 2, (uchar *)header, sizeof(struct am43xx_board_id))) &#123; printf(\"Could not read the EEPROM\\n\"); return -EIO; &#125; if (header-&gt;magic != 0xEE3355AA) &#123; /* * read the eeprom using i2c again, * but use only a 1 byte address */ if (i2c_read(CONFIG_SYS_I2C_EEPROM_ADDR, 0, 1, (uchar *)header, sizeof(struct am43xx_board_id))) &#123; printf(\"Could not read the EEPROM at 0x%x\\n\", CONFIG_SYS_I2C_EEPROM_ADDR); return -EIO; &#125; if (header-&gt;magic != 0xEE3355AA) &#123; printf(\"Incorrect magic number (0x%x) in EEPROM\\n\", header-&gt;magic); return -EINVAL; &#125; &#125;#endif //strncpy(am43xx_board_name, (char *)header-&gt;name, sizeof(header-&gt;name)); strncpy(am43xx_board_name, \"AM43__SK\", sizeof(header-&gt;name)); am43xx_board_name[sizeof(header-&gt;name)] = 0; //strncpy(am43xx_board_rev, (char *)header-&gt;version, sizeof(header-&gt;version)); strncpy(am43xx_board_rev, \"1.2\",sizeof(header-&gt;version)); am43xx_board_rev[sizeof(header-&gt;version)] = 0; return 0;&#125; 修改后，重新编译Uboot，重新下载，又能愉快启动了。 3.I2C设备驱动3.1 编写I2C设备驱动的四种方法在内核linux-3.14.43+gitAUTOINC+875c69b2c3-g875c69b\\Documentation\\i2c\\instantiating-devices里面介绍了How to instantiate I2C devices。 说明了I2C设备驱动有以下四种编写方式： Method 1: Method 1a: Declare the I2C devices by bus number Method 1b: Declare the I2C devices via devicetree Method 1c: Declare the I2C devices via ACPIMethod 2: Instantiate the devices explicitlyMethod 3: Probe an I2C bus for certain devicesMethod 4: Instantiate from user-space Method 1a中，先定义一个板载信息结构体i2c_board_info，然后通过i2c_register_board_info()注册板载信息。然后i2c_board_info就被放在了i2c_board_list链表中。 但调用i2c_ragister_adapter()时，会使用i2c_scan_static_board_info对i2c_board_list进行扫描，调用i2c_new_device()创建client。 该方式的i2c_scan_static_board_info在i2c_ragister_adapter()之前，不适合动态加载(insmod方式)。 Method 1b中，就是把资源信息，以设备树的方式提供，换汤不换药。 Method 1c中，ACPI不懂，跳过。 Method 2中，翻译的意思是 明确实例化设备。还是先定义一个板载信息结构体i2c_board_info，然后通过i2c_new_device()或i2c_new_probed_device()去创建client。这两个函数前者认为设备一定存在，根据i2c_board_info的地址创建设备。而i2c_new_probed_device()则会先检查i2c_board_info描述的地址设备是否真的存在，只有存在才会创建client。本次I2C设备驱动就是用的这种方式。 Method 3中，不需要事先确定适配器，内核不太推荐该方法，跳过。 Method 4，这个就NB了，直接从用户层创建I2C设备。但需要下个i2c-tools使用里面的头文件i2c-dev.h,才好在应用程序中，调用i2c_smbus_read_word_data进行访问。感觉统一了驱动，减少了驱动的工作量，但稍微加大了应用程序设计的工作量。这里我没使用，以后遇到了再说。从用户空间创建设备的方法： 1234//创建echo eeprom 0x50 &gt; /sys/bus/i2c/devices/i2c-03/new_device//删除# echo 0x50 &gt; /sys/bus/i2c/devices/i2c-0/new_device 3.2 采用Method 2编写驱动采用设备平台驱动模型编写。 首先分析at24cxx_dev.c，按照前面介绍的步骤:1.先定义一个板载信息结构体i2c_board_info：123static struct i2c_board_info at24cxx_info = &#123; I2C_BOARD_INFO(&quot;at24c256&quot;, 0x50),&#125;; 2.通过i2c_new_device()创建client：123456789101112static int at24cxx_dev_init(void)&#123; struct i2c_adapter *i2c_adap; printk(KERN_INFO&quot;%s OK.\\n&quot;,__func__); i2c_adap = i2c_get_adapter(0); at24cxx_client = i2c_new_device(i2c_adap, &amp;at24cxx_info); i2c_put_adapter(i2c_adap); return 0;&#125; 这里还通过i2c_get_adapter()获取了适配器0(AM437X的I2C控制器0)，然后调用i2c_put_adapter再将其挂起。现在I2C设备就有了。 再分析at24cxx_drv.c:1.分配/设置一个i2c_driver: 123456789static struct i2c_driver at24cxx_driver = &#123; .driver = &#123; .name = &quot;ti_i2c0&quot;, .owner = THIS_MODULE, &#125;, .probe = at24cxx_probe, .remove = at24cxx_remove, .id_table = at24cxx_id_table,&#125;; name无所谓，这里还有probe()和remove()函数，分别在模块加载和卸载时调用。这里的probe()加载，必须要id_table里面的设备名字与i2c_board_info相同才能加载。 2.注册i2c_driver:1i2c_add_driver(&amp;at24cxx_driver); 3.注册字符设备：待id_table里面的设备名字与i2c_board_info相同，调用probe()函数。probe()函数进行字符设备注册那一套操作。 3.1申请设备号：123456if(alloc_chrdev_region(&amp;devid, 0, TI_EEPROM_CNT, &quot;at24cxx&quot;) &lt; 0)&#123; printk(KERN_INFO&quot;%s ERROR.\\n&quot;,__func__); goto error;&#125;major = MAJOR(devid); 3.2绑定操作函数、创建类、创建设备：1234cdev_init(&amp;at24cxx_cdev, &amp;at24cxx_fops); cdev_add(&amp;at24cxx_cdev, devid, TI_EEPROM_CNT); at24cxx_cls = class_create(THIS_MODULE, &quot;ti_at24cxx&quot;);device_create(at24cxx_cls, NULL, MKDEV(major, 0), NULL, &quot;at24cxx&quot;); 4.释放资源：在卸载模块时，释放probe()申请的资源：1234567for(i=0;i&lt;TI_EEPROM_CNT;i++)&#123; device_destroy(at24cxx_cls, MKDEV(major, i)); &#125;class_destroy(at24cxx_cls);unregister_chrdev(major, &quot;at24cxx&quot;); 5.完善操作函数：这里只实现了EEPROM的随机读写。先说写EEPROM，前面裸机的时候，写EEPROM是先发送一个8位的设备地址和写命令(这个控制器自动的，不管)，然后是发送两个8位的数据地址，最后是一个8位要写的数据。因此，用户层传进来的的参数是地址和数据，需要分解成两个8位地址和数据再发送，一共三个数据。1234567891011if (copy_from_user(&amp;ker_buf, user_buf, count)) return -EFAULT;send[0] = ker_buf[0]&gt;&gt;8;send[1] = ker_buf[0];send[2] = ker_buf[1];if(i2c_master_send(at24cxx_client, send, 3)) return 2;else return -EIO; 再分析下写，裸机的时候对EEPROM写，需要先发送一个8位的设备地址和写命令(这个控制器自动的，不管)，再发送两个数据8位地址，再发送一个8位的设备地址和读命令(这个控制器自动的，也不管)，再读取8位数据。 因此，用户层传进来的是一个地址数据，需要分解成两个8位地址，发送出去，再接收一个8位数据。 1234567891011if (copy_from_user(&amp;addr, user_buf, count)) return -EFAULT;send[0] = addr&gt;&gt;8;send[1] = addr;i2c_master_send(at24cxx_client, send, 2);i2c_master_recv(at24cxx_client, &amp;data, 1);ret = copy_to_user(user_buf, &amp;data, 1); 最后看看应用程序app_at24cxx.c:读取EEPROM格式是./app_at24cxx r addr，写EEPROM格式是./app_at24cxx w addr val。1.先判断传入的参数：12345if ((argc != 3) &amp;&amp; (argc != 4))&#123; print_usage(argv[0]); return -1;&#125; 2.打开EEPROM设备：1fd = open(&quot;/dev/at24cxx&quot;, O_RDWR); 3.判断如果是读操作：123456if (strcmp(argv[1], &quot;r&quot;) == 0)&#123; buf[0] = strtoul(argv[2], NULL, 0); read(fd, buf, 1); printf(&quot;data: %c, %d, 0x%2x\\n&quot;, buf[0], buf[0], buf[0]);&#125; strcmp()比较字符串，strtoul()将字符串转换成整型。 4.判断如果是写操作：12345678910else if ((strcmp(argv[1], &quot;w&quot;) == 0) &amp;&amp; (argc == 4))&#123; buf[0] = strtoul(argv[2], NULL, 0); buf[1] = strtoul(argv[3], NULL, 0); if (write(fd, buf, 2) == 2) printf(&quot;write ok, addr = 0x%02x, data = 0x%02x\\n&quot;, buf[0], buf[1]); else printf(&quot;write err, addr = 0x%02x, data = 0x%02x\\n&quot;, buf[0], buf[1]);&#125; write()的写成功返回的是实际写入的字节数，这个靠驱动的写函数的返回值。 3.3 完整代码[at24cxx_dev.c]link123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/i2c.h&gt;#include &lt;linux/err.h&gt;#include &lt;linux/regmap.h&gt;#include &lt;linux/slab.h&gt;static struct i2c_board_info at24cxx_info = &#123; I2C_BOARD_INFO(\"at24c256\", 0x50),&#125;;static struct i2c_client *at24cxx_client;static int at24cxx_dev_init(void)&#123; struct i2c_adapter *i2c_adap; printk(KERN_INFO\"%s OK.\\n\",__func__); i2c_adap = i2c_get_adapter(0); at24cxx_client = i2c_new_device(i2c_adap, &amp;at24cxx_info); i2c_put_adapter(i2c_adap); return 0;&#125;static void at24cxx_dev_exit(void)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); i2c_unregister_device(at24cxx_client);&#125;module_init(at24cxx_dev_init);module_exit(at24cxx_dev_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am437x board i2c device to at24c256\");MODULE_ALIAS(\"platform:device tree:ti_i2c\");MODULE_VERSION(\"V1.0\"); [at24cxx_drv.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/i2c.h&gt;#include &lt;linux/err.h&gt;#include &lt;linux/regmap.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/fs.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/cdev.h&gt;#define TI_EEPROM_CNT 1static int major;static struct cdev at24cxx_cdev;static struct class *at24cxx_cls;static struct i2c_client *at24cxx_client;/* * 传入: buf[0] : addr * 输出: buf[0] : data */static ssize_t at24cxx_read(struct file * file, char __user *user_buf, size_t count, loff_t *off)&#123; unsigned char addr, data; char send[2]; int ret; if(count != 1)&#123; printk(KERN_INFO\"at24cxx_read count != 1.\\n\"); return 1; &#125; if (copy_from_user(&amp;addr, user_buf, count)) return -EFAULT; send[0] = addr&gt;&gt;8; send[1] = addr; i2c_master_send(at24cxx_client, send, 2); i2c_master_recv(at24cxx_client, &amp;data, 1); ret = copy_to_user(user_buf, &amp;data, 1); return 1;&#125;/* buf[0] : addr * buf[1] : data */static ssize_t at24cxx_write(struct file *file, const char __user *user_buf, size_t count, loff_t *off)&#123; unsigned char ker_buf[2]; char send[3]; printk(KERN_INFO\"%s OK.\\n\",__func__); if(count != 2)&#123; printk(KERN_INFO\"at24cxx_write count != 2.\\n\"); return 1; &#125; if (copy_from_user(&amp;ker_buf, user_buf, count)) return -EFAULT; //printk(\"ker_buf[0]= 0x%02x, ker_buf[1]= x%02x\\n\", ker_buf[0], ker_buf[1]); send[0] = ker_buf[0]&gt;&gt;8; send[1] = ker_buf[0]; send[2] = ker_buf[1]; if(i2c_master_send(at24cxx_client, send, 3)) return 2; else return -EIO;&#125;static struct file_operations at24cxx_fops = &#123; .owner = THIS_MODULE, .read = at24cxx_read, .write = at24cxx_write,&#125;;static int at24cxx_probe(struct i2c_client *client, const struct i2c_device_id *id)&#123; dev_t devid; at24cxx_client = client; printk(KERN_INFO\"%s OK.\\n\",__func__); //1.申请设备号 if(alloc_chrdev_region(&amp;devid, 0, TI_EEPROM_CNT, \"at24cxx\") &lt; 0) &#123; printk(KERN_INFO\"%s ERROR.\\n\",__func__); goto error; &#125; major = MAJOR(devid); //2.注册到系统中 cdev_init(&amp;at24cxx_cdev, &amp;at24cxx_fops); cdev_add(&amp;at24cxx_cdev, devid, TI_EEPROM_CNT); at24cxx_cls = class_create(THIS_MODULE, \"ti_at24cxx\"); device_create(at24cxx_cls, NULL, MKDEV(major, 0), NULL, \"at24cxx\"); error: unregister_chrdev_region(MKDEV(major, 0), TI_EEPROM_CNT); return 0;&#125;static int at24cxx_remove(struct i2c_client *client)&#123; unsigned int i; printk(KERN_INFO\"%s OK.\\n\",__func__); for(i=0;i&lt;TI_EEPROM_CNT;i++) &#123; device_destroy(at24cxx_cls, MKDEV(major, i)); &#125; class_destroy(at24cxx_cls); unregister_chrdev(major, \"at24cxx\"); return 0;&#125;static const struct i2c_device_id at24cxx_id_table[] = &#123; &#123; \"at24c256\", 0 &#125;, &#123;&#125;&#125;;/* 1. 分配/设置i2c_driver */static struct i2c_driver at24cxx_driver = &#123; .driver = &#123; .name = \"ti_i2c0\", .owner = THIS_MODULE, &#125;, .probe = at24cxx_probe, .remove = at24cxx_remove, .id_table = at24cxx_id_table,&#125;;static int at24cxx_drv_init(void)&#123; /* 2. 注册i2c_driver */ printk(KERN_INFO\"%s OK.\\n\",__func__); i2c_add_driver(&amp;at24cxx_driver); return 0;&#125;static void at24cxx_drv_exit(void)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); i2c_del_driver(&amp;at24cxx_driver);&#125;module_init(at24cxx_drv_init);module_exit(at24cxx_drv_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am437x board i2c drvice to at24c256\");MODULE_ALIAS(\"platform:device tree:ti_i2c\");MODULE_VERSION(\"V1.0\"); [app_at24cxx.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;/* * ./app_at24cxx r addr * ./app_at24cxx w addr val */void print_usage(char *file)&#123; printf(\"%s r addr\\n\", file); printf(\"%s w addr val\\n\", file);&#125;int main(int argc, char **argv)&#123; int fd; unsigned char buf[2]; int x; if ((argc != 3) &amp;&amp; (argc != 4)) &#123; print_usage(argv[0]); return -1; &#125; fd = open(\"/dev/at24cxx\", O_RDWR); if (fd &lt; 0) &#123; printf(\"can't open /dev/at24cxx\\n\"); return -1; &#125; if (strcmp(argv[1], \"r\") == 0) &#123; buf[0] = strtoul(argv[2], NULL, 0); read(fd, buf, 1); printf(\"data: %c, %d, 0x%2x\\n\", buf[0], buf[0], buf[0]); &#125; else if ((strcmp(argv[1], \"w\") == 0) &amp;&amp; (argc == 4)) &#123; buf[0] = strtoul(argv[2], NULL, 0); buf[1] = strtoul(argv[3], NULL, 0); if (write(fd, buf, 2) == 2) printf(\"write ok, addr = 0x%02x, data = 0x%02x\\n\", buf[0], buf[1]); else printf(\"write err, addr = 0x%02x, data = 0x%02x\\n\", buf[0], buf[1]); &#125; else &#123; print_usage(argv[0]); return -1; &#125; close(fd); return 0;&#125; 4.I2C适配器驱动下面开始比较好玩的I2C适配器驱动。去除内核的I2C适配器模块，删除设备树文件里相关的I2C资源信息。 4.1 编写I2C适配器驱动I2C适配器驱动采用最原始的方法编写。1.入口函数入口函数做了四件事情：硬件相关设置、注册中断、初始化等待队列、注册I2C适配器。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667static const struct i2c_algorithm am437x_i2c_algo = &#123; // .smbus_xfer = , .master_xfer = am437x_i2c_xfer, .functionality = am437x_i2c_func,&#125;;static struct i2c_adapter am437x_i2c_adapter = &#123; .name = &quot;i2c_adapter&quot;, .algo = &amp;am437x_i2c_algo,//i2c总线通信方法 .owner = THIS_MODULE,&#125;;static void i2c_init(void)&#123; printk(KERN_INFO&quot;%s OK.\\n&quot;,__func__); /*clk*/ PRCM_CM_WKUP_I2C0_CLKCTRL = ioremap(0x44DF2800+0x340, 0x04*1); *PRCM_CM_WKUP_I2C0_CLKCTRL |= (0x02&lt;&lt;0); PRCM_CM_WKUP_CLKSTCTRL = ioremap(0x44DF2800+0x300, 0x04*1); *PRCM_CM_WKUP_CLKSTCTRL |= (0x01&lt;&lt;14); PRCM_CM_PER_L4LS_CLKSTCTRL = ioremap(0x44DF8800+0x400, 0x04*1); *PRCM_CM_PER_L4LS_CLKSTCTRL |= (0x01&lt;&lt;27); /*GPIO:gpio3_5-&gt;I2C0_SDA;gpio3_6-&gt;I2C0_SCL*/ CTRL_CONF_I2C0_SDA = ioremap(0x44E10000+0x0988, 0x04*1); CTRL_CONF_I2C0_SCL = ioremap(0x44E10000+0x098C, 0x04*1); *CTRL_CONF_I2C0_SDA &amp;= ~(0x07&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;19); *CTRL_CONF_I2C0_SCL &amp;= ~(0x07&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;19); /*I2C0 set*/ I2C0 = ioremap(0x44E0B000, sizeof(struct am437x_i2c_regs)); I2C0-&gt;CON &amp;= ~(0x01&lt;&lt;15);//reset I2C0-&gt;SYSC &amp;= ~(0x01&lt;&lt;0);//Auto Idle disabled. I2C0-&gt;PSC = 3;//the module divided by (PSC + 1) -&gt; 48M/(3+1)=12M I2C0-&gt;SCLL = 63;//tLOW = (SCLL + 7) * ICLK time period I2C0-&gt;SCLH = 65;//tHIGH = (SCLH + 5) * ICLK time period //I2C0-&gt;SA = 0x50;//Slave address.x 1010 000 I2C0-&gt;CON |= (0x01&lt;&lt;15);//Module enabled &#125;static int i2c_bus_drv_init(void)&#123; printk(KERN_INFO&quot;%s OK.\\n&quot;,__func__); //硬件相关的设置 i2c_init(); if (request_irq(102, i2c_xfer_irq, 0, &quot;am437x-i2c&quot;, NULL)) return -EAGAIN; init_waitqueue_head(&amp;i2c_data.wait); i2c_add_adapter(&amp;am437x_i2c_adapter);//会在/sys/class/i2c-adapter下生成i2c-x return 0;&#125; 硬件设置部分，初始化了相关时钟，设置GPIO复用，设置了I2C0控制器的一些设置。这里设置直接用ioremap()映射寄存器进程操作，是很不对的，内核是个整体，相关之间有关联，理论上时钟部分内核已经封装好了，我现在只需要调用相关就行。但秉着先调通，再优化改进的思想，映射是最快，最方便的= =。同理GPIO的设置和中断号也是不规范的。 i2c_add_adapter()会调用i2c_register_adapter()注册适配器，自动完成字符设备注册那一套。绑定了结构体i2c_adapter，i2c_adapter里面有I2C总线通信方法i2c_algorithm。i2c_algorithm里面两个函数：.master_xfer = am437x_i2c_xfer,:传输函数；.functionality = am437x_i2c_func,:支持的协议； I2C适配器驱动的关键就是实现这两个函数。 2.出口函数与入口函数相反操作：1234567891011121314151617static void i2c_bus_drv_exit(void)&#123; printk(KERN_INFO&quot;%s OK.\\n&quot;,__func__); iounmap(CTRL_CONF_I2C0_SDA); iounmap(CTRL_CONF_I2C0_SCL); iounmap(PRCM_CM_WKUP_I2C0_CLKCTRL); iounmap(PRCM_CM_WKUP_CLKSTCTRL); iounmap(PRCM_CM_PER_L4LS_CLKSTCTRL); iounmap(I2C0); free_irq(102, NULL); i2c_del_adapter(&amp;am437x_i2c_adapter);&#125; 3.实现关键函数一：am437x_i2c_func()虽说是关键函数，但这个是送分题，返回支持协议即可。123456static u32 am437x_i2c_func(struct i2c_adapter *adap)&#123; printk(KERN_INFO&quot;%s OK.\\n&quot;,__func__); //用于返回总线支持的协议 return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_PROTOCOL_MANGLING;&#125; 4.实现关键函数二：am437x_i2c_xfer()先定义个传输数据的结构体：123456789struct am437x_i2c_xfer_data &#123; struct i2c_msg *msgs; uint32_t cur_rec; uint32_t cur_send; uint32_t reg_cnt; uint32_t err; wait_queue_head_t wait;&#125;;static struct am437x_i2c_xfer_data i2c_data; 里面包含了i2c_msg结构体、当前接收位置cur_rec、当前发送位置cur_send、CNT寄存器计数reg_cnt、状态标志err、唤醒队列wait； i2c_msg结构体比较重要，包含了从机地址，发送/接收标志、数据长度和数据指针。12345678struct i2c_msg &#123; __u16 addr; // 从机地址 __u16 flags; // 标志 #define I2C_M_TEN 0x0010 // 十位地址标志 #define I2C_M_RD 0x0001 // 接收数据标志 __u16 len; // 数据长度 __u8 *buf; // 数据指针 &#125;; 前面at24cxx_drv.c中调用发送i2c_master_send()和接收i2c_master_recv()时，就会调用这里的传输函数am437x_i2c_xfer()。先初始化相关变量：123456789i2c_data.msgs = msgs;i2c_data.cur_rec = 0;i2c_data.cur_send = 0;i2c_data.err = -ENODEV;I2C0-&gt;CNT = i2c_data.msgs-&gt;len;i2c_data.reg_cnt = I2C0-&gt;CNT;I2C0-&gt;SA = i2c_data.msgs-&gt;addr; 保存传入的i2c_msg，设置当前接收位置cur_rec和当前发送位置cur_send为0，赋值给I2C0-&gt;CNT寄存器传输长度，因为I2C0-&gt;CNT在后面不好把握什么时候会清零，再将I2C0-&gt;CNT赋值给reg_cnt,作为要传输数据的总长度。再将设备地址传给寄存器。 接着开始传输：123456789101112131415161718192021222324static void am437x_i2c_start(void)&#123; printk(KERN_INFO&quot;%s OK.\\n&quot;,__func__); I2C0-&gt;IRQSTS |= 0x7FFF; I2C0-&gt;IRQEN_CLR |= 0x7FFF; if(i2c_data.msgs-&gt;flags &amp; I2C_M_RD) //read &#123; I2C0-&gt;CON |= (0x01&lt;&lt;10 | (0x01&lt;&lt;15)); //MST=1 TRX=0 I2C0-&gt;CON &amp;= ~(0x01&lt;&lt;9); I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;3); &#125; else//write &#123; I2C0-&gt;CON |= (0x01&lt;&lt;9 | 0x01&lt;&lt;10 | 0x01&lt;&lt;15); //MST=1 TRX=1 I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;4); &#125; I2C0-&gt;CON |= (0x01&lt;&lt;0);&#125; 先清除所有中断，利用i2c_data.msgs-&gt;flags判断时读还是写，设置对应模式和对应中断，最后启动传输。 随后进入休眠，中断就会根据情况发送/接收数据，待满足 当前传输长度等于总传输长度时，唤醒该函数，完成本次传输。 5.中断函数前面am437x_i2c_start()中设置I2C0-&gt;CON |= (0x01&lt;&lt;0);后，AM437X的I2C控制器就会自动传输数据，等完成后，生成对应的标志位。但发生中断后，进入中断函数，先清除除 接收标志和发送标志 以外的中断（更好的方式保留ACK响应标志和bus空闲标志，这里简化，暂不管）。判断是接收完成还是发送完成，如果是接收完成：清除接收中断，保存I2C0-&gt;DATA数据，同时，当前接收标志i2c_data.cur_rec加1，直到 当前接收等于总传输，即可关闭中断，发送停止信号。如果是发送完成：清除发送中断，赋值I2C0-&gt;DATA数据，同时，当前接收标志i2c_data.cur_send加1，直到 当前发送等于总传输，即可关闭中断，发送停止信号。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static irqreturn_t i2c_xfer_irq(int irq, void *dev_id)&#123; unsigned int status = 0; printk(KERN_INFO&quot;%s OK.\\n&quot;,__func__); status = I2C0-&gt;IRQSTS; //I2C0-&gt;IRQSTS = (status &amp; (0x01&lt;&lt;1 |0x01&lt;&lt;3 | 0x01&lt;&lt;4)); I2C0-&gt;IRQSTS = (status &amp; (0x01&lt;&lt;3 | 0x01&lt;&lt;4)); if(status &amp; (0x01&lt;&lt;3))//receive &#123; //printk(KERN_INFO&quot;i2c receive.\\n&quot;); I2C0-&gt;IRQSTS |= (0x01&lt;&lt;3); i2c_data.msgs-&gt;buf[i2c_data.cur_rec] = I2C0-&gt;DATA; i2c_data.cur_rec++; if(i2c_data.cur_rec == i2c_data.reg_cnt) &#123; I2C0-&gt;IRQEN_CLR |= (0x01&lt;&lt;3); am437x_i2c_stop(1); &#125; &#125; if (status &amp; (0x01&lt;&lt;4))//send &#123; //printk(KERN_INFO&quot;i2c send.\\n&quot;); I2C0-&gt;IRQSTS |= (0x01&lt;&lt;4); I2C0-&gt;DATA = i2c_data.msgs-&gt;buf[i2c_data.cur_send]; i2c_data.cur_send++; if(i2c_data.cur_send == i2c_data.reg_cnt) &#123; I2C0-&gt;IRQEN_CLR |= (0x01&lt;&lt;4); am437x_i2c_stop(1); &#125; &#125; //判断是否有ack和bus空闲 I2C0-&gt;IRQSTS |= 0x7FFF; return IRQ_HANDLED;&#125; 在am437x_i2c_stop()里，除了要发送停止信号，还要唤醒队列。123456789101112static void am437x_i2c_stop(int err)&#123; printk(KERN_INFO&quot;%s OK.\\n&quot;,__func__); i2c_data.err = err; I2C0-&gt;CON |= (0x01&lt;&lt;1); //stop ndelay(50); /*唤醒*/ wake_up(&amp;i2c_data.wait);&#125; 这就完了，还是比较清晰的。 4.2 完整代码[i2c_bus_am437x.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/i2c.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/time.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/err.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/pm_runtime.h&gt;#include &lt;linux/clk.h&gt;#include &lt;linux/cpufreq.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/io.h&gt;#include &lt;asm/irq.h&gt;struct am437x_i2c_xfer_data &#123; struct i2c_msg *msgs; uint32_t cur_rec; uint32_t cur_send; uint32_t reg_cnt; uint32_t err; wait_queue_head_t wait;&#125;;static struct am437x_i2c_xfer_data i2c_data;static volatile unsigned long *CTRL_CONF_I2C0_SDA;static volatile unsigned long *CTRL_CONF_I2C0_SCL;static volatile unsigned long *PRCM_CM_WKUP_I2C0_CLKCTRL;static volatile unsigned long *PRCM_CM_WKUP_CLKSTCTRL;static volatile unsigned long *PRCM_CM_PER_L4LS_CLKSTCTRL;struct am437x_i2c_regs &#123; uint32_t REVNB_LO; //00h uint32_t REVNB_HI; //04h uint32_t RESERVED0[2]; //08h uint32_t SYSC; //10h uint32_t RESERVED1[4]; //14h uint32_t IRQSTS_RAW; //24h uint32_t IRQSTS; //28h uint32_t IRQEN_SET; //2ch uint32_t IRQEN_CLR; //30h uint32_t WE; //34h uint32_t DMARXEN_SET; //38h uint32_t DMATXEN_SET; //3ch uint32_t DMARXEN_CLR; //40h uint32_t DMATXEN_CLR; //44h uint32_t DMARXWAKE_EN; //48h uint32_t DMATXWAKE_EN; //4ch uint32_t RESERVED2[16]; //50h uint32_t SYSS; //90h uint32_t BUF; //94h uint32_t CNT; //98h uint32_t DATA; //9ch uint32_t RESERVED3; //a0h uint32_t CON; //a4h uint32_t OA; //a8h uint32_t SA; //ach uint32_t PSC; //b0h uint32_t SCLL; //b4h uint32_t SCLH; //b8h uint32_t SYSTEST; //bch uint32_t BUFSTAT; //c0h uint32_t OA1; //c4h uint32_t OA2; //c8h uint32_t OA3; //cch uint32_t ACTOA; //d0h&#125;;static volatile struct am437x_i2c_regs *I2C0;static void am437x_i2c_start(void)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); I2C0-&gt;IRQSTS |= 0x7FFF; I2C0-&gt;IRQEN_CLR |= 0x7FFF; if(i2c_data.msgs-&gt;flags &amp; I2C_M_RD) //read &#123; I2C0-&gt;CON |= (0x01&lt;&lt;10 | (0x01&lt;&lt;15)); //MST=1 TRX=0 I2C0-&gt;CON &amp;= ~(0x01&lt;&lt;9); I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;3); &#125; else//write &#123; I2C0-&gt;CON |= (0x01&lt;&lt;9 | 0x01&lt;&lt;10 | 0x01&lt;&lt;15); //MST=1 TRX=1 I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;4); &#125; I2C0-&gt;CON |= (0x01&lt;&lt;0);&#125;static void am437x_i2c_stop(int err)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); i2c_data.err = err; mdelay(2);//为了防止读EEPROM的时候，写操作后，马上就读操作，导致错误; I2C0-&gt;CON |= (0x01&lt;&lt;1); //stop ndelay(50);//等待停止信号发完 /*唤醒*/ wake_up(&amp;i2c_data.wait);&#125;static irqreturn_t i2c_xfer_irq(int irq, void *dev_id)&#123; unsigned int status = 0; printk(KERN_INFO\"%s OK.\\n\",__func__); status = I2C0-&gt;IRQSTS; //I2C0-&gt;IRQSTS = (status &amp; (0x01&lt;&lt;1 |0x01&lt;&lt;3 | 0x01&lt;&lt;4)); I2C0-&gt;IRQSTS = (status &amp; (0x01&lt;&lt;3 | 0x01&lt;&lt;4)); if(status &amp; (0x01&lt;&lt;3))//receive &#123; //printk(KERN_INFO\"i2c receive.\\n\"); I2C0-&gt;IRQSTS |= (0x01&lt;&lt;3); i2c_data.msgs-&gt;buf[i2c_data.cur_rec] = I2C0-&gt;DATA; i2c_data.cur_rec++; if(i2c_data.cur_rec == i2c_data.reg_cnt) &#123; I2C0-&gt;IRQEN_CLR |= (0x01&lt;&lt;3); am437x_i2c_stop(1); &#125; &#125; if (status &amp; (0x01&lt;&lt;4))//send &#123; //printk(KERN_INFO\"i2c send.\\n\"); I2C0-&gt;IRQSTS |= (0x01&lt;&lt;4); I2C0-&gt;DATA = i2c_data.msgs-&gt;buf[i2c_data.cur_send]; i2c_data.cur_send++; if(i2c_data.cur_send == i2c_data.reg_cnt) &#123; I2C0-&gt;IRQEN_CLR |= (0x01&lt;&lt;4); am437x_i2c_stop(1); &#125; &#125; //判断是否有ack和bus空闲 I2C0-&gt;IRQSTS |= 0x7FFF; return IRQ_HANDLED;&#125;static int am437x_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)&#123; //用于实现I2C协议，将i2c_msg消息传给i2c设备 unsigned long timeout; printk(KERN_INFO\"%s OK.\\n\",__func__); //把num个i2c_msg的I2C数据发送出去/读进来 i2c_data.msgs = msgs; i2c_data.cur_rec = 0; i2c_data.cur_send = 0; i2c_data.err = -ENODEV; I2C0-&gt;CNT = i2c_data.msgs-&gt;len; i2c_data.reg_cnt = I2C0-&gt;CNT; I2C0-&gt;SA = i2c_data.msgs-&gt;addr; am437x_i2c_start(); /*休眠*/ if(i2c_data.msgs-&gt;flags &amp; I2C_M_RD) //读 &#123; timeout = wait_event_timeout(i2c_data.wait,(i2c_data.cur_rec == i2c_data.reg_cnt), HZ * 5);//5S &#125; else &#123; timeout = wait_event_timeout(i2c_data.wait, (i2c_data.cur_send == i2c_data.reg_cnt), HZ * 5);//5S &#125; if(0 == timeout) &#123; printk(\"am437x i2c timeout.\\n\"); return -ETIMEDOUT; &#125; else &#123; return i2c_data.err; &#125;&#125;static u32 am437x_i2c_func(struct i2c_adapter *adap)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); //用于返回总线支持的协议 return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_PROTOCOL_MANGLING;&#125;static const struct i2c_algorithm am437x_i2c_algo = &#123; // .smbus_xfer = , .master_xfer = am437x_i2c_xfer, .functionality = am437x_i2c_func,&#125;;static struct i2c_adapter am437x_i2c_adapter = &#123; .name = \"i2c_adapter\", .algo = &amp;am437x_i2c_algo,//i2c总线通信方法 .owner = THIS_MODULE,&#125;; static void i2c_init(void)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); /*clk*/ PRCM_CM_WKUP_I2C0_CLKCTRL = ioremap(0x44DF2800+0x340, 0x04*1); *PRCM_CM_WKUP_I2C0_CLKCTRL |= (0x02&lt;&lt;0); PRCM_CM_WKUP_CLKSTCTRL = ioremap(0x44DF2800+0x300, 0x04*1); *PRCM_CM_WKUP_CLKSTCTRL |= (0x01&lt;&lt;14); PRCM_CM_PER_L4LS_CLKSTCTRL = ioremap(0x44DF8800+0x400, 0x04*1); *PRCM_CM_PER_L4LS_CLKSTCTRL |= (0x01&lt;&lt;27); /*GPIO:gpio3_5-&gt;I2C0_SDA;gpio3_6-&gt;I2C0_SCL*/ CTRL_CONF_I2C0_SDA = ioremap(0x44E10000+0x0988, 0x04*1); CTRL_CONF_I2C0_SCL = ioremap(0x44E10000+0x098C, 0x04*1); *CTRL_CONF_I2C0_SDA &amp;= ~(0x07&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;19); *CTRL_CONF_I2C0_SCL &amp;= ~(0x07&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;19); /*I2C0 set*/ I2C0 = ioremap(0x44E0B000, sizeof(struct am437x_i2c_regs)); I2C0-&gt;CON &amp;= ~(0x01&lt;&lt;15);//reset I2C0-&gt;SYSC &amp;= ~(0x01&lt;&lt;0);//Auto Idle disabled. I2C0-&gt;PSC = 3;//the module divided by (PSC + 1) -&gt; 48M/(3+1)=12M I2C0-&gt;SCLL = 63;//tLOW = (SCLL + 7) * ICLK time period I2C0-&gt;SCLH = 65;//tHIGH = (SCLH + 5) * ICLK time period //I2C0-&gt;SA = 0x50;//Slave address.x 1010 000 I2C0-&gt;CON |= (0x01&lt;&lt;15);//Module enabled &#125;static int i2c_bus_drv_init(void)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); //硬件相关的设置 i2c_init(); if (request_irq(102, i2c_xfer_irq, 0, \"am437x-i2c\", NULL)) return -EAGAIN; init_waitqueue_head(&amp;i2c_data.wait); i2c_add_adapter(&amp;am437x_i2c_adapter);//会在/sys/class/i2c-adapter下生成i2c-x return 0;&#125;static void i2c_bus_drv_exit(void)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); iounmap(CTRL_CONF_I2C0_SDA); iounmap(CTRL_CONF_I2C0_SCL); iounmap(PRCM_CM_WKUP_I2C0_CLKCTRL); iounmap(PRCM_CM_WKUP_CLKSTCTRL); iounmap(PRCM_CM_PER_L4LS_CLKSTCTRL); iounmap(I2C0); free_irq(102, NULL); i2c_del_adapter(&amp;am437x_i2c_adapter);&#125;module_init(i2c_bus_drv_init);module_exit(i2c_bus_drv_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am437x board i2c bus drvice.\");MODULE_ALIAS(\"ti_i2c\");MODULE_VERSION(\"V2.0\"); 5.测试结果加载i2c0总线驱动，再加载at24cxx设备驱动，最后运行应用程序。写1地址1，2地址2，3地址3，4地址4； 再读取1地址数据，2地址数据，3地址数据，4地址数据。 再看下逻辑分析仪效果：向地址0x02写入数据2：向地址0x02读出数据2：（PS:图片经过处理，让其在一张图上显示，因此时间标识有误。） 6.心得本次I2C适配器驱动，算是第一次写一个较复杂的驱动，目的是先写通，其次才是优化，因此存在以下一些问题：1.没有使用系统提供的时钟、GPIO配置等函数，全是自己映射；2.中断没有对总线空闲、没有ack进行判断；3.有些函数返回值没有处理； 收获：1.先调通再优化，现在调通了，优化等下次有机会在优化；2.调不动的时候，拿逻辑分析仪抓，再对照标准波形，一找一个准； 在写博客的时候，发现个BUG：printk()打印调试的时候，一切正常。在关闭printk()打印后，先对EEPROM写操作，再去读操作，发现怎么都是255。这种情况，多半是哪里延时时序问题。用逻辑分析仪抓波形，一个个printk()的关，最终发现问题在am437x_i2c_stop()。波形如下：可以看到地址发错了，加上一个2ms的延时后，即正常。 I2C驱动完了，下一个计划，LCD驱动。😀 7. i2c-tools的使用i2c-tools是Linux应用层，用于对i2c总线、设备进行简单测试、操作的工具。包含的工具有： i2cdetect – 用来列举I2C Bus上的所有设备i2cdump – 显示指定I2C设备的寄存器值i2cget – 读取指定I2C设备的某个寄存器的值i2cset – 写入指定I2C设备的某个寄存器的值 eg： 1.用i2cdetect检测有几组i2c总线在系统上： 123# i2cdetect -li2c-0 i2c OMAP I2C adapter I2C adapteri2c-1 i2c OMAP I2C adapter I2C adapter 2.用i2cdetect检测挂载在i2c总线上器件： 12345678910# i2cdetect -r -y 1 0 1 2 3 4 5 6 7 8 9 a b c d e f00: -- -- -- -- -- -- -- -- -- -- -- -- --10: -- -- -- -- -- -- -- -- -- -- -- UU -- -- -- --20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --50: 50 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --70: -- -- -- -- -- -- -- -- 可以看到0x1b和0x50地址上挂有有I2C设备；UU的代表该设备有被侦测到并正在被内核驱动器使用着； 3.用i2cdump查看器件所有寄存器的值： 12345678910111213141516171819# i2cdump -f -y 1 0x50No size specified (using byte-data access) 0 1 2 3 4 5 6 7 8 9 a b c d e f 0123456789abcdef00: 00 08 04 06 08 ff ff ff ff ff ff ff ff ff ff ff .????...........10: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................20: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................30: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................40: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................50: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................60: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................70: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................80: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................90: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................a0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................b0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................c0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................d0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................e0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................f0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................ 3.用i2cset设置单个寄存器值，用i2cget读取单个寄存器值： 12345# i2cget -f -y 1 0x50 0x010x08# i2cset -f -y 1 0x50 0x01 0x44# i2cget -f -y 1 0x50 0x010x44 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"AM437X","slug":"AM437X","permalink":"http://yoursite.com/tags/AM437X/"}]},{"title":"AM437x——I2C裸机","date":"2017-08-28T06:12:26.000Z","path":"2017/08/28/AM437x——I2C裸机/","text":"记录AM437x的I2C裸机调试，包含GPIO模拟和寄存器控制。 0.I2C协议关键点0.1 I2C协议想象有两个设备，他们之间要传输数据。发数据的叫主设备，接收数据的叫从设备。两个设备之间，只有两根线。一根线得作为时钟信号线，这样两个设备才能统一一个信号标准，另外一个自然只有作为信号线传输数据。 主设备要发送数据前，得发出一个特殊的信号，告诉从设备，这个信号就是开始信号。同理，发送完后，有个特殊的结束信号。以及从机在接收到数据后，给个响应信号表示自己收到了。 开始信号s：SCL为高，SDA由高变低，开始传输数据结束信号p：SCL为高，SDA由低变高，结束传输数据响应信号a：接收器在收到8位数据后，在第9个时钟周期，拉低SDA电平。SDA的信号，只能在SCL为低的时候发生变化。 如图， SDA和SCL开始都为高。然后SDA拉低，表示开始信号。 在接下来的8个时间周期里，主机控制SDA的高低，发出一个 包含从机地址 和 是读操作还是写操作 的数据。第9个时钟周期，主设备拉高后释放掉SDA，再去读取它。从设备应该拉低SDA，给出响应信号。 再接下来的8个时间周期里，主机控制SDA的高低，传达数据。从机就读取电平高低，得到数据。第9个时钟周期，从设备给主设备一个响应信号。 最后，主机给个停止信号，表示传输结束。 0.2 EEPROM以CAT24C256这个EEPROM作为从设备为例。 先看看CAT24C256的引脚有哪些：SCL和SDA，时钟和数据。A0,A1和A2，用来表示从设备的地址，在硬件电路上，设置这3个引脚的值。WP，写保护引脚。高电平的时候写保护，因此在写EEPROM的时候得将该引脚置低。 再看看，前面说的 “一个 包含从机地址 和 是读操作还是写操作 的数据”：可以看到前4位固定为”1010”，然后是3位地址，最后位表示是读操作还是写操作。 写操作的时序先来个开始信号，然后是从机地址(写)，然后是要写地址的高8位，再是低8位，再是要写的8位数据，最后是停止信号。每次传输的后面都得有个响应信号。 读操作的时序先来个开始信号，然后是从机地址(写)，然后是要写地址的高8位，再是低8位。再来个开始信号，然后是从机地址(读)，获取8位数据，最后是停止信号。每次传输的后面都得有个响应信号，但如果是最后一次接收数据可不要。 1.GPIO模拟版本1.1硬件结构TI EVM开发板的EEPROM部分电路图： 米尔科技开发板的EEPROM部分电路图： 两个板子都是用的I2C0，器件地址都是000，唯一不同的是米尔的板子用了EMU0引脚控制EEPROM的写保护。后面以米尔板子为例。这三个引脚分别是： I2C0_SDA-&gt;gpio3_5;I2C0_SCL-&gt;gpio3_6; WP-&gt;gpio3_7; 1.2相关函数 GPIO相关 1.启用GPIO3时钟，引脚控制默认为GPIO，再设置为输出，拉高引脚，做好准备；123456789101112void i2c_init(void)&#123; PRCM_CM_PER_GPIO3_CLKCTRL |= (0x02&lt;&lt;0); //gpio3_5-&gt;I2C0_SDA;gpio3_6-&gt;I2C0_SCL;gpio3_7-&gt;WP //CTRL_CONF_I2C0_SDA ;//GPIO模式I2C，默认配置即可 //CTRL_CONF_I2C0_SCL ;//GPIO模式I2C，默认配置即可 GPIO3-&gt;OE &amp;= ~(0x01&lt;&lt;7 | 0x01&lt;&lt;6 | 0x01&lt;&lt;5);//输出 GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;7 | 0x01&lt;&lt;6 | 0x01&lt;&lt;5);//拉高&#125; 2.封装好SDA和SCL的输出高低电平函数，以及获取SDA引脚数据函数，最后还有使能写保护引脚函数；1234567891011121314151617181920212223242526272829303132333435363738static void SDA(char x)&#123; GPIO3-&gt;OE &amp;= ~(0x01&lt;&lt;5); if(x) &#123; GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;5); &#125; else &#123; GPIO3-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;5); &#125; &#125;static void SCL(char x)&#123; GPIO3-&gt;OE &amp;= ~(0x01&lt;&lt;6); if(x) &#123; GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;6); &#125; else &#123; GPIO3-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;6); &#125; &#125;static char GET_SDA(void)&#123; GPIO3-&gt;OE |= (0x01&lt;&lt;5); return (GPIO3-&gt;DATAIN &amp; (0x01&lt;&lt;5)?1:0);&#125;void eeprom_write_protect(char x)&#123; if(x) GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;7); else GPIO3-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;7);&#125; I2C协议相关1.三个信号函数：开始信号、停止信号、响应信号(判断是否收到从设备的响应信号)。理论上可以通过调节延时的长短，改变传输速度。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static void i2c_delay(volatile int time)&#123; time = time*1; for (; time &gt; 0; time--);&#125;static void i2c_start(void)&#123; SCL(1); i2c_delay(1); SDA(1); i2c_delay(1); SDA(0); i2c_delay(1); SCL(0); i2c_delay(1);&#125;static void i2c_stop(void)&#123; SDA(0); i2c_delay(1); SCL(1); i2c_delay(1); SDA(1); i2c_delay(1);&#125;static int i2c_ack(void)&#123; int pin_val; SCL(0); i2c_delay(1); SDA(1); i2c_delay(1); //实测中，am437x引脚由输出设置为输入的时候，会有一个高电平 //因此，趁现在SCL为低，先设置为输入 GET_SDA(); SCL(1); i2c_delay(1); pin_val = GET_SDA(); i2c_delay(1); SCL(0); i2c_delay(1); return pin_val;&#125; 2.I2C的读写函数写就是在8个时钟周期里，SCL低的时候，改变SDA，SCL高的时候，稳定SDA，从而发出8位数据。写就是在8个时钟周期里，SCL低的时候，不读引脚，SCL高的时候，读引脚，从而得到8位数据。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void eeprom_write(unsigned char addr, unsigned char data)&#123; eeprom_write_protect(0); i2c_start(); i2c_write(0xA0); while(i2c_ack()); i2c_write(addr&gt;&gt;8); while(i2c_ack()); i2c_write(addr); while(i2c_ack()); i2c_write(data); while(i2c_ack()); i2c_stop(); eeprom_write_protect(1);&#125;unsigned char eeprom_read(unsigned char addr)&#123; unsigned char data = 0; eeprom_write_protect(0); i2c_start(); i2c_write(0xA0); while(i2c_ack()); i2c_write(addr&gt;&gt;8); while(i2c_ack()); i2c_write(addr); while(i2c_ack()); i2c_stop(); i2c_delay(10); i2c_start(); i2c_write(0xA1); while(i2c_ack()); data = i2c_read(); i2c_stop(); eeprom_write_protect(1); return data;&#125; EEPROM相关写操作：先关闭写保护，发出开始信号，发出从机地址(写)，发出高地址、低地址，发出数据，发出停止信号和打开写保护。读操作：先关闭写保护，发出开始信号，发出从机地址(写)，发出高地址、低地址。再发出开始信号，发出从机地址(写读)，读取数据，发出停止信号和打开写保护。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void eeprom_write(unsigned char addr, unsigned char data)&#123; eeprom_write_protect(0); i2c_start(); i2c_write(0xA0); while(i2c_ack()); i2c_write(addr&gt;&gt;8); while(i2c_ack()); i2c_write(addr); while(i2c_ack()); i2c_write(data); while(i2c_ack()); i2c_stop(); eeprom_write_protect(1);&#125;unsigned char eeprom_read(unsigned char addr)&#123; unsigned char data = 0; eeprom_write_protect(0); i2c_start(); i2c_write(0xA0); while(i2c_ack()); i2c_write(addr&gt;&gt;8); while(i2c_ack()); i2c_write(addr); while(i2c_ack()); i2c_stop(); i2c_delay(10); i2c_start(); i2c_write(0xA1); while(i2c_ack()); data = i2c_read(); i2c_stop(); eeprom_write_protect(1); return data;&#125; 1.3测试效果 串口打印： 向0x01地址写数据2： 读0x01地址数据为2： 2.I2C寄存器版本2.1硬件结构同上。 2.2相关函数 初始化相关1.初始化相关的时钟和配置复用功能； 12345678910111213141516static void i2c_gpio_init(void)&#123; PRCM_CM_WKUP_I2C0_CLKCTRL |= (0x02&lt;&lt;0); PRCM_CM_WKUP_CLKSTCTRL |= (0x01&lt;&lt;14); PRCM_CM_PER_L4LS_CLKSTCTRL|= (0x01&lt;&lt;27); PRCM_CM_PER_GPIO3_CLKCTRL |= (0x02&lt;&lt;0); //gpio3_5-&gt;I2C0_SDA;gpio3_6-&gt;I2C0_SCL;gpio3_7-&gt;WP CTRL_CONF_I2C0_SDA &amp;= ~(0x07&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;19); CTRL_CONF_I2C0_SCL &amp;= ~(0x07&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;19); //CTRL_CONF_EMU0 GPIO3-&gt;OE &amp;= ~(0x01&lt;&lt;7); GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;7);&#125; 2.初始化I2C0，注册中断；注意这里的从机地址不含最后的读写操作位。 123456789101112131415161718192021void i2c_init(void)&#123; i2c_gpio_init(); register_irq(IRQ_I2C0, i2c0_irq); interrupt_init(IRQ_I2C0); I2C0-&gt;CON &amp;= ~(0x01&lt;&lt;15);//reset I2C0-&gt;SYSC &amp;= ~(0x01&lt;&lt;0);//Auto Idle disabled. I2C0-&gt;PSC = 3;//the module divided by (PSC + 1) -&gt; 48M/(3+1)=12M I2C0-&gt;SCLL = 63;//tLOW = (SCLL + 7) * ICLK time period I2C0-&gt;SCLH = 65;//tHIGH = (SCLH + 5) * ICLK time period I2C0-&gt;SA = 0x50;//Slave address.1010 000 I2C0-&gt;CON |= (0x01&lt;&lt;15);//Module enabled &#125; 中断处理函数中断处理函数是硬件I2C的核心，根据中断状态标志位去进行相应的读或写操作。 12345678910111213141516171819202122232425262728293031323334void i2c0_irq(void)&#123; unsigned int status = 0; status = I2C0-&gt;IRQSTS; I2C0-&gt;IRQSTS = (status &amp; (0x01&lt;&lt;3 | 0x01&lt;&lt;4)); if(status &amp; (0x01&lt;&lt;3))//receive &#123; I2C0-&gt;IRQSTS |= (0x01&lt;&lt;3); if(r_count == num) &#123; I2C0-&gt;IRQEN_CLR |= (0x01&lt;&lt;3); I2C0-&gt;CON |= (0x01&lt;&lt;1);//stop &#125; else &#123; data_from_slave[r_count++] = (unsigned char)I2C0-&gt;DATA; &#125; &#125; if (status &amp; (0x01&lt;&lt;4))//send &#123; I2C0-&gt;DATA = data_to_slave[t_count++]; I2C0-&gt;IRQSTS |= (0x01&lt;&lt;4); if(t_count == num) &#123; I2C0-&gt;IRQEN_CLR |= (0x01&lt;&lt;4); &#125; &#125;&#125; EEPROM相关写操作：去写保护，分解地址高低位，设置传输数据的位数(地址是两位+数据一位)，清除中断，设置为主机发送模式，使能发送中断，开始传输，直到地址数据传完，开启写保护。读操作：去写保护，分解地址高低位，设置传输数据的位数(地址是两位)，清除中断，设置为主机发送模式，使能发送中断，开始传输，直到地址数据传完。再设置传输位（接收数据一位），清除中断，设置位主机接收模式，开始传输，直至传输完成，开启写保护。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687void eeprom_write(unsigned char addr, unsigned char data)&#123; eeprom_write_protect(0); data_to_slave[0] = addr&gt;&gt;8; data_to_slave[1] = (addr &amp; 0xFF); data_to_slave[2] = data; t_count = 0; I2C0-&gt;CNT = 0x03; num = I2C0-&gt;CNT; I2C0-&gt;IRQSTS |= 0x7FFF; I2C0-&gt;IRQEN_CLR |= 0x7FFF; I2C0-&gt;CON |= (0x01&lt;&lt;9 | 0x01&lt;&lt;10 | 0x01&lt;&lt;15); //MST=1 TRX=1 I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;4); I2C0-&gt;CON |= (0x01&lt;&lt;0); while(i2c_master_bus_busy() == 0); while(t_count != num); I2C0-&gt;CON |= (0x01&lt;&lt;1); //stop eeprom_write_protect(1);&#125;unsigned char eeprom_read(unsigned char addr)&#123; unsigned char data = 0; eeprom_write_protect(0); data_to_slave[0] = addr&gt;&gt;8; data_to_slave[1] = (addr &amp; 0xFF); t_count = 0; r_count = 0; I2C0-&gt;CNT = 0x02; num = I2C0-&gt;CNT; I2C0-&gt;IRQSTS |= 0x7FFF; I2C0-&gt;IRQEN_CLR |= 0x6FFF; I2C0-&gt;CON |= (0x01&lt;&lt;9 | 0x01&lt;&lt;10 | 0x01&lt;&lt;15); //MST=1 TRX=1 I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;4); I2C0-&gt;CON |= (0x01&lt;&lt;0); while(i2c_master_bus_busy() == 0); while(t_count != num); while(!(I2C0-&gt;IRQSTS_RAW &amp; (0x01&lt;&lt;2)));//----------------------------------------------------------------// I2C0-&gt;CNT = 0x01; num = I2C0-&gt;CNT; I2C0-&gt;IRQSTS |= 0x7FFF; I2C0-&gt;IRQEN_CLR |= 0x6FFF; I2C0-&gt;CON |= (0x01&lt;&lt;10 | (0x01&lt;&lt;15)); I2C0-&gt;CON &amp;= ~(0x01&lt;&lt;9); I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;3 | 0x01&lt;&lt;8); I2C0-&gt;CON |= (0x01&lt;&lt;0); while(i2c_master_bus_busy() == 0); while(r_count != num); data = data_from_slave[0]; eeprom_write_protect(1); return data;&#125; 2.3测试效果 向0x01地址写数据2： 读0x01地址数据为2： 3.完整代码[main.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/************************************************************************* &gt; File Name: main.c &gt; Author: hceng &gt; Description: AM437X裸机i2c &gt; Created Time: 20170815*************************************************************************/#include \"AM437X/AM437X_SOC.h\"#include \"led.h\"#include \"delay.h\"#include \"uart.h\"#include \"printf.h\"#include \"key.h\"#include \"clkout.h\"#include \"int.h\"#include \"timer.h\"#include \"i2c.h\"int main()&#123; unsigned int i; uart_init(); gic_init(); timer2_init(); i2c_init(); printf(\"init ok.\\n\\r\"); //write eeprom. for(i=0; i&lt;5; i++) &#123; eeprom_write(i,2*i); delay_ms(4);//Must be delayed more than 4ms. &#125; delay_ms(10); //read eeprom. for(i=0; i&lt;5; i++) &#123; printf(\"read_data%d = %d\\n\\r\",i, eeprom_read(i)); delay_ms(4); &#125; while(1) &#123; &#125; return 0;&#125; [i2c.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461#include \"AM437X/AM437X_SOC.h\"#include \"i2c.h\"#include \"uart.h\"#include \"printf.h\"#include \"int.h\" #include \"delay.h\" #ifdef GPIO_I2Cstatic void i2c_delay(volatile int time)&#123; time = time*1; for (; time &gt; 0; time--);&#125;static void SDA(char x)&#123; GPIO3-&gt;OE &amp;= ~(0x01&lt;&lt;5); if(x) &#123; GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;5); &#125; else &#123; GPIO3-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;5); &#125; &#125;static void SCL(char x)&#123; GPIO3-&gt;OE &amp;= ~(0x01&lt;&lt;6); if(x) &#123; GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;6); &#125; else &#123; GPIO3-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;6); &#125; &#125;static char GET_SDA(void)&#123; GPIO3-&gt;OE |= (0x01&lt;&lt;5); return (GPIO3-&gt;DATAIN &amp; (0x01&lt;&lt;5)?1:0);&#125;void i2c_init(void)&#123; PRCM_CM_PER_GPIO3_CLKCTRL |= (0x02&lt;&lt;0); //gpio3_5-&gt;I2C0_SDA;gpio3_6-&gt;I2C0_SCL;gpio3_7-&gt;WP //CTRL_CONF_I2C0_SDA ;//GPIO模式I2C，默认配置即可 //CTRL_CONF_I2C0_SCL ;//GPIO模式I2C，默认配置即可 GPIO3-&gt;OE &amp;= ~(0x01&lt;&lt;7 | 0x01&lt;&lt;6 | 0x01&lt;&lt;5);//输出 GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;7 | 0x01&lt;&lt;6 | 0x01&lt;&lt;5);//拉高&#125;static void i2c_start(void)&#123; SCL(1); i2c_delay(1); SDA(1); i2c_delay(1); SDA(0); i2c_delay(1); SCL(0); i2c_delay(1);&#125;static void i2c_stop(void)&#123; SDA(0); i2c_delay(1); SCL(1); i2c_delay(1); SDA(1); i2c_delay(1);&#125;static int i2c_ack(void)&#123; int pin_val; SCL(0); i2c_delay(1); SDA(1); i2c_delay(1); //实测中，am437x引脚由输出设置为输入的时候，会有一个高电平 //因此，趁现在SCL为低，先设置为输入 GET_SDA(); SCL(1); i2c_delay(1); pin_val = GET_SDA(); i2c_delay(1); SCL(0); i2c_delay(1); return pin_val;&#125;static void i2c_write(unsigned char data)&#123; int i = 0; for(i=0; i&lt;8; i++) &#123; SCL(0); i2c_delay(1); if(data &amp; 0x80) SDA(1); else SDA(0); data = data&lt;&lt;1; i2c_delay(1); SCL(1); i2c_delay(1); &#125; SCL(0); i2c_delay(1);&#125;static unsigned char i2c_read(void)&#123; int i = 0; unsigned char data = 0; SCL(0); i2c_delay(1); SDA(1); GET_SDA();//同理 i2c_delay(1); for(i=0; i&lt;8; i++) &#123; SCL(1); i2c_delay(1); data = data&lt;&lt;1; if(GET_SDA()) data |= 0x01; SCL(0); i2c_delay(1); &#125; SCL(1);//再给eeprom的ack提供一个时钟周期 i2c_delay(1); SCL(0); i2c_delay(1); return data;&#125;static void eeprom_write_protect(char x)&#123; if(x) GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;7); else GPIO3-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;7);&#125;void eeprom_write(unsigned char addr, unsigned char data)&#123; eeprom_write_protect(0); i2c_start(); i2c_write(0xA0); while(i2c_ack()); i2c_write(addr&gt;&gt;8); while(i2c_ack()); i2c_write(addr); while(i2c_ack()); i2c_write(data); while(i2c_ack()); i2c_stop(); eeprom_write_protect(1);&#125;unsigned char eeprom_read(unsigned char addr)&#123; unsigned char data = 0; eeprom_write_protect(0); i2c_start(); i2c_write(0xA0); while(i2c_ack()); i2c_write(addr&gt;&gt;8); while(i2c_ack()); i2c_write(addr); while(i2c_ack()); i2c_stop(); i2c_delay(10); i2c_start(); i2c_write(0xA1); while(i2c_ack()); data = i2c_read(); i2c_stop(); eeprom_write_protect(1); return data;&#125;#endif#ifdef REG_I2Cvoid i2c0_irq(void)&#123; unsigned int status = 0; status = I2C0-&gt;IRQSTS; I2C0-&gt;IRQSTS = (status &amp; (0x01&lt;&lt;3 | 0x01&lt;&lt;4)); if(status &amp; (0x01&lt;&lt;3))//receive &#123; I2C0-&gt;IRQSTS |= (0x01&lt;&lt;3); if(r_count == num) &#123; I2C0-&gt;IRQEN_CLR |= (0x01&lt;&lt;3); I2C0-&gt;CON |= (0x01&lt;&lt;1);//stop &#125; else &#123; data_from_slave[r_count++] = (unsigned char)I2C0-&gt;DATA; &#125; &#125; if (status &amp; (0x01&lt;&lt;4))//send &#123; I2C0-&gt;DATA = data_to_slave[t_count++]; I2C0-&gt;IRQSTS |= (0x01&lt;&lt;4); if(t_count == num) &#123; I2C0-&gt;IRQEN_CLR |= (0x01&lt;&lt;4); &#125; &#125;&#125;void eeprom_write_protect(char x)&#123; if(x) GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;7); else GPIO3-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;7);&#125;static unsigned int i2c_master_bus_busy(void)&#123; if(I2C0-&gt;IRQSTS_RAW &amp; (0x01&lt;&lt;12)) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;unsigned char eeprom_read(unsigned char addr)&#123; unsigned char data = 0; eeprom_write_protect(0); data_to_slave[0] = addr&gt;&gt;8; data_to_slave[1] = (addr &amp; 0xFF); t_count = 0; r_count = 0; I2C0-&gt;CNT = 0x02; num = I2C0-&gt;CNT; I2C0-&gt;IRQSTS |= 0x7FFF; I2C0-&gt;IRQEN_CLR |= 0x6FFF; I2C0-&gt;CON |= (0x01&lt;&lt;9 | 0x01&lt;&lt;10 | 0x01&lt;&lt;15); //MST=1 TRX=1 I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;4); I2C0-&gt;CON |= (0x01&lt;&lt;0); while(i2c_master_bus_busy() == 0); while(t_count != num); while(!(I2C0-&gt;IRQSTS_RAW &amp; (0x01&lt;&lt;2)));//----------------------------------------------------------------// I2C0-&gt;CNT = 0x01; num = I2C0-&gt;CNT; I2C0-&gt;IRQSTS |= 0x7FFF; I2C0-&gt;IRQEN_CLR |= 0x6FFF; I2C0-&gt;CON |= (0x01&lt;&lt;10 | (0x01&lt;&lt;15)); I2C0-&gt;CON &amp;= ~(0x01&lt;&lt;9); I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;3 | 0x01&lt;&lt;8); I2C0-&gt;CON |= (0x01&lt;&lt;0); while(i2c_master_bus_busy() == 0); while(r_count != num); data = data_from_slave[0]; eeprom_write_protect(1); return data;&#125;void eeprom_write(unsigned char addr, unsigned char data)&#123; eeprom_write_protect(0); data_to_slave[0] = addr&gt;&gt;8; data_to_slave[1] = (addr &amp; 0xFF); data_to_slave[2] = data; t_count = 0; I2C0-&gt;CNT = 0x03; num = I2C0-&gt;CNT; I2C0-&gt;IRQSTS |= 0x7FFF; I2C0-&gt;IRQEN_CLR |= 0x7FFF; I2C0-&gt;CON |= (0x01&lt;&lt;9 | 0x01&lt;&lt;10 | 0x01&lt;&lt;15); //MST=1 TRX=1 I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;4); I2C0-&gt;CON |= (0x01&lt;&lt;0); while(i2c_master_bus_busy() == 0); while(t_count != num); I2C0-&gt;CON |= (0x01&lt;&lt;1); //stop eeprom_write_protect(1);&#125;static void i2c_gpio_init(void)&#123; PRCM_CM_WKUP_I2C0_CLKCTRL |= (0x02&lt;&lt;0); PRCM_CM_WKUP_CLKSTCTRL |= (0x01&lt;&lt;14); PRCM_CM_PER_L4LS_CLKSTCTRL|= (0x01&lt;&lt;27); PRCM_CM_PER_GPIO3_CLKCTRL |= (0x02&lt;&lt;0); //gpio3_5-&gt;I2C0_SDA;gpio3_6-&gt;I2C0_SCL;gpio3_7-&gt;WP CTRL_CONF_I2C0_SDA &amp;= ~(0x07&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;19); CTRL_CONF_I2C0_SCL &amp;= ~(0x07&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;19); //CTRL_CONF_EMU0 GPIO3-&gt;OE &amp;= ~(0x01&lt;&lt;7); GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;7);&#125;void i2c_init(void)&#123; i2c_gpio_init(); register_irq(IRQ_I2C0, i2c0_irq); interrupt_init(IRQ_I2C0); I2C0-&gt;CON &amp;= ~(0x01&lt;&lt;15);//reset I2C0-&gt;SYSC &amp;= ~(0x01&lt;&lt;0);//Auto Idle disabled. I2C0-&gt;PSC = 3;//the module divided by (PSC + 1) -&gt; 48M/(3+1)=12M I2C0-&gt;SCLL = 63;//tLOW = (SCLL + 7) * ICLK time period I2C0-&gt;SCLH = 65;//tHIGH = (SCLH + 5) * ICLK time period I2C0-&gt;SA = 0x50;//Slave address.1010 000 I2C0-&gt;CON |= (0x01&lt;&lt;15);//Module enabled &#125;void debug_i2c(char *str)&#123; printf(\"-------------------------%s---------------------------\\r\\n\",str); printf(\"I2C0-&gt;REVNB_HI = 0x%x\\r\\n\",I2C0-&gt;REVNB_HI ); printf(\"I2C0-&gt;REVNB_LO = 0x%x\\r\\n\",I2C0-&gt;REVNB_LO ); printf(\"I2C0-&gt;REVNB_HI = 0x%x\\r\\n\",I2C0-&gt;REVNB_HI ); printf(\"I2C0-&gt;SYSC = 0x%x\\r\\n\",I2C0-&gt;SYSC ); printf(\"I2C0-&gt;IRQSTS_RAW = 0x%x\\r\\n\",I2C0-&gt;IRQSTS_RAW ); printf(\"I2C0-&gt;IRQSTS = 0x%x\\r\\n\",I2C0-&gt;IRQSTS ); printf(\"I2C0-&gt;IRQEN_SET = 0x%x\\r\\n\",I2C0-&gt;IRQEN_SET ); printf(\"I2C0-&gt;IRQEN_CLR = 0x%x\\r\\n\",I2C0-&gt;IRQEN_CLR ); printf(\"I2C0-&gt;WE = 0x%x\\r\\n\",I2C0-&gt;WE ); printf(\"I2C0-&gt;DMARXEN_SET = 0x%x\\r\\n\",I2C0-&gt;DMARXEN_SET ); printf(\"I2C0-&gt;DMATXEN_SET = 0x%x\\r\\n\",I2C0-&gt;DMATXEN_SET ); printf(\"I2C0-&gt;DMARXEN_CLR = 0x%x\\r\\n\",I2C0-&gt;DMARXEN_CLR ); printf(\"I2C0-&gt;DMATXEN_CLR = 0x%x\\r\\n\",I2C0-&gt;DMATXEN_CLR ); printf(\"I2C0-&gt;DMARXWAKE_EN= 0x%x\\r\\n\",I2C0-&gt;DMARXWAKE_EN); printf(\"I2C0-&gt;DMATXWAKE_EN= 0x%x\\r\\n\",I2C0-&gt;DMATXWAKE_EN); printf(\"I2C0-&gt;SYSS = 0x%x\\r\\n\",I2C0-&gt;SYSS ); printf(\"I2C0-&gt;BUF = 0x%x\\r\\n\",I2C0-&gt;BUF ); printf(\"I2C0-&gt;CNT = 0x%x\\r\\n\",I2C0-&gt;CNT ); printf(\"I2C0-&gt;DATA = 0x%x\\r\\n\",I2C0-&gt;DATA ); printf(\"I2C0-&gt;CON = 0x%x\\r\\n\",I2C0-&gt;CON ); printf(\"I2C0-&gt;OA = 0x%x\\r\\n\",I2C0-&gt;OA ); printf(\"I2C0-&gt;SA = 0x%x\\r\\n\",I2C0-&gt;SA ); printf(\"I2C0-&gt;PSC = 0x%x\\r\\n\",I2C0-&gt;PSC ); printf(\"I2C0-&gt;SCLL = 0x%x\\r\\n\",I2C0-&gt;SCLL ); printf(\"I2C0-&gt;SCLH = 0x%x\\r\\n\",I2C0-&gt;SCLH ); printf(\"I2C0-&gt;SYSTEST = 0x%x\\r\\n\",I2C0-&gt;SYSTEST ); printf(\"I2C0-&gt;BUFSTAT = 0x%x\\r\\n\",I2C0-&gt;BUFSTAT ); printf(\"I2C0-&gt;OA1 = 0x%x\\r\\n\",I2C0-&gt;OA1 ); printf(\"I2C0-&gt;OA2 = 0x%x\\r\\n\",I2C0-&gt;OA2 ); printf(\"I2C0-&gt;OA3 = 0x%x\\r\\n\",I2C0-&gt;OA3 ); printf(\"I2C0-&gt;ACTOA = 0x%x\\r\\n\",I2C0-&gt;ACTOA ); printf(\"I2C0-&gt;SBLOCK = 0x%x\\r\\n\",I2C0-&gt;SBLOCK ); printf(\"******************************************************\\r\\n\");&#125;#endif [i2c.h]link12345678910111213141516171819202122232425262728293031323334#ifndef __I2C_H__#define __I2C_H__#define GPIO_I2C//#define REG_I2C#ifdef GPIO_I2Cextern void i2c_init(void);extern void eeprom_write(unsigned char addr, unsigned char data);extern unsigned char eeprom_read(unsigned char addr);#endif#ifdef REG_I2Cvolatile unsigned int t_count;volatile unsigned int r_count;volatile unsigned int num;volatile unsigned char data_to_slave[5];volatile unsigned char data_from_slave[5];extern void i2c_init(void);extern unsigned char eeprom_read(unsigned char addr);extern void eeprom_write(unsigned char addr, unsigned char data);extern void debug_i2c(char *str);#endif#endif 4.心得GPIO模拟I2C优势是通用性高，移植方便。利用SOC自带的I2C控制的优势是稳定，高效。 GPIO模拟I2C需要对时序的每个细节都比较清楚才行，非常适合去理解I2C的原理。硬件I2C几乎不需要考虑时序，按逻辑设置和读取相关寄存器即可。还有一个重要的点是去看从机I2C设备的时序，不同的设备，可能会不一样的。下一步，终于要开始I2C的驱动了~~~ 整个过程，最大的功臣就是逻辑分析仪，太好用了😀 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"AM437X","slug":"AM437X","permalink":"http://yoursite.com/tags/AM437X/"},{"name":"裸机","slug":"裸机","permalink":"http://yoursite.com/tags/裸机/"}]},{"title":"AM437x——RTC驱动","date":"2017-08-27T08:47:02.000Z","path":"2017/08/27/AM437x——RTC驱动/","text":"本文主要记录AM437X驱动的RTC。包含一个不标准的RTC驱动、一个还算有点标准的RTC驱动，以及正常的测试方式。 0.本次关于驱动的新收获写RTC驱动的时候，我先尝试的按标准的RTC框架来，写着写着，我想试试之前的一个猜想。理论上任何字符驱动，我都可以通过填充file_operations里面的函数，实现对硬件的操作控制。也就是说，写完裸机程序，按之前LED那套标准的字符驱动框架去写驱动，在应用层通过open()等函数去操作/dev/下的设备，是万能的。实际上RTC驱动也是这样做的，但因为RTC的特殊性，内核提供的是rtc_class_ops这个结构体，而不是file_operations。正常所需做的就是去填充rtc_class_ops的函数，然后注册等。想想这两个的区别，前面万能那个，应用层就没那么好受了，不通用，比如使用hwclock是不能调用到驱动函数的，因此需要自己去实现去RTC的访问，就像访问LED驱动一样。后面标准RTC那个，其最后的实质、原理是一样的，只是提供了统一的框架，增强了通用性。 1.不标准的RTC驱动1.1入口函数和出口函数先是入口函数，在insmod驱动的时候调用，分配了主设备号，注册了字符设备驱动，创建了个类，使用cdev机制，自动在/dev/目录下创建设备，应用层就是通过对这个设备操作，调用驱动实现对硬件的操作。再申请了内存，映射了寄存器地址，后面对这些映射出来的寄存器操作，就实现对硬件层的寄存器操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static int rtc_drv_init(void)&#123; dev_t devid; printk(KERN_INFO\"%s OK.\\n\",__func__); if(alloc_chrdev_region(&amp;devid, 0, TI_RTC_CNT, \"ti_rtc\") &lt; 0) &#123; printk(KERN_INFO\"%s ERROR.\\n\",__func__); goto error; &#125; major = MAJOR(devid); cdev_init(&amp;rtc_cdev, &amp;rtc_fops); cdev_add(&amp;rtc_cdev, devid, TI_RTC_CNT); rtc_cls = class_create(THIS_MODULE, \"ti_rtc\"); device_create(rtc_cls, NULL, MKDEV(major, 0), NULL, \"ti_rts0\"); PRCM_CM_RTC_CLKSTCTRL = ioremap(0x44DF8500+0x00, 0x04*1); PRCM_CM_RTC_CLKCTRL = ioremap(0x44DF8500+0x20, 0x04*1); RTCSS_BASE = ioremap(0x44E3E000, 0xA0); RTCSS_SECONDS = RTCSS_BASE + 0; RTCSS_MINUTES = RTCSS_BASE + 1; RTCSS_HOURS = RTCSS_BASE + 2; RTCSS_DAYS = RTCSS_BASE + 3; RTCSS_WEEKS = RTCSS_BASE + 4; RTCSS_MONTHS = RTCSS_BASE + 5; RTCSS_YEARS = RTCSS_BASE + 6; RTCSS_ALARM_SECONDS = RTCSS_BASE + 8; RTCSS_ALARM_MINUTES = RTCSS_BASE + 9; RTCSS_ALARM_HOURS = RTCSS_BASE + 10; RTCSS_ALARM_DAYS = RTCSS_BASE + 11; RTCSS_ALARM_MONTHS = RTCSS_BASE + 12; RTCSS_ALARM_YEARS = RTCSS_BASE + 13; RTCSS_CTRL = RTCSS_BASE + 15; RTCSS_OSC = RTCSS_BASE + 20; RTCSS_KICK0R = RTCSS_BASE + 25; RTCSS_KICK1R = RTCSS_BASE + 26; error: unregister_chrdev_region(MKDEV(major, 0), TI_RTC_CNT); return 0;&#125; 然后是出口函数，注册做什么，这里就反过来做什么。清除设备，清除类，注销字符设备，释放映射的内存。1234567891011121314151617static void rtc_drv_exit(void)&#123; unsigned i; printk(KERN_INFO\"%s OK.\\n\",__func__); for(i=0;i&lt;TI_RTC_CNT;i++) &#123; device_destroy(rtc_cls, MKDEV(major, i)); &#125; class_destroy(rtc_cls); cdev_del(&amp;rtc_cdev); unregister_chrdev(major, \"ti_rtc\"); iounmap(PRCM_CM_RTC_CLKSTCTRL); iounmap(PRCM_CM_RTC_CLKCTRL); iounmap(RTCSS_BASE); &#125; 修饰下入口函数和出口函数，让这两个普通函数，能够通过insmod加载的时候被调用。以及对该添加版权信息，驱动信息等。12345678module_init(rtc_drv_init);module_exit(rtc_drv_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am437x board rtc drvice\");MODULE_ALIAS(\"character device:ti_rtc\");MODULE_VERSION(\"V1.0\"); 1.2填充构造函数这里添加构造函数，需要什么，加什么，加了之后，再去实现，应用层就是调用到这些函数的功能。这里只打开设备、读取和设置时间操作。123456static struct file_operations rtc_fops = &#123; .owner = THIS_MODULE, .open = rtc_drv_open, .read = rtc_drv_read_time, .write = rtc_drv_set_time, &#125;; 1.3实现构造函数现在去实现构造函数。这部分和裸机的操作是一摸一样的，在open()函数里进行初始化，在read()函数里对寄存器(映射后的)进行读取，传输给应用层。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct rtc_struct &#123; int year; int month; //int week; int day; int hour; int minute; int second;&#125;;static int rtc_drv_open(struct inode *inode, struct file *file)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); *PRCM_CM_RTC_CLKCTRL &amp;= ~(0x03&lt;&lt;0); *PRCM_CM_RTC_CLKCTRL |= (0x01&lt;&lt;1); *PRCM_CM_RTC_CLKSTCTRL &amp;= ~(0x03&lt;&lt;0); *RTCSS_CTRL &amp;= ~(0x01&lt;&lt;6); *RTCSS_KICK0R = (0x83E70B13); *RTCSS_KICK1R = (0x95A4F1E0); *RTCSS_OSC &amp;= ~(0x01&lt;&lt;3); *RTCSS_OSC |= (0x01&lt;&lt;6); *RTCSS_CTRL |= (0x01&lt;&lt;0); return 0; &#125;static ssize_t rtc_drv_read_time(struct file *file, char __user *user_buf, size_t size, loff_t *ppos)&#123; struct rtc_struct rtc_time; printk(KERN_INFO\"%s OK.\\n\",__func__); rtc_time.year = (((*RTCSS_YEARS &amp; (0x03&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_YEARS &amp; (0x0F&lt;&lt;0))); rtc_time.month = (((*RTCSS_MONTHS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_MONTHS &amp; (0x0F&lt;&lt;0))); rtc_time.day = (((*RTCSS_DAYS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_DAYS &amp; (0x0F&lt;&lt;0))); rtc_time.hour = (((*RTCSS_HOURS &amp; (0x03&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_HOURS &amp; (0x0F&lt;&lt;0))); rtc_time.minute = (((*RTCSS_MINUTES &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_MINUTES &amp; (0x0F&lt;&lt;0))); rtc_time.second = (((*RTCSS_SECONDS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_SECONDS &amp; (0x0F&lt;&lt;0))); copy_to_user(user_buf, &amp;rtc_time, sizeof(rtc_time)); return 0; &#125; 接收应用层的数据，写入寄存器(映射后的)，完成对RTC的设置。和裸机的操作，是一摸一样的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static ssize_t rtc_drv_set_time(struct file *file, const char __user *user_buf, size_t count, loff_t * ppos)&#123; struct rtc_struct rtc_time; printk(KERN_INFO\"%s OK.\\n\",__func__); if(count != sizeof(rtc_time))&#123; printk(KERN_INFO\"write count != %d.\\n\",sizeof(rtc_time)); return 1; &#125; if (copy_from_user(&amp;rtc_time, user_buf, count)) return -EFAULT; *RTCSS_CTRL &amp;= ~(0x01&lt;&lt;0);//stop if((rtc_time.year-2000) &gt; 99 || (rtc_time.year-2000) &lt; 0) goto err; if(rtc_time.month &gt; 12 || rtc_time.month &lt; 0) goto err; *RTCSS_MONTHS = ((rtc_time.month/10) &lt;&lt; 4) | ((rtc_time.month%10) &lt;&lt; 0); if(rtc_time.day &gt; 32 || rtc_time.day &lt; 0) goto err; *RTCSS_DAYS = ((rtc_time.day/10) &lt;&lt; 4) | ((rtc_time.day%10) &lt;&lt; 0); if(rtc_time.hour &gt; 23 || rtc_time.hour &lt; 0) goto err; *RTCSS_HOURS = ((rtc_time.hour/10) &lt;&lt; 4) | ((rtc_time.hour%10) &lt;&lt; 0); if(rtc_time.minute &gt; 59 || rtc_time.minute &lt; 0) goto err; *RTCSS_MINUTES = ((rtc_time.minute/10) &lt;&lt; 4) | ((rtc_time.minute%10) &lt;&lt; 0); if(rtc_time.second &gt; 59 || rtc_time.second &lt; 0) goto err; *RTCSS_SECONDS = ((rtc_time.second/10) &lt;&lt; 4) | ((rtc_time.second%10) &lt;&lt; 0); *RTCSS_CTRL |= (0x01&lt;&lt;0);//start return 0; err: printk(KERN_INFO\"rtc_drv_set_time err.\\n\"); return 1; &#125; 1.4完整驱动代码[rtc_drv.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;asm/io.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/cdev.h&gt;#define TI_RTC_CNT 1int major;static struct cdev rtc_cdev;static struct class *rtc_cls;static volatile unsigned long *PRCM_CM_RTC_CLKCTRL = NULL; static volatile unsigned long *PRCM_CM_RTC_CLKSTCTRL = NULL; static volatile unsigned long *RTCSS_BASE = NULL;static volatile unsigned long *RTCSS_CTRL = NULL;static volatile unsigned long *RTCSS_KICK0R = NULL;static volatile unsigned long *RTCSS_KICK1R = NULL; static volatile unsigned long *RTCSS_OSC = NULL;static volatile unsigned long *RTCSS_YEARS = NULL; static volatile unsigned long *RTCSS_MONTHS = NULL;static volatile unsigned long *RTCSS_WEEKS = NULL; static volatile unsigned long *RTCSS_DAYS = NULL;static volatile unsigned long *RTCSS_HOURS = NULL; static volatile unsigned long *RTCSS_MINUTES = NULL;static volatile unsigned long *RTCSS_SECONDS = NULL; static volatile unsigned long *RTCSS_ALARM_YEARS = NULL; static volatile unsigned long *RTCSS_ALARM_MONTHS = NULL; static volatile unsigned long *RTCSS_ALARM_DAYS = NULL;static volatile unsigned long *RTCSS_ALARM_HOURS = NULL; static volatile unsigned long *RTCSS_ALARM_MINUTES = NULL;static volatile unsigned long *RTCSS_ALARM_SECONDS = NULL; struct rtc_struct &#123; int year; int month; //int week; int day; int hour; int minute; int second;&#125;;static int rtc_drv_open(struct inode *inode, struct file *file)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); *PRCM_CM_RTC_CLKCTRL &amp;= ~(0x03&lt;&lt;0); *PRCM_CM_RTC_CLKCTRL |= (0x01&lt;&lt;1); *PRCM_CM_RTC_CLKSTCTRL &amp;= ~(0x03&lt;&lt;0); *RTCSS_CTRL &amp;= ~(0x01&lt;&lt;6); *RTCSS_KICK0R = (0x83E70B13); *RTCSS_KICK1R = (0x95A4F1E0); *RTCSS_OSC &amp;= ~(0x01&lt;&lt;3); *RTCSS_OSC |= (0x01&lt;&lt;6); *RTCSS_CTRL |= (0x01&lt;&lt;0); return 0; &#125;static ssize_t rtc_drv_read_time(struct file *file, char __user *user_buf, size_t size, loff_t *ppos)&#123; struct rtc_struct rtc_time; printk(KERN_INFO\"%s OK.\\n\",__func__); rtc_time.year = (((*RTCSS_YEARS &amp; (0x03&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_YEARS &amp; (0x0F&lt;&lt;0))); rtc_time.month = (((*RTCSS_MONTHS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_MONTHS &amp; (0x0F&lt;&lt;0))); rtc_time.day = (((*RTCSS_DAYS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_DAYS &amp; (0x0F&lt;&lt;0))); rtc_time.hour = (((*RTCSS_HOURS &amp; (0x03&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_HOURS &amp; (0x0F&lt;&lt;0))); rtc_time.minute = (((*RTCSS_MINUTES &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_MINUTES &amp; (0x0F&lt;&lt;0))); rtc_time.second = (((*RTCSS_SECONDS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_SECONDS &amp; (0x0F&lt;&lt;0))); copy_to_user(user_buf, &amp;rtc_time, sizeof(rtc_time)); return 0; &#125;static ssize_t rtc_drv_set_time(struct file *file, const char __user *user_buf, size_t count, loff_t * ppos)&#123; struct rtc_struct rtc_time; printk(KERN_INFO\"%s OK.\\n\",__func__); if(count != sizeof(rtc_time))&#123; printk(KERN_INFO\"write count != %d.\\n\",sizeof(rtc_time)); return 1; &#125; if (copy_from_user(&amp;rtc_time, user_buf, count)) return -EFAULT; *RTCSS_CTRL &amp;= ~(0x01&lt;&lt;0);//stop if((rtc_time.year-2000) &gt; 99 || (rtc_time.year-2000) &lt; 0) goto err; if(rtc_time.month &gt; 12 || rtc_time.month &lt; 0) goto err; *RTCSS_MONTHS = ((rtc_time.month/10) &lt;&lt; 4) | ((rtc_time.month%10) &lt;&lt; 0); if(rtc_time.day &gt; 32 || rtc_time.day &lt; 0) goto err; *RTCSS_DAYS = ((rtc_time.day/10) &lt;&lt; 4) | ((rtc_time.day%10) &lt;&lt; 0); if(rtc_time.hour &gt; 23 || rtc_time.hour &lt; 0) goto err; *RTCSS_HOURS = ((rtc_time.hour/10) &lt;&lt; 4) | ((rtc_time.hour%10) &lt;&lt; 0); if(rtc_time.minute &gt; 59 || rtc_time.minute &lt; 0) goto err; *RTCSS_MINUTES = ((rtc_time.minute/10) &lt;&lt; 4) | ((rtc_time.minute%10) &lt;&lt; 0); if(rtc_time.second &gt; 59 || rtc_time.second &lt; 0) goto err; *RTCSS_SECONDS = ((rtc_time.second/10) &lt;&lt; 4) | ((rtc_time.second%10) &lt;&lt; 0); *RTCSS_CTRL |= (0x01&lt;&lt;0);//start return 0; err: printk(KERN_INFO\"rtc_drv_set_time err.\\n\"); return 1; &#125;static struct file_operations rtc_fops = &#123; .owner = THIS_MODULE, .open = rtc_drv_open, .read = rtc_drv_read_time, .write = rtc_drv_set_time, &#125;;static int rtc_drv_init(void)&#123; dev_t devid; printk(KERN_INFO\"%s OK.\\n\",__func__); if(alloc_chrdev_region(&amp;devid, 0, TI_RTC_CNT, \"ti_rtc\") &lt; 0) &#123; printk(KERN_INFO\"%s ERROR.\\n\",__func__); goto error; &#125; major = MAJOR(devid); cdev_init(&amp;rtc_cdev, &amp;rtc_fops); cdev_add(&amp;rtc_cdev, devid, TI_RTC_CNT); rtc_cls = class_create(THIS_MODULE, \"ti_rtc\"); device_create(rtc_cls, NULL, MKDEV(major, 0), NULL, \"ti_rts0\"); PRCM_CM_RTC_CLKSTCTRL = ioremap(0x44DF8500+0x00, 0x04*1); PRCM_CM_RTC_CLKCTRL = ioremap(0x44DF8500+0x20, 0x04*1); RTCSS_BASE = ioremap(0x44E3E000, 0xA0); RTCSS_SECONDS = RTCSS_BASE + 0; RTCSS_MINUTES = RTCSS_BASE + 1; RTCSS_HOURS = RTCSS_BASE + 2; RTCSS_DAYS = RTCSS_BASE + 3; RTCSS_WEEKS = RTCSS_BASE + 4; RTCSS_MONTHS = RTCSS_BASE + 5; RTCSS_YEARS = RTCSS_BASE + 6; RTCSS_ALARM_SECONDS = RTCSS_BASE + 8; RTCSS_ALARM_MINUTES = RTCSS_BASE + 9; RTCSS_ALARM_HOURS = RTCSS_BASE + 10; RTCSS_ALARM_DAYS = RTCSS_BASE + 11; RTCSS_ALARM_MONTHS = RTCSS_BASE + 12; RTCSS_ALARM_YEARS = RTCSS_BASE + 13; RTCSS_CTRL = RTCSS_BASE + 15; RTCSS_OSC = RTCSS_BASE + 20; RTCSS_KICK0R = RTCSS_BASE + 25; RTCSS_KICK1R = RTCSS_BASE + 26; error: unregister_chrdev_region(MKDEV(major, 0), TI_RTC_CNT); return 0;&#125;static void rtc_drv_exit(void)&#123; unsigned i; printk(KERN_INFO\"%s OK.\\n\",__func__); for(i=0;i&lt;TI_RTC_CNT;i++) &#123; device_destroy(rtc_cls, MKDEV(major, i)); &#125; class_destroy(rtc_cls); cdev_del(&amp;rtc_cdev); unregister_chrdev(major, \"ti_rtc\"); iounmap(PRCM_CM_RTC_CLKSTCTRL); iounmap(PRCM_CM_RTC_CLKCTRL); iounmap(RTCSS_BASE); &#125;module_init(rtc_drv_init);module_exit(rtc_drv_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am437x board rtc drvice\");MODULE_ALIAS(\"character device:ti_rtc\");MODULE_VERSION(\"V1.0\"); 1.5测试程序及效果[rtc_app.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#define msleep(x) usleep(x*1000)/* * ./rtc_app w 2017 08 25 18 36 20 * ./rtc_app r [times]*/struct rtc_struct &#123; int year; int month; //int week; int day; int hour; int minute; int second;&#125;;struct rtc_struct set_time, rtc_time;int main(int argc, char **argv)&#123; int fd; int i; fd = open(\"/dev/ti_rts0\", O_RDWR); if (fd &lt; 0) &#123; printf(\"can't open /dev/ti_rts0.\\n\"); return 0; &#125; if(strcmp(argv[1], \"w\") == 0 &amp;&amp; argc == 8) &#123; set_time.year = atoi(argv[2]); set_time.month = atoi(argv[3]); set_time.day = atoi(argv[4]); set_time.hour = atoi(argv[5]); set_time.minute = atoi(argv[6]); set_time.second = atoi(argv[7]); write(fd, &amp;set_time, sizeof(set_time)); printf(\"write ok\\n\"); &#125; else if(strcmp(argv[1], \"r\") == 0) &#123; if(argv[2] == NULL) i = 999; else i = atoi(argv[2]); do&#123; read(fd, &amp;rtc_time, sizeof(rtc_time)); printf(\"\\n\\rcurrent_time is:\\n\\r\\%d-%d-%d %d:%d:%d\\n\\r\",\\ rtc_time.year+2000,rtc_time.month,rtc_time.day,rtc_time.hour,rtc_time.minute,rtc_time.second); printf(\"read ok\\n\"); msleep(1000); i--; &#125; while(i); &#125; close(fd); return 0;&#125; 这里除了年，其它都还OK，估计是和系统的一些设置冲突了。 2.还算有点标准的RTC驱动本来计划完整的写好RTC驱动的，实际过程中发现ti官方内核的RTC不能关，关了无法正常启动。经验不足，又无法解决这个问题，只能在保持他远样的基础上，能写成什么算什么。大部分框架也算写了，剩下的感觉应该也不难了。这次用的设备驱动模型来写的。由rtc_dev.c和rtc_drv.c组成。 2.1rtc_dev.c首先是在rtc_dev.c中注册平台设备，并设置硬件资源。RTC所需的硬件资源教少，主要是RTC寄存器和中断。12345678910111213141516171819202122static struct resource am437x_rtc_resource[] = &#123; [0] = &#123; .name = \"RTCSS\", .start = 0x44E3E000, .end = 0x44E3EFFF, .flags = IORESOURCE_MEM, &#125;, [1] = &#123; .name = \"RTCINT\", .start = 107, .end = 107, .flags = IORESOURCE_IRQ,//107 &#125;, [2] = &#123; .name = \"RTCALARMINT\", .start = 108, .end = 108, .flags = IORESOURCE_IRQ,//108 &#125;,&#125;; 2.2rtc_drv.crtc_drv.c开始要做的也差不多，注册平台设备。然后两个名字相同，匹配成功后调用probe()函数。这里的probe()先获取rtc_dev.c里面的中断和RTC物理基地址的资源。随即映射RTC基地址。同时初始化RTC。然后注册RTC设备devm_rtc_device_register().这里绑定的是rtc_class_ops，而不是之前的file_operations。这里的rtc_class_ops是为RTC“量身定做”的操作函数，更设备RTC设备。devm_rtc_device_register()里面的操作也是注册字符设备那一套，本质还是一样的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119static struct rtc_class_ops am437x_rtc_ops = &#123; .open = rtc_drv_open, .release = rtc_drv_release, .read_time = rtc_drv_read_time, .set_time = rtc_drv_set_time, .read_alarm = rtc_drv_read_alarm, .set_alarm = rtc_drv_set_alarm, .proc = rtc_drv_proc, .alarm_irq_enable = rtc_drv_alarm_irq_enable, &#125;; static void am437x_rtc_enable(struct platform_device *pdev, int en)&#123; void __iomem *rtc_base = am437x_rtc_base; unsigned int tmp; if (am437x_rtc_base == NULL) return; if (en) &#123; /* Enable the clock/module so that we can access the registers */ pm_runtime_get_sync(&amp;pdev-&gt;dev); //rtc init. tmp = readb(rtc_base + 0x40);//CTRL.Enable the RTC module writew(tmp &amp; ~(0x01&lt;&lt;6), rtc_base + 0x40); writel(0x83E70B13, rtc_base + 0x6C);//KICK0R.Write Project Disable writel(0x95A4F1E0, rtc_base + 0x70);//KICK1R tmp = readb(rtc_base + 0x54);//OSC.mode1:Internal clock writew(tmp &amp; ~(0x01&lt;&lt;3), rtc_base + 0x54); tmp = readb(rtc_base + 0x54); writew(tmp | (0x01&lt;&lt;6), rtc_base + 0x54); tmp = readb(rtc_base + 0x40);//run. writew(tmp | (0x01&lt;&lt;0), rtc_base + 0x40); &#125; else &#123; tmp = readb(rtc_base + 0x40);//stop. writew(tmp &amp; ~(0x01&lt;&lt;0), rtc_base + 0x40); tmp = readb(rtc_base + 0x40);//CTRL.Disable the RTC module writew(tmp | (0x01&lt;&lt;6), rtc_base + 0x40); /* Disable the clock/module */ pm_runtime_put_sync(&amp;pdev-&gt;dev); &#125;&#125;struct resource *am437x_rtc_mem;static int am437x_rtc_probe(struct platform_device *pdev) &#123; struct resource *res; int ret; printk(KERN_INFO\"%s OK.\\n\",__func__); /* find the IRQs */ am437x_rtc_timer_irq = platform_get_irq(pdev, 0); if (am437x_rtc_timer_irq &lt; 0) &#123; dev_err(&amp;pdev-&gt;dev, \"no irq for rtc tick\\n\"); return am437x_rtc_timer_irq; &#125; am437x_rtc_alarm_irq = platform_get_irq(pdev, 1); if (am437x_rtc_alarm_irq &lt; 0) &#123; dev_err(&amp;pdev-&gt;dev, \"no irq for alarm\\n\"); return am437x_rtc_alarm_irq; &#125; dev_dbg(&amp;pdev-&gt;dev, \"am437x_rtc: tick irq %d, alarm irq %d\\n\", am437x_rtc_timer_irq, am437x_rtc_alarm_irq); /*RTC*/ res = platform_get_resource(pdev, IORESOURCE_MEM, 0); if(res == NULL)&#123; dev_err(&amp;pdev-&gt;dev, \"RTC:failed to get memory regin resource.\\n\"); return -ENOENT; &#125; am437x_rtc_mem = request_mem_region(res-&gt;start, res-&gt;end - res-&gt;start+1, pdev-&gt;name); if (am437x_rtc_mem == NULL)&#123; dev_err(&amp;pdev-&gt;dev, \"RTC:failed to reserve memory region.\\n\"); return -ENOENT; goto err_nores; &#125; am437x_rtc_base = ioremap(res-&gt;start, res-&gt;end - res-&gt;start+1); if (am437x_rtc_mem == NULL)&#123; dev_err(&amp;pdev-&gt;dev, \"RTC:failed ioremap.\\n\"); return -EINVAL; goto err_nomap; &#125; am437x_rtc_enable(pdev, 1); rtc = devm_rtc_device_register(&amp;pdev-&gt;dev, pdev-&gt;name,&amp;am437x_rtc_ops, THIS_MODULE); if (IS_ERR(rtc)) &#123; pr_debug(\"%s: can't register RTC device, err %ld\\n\",pdev-&gt;name, PTR_ERR(rtc)); goto err_nortc; &#125; return 0; err_nortc: am437x_rtc_enable(pdev, 0); iounmap(am437x_rtc_base); err_nomap: release_resource(am437x_rtc_mem); err_nores: return ret;&#125; 然后是填充rtc_class_ops里面的操作函数，open()本来计划用来申请中断的，但申请的时候说被占用了，还是之前没有去掉内核RTC的原因。这里就先屏蔽了。read_time()和set_time()里面还是读取/设置寄存器。alarm的也差不多，没有中断，就先搁置了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143static int rtc_drv_open(struct device *dev)&#123; struct platform_device *pdev = to_platform_device(dev); struct rtc_device *rtc_dev = platform_get_drvdata(pdev); int ret; printk(KERN_INFO\"%s OK.\\n\",__func__);/* if (devm_request_irq(&amp;pdev-&gt;dev, am437x_rtc_timer_irq, rtc_irq, 0, dev_name(&amp;rtc-&gt;dev), rtc)) &#123; pr_debug(\"%s: RTC timer interrupt IRQ%d already claimed\\n\",pdev-&gt;name, am437x_rtc_timer_irq); goto fail0; &#125; if ((am437x_rtc_timer_irq != am437x_rtc_alarm_irq) &amp;&amp; (devm_request_irq(&amp;pdev-&gt;dev, am437x_rtc_alarm_irq, rtc_irq, 0, dev_name(&amp;rtc-&gt;dev), rtc))) &#123; pr_debug(\"%s: RTC alarm interrupt IRQ%d already claimed\\n\",pdev-&gt;name, am437x_rtc_alarm_irq); goto fail0; &#125;*/ return 0;fail0: return -EIO;&#125;static int rtc_drv_release(struct device *dev)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); return 0;&#125;static int tm2bcd(struct rtc_time *tm)&#123; if (rtc_valid_tm(tm) != 0) return -EINVAL; tm-&gt;tm_sec = bin2bcd(tm-&gt;tm_sec); tm-&gt;tm_min = bin2bcd(tm-&gt;tm_min); tm-&gt;tm_hour = bin2bcd(tm-&gt;tm_hour); tm-&gt;tm_mday = bin2bcd(tm-&gt;tm_mday); tm-&gt;tm_mon = bin2bcd(tm-&gt;tm_mon + 1); /* epoch == 1900 */ if (tm-&gt;tm_year &lt; 100 || tm-&gt;tm_year &gt; 199) return -EINVAL; tm-&gt;tm_year = bin2bcd(tm-&gt;tm_year - 100); return 0;&#125;static void bcd2tm(struct rtc_time *tm)&#123; tm-&gt;tm_sec = bcd2bin(tm-&gt;tm_sec); tm-&gt;tm_min = bcd2bin(tm-&gt;tm_min); tm-&gt;tm_hour = bcd2bin(tm-&gt;tm_hour); tm-&gt;tm_mday = bcd2bin(tm-&gt;tm_mday); tm-&gt;tm_mon = bcd2bin(tm-&gt;tm_mon) - 1; /* epoch == 1900 */ tm-&gt;tm_year = bcd2bin(tm-&gt;tm_year) + 2000;&#125;static void rtc_wait_not_busy(void)&#123; int count = 0; u8 status; /* BUSY may stay active for 1/32768 second (~30 usec) */ for (count = 0; count &lt; 50; count++) &#123; status = readb(am437x_rtc_base + 0x44);//STS if ((status &amp; (0x01&lt;&lt;0)) == 0) break; udelay(1); &#125; /* now we have ~15 usec to read/write various registers */&#125;static int rtc_drv_read_time(struct device *dev, struct rtc_time *rtc_t)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); //local_irq_disable(); rtc_wait_not_busy(); rtc_t-&gt;tm_sec = readb(am437x_rtc_base + 0x00); rtc_t-&gt;tm_min = readb(am437x_rtc_base + 0x04); rtc_t-&gt;tm_hour = readb(am437x_rtc_base + 0x08); rtc_t-&gt;tm_mday = readb(am437x_rtc_base + 0x0C); rtc_t-&gt;tm_mon = readb(am437x_rtc_base + 0x10); rtc_t-&gt;tm_year = readb(am437x_rtc_base + 0x14); //local_irq_enable(); bcd2tm(rtc_t); printk(\"\\n\\rcurrent_time is:\\n\\r\\%d-%d-%d %d:%d:%d\\n\\r\",\\ rtc_t-&gt;tm_year,rtc_t-&gt;tm_mon,rtc_t-&gt;tm_mday,rtc_t-&gt;tm_hour,rtc_t-&gt;tm_min,rtc_t-&gt;tm_sec); return 0;&#125;static int rtc_drv_set_time(struct device *dev, struct rtc_time *rtc_t)&#123; if (tm2bcd(rtc_t) &lt; 0) return -EINVAL; //local_irq_disable(); rtc_wait_not_busy(); writeb(rtc_t-&gt;tm_sec, am437x_rtc_base + 0x00); writeb(rtc_t-&gt;tm_min, am437x_rtc_base + 0x04); writeb(rtc_t-&gt;tm_hour, am437x_rtc_base + 0x08); writeb(rtc_t-&gt;tm_mday, am437x_rtc_base + 0x0C); writeb(rtc_t-&gt;tm_mon, am437x_rtc_base + 0x10); writeb(rtc_t-&gt;tm_year, am437x_rtc_base + 0x14); //local_irq_enable(); return 0;&#125;static int rtc_drv_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); return 0;&#125;static int rtc_drv_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); return 0;&#125;static int rtc_drv_proc(struct device *dev, struct seq_file *seq)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); return 0;&#125;static int rtc_drv_alarm_irq_enable(struct device *dev, unsigned int enabled)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); return 0;&#125; 2.3相关代码及测试效果rtc_dev.crtc_drv.c在系统输入hwclock -f /dev/rtc1 3.正常的测试驱动额，虽然没有正常调试出RTC，但还是记下正常调试的方法，万一以后用到了呢。 Linux中有两个时间，一个是系统时间，通过命令date获取；一个是硬件时间，通过命令hwclock获取； RTC驱动的一般测试如下：1.获取系统时间1date 如果时间正常，则进行第2步，如果不正常，修改系统时间为正常时间：1date 082316432017.00 //2017-08-23 16:43:00 2.获取硬件时间1hwclock 由于此处是RTC驱动第一次加载，还没设置正确的时间，所以此时显示的时间，多数是不正确的1970年。 3.同步硬件时间1hwclock -w 第一步设置好了正常的系统时间，现在将系统时间与硬件时间进行同步。 4.自动同步硬件时间现在的系统时间和硬件时间是同步的，如果关机重启，系统时间将不会实时同步，而硬件时间是一直实时同步的，因此需要将硬件时间同步到系统时间。修改启动脚本：etc/init.d/rcS，在最后一行加上：1/sbin/hwclock -s 4.验证重启，检查系统时间和硬件时间是不是实时的。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"AM437X","slug":"AM437X","permalink":"http://yoursite.com/tags/AM437X/"}]},{"title":"AM437x——RTC裸机","date":"2017-08-23T08:46:58.000Z","path":"2017/08/23/AM437x——RTC裸机/","text":"AM437x的RTC模块裸机程序。 0.为什么要RTC在实际开发中，往往需要知道当前的时间，比如现在的2017年8月23日17点02分。由于设备不使用的时候或者遇到故障时，会出现关机操作，而关机的这段时间长短，设备是不知道的，当再次开机时，时间要么被归零，要么显示为关机时的那个时间。 为了同步到现在的实时时间，我能想到两个解决方案。 1.利用网络，从网络中获取当前时间。2.利用一个设备关机仍在计时工作的模块，开机后加上关机的这段时间。 第一个方案，需要网络，对于大多数单片机设备是不现实的，附加的成本太高。第二个方案，就是现在大量使用的RTC，有的集成到SOC里面了，有些仍以外部芯片的形式出现。 在设备关机后，RTC在备用电池（一般是纽扣电池）的支持下，以超低功耗的方式继续默默的工作，直到开机，将时间同步。 这就是RTC存在的主要意义。 1.AM437x的RTCAM437x的RTC介绍在参考手册19章Timers的第4部分：Real-Time Clock (RTC)大致的特性有： 总计数时间为100年； 提供秒、分、小时、星期、日期、月份、年等； 数据以Binary-coded-decimal (BCD)表示； 时钟源可选择内部或外部； 有两个闹钟； 有两种中断：时间中断和闹钟中断； 很良心的有个Use Cases： The following list includes high-level steps to start using the RTC: Enable the module clock domains (for details on which clock domain, see Section 19.4.2, Integration). Enable the RTC module using CTRL_REG.RTC_disable. Enable the 32K clock from PER PLL, if using the internal RTC oscillator. Write to the kick registers (KICK0R, KICK1R) in the RTC. Configure the timer in RTCSS for desired application (set time and date, alarm wakeup, and so on). Start the RTC (in CTRL_REG.STOP_RTC). 基本把配置步骤写得很清楚了。 关于时钟和中断：时钟来自于外部CLKIN32的CLK_32K_RTC或者内部PRCM的CLK_32KHz；可以产生两种中断：timer_intr_pend和alarm_intr_pend。 关于写保护如图中的三个状态，向KICK0和KICK1写入指定的值，即可去写保护。 2.RTC编程本次裸机的目的，是想实现以下两个功能： 设置和读取RTC的时间； 设置和读取RTC闹钟的时间，利用中断打印闹钟； 模块初始化：包含时钟使能、模块使能、时钟源选择、中断注册、使能中断。1234567891011121314151617181920212223242526272829303132333435363738void rtc_init(void)&#123; //1.set performing the System Clock configuration for RTC. PRCM_CM_RTC_CLKCTRL &amp;= ~(0x3&lt;&lt;0); PRCM_CM_RTC_CLKCTRL |= (0x01&lt;&lt;1); PRCM_CM_RTC_CLKSTCTRL &amp;= ~(0x3&lt;&lt;0); //Wait write is completed. while(!(PRCM_CM_RTC_CLKSTCTRL &amp; (0x01&lt;&lt;9 | 0x01&lt;&lt;8))); while(PRCM_CM_RTC_CLKCTRL &amp; (0x03&lt;&lt;16)); //2.Enable the RTC module; RTCSS-&gt;CTRL &amp;= ~(0x01&lt;&lt;6); //3.Write Project Disable; RTCSS-&gt;KICK0R = (0x83E70B13); RTCSS-&gt;KICK1R = (0x95A4F1E0); //4.Set clock Source; //mode1:Internal clock RTCSS-&gt;OSC &amp;= ~(0x01&lt;&lt;3); RTCSS-&gt;OSC |= (0x01&lt;&lt;6); //mode2:External clock //RTCSS-&gt;OSC &amp;= ~(0x01&lt;&lt;3); //RTCSS-&gt;OSC |= (0x01&lt;&lt;6 | 0x01&lt;&lt;3); register_irq(RTCALARMINT, alarm_irq); interrupt_init(RTCALARMINT); //5.Enable interrupt; rtc_int_enalbe(); //6.Run. //rtc_start();&#125; 这里将中断的使能/去能、RTC的启动/停止，分别封装成了函数。12345678910111213141516171819void rtc_start(void)&#123; RTCSS-&gt;CTRL |= (0x01&lt;&lt;0);&#125;void rtc_stop(void)&#123; RTCSS-&gt;CTRL &amp;= ~(0x01&lt;&lt;0);&#125;static void rtc_int_enalbe(void)&#123; RTCSS-&gt;INTRS |= (0x01&lt;&lt;3);//RTC_ALARM1&#125;static void rtc_int_clear(void)&#123; RTCSS-&gt;STS |= (0x01&lt;&lt;6);;//RTC_ALARM1&#125; 设置时间和获取时间：将所有时间参数封装成一个结构体：1234567891011struct rtc_struct &#123; int year; int month; int week; int day; int hour; int minute; int second;&#125;;extern struct rtc_struct rtc_time, rtc_alarm; 设置时间主要是将值分解成BCD的格式：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int set_time(struct rtc_struct rtc_time)&#123; rtc_stop(); if((rtc_time.year-2000) &gt; 99 || (rtc_time.year-2000) &lt; 0) goto err; RTCSS-&gt;YEARS = (((rtc_time.year-2000)/10) &lt;&lt; 4) | (((rtc_time.year-2000)%10) &lt;&lt; 0); if(rtc_time.month &gt; 12 || rtc_time.month &lt; 0) goto err; RTCSS-&gt;MONTHS = ((rtc_time.month/10) &lt;&lt; 4) | ((rtc_time.month%10) &lt;&lt; 0); if(rtc_time.week &gt; 7 || rtc_time.week &lt; 0) //goto err; rtc_time.week = 1; RTCSS-&gt;WEEKS = rtc_time.week; if(rtc_time.day &gt; 32 || rtc_time.day &lt; 0) goto err; RTCSS-&gt;DAYS = ((rtc_time.day/10) &lt;&lt; 4) | ((rtc_time.day%10) &lt;&lt; 0); if(rtc_time.hour &gt; 23 || rtc_time.hour &lt; 0) goto err; RTCSS-&gt;HOURS = ((rtc_time.hour/10) &lt;&lt; 4) | ((rtc_time.hour%10) &lt;&lt; 0); if(rtc_time.minute &gt; 59 || rtc_time.minute &lt; 0) goto err; RTCSS-&gt;MINUTES = ((rtc_time.minute/10) &lt;&lt; 4) | ((rtc_time.minute%10) &lt;&lt; 0); if(rtc_time.second &gt; 59 || rtc_time.second &lt; 0) goto err; RTCSS-&gt;SECONDS = ((rtc_time.second/10) &lt;&lt; 4) | ((rtc_time.second%10) &lt;&lt; 0); rtc_start(); return 0; err: printf(\"set_time err.\\n\\r\"); return 1;&#125;struct rtc_struct get_time(void)&#123; struct rtc_struct current_time; current_time.year = (((RTCSS-&gt;YEARS &amp; (0x03&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;YEARS &amp; (0x0F&lt;&lt;0))); current_time.month = (((RTCSS-&gt;MONTHS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;MONTHS &amp; (0x0F&lt;&lt;0))); current_time.week = ( RTCSS-&gt;WEEKS &amp; (0x0F&lt;&lt;0)); current_time.day = (((RTCSS-&gt;DAYS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;DAYS &amp; (0x0F&lt;&lt;0))); current_time.hour = (((RTCSS-&gt;HOURS &amp; (0x03&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;HOURS &amp; (0x0F&lt;&lt;0))); current_time.minute = (((RTCSS-&gt;MINUTES &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;MINUTES &amp; (0x0F&lt;&lt;0))); current_time.second = (((RTCSS-&gt;SECONDS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;SECONDS &amp; (0x0F&lt;&lt;0))); printf(\"\\n\\rcurrent_time is:\\n\\r\\%d-%d-%d %d:%d:%d\\n\\r\",\\current_time.year+2000,current_time.month,current_time.day,current_time.hour,current_time.minute,current_time.second); return current_time;&#125; 设置闹钟和获取闹钟：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int set_alarm(struct rtc_struct alarm_time)&#123; if((alarm_time.year-2000) &gt; 99 || (alarm_time.year-2000) &lt; 0) goto err; RTCSS-&gt;ALARM_YEARS = (((alarm_time.year-2000)/10) &lt;&lt; 4) | (((alarm_time.year-2000)%10) &lt;&lt; 0); if(alarm_time.month &gt; 12 || alarm_time.month &lt; 0) goto err; RTCSS-&gt;ALARM_MONTHS = ((alarm_time.month/10) &lt;&lt; 4) | ((alarm_time.month%10) &lt;&lt; 0); if(alarm_time.day &gt; 32 || alarm_time.day &lt; 0) goto err; RTCSS-&gt;ALARM_DAYS = ((alarm_time.day/10) &lt;&lt; 4) | ((alarm_time.day%10) &lt;&lt; 0); if(alarm_time.hour &gt; 23 || alarm_time.hour &lt; 0) goto err; RTCSS-&gt;ALARM_HOURS = ((alarm_time.hour/10) &lt;&lt; 4) | ((alarm_time.hour%10) &lt;&lt; 0); if(alarm_time.minute &gt; 59 || alarm_time.minute &lt; 0) goto err; RTCSS-&gt;ALARM_MINUTES = ((alarm_time.minute/10) &lt;&lt; 4) | ((alarm_time.minute%10) &lt;&lt; 0); if(alarm_time.second &gt; 59 || alarm_time.second &lt; 0) goto err; RTCSS-&gt;ALARM_SECONDS = ((alarm_time.second/10) &lt;&lt; 4) | ((alarm_time.second%10) &lt;&lt; 0); return 0; err: printf(\"set_alarm err.\\n\\r\"); return 1;&#125;struct rtc_struct get_alarm(void)&#123; struct rtc_struct alarm_time; alarm_time.year = (((RTCSS-&gt;ALARM_YEARS &amp; (0x03&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;ALARM_YEARS &amp; (0x0F&lt;&lt;0))); alarm_time.month = (((RTCSS-&gt;ALARM_MONTHS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;ALARM_MONTHS &amp; (0x0F&lt;&lt;0))); alarm_time.day = (((RTCSS-&gt;ALARM_DAYS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;ALARM_DAYS &amp; (0x0F&lt;&lt;0))); alarm_time.hour = (((RTCSS-&gt;ALARM_HOURS &amp; (0x03&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;ALARM_HOURS &amp; (0x0F&lt;&lt;0))); alarm_time.minute = (((RTCSS-&gt;ALARM_MINUTES &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;ALARM_MINUTES &amp; (0x0F&lt;&lt;0))); alarm_time.second = (((RTCSS-&gt;ALARM_SECONDS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;ALARM_SECONDS &amp; (0x0F&lt;&lt;0))); printf(\"\\n\\ralarm_time is:\\n\\r\\%d-%d-%d %d:%d:%d\\n\\r\",\\ alarm_time.year+2000,alarm_time.month,alarm_time.day,alarm_time.hour,alarm_time.minute,alarm_time.second); return alarm_time;&#125; 中断服务函数12345void alarm_irq(void)&#123; rtc_int_clear(); printf(\"\\n\\r----------------alarm_irq-----------------\\n\\r\");&#125; 主函数123456789101112131415161718192021222324252627282930313233343536373839404142int main()&#123; rtc_time.year = 2017; rtc_time.month = 8; //rtc_time.week = 1; rtc_time.day = 24; rtc_time.hour = 10; rtc_time.minute = 42; rtc_time.second = 15; rtc_alarm.year = 2017; rtc_alarm.month = 8; rtc_alarm.day = 24; rtc_alarm.hour = 10; rtc_alarm.minute = 42; rtc_alarm.second = 20; uart_init(); printf(\"init ok.\\n\\r\"); gic_init(); timer2_init(); rtc_init(); set_time(rtc_time); set_alarm(rtc_alarm); printf(\"=====set time and alarm is:=====\\n\\r\"); get_time(); get_alarm(); printf(\"================================\\n\\r\"); while(1) &#123; delay_ms(1000); get_time(); &#125; return 0;&#125; 3.实测与源码BUG:上电后，set_alarm()是没问题的，set_time()显示没有设置成功，这时按键复位重启一下，发现这时就设置成功了。 = = ? 源码——&gt;GitHub 4.心得RTC感觉还是比较重要，能够实现得到实时的时间。整个过程，稍微需要注意点的就是BCD的转换，容易弄错。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"AM437X","slug":"AM437X","permalink":"http://yoursite.com/tags/AM437X/"},{"name":"裸机","slug":"裸机","permalink":"http://yoursite.com/tags/裸机/"}]},{"title":"AM437x——LED驱动","date":"2017-08-12T08:06:46.000Z","path":"2017/08/12/AM437x——LED驱动/","text":"本文主要记录AM437X驱动的LED。含简单的字符设备驱动、设备驱动模型、设备树以及LED子系统。 目前就Linux驱动的理解是： Linux驱动 = 裸机 + 框架 关于框架，目前的理解是： 以LED驱动为例，之前印象中就是韦老大的思路，先在init里注册字符设备、硬件初始化，然后应用层open()、read()就调用了file_operations里面的drv_open()、drv_write()等，算是最简单的驱动框架。 然后韦老大又提及了总线设备驱动模型，将设备和驱动分离，慢慢的体会到了新的框架。不久前，简单接触了下设备树，感觉就是总线设备驱动模型的修改（升级），将原来的设备部分，不再单独放在代码里，而是放在dts里面，开机在U-boot加载，然后与驱动匹配获取硬件资源。因此，感觉驱动的框架在一步一步的发展，优化，最原始的注册字符设备、open等框架，还是不变。 同时，了解到了除输入子系统的其它子系统，加深了对这一模式的理解。感觉就是，将某个硬件资源无缝的融入现有的环境中，而无须改变应用层的程序。 这就是目前的一点小小理解吧，算是打开了个入口，希望以后了解得更加全面、细致。 1.搭建开发环境1.1安装TI_SDK先在TI官网下载ti-processor-sdk-linux-am437x-evm-01.00.00.03-Linux-x86-Install.bin在Ubuntu（only Ubuntu 12.04 LTS and Ubuntu 14.04 LTS are supported）下，对该文件加入可执行权限，然后直接运行。安装目录选择默认即可。完成之后，便在当前用户的home目录生成了所有所需文件。 1.2编译内核在当前生成ti-processor-sdk-linux-am437x-evm-01.00.00.03目录下，有个Makefile，打开后可以看到相关的编译选项，如： 编译全部文件：make all 编译内核：make linux 编译u-boot:make u-boot-spl 以及make的依赖：-include Rules.make。在本层目录里，打开Rules.make，可以知道内核的默认配置文件：12#defconfigDEFCONFIG=tisdk_am437x-evm_defconfig 通过查找，tisdk_am437x-evm_defconfig在~/ti-processor-sdk-linux-am437x-evm-01.00.00.03/board-support/linux-3.14.43+gitAUTOINC+875c69b2c3-g875c69b/arch/arm/configs里。这里通过修改该配置文件，然后重新编译内核，即可关闭系统LED相关的驱动，在后面自己写LED驱动时，防止互相干扰。因此将tisdk_am437x-evm_defconfig配置文件里的所有有关LED的配置都关闭掉。 最后在顶层目录执行make linux,编译完成后，生成~/ti-processor-sdk-linux-am437x-evm-01.00.00.03/board-support/linux-3.14.43+gitAUTOINC+875c69b2c3-g875c69b/arch/arm/boot/zImage文件。 1.3烧写SD卡回到~/ti-processor-sdk-linux-am437x-evm-01.00.00.03/bin下，TI制作了很多脚本，其中的create-sdcard.sh就是制作SD卡的。Ubuntu插上SD卡，然后切换成root用户，执行该脚本，根据提示一路选择下去即可。 这里烧写完了，测试发现并没有使用之前编译的内核，分析脚本后发现，该脚本直接使用的~/ti-processor-sdk-linux-am437x-evm-01.00.00.03/filesystem下的tisdk-rootfs-image-am437x-evm.tar.gz。脚本将该文件作为根文件系统放入SD卡，因此并没有使用之前编译的内核。解决方法要么在执行脚本的过程中根据提示输入相关的路径，要么在制作好SD卡后，将编译好的内核覆盖掉SD卡的内核即可。我选择的后者：cp ~/ti-processor-sdk-linux-am437x-evm-01.00.00.03/board-support/linux-3.14.43+gitAUTOINC+875c69b2c3-g875c69b/arch/arm/boot/zImage /media/hceng/rootfs/boot/。 最后将制作好的SD卡插上开发板启动即可。 2.简单的字符驱动先记录下几个重要类型或结构体： 表示设备号(32位机中：高12位表示主设备号，低20位表示次设备号) 1typedef __kernel_dev_t dev_t; 描述字符设备 12345678struct cdev &#123; struct kobject kobj; //内嵌kobject结构体，用于设备驱动模型管理 struct module *owner; //包含指向该结构的模块的指针，用于引用计数 const struct file_operations *ops; //指向字符设备操作函数集的指针 struct list_head list; //该结构将使用该驱动的字符设备连接成一个链表 dev_t dev; //该字符设备的其实设备号，一个设备可能有多个设备号 unsigned int count; //使用该字符设备驱动的设备数量&#125;; 描述类 12345678910111213struct class&#123; const char *name; //类名称 struct module *owner; //对应模块 struct subsystem subsys; //对应的subsystem; struct list_head children; //class_device链表 struct list_head interfaces; //class_interface链表 struct semaphore sem; /用于同步的信号锁 struct class_attribute *class_attrs; //类属性 int (*uevent)(struct class_device *dev,char **envp,int num_envp, char *buffer,int buffer_size); //事件 void (*release)(struct class_device *dev); //释放类设备 void (*class_release)(struct class *class); //释放类&#125; 总结下，目前理解的字符设备编写流程: 1)驱动加载函数：xx_drv_init() 1.1)申请设备号：alloc_chrdev_region() 1.2)cde初始化(绑定fops)：cdev_init() 1.3)注册到内核：cdev_add() 1.4)创建类：class_create() 1.5)向类中添加设备(mdev自动创建设备节点)：device_create() 1.6)硬件相关(内存映射)：ioremap()2)驱动卸载函数：xx_drv_exit() 2.1)移除设备：device_destroy() 2.2)移除类：class_destroy() 2.3)注销cdev：cdev_del() 2.4)释放设备号：unregister_chrdev() 2.5)释放内存：iounmap()3)必要修饰:module_init(xx_drv_init);module_exit(xx_drv_exit);MODULE_LICENSE(&quot;GPL&quot;);4)构造file_operations:struct file_operations xx_drv_fops;5)实现file_operations里每个函数:xx_open()、xx_write()…… 2.1驱动代码[leds_drv.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;asm/io.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/cdev.h&gt;#define TI_LEDS_CNT 4int major;static struct cdev leds_cdev;static struct class *leds_cls;static volatile unsigned long *PRCM_CM_PER_GPIO5_CLKCTRL = NULL; static volatile unsigned long *CTRL_CONF_UART3_RXD = NULL; static volatile unsigned long *CTRL_CONF_UART3_TXD = NULL; static volatile unsigned long *CTRL_CONF_UART3_CTSN = NULL;static volatile unsigned long *CTRL_CONF_UART3_RTSN = NULL;static volatile unsigned long *GPIO_OE = NULL;static volatile unsigned long *GPIO_SETDATAOUT = NULL;static volatile unsigned long *GPIO_DATAOUT = NULL; static int leds_drv_open(struct inode *inode, struct file *file) &#123; int minor = iminor(file-&gt;f_inode); printk(KERN_INFO\"%s OK.\\n\",__func__); *PRCM_CM_PER_GPIO5_CLKCTRL = (0x01&lt;&lt;1); *CTRL_CONF_UART3_RXD &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18); *CTRL_CONF_UART3_RXD |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17); *GPIO_OE &amp;= ~(0x01&lt;&lt;minor); *GPIO_SETDATAOUT |= (0x01&lt;&lt;minor); return 0; &#125; static ssize_t leds_drv_write(struct file *file, const char __user *user_buf, size_t count, loff_t * ppos) &#123; int minor = iminor(file-&gt;f_inode); char buf; printk(KERN_INFO\"%s OK.\\n\",__func__); if(count != 1)&#123; printk(KERN_INFO\"write count != 1.\\n\"); return 1; &#125; if (copy_from_user(&amp;buf, user_buf, count)) return -EFAULT; if (0x01 == buf) *GPIO_DATAOUT |= (0x01&lt;&lt;minor); else if(0x00 == buf) *GPIO_DATAOUT &amp;= ~(0x01&lt;&lt;minor); return 0; &#125; static struct file_operations leds_fops = &#123; .owner = THIS_MODULE, .open = leds_drv_open, .write = leds_drv_write, &#125;;static int leds_drv_init(void)&#123; //1.申请设备号 dev_t devid; printk(KERN_INFO\"%s OK.\\n\",__func__); if(alloc_chrdev_region(&amp;devid, 0, TI_LEDS_CNT, \"ti_leds\") &lt; 0) &#123; printk(KERN_INFO\"%s ERROR.\\n\",__func__); goto error; &#125; major = MAJOR(devid); //2.注册到系统中 cdev_init(&amp;leds_cdev, &amp;leds_fops); cdev_add(&amp;leds_cdev, devid, TI_LEDS_CNT); leds_cls = class_create(THIS_MODULE, \"ti_leds\"); device_create(leds_cls, NULL, MKDEV(major, 0), NULL, \"ti_led0\"); device_create(leds_cls, NULL, MKDEV(major, 1), NULL, \"ti_led1\"); device_create(leds_cls, NULL, MKDEV(major, 2), NULL, \"ti_led2\"); device_create(leds_cls, NULL, MKDEV(major, 3), NULL, \"ti_led3\"); //3.硬件相关 PRCM_CM_PER_GPIO5_CLKCTRL = ioremap(0x44DF8800+0x498, 0x04*1); CTRL_CONF_UART3_RXD = ioremap(0x44E10000+0xA28, 0x04*4); CTRL_CONF_UART3_TXD = CTRL_CONF_UART3_RXD + 1; CTRL_CONF_UART3_CTSN = CTRL_CONF_UART3_RXD + 2; CTRL_CONF_UART3_RTSN = CTRL_CONF_UART3_RXD + 3; GPIO_OE = ioremap(0x48322000+0x134, 0x04); GPIO_DATAOUT = ioremap(0x48322000+0x13C, 0x04); GPIO_SETDATAOUT = ioremap(0x48322000+0x194, 0x04);error: unregister_chrdev_region(MKDEV(major, 0), TI_LEDS_CNT); return 0;&#125;static void leds_drv_exit(void)&#123; unsigned i; printk(KERN_INFO\"%s OK.\\n\",__func__); for(i=0;i&lt;TI_LEDS_CNT;i++) &#123; device_destroy(leds_cls, MKDEV(major, i)); &#125; class_destroy(leds_cls); cdev_del(&amp;leds_cdev); unregister_chrdev(major, \"ti_leds\"); iounmap(PRCM_CM_PER_GPIO5_CLKCTRL); iounmap(CTRL_CONF_UART3_RXD); iounmap(GPIO_OE); iounmap(GPIO_DATAOUT); iounmap(GPIO_SETDATAOUT);&#125;module_init(leds_drv_init);module_exit(leds_drv_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am437x board leds drvice\");MODULE_ALIAS(\"character device:ti_leds\");MODULE_VERSION(\"V1.0\"); 2.2测试代码(跑马灯)[leds_app.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#define msleep(x) usleep(x*1000)int main(int argc, char **argv)&#123; int fd[4]; int val = 0; int i = 0; //const char *dev[] = &#123;\"/dev/ti_led0\", \"/dev/ti_led1\", \"/dev/ti_led2\", \"/dev/ti_led3\"&#125;; const char *dev[] = &#123;\"/dev/ti_led2\", \"/dev/ti_led0\", \"/dev/ti_led3\", \"/dev/ti_led1\"&#125;; for(i=0; i&lt;4; i++) &#123; fd[i] = open(dev[i], O_RDWR); if (fd[i] &lt; 0) &#123; printf(\"can't open %s\\n\", *dev[i]); return 0; &#125; &#125; //leds off all. for(i=0; i&lt;4; i++) &#123; write(fd[i], &amp;val, 1); &#125; //flicker leds. while(1) &#123; val = !val; for(i=0; i&lt;4; i++) &#123; write(fd[i], &amp;val, 1); msleep(300); &#125; &#125;&#125; 2.3关于printk调试内核的printk定义了如下的打印等级：12345678#define KERN_EMERG &quot;&lt;0&gt;&quot; /* system is unusable */#define KERN_ALERT &quot;&lt;1&gt;&quot; /* action must be taken immediately */#define KERN_CRIT &quot;&lt;2&gt;&quot; /* critical conditions */#define KERN_ERR &quot;&lt;3&gt;&quot; /* error conditions */#define KERN_WARNING &quot;&lt;4&gt;&quot; /* warning conditions */#define KERN_NOTICE &quot;&lt;5&gt;&quot; /* normal but significant condition */#define KERN_INFO &quot;&lt;6&gt;&quot; /* informational */#define KERN_DEBUG &quot;&lt;7&gt;&quot; /* debug-level messages */ 如果使用串口登陆，可通过修改/proc/sys/kernel/printk里的参数进行设置：1echo &quot;8 4 1 7&quot; &gt;/proc/sys/kernel/printk 上面的四个数字分别代表：控制台日志级别：优先级[s1] 高于该值的消息将被打印至控制台，[s1]数值越小，优先级越高；默认的消息日志级别：将用该优先级来打印没有优先级的消息；最低的控制台日志级别：控制台日志级别可被设置的最小值(最高优先级)；默认的控制台日志级别：控制台日志级别的缺省值； 如果使用SSH登陆，是无法显示printk的打印信息的，但打印的数据会被放在/var/log/messages和/proc/kmsg中，利用这一特性，可以后台运行tail命令进行侦测：1tail -f /var/log/messages &amp; 缺点是不能设置打印等级，同时内核的其它信息也会被打印出来。 3.设备驱动模型驱动关于设备驱动模型前面以及有点了解，在写驱动的时候，主要体现在将原本的硬件资源信息抽取了出来，单独放在了一个文件里，当两个文件的分别加载的时候，根据名字匹配，匹配成功则调用probe()函数，进行类似前面的init()进行初始化。其它的内容基本一样，该干嘛就干嘛。 3.1驱动代码[leds_dev.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/delay.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;asm/irq.h&gt;#include &lt;asm/io.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/platform_device.h&gt;/************************************************** TI_BOARD --------------------------------------------------- Ball Color Mode Pin --------------------------------------------------- H24 D7_Blue 0x07 uart3_txd(GPIO5_3) H25 D8_Blue 0x07 uart3_rxd(GPIO5_2) K24 D9_Green 0x07 uart3_rtsn(GPIO5_1) H22 D10_Red 0x07 uart3_ctsn(GPIO5_0) **************************************************/static struct resource leds_resource[] = &#123; //PRCM_CM_PER_GPIO5_CLKCTRL(498h) [0] = &#123; .start = 0x44DF8800, .end = 0x44DFFFFF, .name = \"CM_PER\", .flags = IORESOURCE_MEM, &#125;, //CTRL_CONF_UART3_RXD(A28h)、CTRL_CONF_UART3_TXD(A2Ch)、CTRL_CONF_UART3_CTSN(A30h)、CTRL_CONF_UART3_RTSN((A34h)) [1] = &#123; .start = 0x44E10000, .end = 0x44E1FFFF, .name = \"CONTROL_MODULE\", .flags = IORESOURCE_MEM, &#125;, //GPIO_OE(134h)、GPIO_SETDATAOUT(194h)、GPIO_DATAOUT(13Ch) [2] = &#123; .start = 0x48322000, .end = 0x48322FFF, .name = \"GOIP5\", .flags = IORESOURCE_MEM, &#125;, [3] = &#123; .start = 0, .end = 3, .name = \"GOIP5_PIN\", .flags = IORESOURCE_IO, &#125;&#125;; static void leds_release(struct device * dev) &#123; printk(KERN_INFO\"%s OK.\\n\",__func__);&#125;static struct platform_device leds_dev = &#123; .name = \"ti_am437x_leds_platform\", .id = -1, .num_resources = ARRAY_SIZE(leds_resource), .resource = leds_resource, .dev = &#123; .release = leds_release, &#125;, &#125;;static int leds_dev_init(void) &#123; printk(KERN_INFO\"%s OK.\\n\",__func__); return platform_device_register(&amp;leds_dev);; &#125; static void leds_dev_exit(void) &#123; printk(KERN_INFO\"%s OK.\\n\",__func__); platform_device_unregister(&amp;leds_dev); &#125; module_init(leds_dev_init);module_exit(leds_dev_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am437x board leds drvice\");MODULE_ALIAS(\"platform:ti_leds\");MODULE_VERSION(\"V2.0\"); [leds_drv.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &lt;linux/module.h&gt; #include &lt;linux/version.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/interrupt.h&gt; #include &lt;linux/irq.h&gt; #include &lt;linux/sched.h&gt; #include &lt;linux/pm.h&gt; #include &lt;linux/sysctl.h&gt; #include &lt;linux/proc_fs.h&gt; #include &lt;linux/delay.h&gt; #include &lt;linux/platform_device.h&gt; #include &lt;linux/input.h&gt; #include &lt;linux/irq.h&gt; #include &lt;asm/uaccess.h&gt; #include &lt;asm/io.h&gt; #include &lt;linux/cdev.h&gt;#include &lt;asm/uaccess.h&gt;#define TI_LEDS_CNT 4int major;static struct cdev leds_cdev;static struct class *leds_cls;static volatile unsigned long *PRCM_CM_PER_GPIO5_CLKCTRL = NULL; static volatile unsigned long *CTRL_CONF_UART3_RXD = NULL; static volatile unsigned long *CTRL_CONF_UART3_TXD = NULL; static volatile unsigned long *CTRL_CONF_UART3_CTSN = NULL;static volatile unsigned long *CTRL_CONF_UART3_RTSN = NULL;static volatile unsigned long *GPIO_OE = NULL;static volatile unsigned long *GPIO_SETDATAOUT = NULL;static volatile unsigned long *GPIO_DATAOUT = NULL; static int leds_drv_open(struct inode *inode, struct file *file) &#123; int minor = iminor(file-&gt;f_inode); printk(KERN_INFO\"%s OK.\\n\",__func__); *PRCM_CM_PER_GPIO5_CLKCTRL = (0x01&lt;&lt;1); *CTRL_CONF_UART3_RXD &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18); *CTRL_CONF_UART3_RXD |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17); *GPIO_OE &amp;= ~(0x01&lt;&lt;minor); *GPIO_SETDATAOUT |= (0x01&lt;&lt;minor); return 0; &#125; static ssize_t leds_drv_write(struct file *file, const char __user *user_buf, size_t count, loff_t * ppos) &#123; int minor = iminor(file-&gt;f_inode); char buf; printk(KERN_INFO\"%s OK.\\n\",__func__); if(count != 1)&#123; printk(KERN_INFO\"write count != 1.\\n\"); return 1; &#125; if (copy_from_user(&amp;buf, user_buf, count)) return -EFAULT; if (0x01 == buf) *GPIO_DATAOUT |= (0x01&lt;&lt;minor); else if(0x00 == buf) *GPIO_DATAOUT &amp;= ~(0x01&lt;&lt;minor); return 0; &#125; static struct file_operations leds_fops = &#123; .owner = THIS_MODULE, .open = leds_drv_open, .write = leds_drv_write, &#125;; static int leds_probe(struct platform_device *pdev) &#123; struct resource *res; dev_t devid; printk(KERN_INFO\"%s OK.\\n\",__func__); //1.申请设备号 if(alloc_chrdev_region(&amp;devid, 0, TI_LEDS_CNT, \"ti_leds\") &lt; 0) &#123; printk(\"%s ERROR\\n\",__func__); goto error; &#125; major = MAJOR(devid); //2.注册到系统中 cdev_init(&amp;leds_cdev, &amp;leds_fops); cdev_add(&amp;leds_cdev, devid, TI_LEDS_CNT); leds_cls = class_create(THIS_MODULE, \"ti_leds\"); device_create(leds_cls, NULL, MKDEV(major, 0), NULL, \"ti_led0\"); device_create(leds_cls, NULL, MKDEV(major, 1), NULL, \"ti_led1\"); device_create(leds_cls, NULL, MKDEV(major, 2), NULL, \"ti_led2\"); device_create(leds_cls, NULL, MKDEV(major, 3), NULL, \"ti_led3\"); //3.硬件相关 res = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"CM_PER\"); if (!res) return -EINVAL; PRCM_CM_PER_GPIO5_CLKCTRL = ioremap(res-&gt;start+0x498, 0x04*1); res = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"CONTROL_MODULE\"); if (!res) return -EINVAL; CTRL_CONF_UART3_RXD = ioremap(res-&gt;start+0xA28, 0x04*4); CTRL_CONF_UART3_TXD = CTRL_CONF_UART3_RXD + 1; CTRL_CONF_UART3_CTSN = CTRL_CONF_UART3_RXD + 2; CTRL_CONF_UART3_RTSN = CTRL_CONF_UART3_RXD + 3; res = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"GOIP5\"); if (!res) return -EINVAL; GPIO_OE = ioremap(res-&gt;start+0x134, 0x04); GPIO_DATAOUT = ioremap(res-&gt;start+0x13C, 0x04); GPIO_SETDATAOUT = ioremap(res-&gt;start+0x194, 0x04); *PRCM_CM_PER_GPIO5_CLKCTRL = (0x01&lt;&lt;1);//使能GPIO外设时钟error: unregister_chrdev_region(MKDEV(major, 0), TI_LEDS_CNT); return 0; &#125; static int leds_remove(struct platform_device *pdev) &#123; unsigned i; printk(KERN_INFO\"%s OK.\\n\",__func__); for(i=0;i&lt;TI_LEDS_CNT;i++) &#123; device_destroy(leds_cls, MKDEV(major, i)); &#125; class_destroy(leds_cls); cdev_del(&amp;leds_cdev); unregister_chrdev(major, \"ti_leds\"); iounmap(PRCM_CM_PER_GPIO5_CLKCTRL); iounmap(CTRL_CONF_UART3_RXD); iounmap(GPIO_OE); iounmap(GPIO_DATAOUT); iounmap(GPIO_SETDATAOUT); return 0; &#125;struct platform_driver leds_drv = &#123; .probe = leds_probe, .remove = leds_remove, .driver = &#123; .name = \"ti_am437x_leds_platform\", &#125; &#125;; static int leds_drv_init(void) &#123; printk(KERN_INFO\"%s OK.\\n\",__func__); return platform_driver_register(&amp;leds_drv); &#125; static void leds_drv_exit(void) &#123; printk(KERN_INFO\"%s OK.\\n\",__func__); platform_driver_unregister(&amp;leds_drv); &#125; module_init(leds_drv_init);module_exit(leds_drv_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am437x board leds drvice\");MODULE_ALIAS(\"platform:ti_leds\");MODULE_VERSION(\"V2.0\"); 测试程序同前面的一样。 4.设备树驱动4.1初识设备树 1）前面的总线设备驱动模型中，硬件资源来自于leds_dev.c里面的信息，这样会导致不同的板子，会添加不同的硬件资源信息，造成内核的臃肿。2）使用设备树后，内核不再包含硬件的描述，硬件描述放在单独的DTS里面，然后编译成二进制的DTB，在U-Boot启动的时候加载进去，然后内核进行解析。3）DTS、DTC和DTB之间的关系：DTS经过DTC编译得到DTB，DTB通过DTC反编译得到DTS. 4）ARM中，所有的DTS文件放在arch/arm/boot/dts目录中，为了简化，将Soc公用部分提取了出来作为dtsi，类似头文件。5）DTC编译工具的源代码在scripts/dtc目录中，编译内核时，编译内核时，需要使能才能将源码编译成工具，对应于scripts/dtc/Makefile中&quot;hostprogs-y:=dtc&quot;。Ubuntu也可直接安装DTC工具：1sudo apt-get install device-tree-compiler 6)内核的arch/arm/boot/dts/Makefile中，描述了当某种Soc被选中后，哪些.dtb会编译出来。执行make dtbs，会根据arch/arm/Makefile编译指定目标。7）单独编译与反编译：12./scripts/dtc/dtc -I dts -O dtb -o xxx.dtb arch/arm/boot/dts/xxx.dts //dts-&gt;dtb./scripts/dtc/dtc -I dtb -O dts -o xxx.dts arch/arm/boot/dts/xxx.dtb //dtb-&gt;dts 8）后面认识深刻了，再总结总结。 4.2修改AM437x设备树AM437x的设备树文件在~/ti-processor-sdk-linux-am437x-evm-01.00.00.03/board-support/linux-3.14.43+gitAUTOINC+875c69b2c3-g875c69b/arch/arm/boot/dts/中，主要是am4372.dtsi和am437x-sk-evm.dts。我的目的是希望写个设备树框架的LED程序，因此想让am437x-sk-evm.dts干净点，只包含LED硬件描述，因此我需要删除am437x-sk-evm.dts里面的其它硬件描述。经过测试，am437x-sk-evm.dts里面包含部分MMC的描述，一旦删除将不能成功启动内核。而且，后面调试的时候，希望开发板通过NFS挂载的方式，直接加载编译的驱动模块，因此需要保留网卡描述部分。最后，将MMC和网卡必须的部分，提取了出来，放在了am4372.dtsi中。精简后的am437x-sk-evm.dts内容如下：[am437x-sk-evm.dts]link1234567891011121314151617181920212223242526272829303132333435363738/* AM437x SK EVM *//dts-v1/;#include \"am4372.dtsi\"#include &lt;dt-bindings/pinctrl/am43xx.h&gt;#include &lt;dt-bindings/gpio/gpio.h&gt;/ &#123; model = \"TI AM437x SK EVM\"; compatible = \"ti,am437x-sk-evm\",\"ti,am4372\",\"ti,am43\"; led_pin &#123; compatible = \"ti_leds\"; pinctrl-names = \"default\"; pinctrl-0 = &lt;&amp;leds_pins&gt;; am437x,led_gpio0 = &lt;&amp;gpio5 0 GPIO_ACTIVE_HIGH&gt;; am437x,led_gpio1 = &lt;&amp;gpio5 1 GPIO_ACTIVE_HIGH&gt;; am437x,led_gpio2 = &lt;&amp;gpio5 2 GPIO_ACTIVE_HIGH&gt;; am437x,led_gpio3 = &lt;&amp;gpio5 3 GPIO_ACTIVE_HIGH&gt;; &#125;;&#125;;&amp;am43xx_pinmux &#123; leds_pins: leds_pins &#123; pinctrl-single,pins = &lt; 0x228 (PIN_OUTPUT | MUX_MODE7) /* uart3_rxd.gpio5_2 */ 0x22c (PIN_OUTPUT | MUX_MODE7) /* uart3_txd.gpio5_3 */ 0x230 (PIN_OUTPUT | MUX_MODE7) /* uart3_ctsn.gpio5_0 */ 0x234 (PIN_OUTPUT | MUX_MODE7) /* uart3_rtsn.gpio5_1 */ &gt;; &#125;;&#125;;&amp;gpio5 &#123; status = \"okay\";&#125;;额，在调试的过程中，需要不断编译新的DTB和复制到SD卡的rootfs分区中，仿照前面写了个脚本进行自动编译和复制，同时检查文件的生成时间间隔，实际中，确实减少了焦躁的重复操作。 4.3驱动代码[leds_drv.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include &lt;linux/module.h&gt; #include &lt;linux/version.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/interrupt.h&gt; #include &lt;linux/irq.h&gt; #include &lt;linux/sched.h&gt; #include &lt;linux/pm.h&gt; #include &lt;linux/sysctl.h&gt; #include &lt;linux/proc_fs.h&gt; #include &lt;linux/delay.h&gt; #include &lt;linux/platform_device.h&gt; #include &lt;linux/input.h&gt; #include &lt;linux/irq.h&gt; #include &lt;asm/uaccess.h&gt; #include &lt;asm/io.h&gt; #include &lt;linux/cdev.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;linux/of_gpio.h&gt;#define TI_LEDS_CNT 4int major;static struct cdev leds_cdev;static struct class *leds_cls;static int led0,led1,led2,led3; static int leds_drv_open(struct inode *inode, struct file *file) &#123; printk(KERN_INFO\"%s OK.\\n\",__func__); return 0; &#125; static ssize_t leds_drv_write(struct file *file, const char __user *user_buf, size_t count, loff_t * ppos) &#123; int minor = iminor(file-&gt;f_inode); char buf; printk(KERN_INFO\"%s OK.\\n\",__func__); if(count != 1)&#123; printk(KERN_INFO\"write count != 1.\\n\"); return 1; &#125; if (copy_from_user(&amp;buf, user_buf, count)) return -EFAULT; if(0x01 == buf) &#123; switch(minor)&#123; case 0: gpio_set_value(led0, 0); break; case 1: gpio_set_value(led1, 0); break; case 2: gpio_set_value(led2, 0); break; case 3: gpio_set_value(led3, 0); break; default: printk(KERN_INFO\"%s receive minor error.\\n\",__func__); &#125; &#125; else if(0x00 == buf) &#123; switch(minor)&#123; case 0: gpio_set_value(led0, 1); break; case 1: gpio_set_value(led1, 1); break; case 2: gpio_set_value(led2, 1); break; case 3: gpio_set_value(led3, 1); break; default: printk(KERN_INFO\"%s receive minor error\\n\",__func__); &#125; &#125; return 0; &#125; static struct file_operations leds_fops = &#123; .owner = THIS_MODULE, .open = leds_drv_open, .write = leds_drv_write, &#125;; static int leds_probe(struct platform_device *pdev) &#123; struct device *dev = &amp;pdev-&gt;dev; dev_t devid; printk(KERN_INFO\"%s OK.\\n\",__func__); //1.申请设备号 if(alloc_chrdev_region(&amp;devid, 0, TI_LEDS_CNT, \"ti_leds\") &lt; 0) &#123; printk(KERN_INFO\"%s ERROR.\\n\",__func__); goto error; &#125; major = MAJOR(devid); //2.注册到系统中 cdev_init(&amp;leds_cdev, &amp;leds_fops); cdev_add(&amp;leds_cdev, devid, TI_LEDS_CNT); leds_cls = class_create(THIS_MODULE, \"ti_leds\"); device_create(leds_cls, NULL, MKDEV(major, 0), NULL, \"ti_led0\"); device_create(leds_cls, NULL, MKDEV(major, 1), NULL, \"ti_led1\"); device_create(leds_cls, NULL, MKDEV(major, 2), NULL, \"ti_led2\"); device_create(leds_cls, NULL, MKDEV(major, 3), NULL, \"ti_led3\"); //3.硬件相关 led0 = of_get_named_gpio(dev-&gt;of_node, \"am437x,led_gpio0\", 0);; led1 = of_get_named_gpio(dev-&gt;of_node, \"am437x,led_gpio1\", 0);; led2 = of_get_named_gpio(dev-&gt;of_node, \"am437x,led_gpio2\", 0);; led3 = of_get_named_gpio(dev-&gt;of_node, \"am437x,led_gpio3\", 0); //printk(KERN_INFO\"led0 = %d\\n\",led0); //printk(KERN_INFO\"led1 = %d\\n\",led1); //printk(KERN_INFO\"led2 = %d\\n\",led2); //printk(KERN_INFO\"led3 = %d\\n\",led3); devm_gpio_request_one(dev, led0, GPIOF_OUT_INIT_HIGH, \"LED0\"); devm_gpio_request_one(dev, led1, GPIOF_OUT_INIT_HIGH, \"LED1\"); devm_gpio_request_one(dev, led2, GPIOF_OUT_INIT_HIGH, \"LED2\"); devm_gpio_request_one(dev, led3, GPIOF_OUT_INIT_HIGH, \"LED3\");error: unregister_chrdev_region(MKDEV(major, 0), TI_LEDS_CNT); return 0; &#125; static int leds_remove(struct platform_device *pdev) &#123; unsigned i; printk(KERN_INFO\"%s OK.\\n\",__func__); for(i=0;i&lt;TI_LEDS_CNT;i++) &#123; device_destroy(leds_cls, MKDEV(major, i)); &#125; class_destroy(leds_cls); cdev_del(&amp;leds_cdev); unregister_chrdev(major, \"ti_leds\"); return 0; &#125;static const struct of_device_id of_gpio_leds_match[] = &#123; &#123; .compatible = \"ti_leds\", &#125;, &#123;&#125;,&#125;;static struct platform_driver leds_drv = &#123; .probe = leds_probe, .remove = leds_remove, .driver = &#123; .name = \"ti_am437x_leds_platform\", .owner = THIS_MODULE, .of_match_table = of_match_ptr(of_gpio_leds_match), &#125;,&#125;;static int leds_drv_init(void) &#123; printk(KERN_INFO\"%s OK.\\n\",__func__); return platform_driver_register(&amp;leds_drv); &#125; static void leds_drv_exit(void) &#123; printk(KERN_INFO\"%s OK.\\n\",__func__); platform_driver_unregister(&amp;leds_drv); &#125; module_init(leds_drv_init);module_exit(leds_drv_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am437x board leds drvice\");MODULE_ALIAS(\"platform:device tree:ti_leds\");MODULE_VERSION(\"V3.0\"); 测试程序同前面的一样。 5.LED子系统驱动5.1 框架分析LED子系统框架如下： 用户态在用户态，可以直接访问节点/sys/class/leds/xxx/下的文件操作LED。在该路径下会有brightness、max_brightness、trigger，根据trigger的不同，还可能有delay_off、delay_on、invert等。brightness用于设置LED亮度，范围为0(LED_OFF)~255(LED_FULL);max_brightness用于显示LED的最大亮度访问，一般值为255;trigger用于设置LED的触发模式，通常可选的有:none、nand-disk、mmc0、cpu0、heartbeat、timer、default-on、oneshot、backlight、gpio；delay_off、delay_on用于trigger为timer等模式时，LED亮灭的时间，单位为毫秒； 内核驱动LED子系统的驱动都在drivers/leds/下面。核心的文件是led-class.c、led-core.c、led-triggers.c；可选触发器方式有： 12345678910obj-$(CONFIG_LEDS_TRIGGER_TIMER) += ledtrig-timer.o //定时触发obj-$(CONFIG_LEDS_TRIGGER_ONESHOT) += ledtrig-oneshot.o //单次触发obj-$(CONFIG_LEDS_TRIGGER_IDE_DISK) += ledtrig-ide-disk.o //硬盘触发obj-$(CONFIG_LEDS_TRIGGER_HEARTBEAT) += ledtrig-heartbeat.o //心跳触发obj-$(CONFIG_LEDS_TRIGGER_BACKLIGHT) += ledtrig-backlight.o //背光设置obj-$(CONFIG_LEDS_TRIGGER_GPIO) += ledtrig-gpio.o //GPIO触发obj-$(CONFIG_LEDS_TRIGGER_CPU) += ledtrig-cpu.o //CPU触发 obj-$(CONFIG_LEDS_TRIGGER_DEFAULT_ON) += ledtrig-default-on.o //默认开obj-$(CONFIG_LEDS_TRIGGER_TRANSIENT) += ledtrig-transient.o obj-$(CONFIG_LEDS_TRIGGER_CAMERA) += ledtrig-camera.o leds-gpio.c和leds-xxx.c对应具体的设备，比如现在某个LED接在了GPIO上，理论上我们就要编写leds-gpio.c这个驱动文件，但LED子系统已经帮我们做好了，我们只需要在设备树文件添加相应的设备信息即可。 下面对主要文件的内容进行分析： led-core.c：抽象出LED操作逻辑，封装成函数导出，供其它文件使用：led_init_core()：核心初始化；led_blink_set()：设置led闪烁时间；led_blink_set_oneshot()：闪烁一次；led_stop_software_blink()：led停止闪烁；led_set_brightness()：设置led的亮度；led_set_brightness_nopm：如果可以休眠，设置led的亮度保证休眠可用；led_set_brightness_nosleep：如果没有休眠，设置led的亮度；led_set_brightness_sync：设置led亮度同步；led_update_brightness：更新亮度；led_sysfs_disable：用户态关闭；led_sysfs_enable：用户态打开；leds_list：leds链表；leds_list_lock：leds链表锁； led-class.c：维护LED子系统的所有LED设备，为LED设备提供注册操作函数:led_classdev_register()/of_led_classdev_register()/devm_of_led_classdev_register()/devm_led_classdev_register()；注销操作函数:led_classdev_unregister()/devm_led_classdev_unregister()；电源管理的休眠和恢复操作函数：led_classdev_suspend()、led_classdev_resume()；同时提供基本的用户态操作接口，brightness、max_brightness等； led-triggers.c：维护LED子系统的所有触发器，为触发器提供注册操作函数：led_trigger_register()、devm_led_trigger_register()，led_trigger_register_simple()；注销操作函数：led_trigger_unregister()、led_trigger_unregister_simple()；以及其它触发器相关的操作函数； ledtrig-timer.c ledtrig-xxxx.c：以ledtrig-timer.c为例的触发器，入口函数调用led_trigger_register()注册触发器，注册时候传入led_trigger结构体，里面有activate和deactivate成员函数指针，这里的作用是生成delay_on、delay_off文件；同时还提供delay_on和delay_off的用户态操作接口；卸载时，使用led_trigger_unregister()注销触发器。 leds-gpio.c leds-xxxx.c：以leds-gpio.c为例的LED设备，在通过设备树或者其它途径匹配到设备信息后，将调用probe()函数，然后再根据设备信息设置led_classdev，最后调用devm_of_led_classdev_register()注册LED设备。 5.2 示例参考首先在内核里，配置LED子系统：1234567891011121314Device Drivers ---&gt; [*] LED Support ---&gt; &lt;*&gt; LED Class Support &lt;*&gt; LED Support for GPIO connected LEDs *** LED Triggers *** -*- LED Trigger support ---&gt; [*] LED Timer Trigger [*] LED One-shot Trigger [*] LED Heartbeat Trigger [*] LED backlight Trigger [*] LED CPU Trigger [*] LED GPIO Trigger [*] LED Default ON Trigger 根据自己需求，配置LED Trigger support的内容。 然后设备树里添加设备节点，参考Documentation/devicetree/bindings/leds/leds-gpio.txt:12345678910111213141516171819202122leds &#123; compatible = &quot;gpio-leds&quot;; led-heartbeat &#123; gpios = &lt;&amp;gpio1 16 GPIO_ACTIVE_LOW&gt;; linux,default-trigger = &quot;heartbeat&quot;; &#125;; led-cpu0 &#123; gpios = &lt;&amp;gpio1 17 GPIO_ACTIVE_LOW&gt;; linux,default-trigger = &quot;cpu0&quot;; &#125;; led-timer &#123; gpios = &lt;&amp;gpio1 19 GPIO_ACTIVE_LOW&gt;; linux,default-trigger = &quot;timer&quot;; &#125;; led-none &#123; gpios = &lt;&amp;gpio1 21 GPIO_ACTIVE_LOW&gt;; linux,default-trigger = &quot;none&quot;; &#125;;&#125;; 重新编译内核和设备树，烧写，启动。 在/sys/class/leds路径下，生成了以下文件夹：1led-cpu0 led-heartbeat led-timer led-none 进入led-heartbeat目录，可以看到以下文件：12brightness max_brightness subsystem ueventdevice power trigger 可以通过echo 0 &gt; brightness来关闭LED灯，通过echo timer &gt; trigger改变触发模式。同时，cat trigger可以显示支持的触发模式，以及当前的触发模式：1none nand-disk mmc0 cpu0 [heartbeat] timer default-on oneshot backlight gpio 6.心得在我理解到驱动=裸机+软件框架的时候，我对之前的裸机也就没那么排斥了。而且这个软件框架，就现在来看，核心的那几步：申请设备号、注册设备、创建类和创建节点这些都不变，早晚会做。对于LED子系统，虽然表面上自己没做上述的操作，但实际上是LED子系统帮我们做了。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"AM437X","slug":"AM437X","permalink":"http://yoursite.com/tags/AM437X/"}]},{"title":"Linux开发环境配置及shell script","date":"2017-08-05T03:37:41.000Z","path":"2017/08/05/Linux开发环境配置及shell-script/","text":"本文主要是以快速搭建环境为目标学习shell script。 之前写过一个Linux嵌入式开发环境搭建的博客，后面每次搭环境都翻来复制上面的代码。感觉就像记事本一样，还是有点用，这也是写博客的一点动力吧。用了Linux也有段时间了，它的魅力也逐渐展现出来了。以前还在熟悉Linux命令的过程中，shell script就是个老虎，觉得没接触过，害怕，每次都绕开它。直到这周遇到了ti的SDK，尝试一边百度，一边测它的脚本，感觉有点小入门了，于是想练习下。想到每次搭建环境重复操作的痛点，就拿它开刀吧。 0.环境搭建的几个方面根据过去的经验，用虚拟机装好Ubuntu后，一般会做这样几个步骤： 1.安装vmware tools,以便复制粘贴和文件共享；2.更新软件源，以便更快的下载软件；3.安装及配置常用软件，比如： 3-1.安装git,方面后续的一些安装； 3-2.安装vim和简单配置； 3-3.安装ftp和简单配置； 3-4.安装nfs和简单配置； 3-5.安装samba和简单配置； 3-6.安装tmux、htop等；4.安装开发所需的 g++等工具、库； 除了第一步，其它都计划用脚本实现。 在开发中，厌烦了每次编辑了驱动，都要拖进Linux主机进行编译，然后还要复制到开发板。重新打造了工作流，只需要在电脑上操作三步：编辑-&gt;make编译-&gt;insmod加载 1.检测当前环境在运行脚本前，需要检测一些东西： 1.1检测网络状态如果不能联网，后续的没必要做了。之前想过自动检测修复网络的，但想了想，网络的情况比较多，暂时搁置。而且刚装好虚拟机肯定是联网的，如果不能联网肯定是虚拟机设置的问题，也不是脚本能解决的。为了方便打印醒目和更改用户名，这里先设置几个变量：12345678910#define echo print color.RED_COLOR='\\E[1;31m' PINK_COLOR='\\E[1;35m' YELOW_COLOR='\\E[1;33m' BLUE_COLOR='\\E[1;34m' GREEN_COLOR='\\E[1;32m' END_COLOR='\\E[0m' #set linux host user name.user_name=hceng 检测网络函数：123456789check_network() &#123; ping -c 1 www.baidu.com &gt; /dev/null 2&gt;&amp;1 if [ $? -eq 0 ];then echo -e \"$&#123;GREEN_COLOR&#125;Network ok.$&#123;END_COLOR&#125;\" else echo -e \"$&#123;RED_COLOR&#125;Network failure!$&#123;END_COLOR&#125;\" exit 1 fi&#125;先ping一次百度，能够ping通就表示网络没问题。 1.2检测是否是root用户很多操作都需要root权限，因此必须使用root用户权限运行脚本，这里先检测是否是root用户：1234567# Check user must root.check_root() &#123; if [ $(id -u) != \"0\" ]; then echo -e \"$&#123;RED_COLOR&#125;Error: You must be root to run this script, please use root.$&#123;END_COLOR&#125;\" exit 1 fi&#125; 1.3检测设置的用户是否存在现在用的用户名是hceng，后面为了方便其它用户使用，所以在前面定义了个变量，改变变量就可以修改用户。但为了防止设置的用户在系统中不存在，这里需要进行检测。12345678910# Check set linux host user name.check_user_name() &#123; cat /etc/passwd|grep $user_name if [ $? -eq 0 ];then echo -e \"$&#123;GREEN_COLOR&#125;Check the set user name OK.$&#123;END_COLOR&#125;\" else echo -e \"$&#123;RED_COLOR&#125;Check the set user name failure!$&#123;END_COLOR&#125;\" exit 1 fi&#125; 1.4检测运行结果为检测某些命令，是否运行正常。1234567check_status() &#123; ret=$? if [ \"$ret\" -ne \"0\" ]; then echo -e \"$&#123;RED_COLOR&#125;Failed setup, aborting..$&#123;END_COLOR&#125;\" exit 1 fi&#125; 1.5获取系统版本信息后面更新源和装某些软件需要当前Ubuntu的版本代号。123456# Get the code name of the Linux host release to the caller.get_host_type() &#123; local __host_type=$1 local the_host=`lsb_release -a 2&gt;/dev/null | grep Codename: | awk &#123;'print $2'&#125;` eval $__host_type=\"'$the_host'\"&#125; 2.更新软件源这里使用了阿里、网易和官方的三个源，应该没问题了。修改配置文件的原则就是先备份再修改。同时为了防止脚本再次运行覆盖掉备份，还需要检测是否已经存在了备份。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#This function will update the source of the software.update_software_source() &#123; local back_file=/etc/apt/sources.list.backup if [ ! -e \"$back_file\" ];then cp /etc/apt/sources.list $back_file fi check_status get_host_type host_release check_status echo \\ \"#Ali source. deb-src http://archive.ubuntu.com/ubuntu $host_release main restricted deb http://mirrors.aliyun.com/ubuntu/ $host_release main restricted deb-src http://mirrors.aliyun.com/ubuntu/ $host_release main restricted multiverse universe deb http://mirrors.aliyun.com/ubuntu/ $host_release-updates main restricted deb-src http://mirrors.aliyun.com/ubuntu/ $host_release-updates main restricted multiverse universe deb http://mirrors.aliyun.com/ubuntu/ $host_release universe deb http://mirrors.aliyun.com/ubuntu/ $host_release-updates universe deb http://mirrors.aliyun.com/ubuntu/ $host_release multiverse deb http://mirrors.aliyun.com/ubuntu/ $host_release-updates multiverse deb http://mirrors.aliyun.com/ubuntu/ $host_release-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ $host_release-backports main restricted universe multiverse deb http://archive.canonical.com/ubuntu $host_release partner deb-src http://archive.canonical.com/ubuntu $host_release partner deb http://mirrors.aliyun.com/ubuntu/ $host_release-security main restricted deb-src http://mirrors.aliyun.com/ubuntu/ $host_release-security main restricted multiverse universe deb http://mirrors.aliyun.com/ubuntu/ $host_release-security universe deb http://mirrors.aliyun.com/ubuntu/ $host_release-security multiverse #Netease source. deb http://mirrors.163.com/ubuntu/ $host_release main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ $host_release-security main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ $host_release-updates main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ $host_release-proposed main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ $host_release-backports main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release-security main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release-updates main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release-proposed main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release-backports main restricted universe multiverse #Official source deb http://archive.ubuntu.com/ubuntu/ $host_release main restricted universe multiverse deb http://archive.ubuntu.com/ubuntu/ $host_release-security main restricted universe multiverse deb http://archive.ubuntu.com/ubuntu/ $host_release-updates main restricted universe multiverse deb http://archive.ubuntu.com/ubuntu/ $host_release-proposed main restricted universe multiverse deb http://archive.ubuntu.com/ubuntu/ $host_release-backports main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release-security main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release-updates main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release-proposed main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release-backports main restricted universe multiverse\" \\ &gt; /etc/apt/sources.list check_status #apt-get update 1&gt;/dev/null apt-get update check_status echo -e \"$&#123;GREEN_COLOR&#125;Update source completed.$&#123;END_COLOR&#125;\" &#125; 3.安装软件及配置软件主要包括自己一般常用的软件，像vim、tmux、samba等。还有就是开发所需的g++、各种库。其中git要在vim前面，因为vim的配置文件需要git下载。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# Execute an action.FA_DoExec() &#123; echo -e \"$&#123;BLUE_COLOR&#125;==&gt; Executing: '$&#123;@&#125;'.$&#123;END_COLOR&#125;\" eval $@ || exit $?&#125;# Install list software.install_software() &#123; local install_software_list=(\"git\" \"vim\" \"tmux\" \"htop\" \"vsftpd\" \"openssh-server\" \"nfs-kernel-server\" \"portmap\" \"samba\") echo -e \"$&#123;PINK_COLOR&#125;install_software_list:$&#123;install_software_list[*]&#125;.$&#123;END_COLOR&#125;\" #install git if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"git\");then apt-get -y install git &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;git install completed.$&#123;END_COLOR&#125;\" fi #install and configure vim if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"vim\");then apt-get -y install vim &amp;&amp; vim_configure &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;vim install completed.$&#123;END_COLOR&#125;\" fi #install tmux if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"tmux\");then apt-get -y install tmux &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;tmux install completed.$&#123;END_COLOR&#125;\" fi #install htop if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"htop\");then apt-get -y install htop &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;htop install completed.$&#123;END_COLOR&#125;\" fi #install and configure vsftpd if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"vsftpd\");then apt-get -y install vsftpd &amp;&amp; ftp_configure &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;vsftpd install completed.$&#123;END_COLOR&#125;\" fi #install openssh-server if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"openssh-server\");then apt-get -y install openssh-server &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;openssh-server install completed.$&#123;END_COLOR&#125;\" fi #install and configure nfs-kernel-server if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"nfs-kernel-server\");then apt-get -y install nfs-kernel-server &amp;&amp; nfs_configure &amp;&amp; \\ /etc/init.d/nfs-kernel-server restart &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;nfs-kernel-server install completed.$&#123;END_COLOR&#125;\" fi #install portmap if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"portmap\");then apt-get -y install portmap &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;portmap install completed.$&#123;END_COLOR&#125;\" fi #install and configure samba if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"samba\");then apt-get -y install samba &amp;&amp; samba_configure &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;samba install completed.$&#123;END_COLOR&#125;\" fi #others get_host_type host_release FA_DoExec apt-get -y install \\ gnupg flex bison gperf build-essential \\ zip curl libc6-dev libncurses5-dev libncurses5-dev:i386 x11proto-core-dev \\ libx11-dev:i386 libreadline6-dev:i386 \\ libgl1-mesa-glx-lts-$host_release:i386 libgl1-mesa-dev-lts-$host_release \\ g++-multilib mingw32 tofrodos libncurses5-dev:i386 \\ python-markdown libxml2-utils xsltproc zlib1g-dev:i386 if [ ! -h /usr/lib/i386-linux-gnu/libGL.so ]; then FA_DoExec ln -s /usr/lib/i386-linux-gnu/mesa/libGL.so.1 \\ /usr/lib/i386-linux-gnu/libGL.so fi # Development support FA_DoExec apt-get -y install \\ dos2unix minicom gawk echo -e \"$&#123;GREEN_COLOR&#125;software install completed.$&#123;END_COLOR&#125;\"&#125; 3.1配置vimvim的配置文件来自GitHub的Amir,我就不重复造轮子了。这里只是先clone下来，然后执行安装脚本。这里值得一提的是执行脚本要指定用户运行，不然会以root用户的路径设置，导致脚本运行错误。1234567891011# Configure vim form github.vim_configure() &#123; git clone --depth=1 https://github.com/amix/vimrc.git /home/$user_name/.vim_runtime touch /home/$user_name/.vim_runtime/my_configs.vim echo \":set number\" &gt; /home/$user_name/.vim_runtime/my_configs.vim chown -R $user_name /home/$user_name/.vim_runtime chmod u+x /home/$user_name/.vim_runtime/install_awesome_vimrc.sh su - $user_name -s /home/$user_name/.vim_runtime/install_awesome_vimrc.sh&#125; 3.2配置ftpFTP主要是修改为可写。在使用MobaXterm SSH登陆后，可以直接通过左边的Sftp进行文件的传输，貌似这个可以不用配置了。12345# Configure ftp.ftp_configure() &#123; sed -i 's/#loacl_enable=YES/loacl_enable=YES/g' /etc/vsftpd.conf sed -i 's/#write_enable=YES/write_enable=YES/g' /etc/vsftpd.conf&#125; 3.3配置nfs在前面的工作流中，开发板直接运行Linux主机中交叉编译好的模块，是通过nfs实现的。因此需要开发板开机后就挂载nfs.习惯在Linux主机中单独开辟一个路径作为工作目录，因此这里是设置的整个工作目录。12345678910111213# Configure nfs.nfs_configure() &#123; local work_file=/work if [ ! -d \"$work_file\" ];then mkdir /work fi check_status grep \"/work\" /etc/exports 1&gt;/dev/null if [ $? -ne 0 ];then sed -i '$a\\/work *(rw,sync,no_root_squash,no_subtree_check)' /etc/exports fi&#125; 3.4配置sambasamba也是实现前面工作流不可确少的一环。这样就不用每次修改代码后，通过ftp上传到Linux主机。samba在Windows上的使用是：先Windows+r，打开命令窗口，然后输入：\\\\192.168.1.xx，最后建议右键，映射网络驱动，方面后续打开。测试中需要重启生效。1234567891011121314151617181920212223# Configure samba.samba_configure() &#123; local back_file=/etc/samba/smb.conf.bakup if [ ! -e \"$back_file\" ];then cp /etc/samba/smb.conf $back_file fi check_status grep \"/work\" /etc/samba/smb.conf 1&gt;/dev/null if [ $? -ne 0 ];then sed -i \\ '$a[share_work]\\n\\ path = \\/work\\n\\ available = yes\\n\\ public = yes\\n\\ guest ok = yes\\n\\ read only = no\\n\\ writeable = yes\\n' /etc/samba/smb.conf fi /etc/init.d/samba restart chmod -R 777 /work&#125; 4.完整代码及心得[setup_ubuntu_host_env.sh]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#!/bin/bash# -------------------------------------------------------------------------------# Filename: setup_ubuntu_host_env.sh# Revision: 1.0# Date: 2017/08/05# Author: hceng# Email: huangcheng.job@foxmail.com# Website: www.hceng.cn# Function: setup ubuntu host env.# Notes: learn# -------------------------------------------------------------------------------## Description: #1.check env.#1.1 check network #1.2 check use root #1.3 check set name #1.4 configure samba #2.update software sourcev. #3.install vim tmux htop ftp ssh nfs samba.#3.1 configure vim #3.2 configure ftp #3.3 configure nfs #3.4 configure samba #4.install system tool eg:g++ ...## -------------------------------------------------------------------------------#define echo print color.RED_COLOR='\\E[1;31m' PINK_COLOR='\\E[1;35m' YELOW_COLOR='\\E[1;33m' BLUE_COLOR='\\E[1;34m' GREEN_COLOR='\\E[1;32m' END_COLOR='\\E[0m' #Set linux host user name.user_name=hceng# Check network.check_network() &#123; ping -c 1 www.baidu.com &gt; /dev/null 2&gt;&amp;1 if [ $? -eq 0 ];then echo -e \"$&#123;GREEN_COLOR&#125;Network OK.$&#123;END_COLOR&#125;\" else echo -e \"$&#123;RED_COLOR&#125;Network failure!$&#123;END_COLOR&#125;\" exit 1 fi&#125;# Check user must root.check_root() &#123; if [ $(id -u) != \"0\" ]; then echo -e \"$&#123;RED_COLOR&#125;Error: You must be root to run this script, please use root.$&#123;END_COLOR&#125;\" exit 1 fi&#125;# Check set linux host user name.check_user_name() &#123; cat /etc/passwd|grep $user_name if [ $? -eq 0 ];then echo -e \"$&#123;GREEN_COLOR&#125;Check the set user name OK.$&#123;END_COLOR&#125;\" else echo -e \"$&#123;RED_COLOR&#125;Check the set user name failure!$&#123;END_COLOR&#125;\" exit 1 fi&#125;# Check the results of the operation.check_status() &#123; ret=$? if [ \"$ret\" -ne \"0\" ]; then echo -e \"$&#123;RED_COLOR&#125;Failed setup, aborting..$&#123;END_COLOR&#125;\" exit 1 fi&#125;# Get the code name of the Linux host release to the caller.get_host_type() &#123; local __host_type=$1 local the_host=`lsb_release -a 2&gt;/dev/null | grep Codename: | awk &#123;'print $2'&#125;` eval $__host_type=\"'$the_host'\"&#125;#This function will update the source of the software.update_software_source() &#123; local back_file=/etc/apt/sources.list.backup if [ ! -e \"$back_file\" ];then cp /etc/apt/sources.list $back_file fi check_status get_host_type host_release check_status echo \\ \"#Ali source. deb-src http://archive.ubuntu.com/ubuntu $host_release main restricted deb http://mirrors.aliyun.com/ubuntu/ $host_release main restricted deb-src http://mirrors.aliyun.com/ubuntu/ $host_release main restricted multiverse universe deb http://mirrors.aliyun.com/ubuntu/ $host_release-updates main restricted deb-src http://mirrors.aliyun.com/ubuntu/ $host_release-updates main restricted multiverse universe deb http://mirrors.aliyun.com/ubuntu/ $host_release universe deb http://mirrors.aliyun.com/ubuntu/ $host_release-updates universe deb http://mirrors.aliyun.com/ubuntu/ $host_release multiverse deb http://mirrors.aliyun.com/ubuntu/ $host_release-updates multiverse deb http://mirrors.aliyun.com/ubuntu/ $host_release-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ $host_release-backports main restricted universe multiverse deb http://archive.canonical.com/ubuntu $host_release partner deb-src http://archive.canonical.com/ubuntu $host_release partner deb http://mirrors.aliyun.com/ubuntu/ $host_release-security main restricted deb-src http://mirrors.aliyun.com/ubuntu/ $host_release-security main restricted multiverse universe deb http://mirrors.aliyun.com/ubuntu/ $host_release-security universe deb http://mirrors.aliyun.com/ubuntu/ $host_release-security multiverse #Netease source. deb http://mirrors.163.com/ubuntu/ $host_release main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ $host_release-security main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ $host_release-updates main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ $host_release-proposed main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ $host_release-backports main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release-security main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release-updates main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release-proposed main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release-backports main restricted universe multiverse #Official source deb http://archive.ubuntu.com/ubuntu/ $host_release main restricted universe multiverse deb http://archive.ubuntu.com/ubuntu/ $host_release-security main restricted universe multiverse deb http://archive.ubuntu.com/ubuntu/ $host_release-updates main restricted universe multiverse deb http://archive.ubuntu.com/ubuntu/ $host_release-proposed main restricted universe multiverse deb http://archive.ubuntu.com/ubuntu/ $host_release-backports main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release-security main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release-updates main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release-proposed main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release-backports main restricted universe multiverse\" \\ &gt; /etc/apt/sources.list check_status #apt-get update 1&gt;/dev/null apt-get update check_status echo -e \"$&#123;GREEN_COLOR&#125;Update source completed.$&#123;END_COLOR&#125;\" &#125;# Configure vim form github.vim_configure() &#123; git clone --depth=1 https://github.com/amix/vimrc.git /home/$user_name/.vim_runtime touch /home/$user_name/.vim_runtime/my_configs.vim echo \":set number\" &gt; /home/$user_name/.vim_runtime/my_configs.vim chown -R $user_name /home/$user_name/.vim_runtime chmod u+x /home/$user_name/.vim_runtime/install_awesome_vimrc.sh su - $user_name -s /home/$user_name/.vim_runtime/install_awesome_vimrc.sh&#125;# Configure ftp.ftp_configure() &#123; sed -i 's/#loacl_enable=YES/loacl_enable=YES/g' /etc/vsftpd.conf sed -i 's/#write_enable=YES/write_enable=YES/g' /etc/vsftpd.conf&#125;# Configure nfs.nfs_configure() &#123; local work_file=/work if [ ! -d \"$work_file\" ];then mkdir /work fi grep \"/work\" /etc/exports 1&gt;/dev/null if [ $? -ne 0 ];then sed -i '$a\\/work *(rw,sync,no_root_squash,no_subtree_check)' /etc/exports fi&#125;# Configure samba.samba_configure() &#123; local back_file=/etc/samba/smb.conf.bakup if [ ! -e \"$back_file\" ];then cp /etc/samba/smb.conf $back_file fi check_status grep \"/work\" /etc/samba/smb.conf 1&gt;/dev/null if [ $? -ne 0 ];then sed -i \\ '$a[share_work]\\n\\ path = \\/work\\n\\ available = yes\\n\\ public = yes\\n\\ guest ok = yes\\n\\ read only = no\\n\\ writeable = yes\\n' /etc/samba/smb.conf fi /etc/init.d/samba restart chmod -R 777 /work&#125;# Execute an action.FA_DoExec() &#123; echo -e \"$&#123;BLUE_COLOR&#125;==&gt; Executing: '$&#123;@&#125;'.$&#123;END_COLOR&#125;\" eval $@ || exit $?&#125;# Install list software.install_software() &#123; local install_software_list=\\ (\"git\" \"vim\" \"tmux\" \"htop\" \"vsftpd\" \"openssh-server\" \"nfs-kernel-server\" \"portmap\" \"samba\") echo -e \"$&#123;PINK_COLOR&#125;install_software_list:$&#123;install_software_list[*]&#125;.$&#123;END_COLOR&#125;\" #install git if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"git\");then apt-get -y install git &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;git install completed.$&#123;END_COLOR&#125;\" fi #install and configure vim if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"vim\");then apt-get -y install vim &amp;&amp; vim_configure &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;vim install completed.$&#123;END_COLOR&#125;\" fi #install tmux if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"tmux\");then apt-get -y install tmux &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;tmux install completed.$&#123;END_COLOR&#125;\" fi #install htop if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"htop\");then apt-get -y install htop &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;htop install completed.$&#123;END_COLOR&#125;\" fi #install and configure vsftpd if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"vsftpd\");then apt-get -y install vsftpd &amp;&amp; ftp_configure &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;vsftpd install completed.$&#123;END_COLOR&#125;\" fi #install openssh-server if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"openssh-server\");then apt-get -y install openssh-server &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;openssh-server install completed.$&#123;END_COLOR&#125;\" fi #install and configure nfs-kernel-server if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"nfs-kernel-server\");then apt-get -y install nfs-kernel-server &amp;&amp; nfs_configure &amp;&amp; \\ /etc/init.d/nfs-kernel-server restart &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;nfs-kernel-server install completed.$&#123;END_COLOR&#125;\" fi #install portmap if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"portmap\");then apt-get -y install portmap &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;portmap install completed.$&#123;END_COLOR&#125;\" fi #install and configure samba if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"samba\");then apt-get -y install samba &amp;&amp; samba_configure &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;samba install completed.$&#123;END_COLOR&#125;\" fi #others get_host_type host_release FA_DoExec apt-get -y install \\ gnupg flex bison gperf build-essential \\ zip curl libc6-dev libncurses5-dev libncurses5-dev:i386 x11proto-core-dev \\ libx11-dev:i386 libreadline6-dev:i386 \\ libgl1-mesa-glx-lts-$host_release:i386 libgl1-mesa-dev-lts-$host_release \\ g++-multilib mingw32 tofrodos libncurses5-dev:i386 \\ python-markdown libxml2-utils xsltproc zlib1g-dev:i386 if [ ! -h /usr/lib/i386-linux-gnu/libGL.so ]; then FA_DoExec ln -s /usr/lib/i386-linux-gnu/mesa/libGL.so.1 \\ /usr/lib/i386-linux-gnu/libGL.so fi # Development support FA_DoExec apt-get -y install \\ dos2unix minicom gawk echo -e \"$&#123;GREEN_COLOR&#125;software install completed.$&#123;END_COLOR&#125;\"&#125;check_networkcheck_rootcheck_user_nameupdate_software_sourceinstall_softwareecho -e \"$&#123;GREEN_COLOR&#125;===================================================$&#123;END_COLOR&#125;\" echo -e \"$&#123;GREEN_COLOR&#125;============setup ubuntu host env ok!==============$&#123;END_COLOR&#125;\" echo -e \"$&#123;GREEN_COLOR&#125;===================================================$&#123;END_COLOR&#125;\"su $user_name exit 0 就目前来看，shell脚本还不算太难。主要就是提取某个文本内容，然后做出判断，对应执行。技巧性还是蛮多的，很有乐趣。遇到要实现某个功能，百度一下也基本有。调试的时候，能够打印出变量，或者提出局部代码进行运行测试，还是很方便的。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/环境搭建/"},{"name":"shell script","slug":"shell-script","permalink":"http://yoursite.com/tags/shell-script/"}]},{"title":"AM437x——LED裸机","date":"2017-07-28T15:09:15.000Z","path":"2017/07/28/AM437x——LED裸机/","text":"最近在玩AM437X，记录下一些学习过程。分为裸机和驱动。 0.准备文件 AM437x EVM Schematic（后称原理图YP） am4378（后称芯片手册SP） spruhl7g（后称参考手册CP） 1.分析原理图四个LED灯，单片机通过控制三极管的通断，从而控制灯的亮灭。单片机高电平，三极管打通，灯亮，反之低电平，LED灭。D7_Blue 对应uart3_txd(GPIO5_3)；D8_Blue 对应uart3_rxd(GPIO5_2)；D9_Green 对应uart3_rtsn(GPIO5_1)；D10_Red 对应uart3_ctsn(GPIO5_0)； 2.编写程序1.使能GPIO外设时钟；1PRCM_CM_PER_GPIO5_CLKCTRL = (0x01&lt;&lt;1); 2.设置GPIO模式（默认使能了上拉，且为GPIO模式）；12345678CTRL_CONF_UART3_RXD &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18);//使能上/下拉、关闭输入CTRL_CONF_UART3_RXD |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17);//IO模式，设置上拉CTRL_CONF_UART3_TXD &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18);//使能上/下拉、关闭输入CTRL_CONF_UART3_TXD |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17);//IO模式，设置上拉CTRL_CONF_UART3_RTSN &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18);//使能上/下拉、关闭输入CTRL_CONF_UART3_RTSN |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17);//IO模式，设置上拉CTRL_CONF_UART3_CTSN &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18);//使能上/下拉、关闭输入CTRL_CONF_UART3_CTSN |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17);//IO模式，设置上拉 3.设置为输出；1GPIO5-&gt;OE &amp;= ~(0x01&lt;&lt;0 | 0x01&lt;&lt;1 | 0x01&lt;&lt;2 | 0x01&lt;&lt;3); 4.设置允许输出位;1GPIO5-&gt;SETDATAOUT |= (0x01&lt;&lt;0 | 0x01&lt;&lt;1 | 0x01&lt;&lt;2 | 0x01&lt;&lt;3); 5.设置输出值;12GPIO5-&gt;DATAOUT |= (0x01&lt;&lt;0 | 0x01&lt;&lt;1 | 0x01&lt;&lt;2 | 0x01&lt;&lt;3);//高GPIO5-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;0 | 0x01&lt;&lt;1 | 0x01&lt;&lt;2 | 0x01&lt;&lt;3);//低 6.封装成函数;将前面的1-4步，封装为void led_init(void);1234567891011121314151617void led_init(void)&#123; PRCM_CM_PER_GPIO5_CLKCTRL = (0x01&lt;&lt;1); CTRL_CONF_UART3_RXD &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18); CTRL_CONF_UART3_RXD |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17); CTRL_CONF_UART3_TXD &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18); CTRL_CONF_UART3_TXD |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17); CTRL_CONF_UART3_RTSN &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18); CTRL_CONF_UART3_RTSN |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17); CTRL_CONF_UART3_CTSN &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18); CTRL_CONF_UART3_CTSN |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17); GPIO5-&gt;OE &amp;= ~(0x01&lt;&lt;0 | 0x01&lt;&lt;1 | 0x01&lt;&lt;2 | 0x01&lt;&lt;3); GPIO5-&gt;SETDATAOUT |= (0x01&lt;&lt;0 | 0x01&lt;&lt;1 | 0x01&lt;&lt;2 | 0x01&lt;&lt;3);&#125;将前面的第5步根据需求，封装成分别操作每个灯；总开关（1开0关）：1234567void led_switch(unsigned char on_off)&#123; if(on_off) GPIO5-&gt;DATAOUT |= (0x01&lt;&lt;0 | 0x01&lt;&lt;1 | 0x01&lt;&lt;2 | 0x01&lt;&lt;3); else GPIO5-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;0 | 0x01&lt;&lt;1 | 0x01&lt;&lt;2 | 0x01&lt;&lt;3);&#125; 每个灯的独立开关（1开0关）：12345678910111213141516171819202122232425262728293031void led0_switch(unsigned char on_off)&#123; if(on_off) GPIO5-&gt;DATAOUT |= (0x01&lt;&lt;0); else GPIO5-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;0);&#125;void led1_switch(unsigned char on_off)&#123; if(on_off) GPIO5-&gt;DATAOUT |= (0x01&lt;&lt;1); else GPIO5-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;1);&#125;void led2_switch(unsigned char on_off)&#123; if(on_off) GPIO5-&gt;DATAOUT |= (0x01&lt;&lt;2); else GPIO5-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;2);&#125;void led3_switch(unsigned char on_off)&#123; if(on_off) GPIO5-&gt;DATAOUT |= (0x01&lt;&lt;3); else GPIO5-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;3);&#125; 3.下载设置AM437X支持多种方式启动，比如：flash memory, memory cards and UART, USB, or Ethernet.以后估计使用U盘和SD卡的情况居多。U盘和SD卡启动对image有一定的格式要求，需要加个头信息。该部分在参考手册5.2.9 Image Format有介绍，后面有时间再分析。 这里直接用现成的tiimage.c进行加头操作。tiimage.c和程序的交叉编译，都是在Linux进行的，需要做如下步骤：1.清理，交叉编译；2.编译，加头；3.重命名；4.复制到SD卡（U盘）； 为了方便，写了脚本完成以上操作，只需要插上U盘（Windows下），然后ssh登陆执行脚本即可。关于工作流的想法，后面找个时间写写。 [hceng_am437x_create_MLO.sh]link123456789101112131415161718192021222324252627282930313233#!/bin/bashmyPath=\"/mnt/hgfs/windows/\" #利用虚拟机\"文件共享\"WindowsU盘的路径RED_COLOR='\\E[1;31m' #红GREEN_COLOR='\\E[1;32m' #绿YELOW_COLOR='\\E[1;33m' #黄BLUE_COLOR='\\E[1;34m' #蓝PINK='\\E[1;35m' #粉红RES='\\E[0m' #END#生成MLOfunction creat_MLO()&#123; rm -f /mnt/hgfs/windows/MLO make clean make gcc ./image_tool/tiimage.c -o tiimage.out ./tiimage.out 0x40300000 MMCSD am437x_hardware.bin /mnt/hgfs/windows/MLO rm -f *.dis *.bin *.o *_elf tiimage.out ls /mnt/hgfs/windows/MLO -l &amp;&amp; echo -e \"$&#123;GREEN_COLOR&#125;======MLO OK!======$&#123;RES&#125;\"\\ || echo -e \"$&#123;RED_COLOR&#125;======MLO ERROR!======$&#123;RES&#125;\" sync&#125;#判断U盘路径是否存在；#存在则生成MLO、拷贝，不存在则提示报错if [ ! -d \"$myPath\" ];then echo -e \"$&#123;RED_COLOR&#125;======Check USB Disk!======$&#123;RES&#125;\" else creat_MLO fi syncexit 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"AM437X","slug":"AM437X","permalink":"http://yoursite.com/tags/AM437X/"},{"name":"裸机","slug":"裸机","permalink":"http://yoursite.com/tags/裸机/"}]},{"title":"2017年中","date":"2017-07-23T14:51:19.000Z","path":"2017/07/23/2017年中/","text":"2017年中，毕业、工作之际。0x00:距离上次博客，过去两个月了。返校答辩后，不知为何，情绪低落了小半个月。0x01:过去的两个月里，搬出了公司，换了一个我还算比较喜欢的房子。接来女朋友，过上了两个人的小日子。趁着618免息，换了个快一万的笔记本。收到了毕业证和学位证，拿到了转正后的第一份工资。搭了梯子，翻了墙，看了看外面的世界……0x02:之前一直准备更新博客，但突然发现一些图片挂掉了，重新规划了一下图床的方案，却又突然好了。但不管怎样，博客还得继续做下去。0x03:工作内容挺杂的，唯一感到满足的终于开始独立的写Linux驱动了和看英文手册写裸机，虽然才是开始，路还很长，但至少开了头。0x04:确实还在迷茫，工作让我巩固基础，但也让我觉得没有跨越。其实很简单，想清楚自己目的是什么，需要什么，要做什么，先做什么，后做什么。给自己点压力，让自己跑起来。2017年中，新的开始。0x05: 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"移植MiniGUI到JZ2440","date":"2017-05-26T01:46:37.000Z","path":"2017/05/26/移植MiniGUI到JZ2440/","text":"尝试将MiniGUI到JZ2440上。移植所需文件： 文件包名 作用 libminigui-1.6.10.tar.gz MiniGUI开发库 minigui-res-1.6.10.tar.gz MiniGUI资源文件 mg-samples-1.6.10.tar.gz MiniGUI示例程序 tslib-1.4.tar.gz 触摸屏功能 1.移植MiniGUI1.1 解压、编译MiniGUI开发库123456tar xzf libminigui-1.6.10.tar.gzcd libminigui-1.6.10/mkdir tmp./configure CC=arm-linux-gcc --prefix=$&#123;PWD&#125;/tmp --build=i386-linux --host=arm-linux --target=arm-linuxmakemake install 完成上面操作，即可在tmp目录下生成以下文件： 将生成的/lib下所有文件(和共享库相关)拷贝到开发板/lib目录下，将生成的/etc下的MiniGUI.cfg也拷贝到开发板/etc目录下:12cp –rfd ./lib/* /work/hceng/nfs_rootfs/libcp ./etc/* /work/hceng/nfs_rootfs/etc 1.2 解压MiniGUI资源文件12tar xzf minigui-res-1.6.10.tar.gzcd minigui-res-1.6.10/ 修改config.linux，指定生成文件路径： 编译生成：1make install 此时会在指定的/tmp目录下生成以下文件： 这些文件包含了MiniGUI会使用到的资源，包括基本字体、图标、位图和鼠标光标等，将这些文件全部复制到开发板的/usr/local/lib/minigui/res/路径下，这个路径是前面MiniGUI.cfg指定的。 1.3 编译MiniGUI示例程序 解压、配置、编译：12345tar xzf mg-samples-1.6.10.tar.gzcd mg-samples-1.6.10.tar.gz/./configure CC=arm-linux-gcc --build=i386-linux --host=arm-linux -target=arm-linux CFLAGS=-I/work/minigui/libminigui-1.6.10/tmp/include LDFLAGS=-L/work/minigui/libminigui-1.6.10/tmp/libmakemake install 此时会在/src目录下生成示例程序： 复制示例程序到开发板里面去，注意有些程序需要本目录下的图片文件，需要一同拷贝过去。这里以helloworld为例：1cp helloworld /work/hceng/nfs_rootfs/ 1.4 其他修改 修改前面复制到开发板/etc目录下的MiniGUI.cfg以适应JZ2440。 在开发板的/etc目录下建立ld.so.conf文件，并添加如下内容：123/usr/local/lib/usr/lib/lib 在/etc/init.d/rcS脚本文件里添加如下内容(非必需)：1/bin/ln –s /dev/vc/0 /dev/tty0 移植MiniGUI完成，运行应用程序： 2.移植tslib2.1 安装一些工具123sudo apt-get install autoconfsudo apt-get install automakesudo apt-get install libtool 2.2 解压、编译123456789tar xzf tslib-1.4.tar.gzcd tslib./autogen.sh mkdir tmpecho &quot;ac_cv_func_malloc_0_nonnull=yes&quot; &gt;arm-linux.cache./configure --host=arm-linux --cache-file=arm-linux.cache --prefix=$(pwd)/tmpmakemake install 2.3 安装12cd tmpcp * -rfd /work/hceng/nfs_rootfs 2.4 修改/etc/ts.conf第1行(去掉#号和第一个空格)1# module_raw input 改为：1module_raw input 2.5 在开发板设置环境变量123456export TSLIB_TSDEVICE=/dev/event0export TSLIB_CALIBFILE=/etc/pointercalexport TSLIB_CONFFILE=/etc/ts.confexport TSLIB_PLUGINDIR=/lib/tsexport TSLIB_CONSOLEDEVICE=noneexport TSLIB_FBDEVICE=/dev/fb0 2.6 运行校准示例程序1ts_calibrate 如果在运行程序的时候，出现提示：1selected device is not a touchscreen I understand 有显示，但无法触屏，可能是编译器版本和内核版本不一致，解决方法如下： 修改编译器的input.h：12cd /usr/local/arm/4.3.2/arm-none-linux-gnueabi/libc/usr/include/linuxsudo vim input.h 将1#define EV_VERSION 0x010000 改为：1#define EV_VERSION 0x010001 重新进行前面的编译即可，编译后，记得改回编译器的版本。 3.MiniGUI和tslib链接 此时虽然分别移植好了MiniGUI和tslib，但触屏并不能正常的控制GUI，需要进行将MiniGUI和tslib进行链接。 使用MiniGUI 的 IAL 引擎，修改/libminigui-1.6.10/src/ial/下的dummy.c成如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include \"common.h\"#include \"tslib.h\"#ifdef _DUMMY_IAL#include &lt;sys/ioctl.h&gt;#include &lt;sys/poll.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;linux/kd.h&gt;#include \"ial.h\"#include \"dummy.h\"#ifndef _DEBUG#define _DEBUG // for debugging#endif/* for storing data reading from /dev/touchScreen/0raw */typedef struct &#123; unsigned short pressure; unsigned short x; unsigned short y; unsigned short pad;&#125; TS_EVENT;static unsigned char state [NR_KEYS];static int mousex = 0;static int mousey = 0;static TS_EVENT ts_event;static struct tsdev *ts;/************************ Low Level Input Operations **********************//** Mouse operations -- Event*/static int mouse_update(void)&#123; return 1;&#125;static void mouse_getxy(int *x, int* y)&#123; if (mousex &lt; 0) mousex = 0; if (mousey &lt; 0) mousey = 0; if (mousex &gt; 639) mousex = 639; if (mousey &gt; 479) mousey = 479;#ifdef _DEBUG // printf (\"mousex = %d, mousey = %d/n\", mousex, mousey);#endif *x = mousex; *y = mousey;&#125;static int mouse_getbutton(void)&#123; return ts_event.pressure;&#125;#ifdef _LITE_VERSIONstatic int wait_event (int which, int maxfd, fd_set *in, fd_set *out, fd_set *except, struct timeval *timeout)#elsestatic int wait_event (int which, fd_set *in, fd_set *out, fd_set *except, struct timeval *timeout)#endif&#123; struct ts_sample sample; int ret = 0; int fd; fd_set rfds; int e; if (!in) &#123; in = &amp;rfds; FD_ZERO (in); &#125;fd = ts_fd(ts); if ((which &amp; IAL_MOUSEEVENT) &amp;&amp; fd &gt;= 0) &#123; FD_SET (fd, in);#ifdef _LITE_VERSION if (fd &gt; maxfd) maxfd = fd;#endif &#125;#ifdef _LITE_VERSION e = select (maxfd + 1, in, out, except, timeout) ;#else e = select (FD_SETSIZE, in, out, except, timeout) ;#endif if (e &gt; 0) &#123; // input events is coming if (fd &gt; 0 &amp;&amp; FD_ISSET (fd, in)) &#123; FD_CLR (fd, in); ts_event.x=0; ts_event.y=0; ret = ts_read(ts, &amp;sample, 1); if (ret &lt; 0) &#123; perror(\"ts_read()\"); exit(-1); &#125; ts_event.x = sample.x; ts_event.y = sample.y; ts_event.pressure = (sample.pressure &gt; 0 ? 4:0); // if (ts_event.pressure &gt; 0 &amp;&amp; if((ts_event.x &gt;= 0 &amp;&amp; ts_event.x &lt;= 639) &amp;&amp; (ts_event.y &gt;= 0 &amp;&amp; ts_event.y &lt;= 479)) &#123; mousex = ts_event.x; mousey = ts_event.y; // printf(\"ts_event.x is %d, ts_event.y is %d-------------------------------------&gt;/n\",ts_event.x ,ts_event.y); &#125;//#ifdef _DEBUG // if (ts_event.pressure &gt; 0) &#123; // printf (\"mouse down: ts_event.x = %d, ts_event.y = %d,ts_event.pressure = %d/n\",ts_event.x,ts_event.y,ts_event.pressure); // &#125;//#endif ret |= IAL_MOUSEEVENT; return (ret); &#125; &#125; else if (e &lt; 0) &#123; return -1; &#125; return (ret);&#125;BOOL InitDummyInput(INPUT* input, const char* mdev, const char* mtype)&#123; char *ts_device = NULL; if ((ts_device = getenv(\"TSLIB_TSDEVICE\")) != NULL) &#123; // open touch screen event device in blocking mode ts = ts_open(ts_device, 0); &#125; else &#123;#ifdef USE_INPUT_API ts = ts_open(\"/dev/input/0raw\", 0);#else ts = ts_open(\"/dev/touchscreen/ucb1x00\", 0);#endif &#125;#ifdef _DEBUG printf (\"TSLIB_TSDEVICE is open!!!!!!!!!!!/n\");#endif if (!ts) &#123; perror(\"ts_open()\"); exit(-1); &#125; if (ts_config(ts)) &#123; perror(\"ts_config()\"); exit(-1); &#125; input-&gt;update_mouse = mouse_update; input-&gt;get_mouse_xy = mouse_getxy; input-&gt;set_mouse_xy = NULL; input-&gt;get_mouse_button = mouse_getbutton; input-&gt;set_mouse_range = NULL; input-&gt;wait_event = wait_event; mousex = 0; mousey = 0; ts_event.x = ts_event.y = ts_event.pressure = 0; return TRUE;&#125;void TermDummyInput(void)&#123; if (ts) ts_close(ts);&#125;#endif /* _DUMMY_IAL */ 指定tslib 相关的头文件和共享库文件重新编译libminigui: 12cd /work/minigui/libminigui-1.6.10/./configure CC=arm-linux-gcc --prefix=$&#123;PWD&#125;/tmp --build=i386-linux --host=arm-linux --target=arm-linux CFLAGS=&quot;-I/work/minigui/tslib/tmp/include -L/work/minigui/tslib/tmp/lib -lts&quot; 将新生成的/tmp/lib下的文件覆盖掉开发板原来的文件： 1cp –rfd ./lib/* /work/hceng/nfs_rootfs/lib 因为共享文件变了，这里重新编译示例程序libminigui: 1./configure CC=arm-linux-gcc --build=i386-linux --host=arm-linux -target=arm-linux CFLAGS=-I/work/minigui/libminigui-1.6.10/tmp/include LDFLAGS=-L/work/minigui/libminigui-1.6.10/tmp/lib 再将生成的应用程序复制到开发板重新运行： 1cp painter /work/hceng/nfs_rootfs/ 在开发板运行： 1./ painter 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/环境搭建/"}]},{"title":"PCB_Ruler","date":"2017-05-18T13:48:04.000Z","path":"2017/05/18/PCB-Ruler/","text":"这是一个毕业的故事。0x00 初衷： 即将大学毕业，大家在一起了四年，所以想在毕业之际准备个小东西作为纪念品。在考虑专业特色、有意义（有一定实用性）且价格不贵这些因素后，我想到做这个PCB_Ruler也许可以。 0x01 过程： 整个过程 两个人利用空闲时间制作，进行了一个多月，进行了三次大修改和PCB打样，投入1000多元。最后做了150块，分别送给了两个班87名同学、若干本专业的任课老师和行政老师等。 0x02 功能： 主要功能是测量，有cm和mil两种，其中cm是日常常用的，mil是pcb制作中一种比较通用的单位。 正面：直尺功能、有常见的电阻电容、元器件的封装参考；过孔的孔径大小参考； 背面：走线线宽参考；元器件的脚间距参考；纪念信息； 0x03 效果： 0x04 致谢： 感谢和我一起制作的同学@小冲冲，抽出空余时间，一同完成本设计。 0x05 权限：东西开源啦，开源地址：https://github.com/hceng/learn/tree/master/PCB_Ruler 0x06 毕业照： 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"PCB","slug":"PCB","permalink":"http://yoursite.com/tags/PCB/"},{"name":"设计","slug":"设计","permalink":"http://yoursite.com/tags/设计/"}]},{"title":"Linux环境编程学习","date":"2017-04-30T15:55:30.000Z","path":"2017/04/30/Linux环境编程/","text":"记录Linux环境下的编程，0基础开始，不断更新。最近在学习Linux环境编程，仿佛打开了新世界的大门。初学，认知有局限，不断修正。 文件相关1.fopen[1-fopen.c]link1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; FILE * fp; unsigned int i = 0; fp = fopen(argv[1], \"w\"); if(fp == NULL) &#123; printf(\"Unable to fopen \\n\"); return -1; &#125;/* printf(\"argc = %d\\n\",argc); for(i; i&lt;argc; i++) &#123; printf(\"argv[%d]=%s\\n\",i,argv[i]); &#125;*/ printf(\"read success \\n\"); fclose(fp); return 0;&#125; 测试结果：分析： fopen的第一个参数：argv[1]，是运行fopen时传入的参数 hceng.txt.fopen对其写操作，但没有这个文件，就自动创建了该文件。 2.fopen_max[2-fopen_max.c]link1234567891011121314#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; FILE * fp; int count = 0; fclose(stdin); while((fp = fopen(argv[1], \"r\")) != NULL) count++; printf(\"count = %d \\n\", count); return 0;&#125; 测试结果：分析： 意味着一个文件最多被打开1022次。 3. fgetc[3-fgetc.c]link123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; FILE * fp; fp = fopen(argv[1], \"r\"); if(fp == NULL) &#123; printf(\"Unable to fopen\\n\"); return -1; &#125; char ch = fgetc(fp); ch = fgetc(fp); ch = fgetc(fp); //printf(\"ch = %c \\n\", ch); fputc(ch, stdout); putchar(10); fclose(fp); return 0;&#125; 测试结果：分析： fgetc每次得到一个字符（且自动跳到下一个字符），fputc这里指定ch写到标准输出流。putchar是输出一个字符的意思，这里参数10换成ascii码是换行。 4. cat[4-cat.c]link1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; FILE *fp_r; char ch; fp_r = fopen(argv[1], \"r\"); if(fp_r == NULL) &#123; // printf(\"Unable to fopen \\n\"); fprintf(stdout, \"Unable to fopen \\n\"); return -1; &#125; while((ch = fgetc(fp_r)) != EOF) &#123; //printf(\"%c\",ch); fputc(ch, stdout); &#125; fclose(fp_r); return 0;&#125; 测试结果：分析： 实现类似cat的命令，fgetc一直获取字符到结尾，然后fputc依次打印出来。 5. cp[5-cp.c]link123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; FILE *fp_r, *fp_w; char ch; fp_r = fopen(argv[1], \"r\"); if(fp_r == NULL) &#123; fprintf(stdout,\"Unable to fopen fp_r\\n\"); return -1; &#125; fp_w = fopen(argv[2], \"w\"); if(fp_w == NULL) &#123; fprintf(stdout, \"Unable to fopen fp_w \\n\"); &#125; while((ch = fgetc(fp_r)) != EOF) &#123; fputc(ch, fp_w); &#125; fclose(fp_r); fclose(fp_w); return 0;&#125; 测试结果：分析： 实现类似cp的命令，fgetc一直获取argv[1]字符到结尾，然后fputc写到argv[2]。 6. line[6-line.c]link1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; FILE *fp_r; char ch; int line = 0; fp_r = fopen(argv[1], \"r\"); if(fp_r == NULL) &#123; fprintf(stdout, \"Unable to fopen \\n\"); return -1; &#125; while((ch = fgetc(fp_r)) != EOF) &#123; if(ch == '\\n') line++; &#125; printf(\"line = %d \\n\",line); fclose(fp_r); return 0;&#125; 测试结果：分析： 获取文件行数，fgetc一直读到结尾，遇到\\n则表示换行，即行数+1。 7. fgets[7-fgets.c]link1234567891011121314151617181920212223#include &lt;stdio.h&gt;#define N 32int main(int argc, const char *argv[])&#123; FILE *fp_r; char buf[N] = &#123;0&#125;; fp_r = fopen(argv[1], \"r\"); if(fp_r == NULL) &#123; fprintf(stdout, \"Unable to fopen fp_r \\n\"); return -1; &#125; fgets(buf, 32, fp_r); fputs(buf, stdout); fclose(fp_r); return 0;&#125; 测试结果：分析： 获取文件字符串，这里要设置读取的字符串的长度，感觉有点局限。应该是识别以\\n结尾，这里一次只读取了一行。 8. fgets_cp[8-fgets_cp.c]link123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#define N 32int main(int argc, const char *argv[])&#123; FILE *fp_r, *fp_w; char buf[N] = &#123;0&#125;; fp_r = fopen(argv[1], \"r\"); if(fp_r == NULL) &#123; fprintf(stdout, \"Unable to fopen fp_r \\n\"); return -1; &#125; fp_w = fopen(argv[2], \"w\"); if(fp_w == NULL) &#123; fprintf(stdout, \"Unable to fopen fp_w \\n\"); return -1; &#125; while(fgets(buf, 16, fp_r) != NULL) fputs(buf, fp_w); fclose(fp_r); fclose(fp_w); return 0;&#125; 测试结果：分析： 以fgets的方式获取一行，写入另一个文件，以实现cp的功能。判断的依据是fgets获取的是非空 9. fread_fwrite[9-fread_fwrite.c]link12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#define N 32int main(int argc, const char *argv[])&#123; FILE *fp_r, *fp_w; char buf[N] = &#123;0&#125;; fp_r = fopen(argv[1], \"r\"); if(fp_r == NULL) &#123; fprintf(stdout, \"Unable to fopen fp_r\\n\"); return -1; &#125; fp_w = fopen(argv[2], \"w\"); if(fp_w == NULL) &#123; fprintf(stdout, \"Unable to fopen fp_w\\n\"); return -1; &#125; size_t bytes = fread(buf, 5, 3, fp_r); fwrite(buf, 5, 2, fp_w); //printf(\"bytes = %d \\n\",bytes); return 0;&#125; 测试结果：分析： fread/ fwrite第一个参数是指向读取/写入的缓冲数据，第二个参数是定义每个数据类型的大小，第三个是定义的数据类型个数，最后是指向操作的文件指针。 10.实例 时间编程题目要求：编程读写一个文件test.txt，每隔1秒向文件中写入一行数据，类似这样：1, 2007-7-30 15:16:422, 2007-7-30 15:16:43该程序应该无限循环，直到按Ctrl-C中断程序。再次启动程序写文件时可以追加到原文件之后，并且序号能够接续上次的序号，比如：1, 2007-7-30 15:16:422, 2007-7-30 15:16:433, 2007-7-30 15:19:024, 2007-7-30 15:19:035, 2007-7-30 15:19:04 提示：要追加写入文件，同时要读取该文件的内容以决定下一个序号是几，应该用什么模式打开文件？首先判断一下打开的文件是否为新文件，如果是新文件，就从序号1开始写入；如果不是新文件，则统计原来有多少行，比如有n行，然后从序号n+1开始写入。以后每写一行就把行号加1。获取当前的系统时间需要调用函数time()，得到的结果是一个time_t类型，其实就是一个大整数，其值表示从UTC时间1970年1月1日00:00:00（称为UNIX的Epoch时间）到当前时刻的秒钟数。然后调用localtime()将time_t所表示的UTC时间转换为本地时间（我们是+8区，比UTC多8个小时）并转成struct tm类型，该类型的各数据成员分别表示年月日时分秒，请自己写出转换格式的代码，不要使用ctime()或asctime()函数。具体用法请查阅man page。time和localtime函数需要头文件time.h。调用sleep(n)可使程序睡眠n秒，该函数需要头文件unistd.h [hceng_time.c]link1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/************************************************************************* &gt; File Name: hceng_time.c &gt; Author:hceng &gt; Mail: huangcheng.job@foxmail.com &gt; Created Time: Wed 26 Apr 2017 06:48:22 AM UTC ************************************************************************/#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;int main(int argc, const char *argv[])&#123; FILE *fd; char ch; unsigned int line = 0; time_t *get_time; struct tm *local_time; //add data to file fd = fopen(argv[1], \"a+\"); if(fd == NULL) &#123; fprintf(stderr,\"can't open file!\"); return -1; &#125; //get line while((ch = fgetc(fd)) != EOF) &#123; if(ch == '\\n') ++line; &#125; //show while(1) &#123; time(get_time); local_time = localtime(get_time); fprintf(fd,\"%d. %d-%d-%d %d:%d:%d\\n\",++line,local_time-&gt;tm_year+1900,local_time-&gt;tm_mon,local_time-&gt;tm_mday,local_time-&gt;tm_hour,local_time-&gt;tm_min,local_time-&gt;tm_sec); printf(\"%d. %d-%d-%d %d:%d:%d\\n\",line,local_time-&gt;tm_year+1900,local_time-&gt;tm_mon,local_time-&gt;tm_mday,local_time-&gt;tm_hour,local_time-&gt;tm_min,local_time-&gt;tm_sec); fflush(fd); sleep(1); &#125; fclose(fd); return 0;&#125; 测试结果：分析： 先以追加的方式打开文件（没有则创建），然后获取文件行数，再获取时间且转换成本地时间，然后按格式要求打印信息。 进程相关1.fork1[fork.c]link12345678910111213141516171819202122232425262728293031#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; pid_t pid; printf(\"hello world\\n\"); pid = fork(); printf(\"pid = %d\\n\",pid); if(pid &lt; 0) &#123; perror(\"Unable to fork\"); return -1; &#125; if(pid == 0) &#123; //子进程 printf(\"child process parent %d ,child = %d\\n\",getppid(), getpid()); &#125; else &#123; //父进程: printf(\"parent process = %d, child = %d\\n\", getpid(), pid); &#125; while(1); return 0;&#125; 测试结果：分析： 首先父进程fork了自己，返回了子进程的PID，并打印出来。然后继续执行，打印出自己的PID和子进程PID。子进程产生了和父进程一模一样的代码，然后从fork处开始执行，子进程fork返回的的固定为0，然后getppi打印出父进程PID，getpid打印出自己的PID。 从PS可以看到父进程PID为：11370，子进程为：11371. 注：一般fork后是父进程继续运行，但如果父进程时间片用完了，则子进程会先进行，所以这里的打印顺序是不确定的，如果要确定，需要同步。 2.fork2[fork_1.c]link12345678910111213141516171819202122232425262728#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; pid_t pid; pid = fork(); if(pid &lt; 0) &#123; perror(\"Unable to fork\"); return -1; &#125; if(pid == 0) &#123; //子进程 printf(\"child process parent %d ,child = %d\\n\",getppid(), getpid()); &#125; else &#123; //父进程: printf(\"parent process = %d, child = %d\\n\", getpid(), pid); while(1); &#125; return 0;&#125; 测试结果：分析： 这里父进程有个whileh会一直执行，二子程序没有。在PS中可以看到子进程（12173）被标记为defunct(僵尸进程)。 在Linux系统中，一个进程结束了，但是他的父进程没有等待(调用wait / waitpid)他，那么他将变成一个僵尸进程。当用ps命令观察进程的执行状态时，看到这些进程的状态栏为defunct。僵尸进程是一个早已死亡的进程，但在进程表（processs table）中仍占了一个位置（slot）。 但是如果该进程的父进程已经先结束了，那么该进程就不会变成僵尸进程。因为每个进程结束的时候,系统都会扫描当前系统中所运行的所有进程，看看有没有哪个进程是刚刚结束的这个进程的子进程，如果是的话，就由Init进程来接管他，成为他的父进程，从而保证每个进程都会有一个父进程。而Init进程会自动wait其子进程,因此被Init接管的所有进程都不会变成僵尸进程。 3.fork3[fork_2.c]link123456789101112131415161718192021222324252627282930313233343536#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;wait.h&gt;int main(int argc, const char *argv[])&#123; pid_t pid; pid = fork(); if(pid &lt; 0) &#123; perror(\"Unable to fork\"); return -1; &#125; if(pid == 0) &#123; //子进程 printf(\"child process parent %d ,child = %d\\n\",getppid(), getpid()); exit(0); &#125; else &#123; //父进程: int status; sleep(4); wait(&amp;status); printf(\"child exit\\n\"); sleep(4); printf(\"parent status = %d\\n\", status); &#125; return 0;&#125; 测试结果：分析： 这里多了个wait来监控子进程。当父进程执行wait时，立即被阻塞，直到子进程退出，才继续执行后续的。第一个sleep(4)时，PS看到父进程为15167,子进程15168为僵尸状态，执行wait时，自动回收僵尸进程。等回收完了，父进程结束阻塞，继续执行到结束。 4.exit和_exit12345678910111213#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;//#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; printf(\"hello world\"); _exit(5); //exit(5); printf(\"hello Shenzhen\\n\"); return 0;&#125; 123456789101112#include &lt;stdio.h&gt;//#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; printf(\"hello world\"); //_exit(5); exit(5); printf(\"hello Shenzhen\\n\"); return 0;&#125; 123456789101112#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;//#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; printf(\"hello world\\n\"); _exit(5); //exit(5); printf(\"hello Shenzhen\\n\"); return 0;&#125; 分析： _exit()执行后立即返回给内核，而exit()要先执行一些清除操作，然后将控制权交给内核。调用_exit函数时，其会关闭进程所有的文件描述符，清理内存以及其他一些内核清理函数，但不会刷新流(stdin, stdout, stderr …)。exit函数是在_exit函数之上的一个封装，其会调用_exit，并在调用之前先刷新流。因此才会看到遇到_exit并不会打印，因为数据在“IO缓存”，而exit会刷新流，导致打印输出。 带三个例子加个\\n，使用_exit也打印出来了， printf函数就是使用缓冲I/O的方式，该函数在遇到“\\n”换行符时自动的从缓冲区中将记录读出。 参考文章 5.daemon1、何为守护进程？（1）daemon:守护进程、 后台程序简称是d，（一般带有d的都是守护进程）（2）长期运行： 从系统启动时开始运行，到系统关闭时结束(运行周期)（3）与控制台脱离（终端）：守护进程启动后，脱离控制台，不受终端控制，背后的问题是会话（4）服务器：是一个应用程序，使用时直接调用定义： 是一个在后台运行，并且不受终端控制的服务程序！2、编写守护进程（1）创建父子进程，父进程退出 （孤儿进程）（2）在子进程中设置新的会话 （setsid）（3）改变当前目录为根目录（4）重设文件权限掩码 （增加对文件操作灵活性）（5）关闭所有文件描述符创建完守护进程之后，要加入服务程序，并且要在while循环之中实现。参考文章1；参考文章2； [dameon.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; pid_t pid; pid = fork(); if(pid &lt; 0) &#123; perror(\"Unable to fork\"); exit(1); &#125; if(pid == 0) &#123; //创建新的会话，让子进程成为会话组的领导者，不受终端控制 setsid(); //改变当前目录为根目录 chdir(\"/\"); //重设文件权限掩码 umask(0); //关闭打开的文件描述符 int i, fd_w; char buf[] = &#123;\"hello world\\n\"&#125;; //getdtablesize()返回这个进程的文件描述表的项数 for(i = 0; i &lt; getdtablesize(); i++) close(i); fd_w = open(\"/test123.txt\", O_CREAT | O_WRONLY | O_APPEND, 0666); if(fd_w &lt; 0) &#123; perror(\"Unalbe to open\"); exit(1); &#125; while(1) &#123; write(fd_w, buf, 20); sleep(1); &#125; close(fd_w); &#125; else &#123; exit(0); &#125; return 0;&#125; 测试结果：ps -ajx分析： 守护进程用于一直后台运行，且不受终端控制。编写守护程序有5步，参考前面的介绍。 6.exec[exec.c]link12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; printf(\"hello start \\n\");#if 1 if(execl(\"/bin/ls\", \"ls\", \"-l\", \"-a\", NULL) &lt; 0) &#123; perror(\"Unable to execl\"); exit(1); &#125;#endif#if 0 if(execlp(\"ls\", \"ls\", \"-l\", \"-a\", NULL) &lt; 0) &#123; perror(\"Unable to execl\"); exit(1); &#125;#endif#if 0 char *arg[] = &#123;\"ls\", \"-la\", NULL&#125;; if(execv(\"/bin/ls\", arg) &lt; 0) &#123; perror(\"Unable to execl\"); exit(1); &#125;#endif printf(\"hello end \\n\"); return 0;&#125; 测试结果：分析： 这里的三个exec系列函数的效果都是一样的。调用某个新程序后，就把自己覆盖了，所以最后的hello end才没打印。 区别如下： 带“p”的表示PATH有关； 带“l”的表示list,与数组有关； 带“v”的表示vector； 带“e”的表示environment，将使用调用者的environ； 线程相关 线程是什么？线程是一个轻量级的进程，内核也会调度线程，线程在进程当中创建。 进程和线程的区别？线程没有自己独享的资源，因此没有自己的地址空间，他要依附在进程的地址空间中借助进程的资源运行。线程优点：数据共享很简单，创建线程的要快于创建进程；线程缺点：安全性、相互之间容易影响、有限的虚拟地址空间； 线程间如何实现通信？ 全局变量、数组 线程标识符：用来唯一的表示一个线程，通过调用线程库来实现对线程的访问操作。 线程相关函数：1、创建 –》 pthread_create2、回收线程 –》 pthread_join3、结束线程 –》 pthread_exit4、线程销毁 –》 pthread_destroy 1.pthread1234567891011int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);功能：创建线程参数：thread 线程对象attr 线程属性默认为NULL，栈的空间大小是8Mstart_routine 函数指针，用来指向函数名arg 参数，作为函数指针的参数返回值：成功： 0失败： 错误码 123void pthread_exit(void *arg)功能： 线程结束函数参数： 传递线程退出时的状态值 12345pthread_join（pthread_t pthread， void**retval）功能：线程回收函数（阻塞等待，直到等到线程退出了，会立即释放）参数： pthread 线程对象retval 线程退出时的状态值 [pthread.c]link12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void *pthread_fun(void * arg)&#123; int i = 20; printf(\"*arg = %d \\n\", *(int *)arg); while(i--) &#123; printf(\"pthread i = %d \\n\", i); sleep(1); if(i == 10) pthread_exit(\"pthread exit\"); &#125;&#125;int main(int argc, const char *argv[])&#123; pthread_t tid; int num = 18; if(pthread_create(&amp;tid, NULL, pthread_fun, &amp;num) != 0) &#123; perror(\"Unable to pthread_create\"); exit(1); &#125; printf(\"pthread start \\n\"); void * ret; pthread_join(tid, &amp;ret); printf(\"pthread end %s \\n\", (char *)ret); return 0;&#125; 测试结果：分析： pthread_create创建线程pthread_fun，并传入参数&amp;num，然后主进程调用pthread_join等待线程。线程每隔1s打印输出，直到i = 10时，调用pthread_exit结束线程，同时传递状态值pthread exit到pthread_join。主进程再打印出状态值后退出。 注意：编译的时候加上-pthread 2.mutex不加互斥锁：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;pthread_mutex_t lock;int value_1, value_2;void *pthread_fun(void * arg)&#123; while(1) &#123; //pthread_mutex_lock(&amp;lock); if(value_1 == value_2) &#123; printf(\"value_1 = %d, value_2 = %d\\n\", value_1, value_2); &#125; //pthread_mutex_unlock(&amp;lock); &#125;&#125;int main(int argc, const char *argv[])&#123; int count = 0; pthread_t pthread; if(pthread_mutex_init(&amp;lock, NULL) &lt; 0) &#123; perror(\"fail to pthread_mutex_init \"); exit(1); &#125; if(pthread_create(&amp;pthread, NULL, pthread_fun, NULL) &lt; 0) &#123; perror(\"fail to pthread_create \"); exit(1); &#125; while(1) &#123; count++; //pthread_mutex_lock(&amp;lock); value_1 = count; value_2 = count; //pthread_mutex_unlock(&amp;lock); &#125; pthread_join(pthread, NULL); return 0;&#125;测试结果： 加上互斥锁：[pthread_mutex.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;pthread_mutex_t lock;int value_1, value_2;void *pthread_fun(void * arg)&#123; while(1) &#123; pthread_mutex_lock(&amp;lock); if(value_1 == value_2) &#123; printf(\"value_1 = %d, value_2 = %d\\n\", value_1, value_2); &#125; pthread_mutex_unlock(&amp;lock); &#125;&#125;int main(int argc, const char *argv[])&#123; int count = 0; pthread_t pthread; if(pthread_mutex_init(&amp;lock, NULL) &lt; 0) &#123; perror(\"fail to pthread_mutex_init \"); exit(1); &#125; if(pthread_create(&amp;pthread, NULL, pthread_fun, NULL) &lt; 0) &#123; perror(\"fail to pthread_create \"); exit(1); &#125; while(1) &#123; count++; pthread_mutex_lock(&amp;lock); value_1 = count; value_2 = count; pthread_mutex_unlock(&amp;lock); &#125; pthread_join(pthread, NULL); return 0;&#125;测试结果：分析： 假如不加互斥锁，可能出现这种情况：主进程里将count赋值给value_1和value_2，此时value_1=value_2，线程里面的if(value_1 == value_2)通过了，这时线程的时间片用完，主进程执行count++和value_1 = count，此时主进程的时间片用完，线程继续执行，打印出value_1和value_2，就会发现value_1不等于value_2。 现在加上互斥锁，主进程count++,然后上锁，此时不能系统中断后续的count赋值给value_1和value_2，然后主线程再解锁。线程在if(value_1 == value_2)也上锁，保证后面的不被中断，打印出value_1和value_2，再解锁，整个过程，value_1一直value_2。 3.syns[pthread_syns.c]link1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;semaphore.h&gt;#define N 32char buf[N] = &#123;0&#125;;sem_t mysem;void *pthread_fun(void * arg)&#123; while(1) &#123; sem_wait(&amp;mysem); printf(\"--&gt; %s\\n\",buf); &#125;&#125;int main(int argc, const char *argv[])&#123; pthread_t tid; sem_init(&amp;mysem, 0, 0); if(pthread_create(&amp;tid, NULL, pthread_fun, NULL) != 0) &#123; perror(\"Unable to pthread_create\"); exit(1); &#125; while(1) &#123; fgets(buf, 32, stdin); sem_post(&amp;mysem); &#125; return 0;&#125; 测试结果：分析： 这里利用了信号同步。主线程调用fgets等待输入，输入完成后使用sem_post发送mysem信号，线程一直调用sem_wait等待信号，一旦信号到来，就打印出buf. 进程通信 条件变量： 定义：一个线程临界资源状态的变化，会通知另外一个线程去做相应的功能处理；条件变量跟互斥锁配合使用； 特点:具有阻塞功能、唤醒；为什么需要进程间通信？ 1、数据交互 2、共享资源 3、信号通知 4、同步或者互斥进程间通信方式介绍： 1、传统的进程间通信 无名管道、有名管道、信号通知 2、sytem V – IPC 共享内存、消息队列、信号量 前面六种只能用于单台的计算机中使用 3、套接字 1.kill[kill.c]link12345678910111213#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; if(kill(atoi(argv[1]), atoi(argv[2])) &lt; 0) &#123; perror(\"Unable to kill\"); exit(1); &#125; return 0;&#125; 测试结果：分析： kill()有两个参数，第一个是操作进程的PID，第二个是信号种类的编号。其中2是SIGINT结束进程，所以发送这个信号后，signal就打印hello world。结束进程。 2.raise[raise.c]link123456789101112131415#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; printf(\"hello wrold.\\n\"); if(raise(atoi(argv[1])) &lt; 0) &#123; perror(\"Unable to raise\"); exit(1); &#125;while(1); return 0;&#125; 测试结果：分析： raise()只能给自己发送信号，而且还不能发送SIGQUIT。这里raise自己发送SIGINT结束了自己。 3.signal12345678signal（int signum， sighandler_t handler）功能：信号响应函数参数：1. signum：信号种类中的一种，跟handler关联起来，执行相应的处理方式2. 忽略 SIG_IGN、 默认 SIG_DFL、 捕捉 --&gt;自己定义一个信号处理函数，类型跟sighandler_t的形式一致 把linux中已经定义好的62种信号中的一种信号跟linux传递给进程的信号signo做判断，看是那种信号，再做相应的处理 常用信号编号 种类 默认操作：结束进程2 SIGINT ctrl+c 结束进程3 SIGQUIT ctrl+\\ 结束进程9 SIGKILL 结束进程10 SIGUSR1 结束进程12 SIGUSR2 结束进程14 SIGALRM 结束进程19 SIGSTOP 暂停进程20 SIGTSTP ctrl+z 暂停进程注：SIGKILL 和SIGSTOP不能被忽略或者捕捉[signal.c]link12345678910111213141516171819202122#include &lt;signal.h&gt;#include &lt;stdio.h&gt;//signo代表内核相当前进程发送的信号时什么,而我们又不清楚时那个信号//需要用if语句做判断void fun(int signo)&#123; if(signo == SIGINT) &#123; printf(\"hello world \\n\"); &#125;&#125;int main(int argc, const char *argv[])&#123; //信号处理函数，本身不具有阻塞作用 //第一个参数： 要出里的信号是什么？62中的一种 //第二个参数： 三种相应方式： //忽略（SIG_IGN）、默认(SIG_DFL)、捕捉(用户自定义函数) signal(SIGINT, fun); pause(); return 0;&#125;测试结果：分析： 主函数调用signal安装信号，第一个参数指定了信号类型为按下CTRL+C产生，第二个为捕捉到信号后相应操作。然后信号的处理函数判断出信号类型后执行对应的操作。 pause()功能：引起调用进程进程阻塞，知道收到信号才会立即结束 4.alarm[alarm.c]link1234567891011121314151617#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; int ret = -1; ret = alarm(9); printf(\"ret = %d \\n\", ret); sleep(3); ret = alarm(10); printf(\"ret = %d \\n\", ret); pause(); printf(\"hello world \\n\"); //while(1); return 0;&#125; 测试结果：分析： 先给ret赋值个-1，然后调用alarm设置为9，因为之前没有设置过alarm，所以返回0.然后休眠3秒后，有赋值为10，此时返回的为6，即上次设置后剩下的时间9-3=6.然后程序调用pause挂起程序，直到10秒后，闹钟到了，发送SIGALRM信号结束进程。 5.pipe[pipe.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, const char *argv[])&#123; int fd[2]; pid_t pid; char buf[1024] = &#123;0&#125;; int count = 0; if(pipe(fd) &lt; 0) &#123; perror(\"Unable to pipe\"); exit(1); &#125;#if 1 pid = fork(); if(pid &lt; 0) &#123; perror(\"Unable to fork\"); exit(1); &#125; if(pid == 0) &#123;// printf(\"fd[0] = %d , fd[1] = %d \\n\", fd[0], fd[1]); while(1) &#123; read(fd[0], buf, 32);//如果管道中没有数据，读操作会阻塞 if(strncmp(buf, \"quit\", 4) == 0) break; printf(\"--&gt; %s \\n\", buf); &#125; &#125; else &#123;// printf(\"fd[0] = %d , fd[1] = %d \\n\", fd[0], fd[1]); while(1) &#123; fgets(buf, 32, stdin); write(fd[1], buf, strlen(buf) + 1); if(strncmp(buf, \"quit\", 4) == 0) break; &#125; wait(NULL); &#125;#endif#if 0 while(1) &#123;//如果缓冲区慢，则会阻塞在write函数 write(fd[1], buf, 1024); count++; if(count == 64) &#123; read(fd[0], buf, 1024); read(fd[0], buf, 1024); read(fd[0], buf, 1024); read(fd[0], buf, 1024); &#125; printf(\"count = %d \\n\", count); &#125;#endif close(fd[0]); write(fd[1], buf, 1024); return 0;&#125; 测试结果：分析： 这里创建一个管道完成进程间的通信，父进程负责写数据，子进程负责读数据。 首先是pipe()创建了一个管道，其中fd[0]是标准输入，fd[1]是标准输出。然后在fork()创建了个子进程。 父进程的工作：不断从键盘获得数据，存入buf。然后将buf数据写入fd[1]。如果收到“quit”字符即退出，调用wait()等待子进程结束。 子进程的工作：不断从fd[0]读取数据到buf，打印buf，如果遇到“quit”字符即退出。 管道的意义就是，连通了fb[0]和fb[1]，实现了进程间数据/信号的单向传输。 6.fifo[mkfifo_w.c]link123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#define N 32int main(int argc, const char *argv[])&#123; int fd_r, fd_w; size_t bytes = 0; char buf[N] = &#123;0&#125;; if(mkfifo(\"myfifo\", 0666) &lt; 0) &#123; perror(\"Unable to mkfifo\"); // exit(1); &#125; fd_w = open(\"myfifo\", O_WRONLY); if(fd_w &lt; 0) &#123; perror(\"Unable to open fd_w.\"); exit(1); &#125; printf(\"fifo write\\n\"); while(1) &#123; fgets(buf, 32, stdin); write(fd_w, buf, strlen(buf) + 1); if(strncmp(buf, \"quit\", 4) == 0) break; &#125; return 0;&#125; [mkfifo_r.c]link12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#define N 32int main(int argc, const char *argv[])&#123; int fd_r; size_t bytes = 0; char buf[N] = &#123;0&#125;; fd_r = open(\"myfifo\", O_RDONLY); if(fd_r &lt; 0) &#123; perror(\"Unable to open fd_r\"); exit(1); &#125; while(1) &#123; read(fd_r, buf, 32); if(strncmp(buf, \"quit\", 4) == 0) break; printf(\"--&gt; %s \\n\", buf); &#125; return 0;&#125; 测试结果：分析： FIFO的功能与管道差不多，但FIFO在文件系统中拥有一个名称，其打开方式和打开普通文件是一样的，这样就可以实现非相关的进程通信。 写入端/发送端：首先创建一个名叫“myfifo“，权限为666的FIFO。然后打开这个FIFO，不断从键盘获得数据写入FIFO里面，直到遇到”quit“退出。 读出端/接收端：打开同名FIFO，不断从中读取数据打印出来，直到遇到”quit“退出。 7.ftok[ftok.c]link1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; key_t key; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"Unable to ftok\"); exit(1); &#125; printf(\"key = %#x \\n\", key); return 0;&#125; 测试结果： 分析： 这里ftok应该是产生一个唯一的标识，因为路径是唯一的，对应的key有是唯一的。后面的IPC对象：共享内存、消息队列、信号灯，通过key找到内核对象。通过shell命令ipcs来查看对象信息。 编程框架：1、通过ftok函数得到key值，让不同的进程找到内核对象2、创建或者打开内核对象（共享内存、消息队列、信号灯集）3、操作内核对象 共享内存 ：通过shmat映射内核中的共享内存到用户空间， 解除映射shmdt，不能再操作共享内存。 消息队列：通过msgsnd发送消息，msgrcv接收消息4、删除内核对象 删除共享内存shmctl 删除消息队列msgctl 8.msg【1】消息队列机制1234特点： 1、先进先出 2、按照类型发送、读取消息 使用ipcs -q查看系统中的消息 【2】如何创建消息队列1234567msggetint msgget(key_t key, int msgflg);功能：创建或者打开消息队列key:让不同的进程找到同一个消息队列msgflg： IPC_CREAT | IPC_EXCL | 0666 创建 防止重复创建 权限 【3】发送消息/接收消息123456789101112131415161718192021结构体： struct msgbuf &#123; long mtype; /* message type, must be &gt; 0 */消息类型 char mtext[1]; /* message data */消息正文 &#125;;msgsnd/msgrcv:int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); 功能： msgid： 消息队列标示符 （用于操作消息队列发送或者接收消息） msgp：首先定义一个消息队列的结构体，类型如上所示结构体1 msgsz：消息队列正文（text）的大小 msgflg：设置为阻塞的方式0 非阻塞的方式 IPC_NOWAITssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); msgid： 消息队列标示符 （用于操作消息队列发送或者接收消息） msgp：首先定义一个消息队列的结构体，类型如上所示结构体1 msgsz：消息队列正文（text）的大小 msgtyp：消息的类型（必须是大于0的整数） msgflg：设置为阻塞的方式0 非阻塞的方式 IPC_NOWAIT 【4】控制(删除)消息队列msgctl1234 int msgctl(int msqid, int cmd, struct msqid_ds *buf); msgid： 消息队列标示符 （用于操作消息队列发送或者接收消息） cmd：操作消息队列的命令 IPC_STAT 获取消息队列属性信息的命令，需要定义一个struct msqid_ds结构体 [msg_w.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/msg.h&gt;struct msgbuf&#123; long type; char text[32];&#125;;#define MSG_SIZE (sizeof(struct msgbuf) - sizeof(long))int main(int argc, const char *argv[])&#123; key_t key; int msgid; struct msgbuf mymsg; char buf[32] = &#123;0&#125;; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"Unable to ftok\"); exit(1); &#125; msgid = msgget(key, IPC_CREAT | IPC_EXCL | 0666); if(msgid &lt; 0) &#123; if(errno == EEXIST) &#123; msgid = msgget(key, 0666); &#125; else &#123; perror(\"Unable to msgget\"); exit(1); &#125; &#125; system(\"ipcs -q\"); mymsg.type = 100; //strcpy(mymsg.text,\"hello world\"); while(1) &#123; fgets(buf, 32, stdin); strcpy(mymsg.text, buf); if(msgsnd(msgid, &amp;mymsg, MSG_SIZE, 0) &lt; 0) &#123; perror(\"Unable to msgsnd\"); exit(1); &#125; &#125; system(\"ipcs -q\"); return 0;&#125; [msg_r.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/msg.h&gt;#include &lt;string.h&gt;struct msgbuf&#123; long type; char text[32];&#125;;#define MSG_SIZE (sizeof(struct msgbuf) - sizeof(long))int main(int argc, const char *argv[])&#123; key_t key; int msgid; struct msgbuf mymsg; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"Unable to ftok\"); exit(1); &#125; msgid = msgget(key, IPC_CREAT | IPC_EXCL | 0666); if(msgid &lt; 0) &#123; if(errno == EEXIST) &#123; msgid = msgget(key, 0666); &#125; else &#123; perror(\"Unable to msgget\"); exit(1); &#125; &#125; while(1) &#123; if(msgrcv(msgid, &amp;mymsg, MSG_SIZE, 100, 0) &lt; 0) &#123; perror(\"Unable to msgsnd\"); exit(1); &#125; system(\"ipcs -q\"); printf(\"--&gt;%ld %s \\n\", mymsg.type, mymsg.text); &#125; if(msgctl(msgid, IPC_RMID, NULL) &lt; 0) &#123; perror(\"Unable to msgctl\"); exit(1); &#125; system(\"ipcs -q\"); return 0;&#125; 测试结果：分析： 消息队列是让进程以消息的形式交换数据。 写入端/发送端：定义一个消息msgbuf的结构体，其中一个是类型，一个是数据。调用ftok()创建唯一的key。调用msgget()创建或打开消息队列，调用shell显示当前的ipc中的消息队列信息。设置类型为100，不断从键盘获取数据复制到mymsg.text，并调用msgsnd()发送出去。 读出端/接收端：使用调用ftok()传入相同的参数，得到相同的key，调用msgget()打开同一个消息队列。调用msgcrv()接收消息，接收到则打印书类型和数据。后面的消息队列控制函数并没有调用到，第二个参数IPC_RMID表示立即删除队列消息。这里使用shell命令：ipcrm -q [msgid]手动删除。 9.sem[1]信号灯机制123信号量的集合（一个或者多个信号量，信号量是一类资源，资源的值代表了资源的数量） 实现同步：按照约定的先后顺序执行 互斥： 可以用两个信号量实现互斥操作 [2]打开或者创建信号灯semget123456789101112int semget(key_t key, int nsems, int semflg);功能：打开或者创建信号量参数 nsems： 信号量的数量是多少个？系统从0开始分配 举例：当nsems = 1则信号量是0 当nsems = 2则信号量分别是 0 和 1 当nsems = 3则信号量分别是 0 和 1 和 2 semflg：设置semget函数的功能： IPC_CREAT | IPC_EXCL | 0666 创建 防止重复创建 有效权限位返回值： 成功返回信号量操作表示符 失败 -1 [3]信号灯初始化semctl12345678910111213141516171819 int semctl(int semid, int semnum, int cmd, ...); 功能：信号量控制函数 参数： semnum 操作第几个信号量 举例 semnum 是 0，表示操作第0个信号量 举例 semnum 是 1，表示操作第1个信号量 cmd： 对信号量使用的命令 IPC_STAT 获取信号量的属性信息 SETVAL 初始化信号量的值，需要定义一个联合体 类型如下所示：union semun &#123; int val; /* Value for SETVAL */ struct semid_ds *buf;/* Buffer for IPC_STAT, IPC_SET */ unsigned short *array;/* Array for GETALL, SETALL */struct seminfo *__buf;/* Buffer for IPC_INFO(Linux-specific) */&#125;; …：表示参数不确定如果使用IPC_STAT、SETVAL命令，必须使用第四个参数定义一个联合体变量来接收如果定义IPC_RMID则不用使用第四个参数 [4]信号量操作方式123456789int semop(int semid, struct sembuf *sops, unsigned nsops); 功能：信号量的pv操作 sops：对信号量的操作方式 unsigned short sem_num; /* 第几个信号量*/ short sem_op; /* 信号量的PV操作,正数表示释放操作、负数表示申请操作 */ short sem_flg; /*0表示阻塞方式,IPC_NOWAIT表示非阻塞方式*/ nsops：表示操作几个信号量，从0开始 P申请操作 V释放操作 [sem_w.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/shm.h&gt;union semun&#123; int val;&#125;;int main(int argc, const char *argv[])&#123; key_t key; int semid; union semun mysem; struct sembuf mybuf; char buf1[32] = &#123;0&#125;; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"fail to ftok\"); exit(1); &#125; semid = semget(key, 2, IPC_CREAT | IPC_EXCL | 0666); if(semid &lt; 0) &#123; if(errno == EEXIST) semid = semget(key, 2, 0666); else &#123; perror(\"fail to semget\"); exit(1); &#125; &#125; else &#123; mysem.val = 0; semctl(semid, 0, SETVAL, mysem); mysem.val = 1; semctl(semid, 1, SETVAL, mysem); &#125; int shmid = shmget(key, 128, IPC_CREAT | 0666); if(shmid &lt; 0) &#123; if(errno == EEXIST) &#123; shmid = shmget(key, 128, 0666); &#125; else&#123; perror(\"fail to shmget\"); exit(1); &#125; &#125; char *buf = (char *)shmat(shmid, NULL, 0); if(buf == (char *)-1) &#123; perror(\"fail to shmat\"); exit(1); &#125; while(1) &#123; fgets(buf1, 32, stdin); mybuf.sem_num = 1; mybuf.sem_op = -1; mybuf.sem_flg = 0; semop(semid, &amp;mybuf, 1); strcpy(buf,buf1); mybuf.sem_num = 0; mybuf.sem_op = 1; mybuf.sem_flg = IPC_NOWAIT; semop(semid, &amp;mybuf, 1); &#125; system(\"ipcs -s\"); return 0;&#125; [sem_rw.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt;union semun&#123; int val;&#125;;int main(int argc, const char *argv[])&#123; key_t key; int semid; union semun mysem; struct sembuf mybuf; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"fail to ftok\"); exit(1); &#125; semid = semget(key, 2, IPC_CREAT | IPC_EXCL | 0666); if(semid &lt; 0) &#123; if(errno == EEXIST) semid = semget(key, 2, 0666); else &#123; perror(\"fail to semget\"); exit(1); &#125; &#125; else &#123; mysem.val = 0; semctl(semid, 0, SETVAL, mysem); mysem.val = 1; semctl(semid, 1, SETVAL, mysem); &#125; int shmid = shmget(key, 128, IPC_CREAT | 0666); if(shmid &lt; 0) &#123; if(errno == EEXIST) &#123; shmid = shmget(key, 128, 0666); &#125; else&#123; perror(\"fail to shmget\"); exit(1); &#125; &#125; char *buf = (char *)shmat(shmid, NULL, 0); if(buf == (char *)-1) &#123; perror(\"fail to shmat\"); exit(1); &#125; while(1) &#123; mybuf.sem_num = 0; mybuf.sem_op = -1; mybuf.sem_flg = 0; semop(semid, &amp;mybuf, 1); printf(\"--&gt; %s \\n\", buf); mybuf.sem_num = 1; mybuf.sem_op = 1; mybuf.sem_flg = IPC_NOWAIT; semop(semid, &amp;mybuf, 1); &#125; system(\"ipcs -s\"); return 0;&#125; 测试结果：分析： 信号量不是用来在进程间传输数据的，而是用来同步数据的。这里里共享内存为例，完成两个进程的同步。 写入端/发送端：首先调用ftok()创建唯一的key。调用semget ()创建或打开信号量集，其中第二个参数表示创建两个信号量。然后调用控制函数semctl()分别设置两个的值为0和1。然后创建一个共享内存，映射到用户空间，不断从键盘获得输入。mybuf.sem_num表示设置第1个信号量，mybuf.sem_op为负表示期望减，mybuf.sem_flg为0为阻塞，IPC_NOWAIT为非阻塞。然后在调用semop()进行设置刚才初始化的sembuf。即读去到数据则欲将第一个信号量减1。复制好后，再将第0个信号量欲加1. 读出端/接收端：前面部分都是对应的，在循环部分，先欲把第0个信号量减1，等打印完后，再欲把第1个信号量设置为1。 即整个流程，先信号量0和1分别为0和1。sem.w收到数据，则欲将第1个信号量减1，成功，继续执行执行strcpy()，然后将信号量0设置为1。这时sem.r中，之前欲将第0个参数减1，但为0，减不动，阻塞着，现在发现第0个信号量被设置为1，于是继续执行，打印了出来。然后设置第1个参数为1。这时，sem.w中刚走完一个循环，且收到了键盘数据，但现在第1个信号量是0，无法拷贝，现在发现第1个参数被设置为了1，于是又继续执行后续的拷贝和设置信号量。如此往复。 10.shm 共享内存：内核空间中的一块区域，由用户创建，系统维护里面的数据结构，通过获取到的描述符shmget的返回值，对共享内存进行操作； 特点： 1、高效，因为用户可以直接对内和对象进行操作，并不需要把数据在写到自己的用户空间里，在所有的进程间通信对象中是最快的。 注意： 1、映射，共享内存的映射，就是把共享内存段的地址传递给用户空间相应数据类型的指针变量。 2、同步和互斥：对共享内存进行循环操作的时候，容易出现一个进程在写操作的时候，另一个已经打读了好多次，为了能够完成写一次读一次操作，需要进行同步或者互斥。 步骤：【1】共享内存创建 1234567shmgetint shmget(key_t key, size_t size, int shmflg);功能： 创建或者打开共享内存key： 通过ftok函数返回，用于让不同的进程找到内核区域中的内核对象（共享内存）size：指定共享内存的大小，以字节为单位shmflg：指定创建的共享内存具有什么权限 IPC_CREAT | IPC_EXCL | ０６６６ 【2】映射共享内存1234567shmatvoid *shmat(int shmid, const void *shmaddr, int shmflg);功能：把内核空间的共享内存映射到用户空间，（因为用户空间根内核空间不能直接访问，所以通过映射的方式，简介得到这块共享内存地址）shmid:【操作】共享内存的表示符shmaddr： NULL有系统来分配一块共享内存shmflg： 0 【3】解除映射1shmdt 【4】删除共享内存12345678shmctlint shmctl(int shmid, int cmd, struct shmid_ds *buf);功能：共享内存对象控制函数通过命令，也就是第二个参数设置：IPC_STAT用来获取共享内存的一些属性信息IPC_RMID用来删除共享内存对象buf：用来存储共享内存的属性信息的，需要定义一个struct shmid_ds 的结构体 [shm_w.c]link1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/shm.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;int main(int argc, const char *argv[])&#123; key_t key; int shmid; char * ptr; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"Unable to ftok\"); exit(1); &#125; printf(\"key = %#x \\n\", key); shmid = shmget(key, 128, IPC_CREAT | IPC_EXCL | 0666); if(shmid &lt; 0) &#123; if(errno == EEXIST) &#123; shmid = shmget(key, 128, 0666); &#125; else &#123; perror(\"Unable to shmget\"); exit(1); &#125; &#125; if((ptr = shmat(shmid, NULL, 0)) == (char *)-1) &#123; perror(\"Unable to shmat\"); exit(1); &#125; strcpy(ptr, \"hello world\"); if(shmdt(ptr) &lt; 0) &#123; perror(\"Unable to shmdt\"); exit(1); &#125;#if 0 if(shmctl(shmid, IPC_RMID, NULL) &lt; 0) &#123; perror(\"Unable to shmctl\"); exit(1); &#125;#endif return 0;&#125; [shm_r.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/shm.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;int main(int argc, const char *argv[])&#123; key_t key; int shmid; char * ptr; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"Unable to ftok\"); exit(1); &#125; shmid = shmget(key, 128, IPC_CREAT | IPC_EXCL | 0666); if(shmid &lt; 0) &#123; if(errno == EEXIST) &#123; shmid = shmget(key, 128, 0666); &#125; else &#123; perror(\"Unable to shmget\"); exit(1); &#125; &#125; if((ptr = shmat(shmid, NULL, 0)) == (char *)-1) &#123; perror(\"Unable to shmat\"); exit(1); &#125; printf(\"--&gt; %s \\n\",ptr); if(shmdt(ptr) &lt; 0) &#123; perror(\"Unable to shmdt\"); exit(1); &#125; if(shmctl(shmid, IPC_RMID, NULL) &lt; 0) &#123; perror(\"Unable to shmctl\"); exit(1); &#125; return 0;&#125; 测试结果：分析： 写入端写入数据到共享内存，读取端读出并释放。 写入端/发送端：首先调用ftok()创建一个key，调用shmget()分配一个所需共享内存，得到shmid。然后调用shmat()再将内核中的共享内存映射到用户空间，最后调用strcpy()将“hello world“写入到这个空间，并释放用户空间。 读出端/接收端：使用调用ftok()传入相同的参数，得到相同的key，调用shmget也得到同样的shmid，再调用shmat()映射，打印出之前的数据。最后 调用shmdt()和shmctl()释放用户空间和内核空间。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux环境编程","slug":"Linux环境编程","permalink":"http://yoursite.com/tags/Linux环境编程/"}]},{"title":"Linux自动挂载/卸载U盘","date":"2017-04-22T03:10:55.000Z","path":"2017/04/22/Linux自动挂载卸载U盘/","text":"记录在mdev机制下不能自动卸载U盘的解决方法。 加载USB驱动有两种方式： 一是将模块编译到内核，再把新内核下载到开发板。 二是将驱动作为模块，内核启动后再加载驱动模块。 在主机中编译模块，在Linux中的/work/hceng/linux-3.4.2目录下执行：1$ make moudles 复制主机生成的drivers/usb/storage/usb-storage.ko到开发板中:1cp drivers/usb/storage/usb-storage.ko /work/hceng/nfs_rootfs 在开发板中，加载USB驱动模块：1$ insmod usb-storage.ko 然后在开发板插上U盘后，再手动挂载U盘即可访问数据:1$ mount /dev/sda1 /mnt 这里存在两个问题，一是需要手动加载usb-storage.ko，二是需要手动挂载U盘。 第一个问题通过将模块加载命令放在启动脚本里实现开机自动加载，/etc/init.d/rcS,加入如下命令：1insmod usb-storage.ko 第二个问题利用mdev机制进行自动挂载U盘，首先修改/etc/medv.conf，将下面代码加入行底：12sd[a-z][0-9] 0:0 666 @/etc/mdev/udisk_insert sd[a-z] 0:0 666 $/etc/mdev/udisk_remove 在/bin/hotplug.sh中把 “case $MDEV in”修改成如下：123456789case $MDEV insd[a-z][0-9]) DEVNAME=udisk MOUNTPOINT=/udisk ;;sda1) DEVNAME=udisk MOUNTPOINT=/udisk ;; 完成上面的设置后，U盘确实能够自动挂载，但拔U盘却不能自动卸载，这样会导致下次插入U盘相应的节点会自动增加，且访问原来的节点报错。 查阅相关资料并无解决方案，多次实验后，发现插上U盘后会自动在/sys/bus/usb/devices/1-1:1.0下生成U盘的信息文件，利用这一点进行检测U盘，在无奈的情况下写了个程序解决这个问题，代码如下：[usb.c]link1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*检查是否有U盘插上，没有则卸载一次/media/sda1，保证下次自动挂载U盘正常*//*定时器相关*/static int count = 0; static struct itimerval oldtv; static unsigned char usb_umount_ok = 0;void set_timer() &#123; struct itimerval itv; itv.it_interval.tv_sec = 1; itv.it_interval.tv_usec = 0; itv.it_value.tv_sec = 1; itv.it_value.tv_usec = 0; setitimer(ITIMER_REAL, &amp;itv, &amp;oldtv); &#125; /*查看/sys/bus/usb/devices/目录下是否有1-1，有则表示有U盘*/static unsigned int judge_usb(void) &#123; FILE *fd; fd = fopen(\"/sys/bus/usb/devices/1-1/version\",\"r\"); if(fd == NULL) return 0; else fclose(fd); usb_umount_ok = 0; return 1;&#125;/*检查usb是否拔出，从而确定是否卸载*/static void colse_usb(void)&#123; if(!judge_usb() &amp;&amp; usb_umount_ok==0) &#123; system(\"cd /;umount /media/sda1;rm -r /media/sd*;echo umount usb ok!\"); usb_umount_ok = 1; &#125; &#125;void signal_handler(int m) &#123; colse_usb(); &#125; int main(void)&#123; signal(SIGALRM, signal_handler); set_timer(); while(1); return 0;&#125; 编译后，运行测试，最后再放在上述启动脚本里：12arm-linux-gcc -o usb usb.c./app/usb&amp; 搞定。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"USB","slug":"USB","permalink":"http://yoursite.com/tags/USB/"}]},{"title":"自己写bootloader","date":"2017-04-13T00:35:55.000Z","path":"2017/04/13/自己写bootloader/","text":"参考写了个bootloader。 0.编写bootloader步骤 初始化硬件：关看门狗、设置时钟、设置SDRAM、初始化NAND FLASH; 因为bootloader比较大（大于4K），需要重定位到SDRAM; 把内核从NAND FLASH读到SDRAM; 设置“要传给内核的参数”; 跳转启动内核; 1.初始化硬件1.1 关看门狗[start.S]1234567.text.global _start_start:/* 1. 关看门狗 ：向寄存器WTCON(0x53000000)写0即可；P462；*/ ldr r0, =0x53000000 //将0x53000000放入r0； mov r1, #0 //将0放入r1中； str r1, [r0] //将r1中的0放入r0所指的存储器中； 1.2 设置时钟[start.S]1234567891011121314151617/* 2. 设置时钟：配置寄存器CLKDIVN(0x4C000014)设置分频；P260； */ ldr r0, =0x4c000014 mov r1, #0x05; //FCLK:HCLK:PCLK=1:4:8 str r1, [r0]/* 如果HDIVN非0，CPU的总线模式应设置为“asynchronous bus mode”;P244 */ mrc p15, 0, r1, c1, c0, 0 //读出控制寄存器； orr r1, r1, #0xc0000000 //设置为“asynchronous bus mode”； mcr p15, 0, r1, c1, c0, 0 //写入控制寄存器； /* 设置MPLLCON = S3C2440_MPLL_400MHZ; P256 */ ldr r0, =0x4c000004 ldr r1, =(0x5c&lt;&lt;12)|(0x01&lt;&lt;4)|(0x01) str r1, [r0] /*优化速度： 启动ICACHE */ mrc p15, 0, r0, c1, c0, 0 @ read control reg orr r0, r0, #(1&lt;&lt;12) mcr p15, 0, r0, c1, c0, 0 @ write it back 1.3 初始化SDRAM[start.S]12345678910111213141516171819202122232425 /*初始化SDRAM：依次向SDRAM寄存器 写入sdram_config中的值*/ ldr r0, = 0x48000000 //将SDRAM寄存器基地址写入r0； adr r1, sdram_config //将sdram_config的当前地址写入r1; add r3, r0, #(13*4) //r3=r0+13*4,即为SDRAM寄存器结尾地址；1: ldr r2, [r1], #4 //将r1寄存器的值放入r2，并将r1的地址+4; str r2, [r0], #4 //将r2的值写入r0，并将r0的地址+4; cmp r0, r3 //比较r0和r3，判断是否设置到了最后一个寄存器；bne 1b //不相等即没有设置完，跳到前面(b)的1处； … … … …sdram_config: //把要设置的值，存在这里；P56; .long 0x22011110 //BWSCON .long 0x00000700 //BANKCON0 .long 0x00000700 //BANKCON1 .long 0x00000700 //BANKCON2 .long 0x00000700 //BANKCON3 .long 0x00000700 //BANKCON4 .long 0x00000700 //BANKCON5 .long 0x00018005 //BANKCON6 .long 0x00018005 //BANKCON7 .long 0x008C04F4 //REFRESH .long 0x000000B1 //BANKSIZE .long 0x00000030 //MRSRB6 .long 0x00000030 //MRSRB7 2.重定位[start.S]123456789101112/*把bootloader本身的代码从flash复制到它的链接地址去*/ ldr sp, =0x34000000 //在调用C语言前，需要先设置栈，即SP指向一个地址；[1] bl nand_init //初始化nand flash；[2] mov r0, #0 //设置copy_code_to_sdram传入参数；参数1：r0=0； ldr r1, =_start //参数2：r1=_start； ldr r2, =__bss_start //r2=__bss_start sub r2, r2, r1 //参数3：r2=r2-r1 即除去_bss段的部分； bl copy_code_to_sdram //执行复制代码到SDRAM的函数；[3] bl clear_bss //执行清理_bss段函数；[4] [1]:为什么是0x34000000？ 栈是由上向下增加的，只要SP指向SDRAM最高处就行。 [2]:为何在这里初始化Nand Flash？ 不管后面的copy_code_to_sdram是Nand启动还是Nor启动，最后都会拷贝Nand上面的内核到SDRAM，所以早晚都得初始化。 [init.c]12345678void nand_init(void)&#123; #define TACLS 0 #define TWRPH0 1 #define TWRPH1 0 NFCONF = (TACLS&lt;&lt;12)|(TWRPH0&lt;&lt;8)|(TWRPH1&lt;&lt;4); //设置时序；P225; NFCONT = (1&lt;&lt;4)|(1&lt;&lt;1)|(1&lt;&lt;0); //使能NAND Flash控制器, 初始化ECC, 禁止片选；P226;&#125; [3]: copy_code_to_sdram具体实现？ start.S中的所有的C函数都在init.c中(除了最后的main)，copy_code_to_sdram()先判断是Nor启动还是Nand启动。 如果是Nor启动：由于Nor Flash特性（可以像内存一样读，但不能像内存一样写），直接复制上面的代码到SDRAM中的链接地址即可； 如果是Nand启动：2440上电后，硬件上将Nand上前4k拷贝到内部RAM中运行，这4k代码再将后续的整个代码拷贝到SDRAM中的链接地址。 [init.c]123456789101112131415161718//传入参数：*src源地址；*dest目的地地址；len数据长度；void copy_code_to_sdram(unsigned char *src, unsigned char *dest, unsigned int len)&#123; int i = 0; if (isBootFromNorFlash()) //如果是NOR启动； &#123; while (i &lt; len) //将len长度的数据，从源地址复制到目标地址上去； &#123; dest[i] = src[i]; i++; &#125; &#125; else &#123; nand_read((unsigned int)src, dest, len); //nand_read较麻烦，再后面介绍； &#125;&#125; 判断是Nand还是Nor：（利用Nor Flash可以像内存一样读，但不能像内存一样写的特性）[init.c]1234567891011121314151617int isBootFromNorFlash(void)&#123; volatile int *p = (volatile int *)0; int val; val = *p; //备份原来0地址的值； *p = 0x12345678; //向0地址写值； if (*p == 0x12345678) //判断是否写入成功； &#123; *p = val; //写成功, 是nand启动，恢复原来的值； return 0; &#125; else &#123; return 1; //NOR不能像内存一样写； &#125;&#125;Nand Flash结构：Nand Flash读操作：[init.c]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576void nand_read(unsigned int addr, unsigned char *buf, unsigned int len)&#123; int col = addr % 2048; int i = 0; /* 1. 选中 */ nand_select(); while (i &lt; len) &#123; /* 2. 发出读命令00h */ nand_cmd(0x00); /* 3. 发出地址(分5步发出) */ nand_addr(addr); /* 4. 发出读命令30h */ nand_cmd(0x30); /* 5. 判断状态 */ nand_wait_ready(); /* 6. 读数据 */ for (; (col &lt; 2048) &amp;&amp; (i &lt; len); col++) //处理没有从最左边开始的情况； &#123; buf[i] = nand_data(); i++; addr++; &#125; col = 0; &#125; /* 7. 取消选中 */ nand_deselect();&#125;/* nand_read 涉及的子函数*//* 1.选中Nand；P226*/ void nand_select(void)&#123; NFCONT &amp;= ~(1&lt;&lt;1); &#125;/* 2.取消选中Nand */ void nand_deselect(void)&#123; NFCONT |= (1&lt;&lt;1); &#125;/* 3.nand命令 */ void nand_cmd(unsigned char cmd)&#123; volatile int i; NFCMMD = cmd; for (i = 0; i &lt; 10; i++);&#125;/* 4.nand地址 */ void nand_addr(unsigned int addr)&#123; unsigned int col = addr % 2048; //对2k取余，得到列； unsigned int page = addr / 2048; //对2k取整，得到行； volatile int i; NFADDR = col &amp; 0xff; //列的7-0位； for (i = 0; i &lt; 10; i++); NFADDR = (col &gt;&gt; 8) &amp; 0xff; //列的15-8位； for (i = 0; i &lt; 10; i++); NFADDR = page &amp; 0xff; //行的7-0位； for (i = 0; i &lt; 10; i++); NFADDR = (page &gt;&gt; 8) &amp; 0xff; //行的15-8位； for (i = 0; i &lt; 10; i++); NFADDR = (page &gt;&gt; 16) &amp; 0xff; //行的23-16位； for (i = 0; i &lt; 10; i++); &#125;/* 5.等待读结束 */ void nand_wait_ready(void)&#123; while (!(NFSTAT &amp; 1));&#125;/* 6.nand数据 */ unsigned char nand_data(void)&#123; return NFDATA;&#125; 清理_bss段： 在start.S跳转到main前，还需要清理_bss段。_bss段存放的是未初始化的全局变量或者初始化为0的全局变量，用于处理可能过多0占用过多空间的情况。现在清0，后续要使用时，再赋0使用(勘误：清理bss段的目的，并不是节约空间，而是为未初始化的全局变量赋值为0。在操作系中写应用程序或者使用集成开发环境写裸机代码，都能保证未定义的全局变量为0，因为操作系统、集成开发环境做了类似清理bss段的操作。而我们自己从头写裸机，需要自己清理bss段。参考文章：Why do we have to clear bss in assembly?)。[init.c]12345678void clear_bss(void)&#123; extern int __bss_start, __bss_end; //声明链接脚本的链接地址; int *p = &amp;__bss_start; for (; p &lt; &amp;__bss_end; p++) //以_bss_start开始，清理到_bss_end; *p = 0;&#125; 链接脚本：[boot.lds]123456789101112131415SECTIONS &#123; . = 0x33f80000; .text : &#123; *(.text) &#125; //代码段在0x33f80000，即链接地址，重定位后程序运行的地址； . = ALIGN(4); //四字节对齐（32位）； .rodata : &#123;*(.rodata*)&#125; //只读数据段 . = ALIGN(4); .data : &#123; *(.data) &#125; //数据段 . = ALIGN(4); __bss_start = .; //_bss开始 .bss : &#123; *(.bss) *(COMMON) &#125; __bss_end = .; //_bss结束&#125; 3.把内核读到SDRAM 前面start.S中调用init.c中的nand_init初始化了Nand Flahsh和写好了nand_read()函数。start.S最后跳到main函数中，而mian函数boot.c中。[boot.c]12/* 0. 帮内核设置串口: 内核启动的开始部分会从串口打印一些信息,但是内核一开始没有初始化串口 */ uart0_init(); //略，看相应章节设置；把内核读到SDRAM:[boot.c]12/* 1. 从NAND FLASH里把内核读入内存 */ nand_read(0x60000+64, (unsigned char *)0x30008000, 0x400000); 第一个参数：源地址：0x60000+64 Nand Flash一般分区情况如图，kernel设计的位置在0x60000，这里加64是因为内核格式为uImage，uImage结构是64字节头+zImage。 第二个参数：目的地址：0x3000 8000 即为Nand Flash的起始地址。 第三个参数：长度：0x200000 内核大小，后面内核大于2M，这里为0x4000 0000。 4.设置要传给内核的参数[boot.c]12345 /* 2. 设置参数 */ setup_start_tag(); setup_memory_tags(); setup_commandline_tag(\"noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0,115200 rootfstype=yaffs2\");setup_end_tag(); 主要分四部分：开始、内存信息、命令信息、结束。 5.跳转启动内核[boot.c]123/* 3. 跳转执行 */ theKernel = (void (*)(int, int, unsigned int))0x30008000; theKernel(0, 362, 0x30000100); 函数指针指向0x3000 8000,即指向内核位置，跳转到内核。theKernel()参数： 第一个参数：固定的0； 第二个参数：机器ID； 第三个参数：要传入给内核的参数位置； 6.其它相关源码参考：韦东山老师毕业班视频； 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Uboot","slug":"Uboot","permalink":"http://yoursite.com/tags/Uboot/"},{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"bootloader","slug":"bootloader","permalink":"http://yoursite.com/tags/bootloader/"}]},{"title":"软件癖","date":"2017-04-06T03:06:19.000Z","path":"2017/04/06/软件癖/","text":"软件“洁癖”。 折腾Windows久了，渐渐的对软件有了“洁癖”。带广告的要想办法去掉广告，有绿色版的要绿色版本优先，能精简的必须精简，收费的也无耻的去百度云找找，有功能限制一定要想办法去掉限制，有最新版的稳定情况下一定使用最新的。 经过时间的过滤，有些软件忍受住了我的“洁癖”，幸存了下来，他们有的堪称“神器”，有的良心无比让人敬佩。谨以此文感谢这些提高工作效率和创造安静的环境的软件，对作者深感敬佩。 Chrome:Windows端的主力浏览器，干净简洁的界面、强大的插件，一直在心中都是无可替代的存在。 SoureInsight:Windows端代码神器，最开始使用的时候是拒绝的，xp时代的审美风格，非常抵触，除去外观，实用性上无话可说，几乎成为每天必开的软件。最近升级到4.0，界面没什么大变化，功能上也少有眼前一亮的更新，站在顶端，难有进步。 OneNote:笔记软件神器，配合数位板手写笔记，神器中的神器。最近看Datasheet，手写笔迹注释，看英语都没那么排斥了，唯一不足是插入任何格式的文档，都是以图片的形式打印输出，查单词没戏了。 PowerPoint:估计是大学玩得最多的软件，几乎可以背到任何一个按钮的位置。上可配合Pr做视频，下可当Ps修图/做图。现在基本没做PPT，但作为做图神器，现在所有的平面图都是在这上面做，胜任了Ps和Visio的功能。 Adobe Photoshop:Adobe，设计领域的老大。Photoshop博大精深，会点小操作，就基本满足日常所有的需求了。PS对我还是很有吸引力的，我在考虑要不要在博客上也加个PS相关的板块 = = Adobe Acrobat DC:在尝试使用其他PDF查看软件后，最终还是觉得Adobe Acrobat DC是最好用的，所有对PDF的“遐想”，几乎都可以完成，比如：分割/合并PDF、添加页眉/页码、设置是导出PDF的表格到Excel，总是一种深藏不露的感觉，只要是我能想到的，用心去找，总能找到解决方法。 WePE:这个真的是情怀，在那个以装系统为家常便饭的时光里，老毛桃带来的除了便利还有捆绑软件和绑定首页，尽管关掉了捆绑软件，绑定首页也是不能忍的。一直希望找到一个干净的PE，现在终于找到了，感谢UEPON。 Everything:积累的文件资料越来越多，时间久了，记不到放在哪了。Windows自带的搜索基本是废的，就没见到过进度条走完过。直到使用Everything才成功解决这一问题，现在使用，仍有那种不可思议的感觉。 huorong:一直都没怎么用过第三方的杀毒软件，Windows Defender基本够用了。出于对垃圾清理和流量状态显示的需求，在经历多种替代方案后，最终决定使用huorong，干净、简洁。我需要的功能都有，附加点可能需要的，我不想的绝对不要出现，挺符合要求的。 Bandzip:用了很久的好压，之前也没怎么觉得有问题，后来有次发现Edeg首页被劫持了，最后发现是它搞的“鬼”。一直对2345这种门户网站没什么好感，这次算彻底失望了。Bandzip还是很不错的，除了干净，可以预览压缩包的图片，这个还是挺实用的。还有就是图标挺新鲜的。 Snipaste:Windows自带截图“Windows+Shift+s”几乎够用，但Snipaste提供贴图和取色，很实用，甚至推出了Windows10应用商店版。 MobaXterm:之前一直想找个串口、SSH、FTP三合一的软件，找了很久，直到用到这个，几乎完美。几乎支持所有的传输协议，还有文件夹同步、录制命令、自定义主题色彩等。免费版几乎就完全就够了，也算良心~ Shadowsocks:科学上网必备，Gitbub开源软件。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Linux并发控制机制","date":"2017-04-05T15:55:00.000Z","path":"2017/04/05/Linux并发控制/","text":"本文主要是简单记录下驱动中的并发控制。 1.并发控制 2.原子变量操作测试代码：[atomic_drv.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;linux/module.h&gt; #include &lt;linux/init.h&gt; #include &lt;asm/atomic.h&gt;//原子变量操作的头文件#include &lt;asm/bitops.h&gt;//原子位操作的头文件atomic_t a1 = ATOMIC_INIT(1);//定义和设置原子量；unsigned long int a2;//操作函数传入参数的数据类型是unsigned long int；static int test_drv_init(void)&#123; //测试原子变量操作： printk(\"test a1\\nKERN_INFO:atomic_read(): a1 = %d\\n\", a1); atomic_add(4, &amp;a1); printk(\"KERN_INFO:atomic_add(): a1 = %d\\n\", a1); atomic_dec(&amp;a1); printk(\"KERN_INFO:atomic_dec(): a1 = %d\\n\", a1); printk(\"KERN_INFO:atomic_dec_and_test(): judge_a1 = %d, new_a1 = %d\\n\",\\ atomic_dec_and_test(&amp;a1),atomic_read(&amp;a1)); //测试原子位操作： set_bit(0,&amp;a2);//设置a的0位为1; printk(\"test a2\\nKERN_INFO:set_bit(): a2 = %ld\\n\", a2); printk(\"KERN_INFO:test_and_clear_bit(): return_a2 = %d, new_a2 = %ld\\n\",\\ test_and_clear_bit(0, &amp;a2), a2); printk(\"KERN_INFO:test_and_set_bit(): return_a2 = %d, new_a2 = %ld\\n\",\\ test_and_set_bit(0, &amp;a2), a2); return 0;&#125;static void test_drv_exit(void)&#123; &#125;module_init(test_drv_init);module_exit(test_drv_exit);MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"hceng\"); MODULE_DESCRIPTION(\"Learn for atomic\"); 3.自旋锁测试代码：[lock_drv.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*设备驱动中，有些设备只允许打开一次，这里用count计数，lock对count进行保护*/#include &lt;linux/module.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_device.h&gt;#include &lt;linux/spinlock.h&gt;//自旋锁头文件static struct class *testdrv_class;static struct class_device *testdrv_class_dev;int count = 0 ;spinlock_t lock;static int test_drv_open(struct inode *inode, struct file *file)&#123; spin_lock(&amp;lock); if(count) &#123; spin_unlock(&amp;lock); printk(\"kernel: open fail! count = %d\\n\",count); return -EBUSY; &#125; count++; spin_unlock(&amp;lock); printk(\"kernel: open ok! count = %d\\n\",count); return 0;&#125;static int test_drv_release(struct inode *inode, struct file *file)&#123; spin_lock(&amp;lock); count--; spin_unlock(&amp;lock); printk(\"kernel: release ok! count = %d\\n\",count); return 0;&#125;static struct file_operations test_drv_fops = &#123; .owner = THIS_MODULE, .open = test_drv_open, .release = test_drv_release, &#125;;int major;static int test_drv_init(void)&#123; major = register_chrdev(0, \"test_drv\", &amp;test_drv_fops); testdrv_class = class_create(THIS_MODULE, \"testdrv\"); testdrv_class_dev = device_create(testdrv_class, NULL, MKDEV(major, 0), NULL, \"locktest\"); spin_lock_init(&amp;lock); printk(\"kernel: init ok!\\n\"); return 0;&#125;static void test_drv_exit(void)&#123; unregister_chrdev(major, \"test_drv\"); device_destroy(testdrv_class, MKDEV(major, 0)); class_destroy(testdrv_class); printk(\"kernel: exit ok!\\n\");&#125;module_init(test_drv_init);module_exit(test_drv_exit);MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"hceng\"); MODULE_DESCRIPTION(\"Learn for lock\");[lock_test.c]link123456789101112131415161718192021#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; int fd; fd = open(\"/dev/locktest\", O_RDWR); if (fd &lt; 0) &#123; printf(\"app: can't open!\\n\"); &#125; else printf(\"app: open ok!\\n\"); while(1); return 0;&#125; 4.信号量[semaphore_drv.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/*设备驱动中，有些资源只能被单一进程访问，这里用sem确保单一访问*/#include &lt;linux/module.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_device.h&gt;#include &lt;linux/semaphore.h&gt;//信号量头文件static struct class *testdrv_class;static struct class_device *testdrv_class_dev;struct semaphore sem;static int test_drv_open(struct inode *inode, struct file *file)&#123; printk(\"kernel:down before sem.count = %d \\n\", sem.count); down(&amp;sem); /*临界资源*/ printk(\"kernel:down after sem.count = %d \\n\", sem.count); return 0;&#125;static int test_drv_release(struct inode *inode, struct file *file)&#123; printk(\"kernel:up before sem.count = %d \\n\", sem.count); up(&amp;sem); printk(\"kernel:up after sem.count = %d \\n\", sem.count); return 0;&#125;static struct file_operations test_drv_fops = &#123; .owner = THIS_MODULE, .open = test_drv_open, .release = test_drv_release, &#125;;int major;static int test_drv_init(void)&#123; major = register_chrdev(0, \"test_drv\", &amp;test_drv_fops); testdrv_class = class_create(THIS_MODULE, \"testdrv\"); testdrv_class_dev = device_create(testdrv_class, NULL, MKDEV(major, 0), NULL, \"semaphoretest\"); sema_init(&amp;sem, 2);//允许同时2个进程访问临界资源 printk(\"kernel: init ok!\\n\"); return 0;&#125;static void test_drv_exit(void)&#123; unregister_chrdev(major, \"test_drv\"); device_destroy(testdrv_class, MKDEV(major, 0)); class_destroy(testdrv_class); printk(\"kernel: exit ok!\\n\");&#125;module_init(test_drv_init);module_exit(test_drv_exit);MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"hceng\"); MODULE_DESCRIPTION(\"Learn for semaphore\"); [semaphore_test.c]link123456789101112131415161718192021#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; int fd; fd = open(\"/dev/semaphoretest\", O_RDWR); if (fd &lt; 0) &#123; printf(\"app: can't open!\\n\"); &#125; else printf(\"app: open ok!\\n\"); while(1); return 0;&#125; 5.完成量 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"}]},{"title":"终端复用软件-Tmux","date":"2017-03-31T11:50:00.000Z","path":"2017/03/31/终端复用软件——Tmux/","text":"本文主要记录终端复用软件——Tmux的简单使用。 Tmux是一个可以把终端分屏的软件，最开始知道这货是在酷安下了Termux，酷安大佬们真会完，刷Termu下面的评论中看到了Tmux，觉得还挺好玩的。最近Linux终端用得比较多，尝试安装玩玩，记录下。 1.安装tmux在ubuntu终端中，使用以下命令安装：1$ sudo apt-get install tmux 2.基本使用Tmux为了不和其它软件的快捷键影响，所以它的命令全要加前缀Ctrl+b后再操作，例如新建个窗口的操作步骤： 按下组合键 Ctrl+b; 放开组合键 Ctrl+b; 按下 c 键; Tmux的操作很多，这里我只记录几个我常用的，后续自己有需求再增加： 功能 前缀操作 组合键 创建新窗口 Ctrl+b-&gt;松开 c 水平划分窗口 Ctrl+b-&gt;松开 “ 垂直划分窗口 Ctrl+b-&gt;松开 % 调整窗口大小 Ctrl+b-&gt;不松住 方向键 切换窗口 Ctrl+b-&gt;松开 方向键 显示窗口标号 Ctrl+b-&gt;松开 q 关闭窗口 Ctrl+b-&gt;松开 x-&gt;y 关闭Tmux Ctrl+b-&gt;松开 &amp;-&gt;y 3.其它优化美化的话参考后面给的博客链接，这里我只美化了底边状态栏：进入home目录，新建.tmux.conf12$ cd ~$ vi ~/.tmux.conf加入以下代码： 12345678910111213141516171819# 状态栏# 颜色set -g status-bg blackset -g status-fg white # 对齐方式set-option -g status-justify centre # 左下角set-option -g status-left &apos;#[bg=black,fg=green][#[fg=cyan]#S#[fg=green]]&apos;set-option -g status-left-length 20 # 窗口列表setw -g automatic-rename onset-window-option -g window-status-format &apos;#[dim]#I:#[default]#W#[fg=grey,dim]&apos;set-window-option -g window-status-current-format &apos;#[fg=cyan,bold]#I#[fg=blue]:#[fg=cyan]#W#[fg=dim]&apos; # 右下角set -g status-right &apos;#[fg=green][#[fg=cyan]%Y-%m-%d#[fg=green]]&apos; 参考博客：Tmux 速成教程：技巧和调整Tmux简单教程 最后修改时间：2017/3/31 19:51:36 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux基础/"}]},{"title":"U-Boot分析、移植及使用","date":"2017-03-26T10:39:00.000Z","path":"2017/03/26/U-Boot分析、移植及使用/","text":"该系列主要是为驱动学习提供基石，从0到Qt。本文是该系列的第二篇:对U-Boot进行分析及移植. 1.U-Boot结构分析Bootloader一般可以分成两个阶段： 第一个阶段通常使用汇编进行必要的硬件初始化，例如：关看门狗、关中断、设置时钟频率、RAM初始化等。除此之外，还要将第二阶段的代码复制到RAM中，设置好栈，然后跳到第二阶段，该阶段主要是与SOC平台相关。 第二阶段一般是用c语言编写，该阶段主要和开发板板载资源相关。该阶段主要初始化后续的硬件，处理内存映射、以及将内核和根文件系统从Flash“搬运”到RAM中运行，然后传入启动参数，最后启动引导内核，完成使命。 Linux中系统一般的分区结构，如下图： 分区主要分为四个分区：Bootloader、Boot parameters、Kernel、Root filesystem。其中Boot parameters是待传入内核的参数，Kernel即内核、Root filesystem是根文件系统。Bootloader在第一个分区(假设该储存介质为Nand Flash)，则在Nand Flash的地址为0x0000 0000，S3C2440上电后，硬件自动把Nand Flash上前4k代码复杂到自己内部RAM中运行。该4k代码先要初始化一些必要的硬件，如看门狗，中断等，然后准备好SRAM，并将后续的代码复制到SDRAM中，再跳到SDRAM中运行，完成Bootloader第一阶段。此时在SDRAM中的第二阶段代码开始工作，首先还是初始化硬件，处理内存映射，把Nand Flash上内核和根文件系统“搬运”到SDRAM准备运行，然后根据用户通过串口传入的启动参数放在Boot parameters，然后内核启动，完成使命。内核启动后，开始去Boot parameters寻找启动参数，根据启动参数做出相应的操作，如：控制台输出、串口波特率、根文件系统位置。 2.U-Boot源码分析 这里根据u-boot-1.1.6的源码进行分析，，主要工作有： 第一阶段的硬件初始化(CPU模式、看门狗、中断) 准备SDRAM 设置堆栈 搬运FLASH中的代码到SDRAM 清除.bss段并跳转至第二阶段 第二阶段的硬件初始化（时钟、串口） 内存映射 根据传入参数启动内核 2.1第一阶段 该阶段的源码在/arch/cpu/arm920t/start.S中：首先进行硬件初始化，包括设置CPU模式，关闭看门狗、关闭中断。这里把时钟配置放在了第二阶段。 设置CPU模式 把CPU设置为SVC模式，将当前程序状态计数器CPSR的值保存到r0中，利用bic指令清除r0的0x1f并存入r0中，再利用orr指令或运算上0xd3并存入r0，最后r0写回CPSR,这一过程就把CPSR设置为SVC模式：[start.S]123456reset:/* set the cpu to SVC32 mode*/ mrs r0,cpsr bic r0,r0,#0x1f orr r0,r0,#0xd3 msr cpsr,r0 设置看门狗和关闭中断 根据S3C2440的datasheet，将0x00写入pWTCON对应寄存器的地址，完成看门狗的关闭。中断部分也类似，将INTMSK寄存器设置为0xffff ffff即可：[start.S]12345678910111213/* turn off the watchdog */# define pWTCON 0x53000000# define INTMOD 0X4A000004# define INTMSK 0x4A000008 /* Interupt-Controller base addresses */# define INTSUBMSK 0x4A00001C# define CLKDIVN 0x4C000014 /* clock divisor register */ ldr r0, =pWTCON mov r1, #0x0 str r1, [r0]/* turn off the int */ ldr r1, =0x3ff ldr r0, =INTSUBMSK str r1, [r0] 准备SDRAMstart.S中没有初始化SDRAM，而是先跳转到函数cpu_init_crit中，再跳转至lowlevel_init.S中进行初始化SDRAM。adr是一个位置无关指令，将_start的地址读取到r0中，上电后，Flash中的前4k就被拷到S3C2440内部RAM，则这里r0=0。然后再用ldr指令将_TEXT_BASE这个地址（来自链接脚本，代表运行地址）的值放在r1中。然后比较r0和r1的值，如果是相等的，那么证明这个时候代码已经位于了其应该位于的地方，这个时候就不再需要初始化SDRAM去重定位了。如果r1和r0的值不相等，那么将直接跳转cpu_init_crit中。[start.S]1234adr r0, _start /* r0 &lt;- current position of code */ldr r1, _TEXT_BASE /* test if we run from flash or RAM */cmp r0, r1 /* don&apos;t reloc during debug */blne cpu_init_crit [start.S]12345678910111213141516171819202122cpu_init_crit: /*flush v4 I/D caches*/ mov r0, #0 mcr p15, 0, r0, c7, c7, 0 /* flush v3/v4 cache */ mcr p15, 0, r0, c8, c7, 0 /* flush v4 TLB */ /*disable MMU stuff and caches*/ mrc p15, 0, r0, c1, c0, 0 bic r0, r0, #0x00002300 @ clear bits 13, 9:8 (--V- --RS) bic r0, r0, #0x00000087 @ clear bits 7, 2:0 (B--- -CAM) orr r0, r0, #0x00000002 @ set bit 2 (A) Align orr r0, r0, #0x00001000 @ set bit 12 (I) I-Cache mcr p15, 0, r0, c1, c0, 0 /* * before relocating, we have to setup RAM timing * because memory timing is board-dependend, you will * find a lowlevel_init.S in your board directory. */ mov ip, lr bl lowlevel_init mov lr, ip 设置栈 通常为了保存调用C语言时传递参数和保存CPU运行时的现场，需要设置栈，根据定义_TEXT_BASED为代码段的开始地址，然后在代码段的下面留出一段内存实现malloc和全局参数，再留出一点给中断模式的栈和abort异常的栈，剩下的就是栈了：[start.S]12345678910/* Set up the stack */stack_setup: ldr r0, _TEXT_BASE /* upper 128 KiB: relocated uboot */ sub r0, r0, #CFG_MALLOC_LEN /* malloc area */ sub r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo */#ifdef CONFIG_USE_IRQ sub r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)#endif sub sp, r0, #12 /* leave 3 words for abort-stack */ 搬运FLASH中的代码到SDRAM 现在将Bootloader的全部代码复制到RAM中运行： [lowlevel_init.S]1234567891011121314151617relocate: /* relocate U-Boot to RAM */ adr r0, _start /* r0 &lt;- current position of code */ ldr r1, _TEXT_BASE /* test if we run from flash or RAM */ cmp r0, r1 /* don&apos;t reloc during debug */ beq clear_bss ldr r2, _armboot_start ldr r3, _bss_start sub r2, r3, r2 /* r2 &lt;- size of armboot */ bl CopyCode2Ram /* r0: source, r1: dest, r2: size */copy_loop: ldmia r0!, &#123;r3-r10&#125; /* copy from source address [r0] */ stmia r1!, &#123;r3-r10&#125; /* copy to target address [r1] */ cmp r0, r2 /* until source end addreee [r2] */ ble copy_loop 清除.bss段并跳转至第二阶段 bss段部分保存有静态变量、没有初始化或初始化值为0的全局变量，为了减小体积和防止程序在读取它们时，读取的时上次的值，所以需要先清0： [start.S]12345678910clear_bss: ldr r0, _bss_start /* find start of bss segment */ ldr r1, _bss_end /* stop here */ mov r2, #0x00000000 /* clear */clbss_l:str r2, [r0] /* clear loop... */ add r0, r0, #4 cmp r0, r1 ble clbss_lldr pc, _start_armboot 2.2第二阶段 第二阶段的代码在lib_arm/board.c中的start_armboot()函数开始，在内部调用各自函数进行设置： 设置时钟[smdk2410.c]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int board_init (void)&#123; S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER(); S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO(); /* to reduce PLL lock time, adjust the LOCKTIME register */ clk_power-&gt;LOCKTIME = 0xFFFFFF; /* configure MPLL */ clk_power-&gt;MPLLCON = ((M_MDIV &lt;&lt; 12) + (M_PDIV &lt;&lt; 4) + M_SDIV); /* some delay between MPLL and UPLL */ delay (4000); /* configure UPLL */ clk_power-&gt;UPLLCON = ((U_M_MDIV &lt;&lt; 12) + (U_M_PDIV &lt;&lt; 4) + U_M_SDIV); /* some delay between MPLL and UPLL */ delay (8000); /* set up the I/O ports */ gpio-&gt;GPACON = 0x007FFFFF; gpio-&gt;GPBCON = 0x00044555; gpio-&gt;GPBUP = 0x000007FF; gpio-&gt;GPCCON = 0xAAAAAAAA; gpio-&gt;GPCUP = 0x0000FFFF; gpio-&gt;GPDCON = 0xAAAAAAAA; gpio-&gt;GPDUP = 0x0000FFFF; gpio-&gt;GPECON = 0xAAAAAAAA; gpio-&gt;GPEUP = 0x0000FFFF; gpio-&gt;GPFCON = 0x000055AA; gpio-&gt;GPFUP = 0x000000FF; gpio-&gt;GPGCON = 0xFF95FFBA; gpio-&gt;GPGUP = 0x0000FFFF; gpio-&gt;GPHCON = 0x002AFAAA; gpio-&gt;GPHUP = 0x000007FF; /* arch number of SMDK2410-Board */ gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE_SMDK2410; /* adress of boot parameters */ gd-&gt;bd-&gt;bi_boot_params = 0x30000100; icache_enable(); dcache_enable(); return 0;&#125; 初始化串口[serial.c]1234567891011121314151617181920int serial_init (void)&#123; serial_setbrg (); return (0);&#125;/* * Read a single byte from the serial port. Returns 1 on success, 0 * otherwise. When the function is succesfull, the character read is * written into its argument c. */int serial_getc (void)&#123; S3C24X0_UART * const uart = S3C24X0_GetBase_UART(UART_NR); /* wait for character to arrive */ while (!(uart-&gt;UTRSTAT &amp; 0x1)); return uart-&gt;URXH &amp; 0xff;&#125; 监内存映射 在smdk2410.c里的函数dram_init中设置的内存起始地址为0x3000 0000,大小为0x4000 0000:[smdk2410.c]1234567int dram_init (void)&#123; gd-&gt;bd-&gt;bi_dram[0].start = PHYS_SDRAM_1; gd-&gt;bd-&gt;bi_dram[0].size = PHYS_SDRAM_1_SIZE; return 0;&#125; 至此，U-Boot的启动过程基本分析完了，在启动U-Boot后，通过lib_arm/armlinux.c中的do_boot_linux来启动内核。这里总结画个图来记录下，中间的顺序可能有点小差异，但大致没问题：3.U-Boot移植待补充。4.U-Boot使用记录下平时使用U-Boot烧写内核/根文件系统和挂载根文件系统，这里假设如下： Ubuntu中待作为nfs挂载的路径：/work/hceng/nfs_rootfsUbuntu IP：192.168.1.141开发板 IP：192.168.1.142网关 IP：192.168.1.1 这里要提前在Ubuntu虚拟机中进行NFS配置，参考上一篇文章中的：2.3安装、 配置网络服务； 启动U-Boot后，迅速按任意键进入U-Boot的下载模式，再输入”q”退出菜单。 设置开发板ip和nfs挂载的服务ip： 123setenv serverip 192.168.1.141 //设置服务器ubuntu ipsetenv ipaddr 192.168.1.142 //设置开发板ipsaveenv 设置u-boot各分区大小（内核也要相应设置匹配，在Linux-3.4.2内核中，文件在arch/arm/mach-s3c24xx/common-smdk.c中）: 12setenv mtdparts mtdparts=nandflash0:256k@0(bootloader),128k(params),4m(kernel),-(root)saveenv 下载、擦除、烧写内核： 123nfs 30000000 192.168.1.141:/work/hceng/nfs_rootfs/uImagenand erase kernelnand write.jffs2 30000000 kernel 下载、擦除、烧写根文件系统： 123nfs 30000000 192.168.1.141:/work/hceng/nfs_rootfs/fs_mini_mdev_new.yaffs2nand erase rootnand write.yaffs 30000000 4a0000 $(filesize) 根文件系统采用nand启动： 12set bootargs noinitrd root=/dev/mtdblock3 rootfstype=yaffs2 init=/linuxrc console=ttySAC0,115200saveenv 启动后，对应的NFS挂载： 1mount -t nfs -o nolock 192.168.1.141:/work/hceng/nfs_rootfs /tmp 根文件系统采用nfs启动： 12set bootargs root=/dev/nfs nfsroot=192.168.1.141:/work/hceng/nfs_rootfs ip=192.168.1.142:192.168.1.141:192.168.1.1:255.255.255.0::eth0:off init=/linuxrc console=ttySAC0,115200 saveenv 最后启动：1boot 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Uboot","slug":"Uboot","permalink":"http://yoursite.com/tags/Uboot/"},{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/环境搭建/"}]},{"title":"搭建嵌入式Linux开发环境","date":"2017-03-23T09:19:00.000Z","path":"2017/03/23/搭建嵌入式Linux开发环境/","text":"本文主要记录在搭建嵌入式Linux开发环境过程中的. 所需材料： 虚拟机：VMware-workstation-full-12.0.0-2985596.exe Ubuntu系统镜像：ubuntu-16.04.1-desktop-amd64.iso 交叉工具链：arm-linux-gcc-4.4.3.tar.gz(根据自己需求下载) 安装脚本：install-devel-packages-for-16.sh 1.安装Ubuntu-16.04.1 打开安装好的虚拟机，选择创建新的虚拟机： 选择典型配置： 选择浏览找到ubuntu-16.04.1-desktop-amd64.iso并选中： 填入用户名、密码（本机密码：123456）： 设置虚拟机名称和保存路径： 设置虚拟机最大容量（60G差不多了）： 在弹出的向导中选择自定义硬件，设置内存、CPU、网络： 等待一会后，安装完毕，输入之前设置的密码进入系统： 点左上角的Ubuntu搜索图标，，输入t，将出现的Terminal控制台： 2.安装、配置必要软件2.1检查虚拟机网络设置 打开编辑-&gt;虚拟网络编辑器： 更改设置： 检查这三个配置： 输入ifconfig查看网络配置，再ping www.baidu.com测试： 2.2修改软件源 首先备份原来的文件：1$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup 用vi编辑器打开编辑：1$ sudo vi /etc/apt/sources.list 删掉文件中的所有内容，替换为以下文本：123456789101112131415161718# deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricteddeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse 注： 此时vi是不完全版的，很难用，编辑模式下方向键是乱的，使用gedit打开编辑，后面再更新vi：1$ sudo gedit /etc/apt/sources.list 此时Ubuntu默认装了VMware Tools，可以复制windows下的文本，然后ctrl+shift+v在Ubuntu里面粘贴文本。也支持windows里文件和Ubuntu的直接拖拽复制。 完成上面的修改后，再更新软件列表和安装完整的vim：12$ sudo apt-get update$ sudo apt-get install vim 安装过程中根据提示输入yes确认，下同。 2.3安装、 配置网络服务 执行以下命令安装 ftp、ssh、nfs服务：1$ sudo apt-get install vsftpd openssh-server nfs-kernel-server portmap 配置 FTP 服务：修改 vsftpd 的配置文件/etc/vsftpd.conf，检查下面两行前面的“#”号是否去掉。第28行，默认没有#：1local_enable=YES 第31行，默认有#，去掉#：1# write_enable=YES 注： 上面第一个表示是否允许本地用户登录，第二行个示是否允许上传文件。 在vim的命令模式输入如下命令即可显示行号：1:set nu 修改完华之后，执行以下命令重启 ftp 服务：1$ sudo /etc/init.d/vsftpd restart 配置 NFS 服务修改/etc/exports，增加以下内容，以后开发板可以通过网络文件系统访问/work 目录和专门用来作为根文件系统挂载的/work/hceng/nfs_rootfs目录： 12/work *(rw,sync,no_root_squash,no_subtree_check)/work/hceng/nfs_rootfs *(rw,sync,no_root_squash,no_subtree_check) 修改完华之后，执行以下命令重启 nfs 服务： 1$ sudo /etc/init.d/nfs-kernel-server restart 最后，关闭Ubuntu的防火墙：1$ sudo ufw disable 4.安装基本开发环境： 这里使用韦东山老师第四期安卓视频环境搭建提供的脚本，这个脚本会自动安装诸如 g++等工具、 库。但该脚本是为Ubuntu12制作的，Ubuntu16使用需要做一些修改，主要是名字变了。修改变化如下：1libgl1-mesa-glx-lts-quantal:i386 libgl1-mesa-dev-lts-quantal \\ 改为：1libgl1-mesa-glx-lts-xenial:i386 libgl1-mesa-dev-lts-xenial \\ 将修改后的脚本文件改为：install-devel-packages-for-16.sh 拖拽到自己建的/work/tool里面，加入可执行权限，然后执行：12$ sudo chmod +x install-devel-packages-for-16.sh$ sudo ./install-devel-packages-for-16.sh 然后报错,提示差mingw32： 解决：在源中加入如下部分：1deb http://cz.archive.ubuntu.com/ubuntu trusty main universe 再更新列表，再执行就没问题了：12$ sudo apt-get update$ sudo ./install-devel-packages-for-16.sh 3.安装基本开发环境 这里使用arm-linux-gcc-4.4.3.tar.gz，之前用的4.5出了问题，换成这个就好了，暂时用这个版本。把文件拖进/work/tool，解压到根目录：1$ sudo tar xzf arm-linux-gcc-4.4.3.tar.gz –C / 再修改环境变量： 1$ sudo vim /etc/ environment 把工具链目录添加到最后，内容如下： 1PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/opt/FriendlyARM/toolschain/4.4.3/bin&quot; 重启Ubuntu，输入如下命令检测是否正常： 1$ arm-linux-gcc –v 至此，开发环境以基本搭建完成。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/环境搭建/"}]},{"title":"设备驱动模型","date":"2017-03-18T15:44:00.000Z","path":"2017/03/18/设备驱动模型/","text":"最近在看设备驱动模型，记录下分析的结构。 设备驱动模型提供了硬件的抽象，内核可以使用该抽象完成很多硬件重复的工作，这样很多重复的代码就不需要重复编写和调试了。这些抽象包括：电源管理、即插即用设备的支持、与用户空间的通信。 1.sysfs文件系统 sysfs文件系统是Linux众多文件系统中的一个，在Linux中每个文件系统都要自己的特殊的用途。Liunx设备驱动模型由大量的数据结构和算法组成，数据结构之间通过指针相互关联，构成树形或者网状关系。显示这种关系最好的利用树形结构的文件系统，同时还要显示内核中一些关于设备、驱动和驱动的信息，因此内核开发者创造sysfs这种新文件系统来实现上述的要求。 sysfs是一个只存在于内存的文件系统，内核通过这个文件系统将系统信息导出到用户空间，同时用户空间的数据也能通过它传到内核中，实现设置驱动程序的状态和属性。 sysfs文件系统是内核对象（kobject）、属性（kobj_type）及它们互相关系的一种表现机制。内核与sysfs的关系如下： Linux内核中的结构 sysfs中的结构 kobject 目录 kobj_type 属性文件 对象间的关系 符号链接 2.核心数据结构 设备驱动模式由kobject、kset、subsystem这三个核心数据结构组成。 2.1 kobject 在Linux系统中，kobject结构体是组成设备驱动模型的基本结构，提供最基本的设备对象管理能力，每个在内核注册的kobject对象都对应sysfs文件系统中的一个目录。 kobject结构体：1234567891011121314struct kobject &#123; const char *name; /* 对应sysfs的目录名 */ struct list_head entry; /* kobjetct双向链表 ,指向下一个kobject结构*/ struct kobject *parent; /* 指向kset中的kobject，相当于指向父目录 */ struct kset *kset; /*指向所属的kset */ struct kobj_type *ktype; /*指向kobject的类型描述符*/ struct sysfs_dirent *sd; /*对应的sysfs文件目录*/ struct kref kref; /*kobject引用计数，为0释放*/ unsigned int state_initialized:1; /*kobject是否已初始化，1初0未*/ unsigned int state_in_sysfs:1 ; /*kobject是否注册到sysfs*/ unsigned int state_add_uevent_sent:1; unsigned int state_remove_uevent_sent:1; unsigned int uevent_suppress:1;&#125;; kobject操作函数： 2.2 kset kobject通过kset组织层次化，kest是拥有相同类型的kobject的集合。 kset结构体：123456struct kset &#123; struct list_head list; /* 连接所包含的kobject对象的链表头部 */ spinlock_t list_lock; /* 添加/删除kobject时使用的自旋锁 */ struct kobject kobj; /*所有属于该kset的kobject的parent均指向这 */ const struct kset_uevent_ops *uevent_ops; /* 热拔插事件函数集 */&#125;; kset操作函数： kest和kobject关系： 2.3 注册kobject到sysfs中的实例[kobject_test.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/* 目的：在/sys目录下添加一个名为kobject_test的目录名， 并在该目录下添加一个kobject_test_attr的文件，这个文件为属性文件； 功能：koject_test_show()函数显示属性的值； kobject_test_store()函数向属性中写入一个值；*/#include &lt;linux/device.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/sysfs.h&gt;#include &lt;linux/stat.h&gt;/*声明释放kobject结构体函数*/void kobject_test_release(struct kobject *kobject);/*读属性的函数*/ssize_t kobject_test_show(struct kobject *kobject, struct attribute *attr, char *buf);/*写属性的函数*/ssize_t kobject_test_store(struct kobject *kobject, struct attribute *attr, const char *buf, size_t count);/*定义了一个名为kobject_test，可以读写的属性*/struct attribute test_attr = &#123; .name = \"kobject_test_attr\", .mode = S_IRWXUGO,&#125;;/*该object只有一个属性*/static struct attribute *def_attrs[] = &#123; &amp;test_attr, NULL,&#125;;/*操作函数*/struct sysfs_ops obj_test_sysops = &#123; .show = kobject_test_show, .store = kobject_test_store,&#125;;/*kobject属性*/struct kobj_type ktype = &#123; .release = kobject_test_release, .sysfs_ops = &amp;obj_test_sysops, .default_attrs = def_attrs,&#125;; /*释放kobject结构体函数*/void kobject_test_release(struct kobject *kobject)&#123; printk(\"kobject_test: kobject_test_release(). \\n\");&#125;/*该函数用于读取一个属性的名字*/ssize_t kobject_test_show(struct kobject *kobject, struct attribute *attr, char *buf)&#123; printk(\"call kobject_test_show(). \\n\"); printk(\"attrname:%s.\\n\", attr-&gt;name); sprintf(buf, \"%s\\n\", attr-&gt;name); return strlen(attr-&gt;name)+2;&#125;/*该函数用于写入一个属性的值*/ssize_t kobject_test_store(struct kobject *kobject, struct attribute *attr, const char *buf, size_t count)&#123; printk(\"call kobject_test_store(). \\n\"); printk(\"write: %s\\n\", buf); strcpy(attr-&gt;name, buf); return count;&#125;/*入口函数*/struct kobject kobj;static int kobject_test_init()&#123; printk(\"kobject test_init().\\n\"); kobject_init_and_add(&amp;kobj, &amp;ktype, NULL, \"kobject_test\"); return 0;&#125;/*出口函数*/static int kobject_test_exit()&#123; printk(\"kobject test exit.\\n\"); kobject_del(&amp;kobj); return 0;&#125;module_init(kobject_test_init);module_exit(kobject_test_exit);MODULE_AUTHOR(\"hceng\");MODULE_LICENSE(\"Dual BSD/GPL\"); [kobject_app.c]link123456789101112131415161718192021222324252627#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;poll.h&gt;#include &lt;signal.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;/* kobject_test */int fd;int main(int argc, char **argv)&#123; fd = open(\"/dev/kobject_test\", O_RDWR); if (fd &lt; 0) &#123; printf(\"can't open!\\n\"); return -1; &#125; return 0;&#125; 调用关系： 3.三大组件 设备驱动模型中有三个重要的组件：总线（bus_type）、设备（device）、驱动（driver）,三者关系如下： bus_type通过扫描设备链表和驱动链表，使用mach方法查找匹配的设备和驱动，然后将struct device中的*driver设置为匹配的驱动； 将struct device_driver中的device设置为匹配的设备，这就完成了将总线、设备和驱动3者之间的关联； bus_type只有很少的成员必须提供初始化，大部分由设备模型核心控制； 内核提供许多函数实现bus_type的注册注销等操作，新注册的总线可以再/sys/bus目录下看到； 3.1总线 总线数据结构bus_type：1234567891011121314151617181920212223struct bus_type &#123; const char *name; /* 总线类型名 */ struct bus_attribute *bus_attrs; /* 总线的属性、方法 */ struct device_attribute *dev_attrs; /* 设备属性,为每个加入总线的设备建立属性链表 */ struct driver_attribute *drv_attrs; /* 驱动属性,为每个加入总线的驱动建立属性链表 */ /* 驱动与设备匹配函数:当一个新设备或者驱动被添加到这个总线时，这个方法会被调用一次或多次， 若指定的驱动程序能够处理指定的设备，则返回非零值。 必须在总线层使用这个函数, 因为那里存在正确的逻辑，核心内核不知道如何为每个总线类型匹配设备和驱动程序 */ int (*match)(struct device *dev, struct device_driver *drv); /*在为用户空间产生热插拔事件之前，这个方法允许总线添加环境变量（参数和 kset 的uevent方法相同）*/ int (*uevent)(struct device *dev, struct kobj_uevent_env *env); int (*probe)(struct device *dev); int (*remove)(struct device *dev); /* 设备移除调用操作 */ void (*shutdown)(struct device *dev); int (*suspend)(struct device *dev, pm_message_t state); int (*resume)(struct device *dev); const struct dev_pm_ops *pm; /*电源管理相关操作符*/ struct subsys_private *p; /* 一个很重要的域，包含了device链表和drivers链表 */&#125;; 相关操作函数： 3.2设备 设备数据结构device：12345678910111213141516171819202122232425262728293031323334353637struct device &#123; struct device *parent; /* 父设备，总线设备指定为NULL */ struct device_private *p; /* 包含设备链表，driver_data（驱动程序要使用数据）等信息 */ struct kobject kobj; const char *init_name; /* 初始默认的设备名,但@device_add调用之后又重新设为NULL */ struct device_type *type; struct mutex mutex; /* mutex to synchronize calls to its driver */ struct bus_type *bus; /* type of bus device is on */ struct device_driver *driver; /* which driver has allocated this device */ void *platform_data; /* Platform specific data, device core doesn't touch it */ struct dev_pm_info power; #ifdef CONFIG_NUMA int numa_node; /* NUMA node this device is close to */ #endif u64 *dma_mask; /* dma mask (if dma'able device) *///Like dma_mask, but for alloc_coherent mappings as not all hardware supports 64 bit addresses //for consistentallocations such descriptors. u64 coherent_dma_mask; struct device_dma_parameters *dma_parms; struct list_head dma_pools; /* dma pools (if dma'ble) */ struct dma_coherent_mem *dma_mem; /* internal for coherent mem override */ /* arch specific additions */ struct dev_archdata archdata; #ifdef CONFIG_OF struct device_node *of_node; #endif dev_t devt; /* dev_t, creates the sysfs \"dev\" 设备号 */ spinlock_t devres_lock; struct list_head devres_head; struct klist_node knode_class; struct class *class; const struct attribute_group **groups; /* optional groups */ void (*release)(struct device *dev); &#125;; 3.3驱动 驱动数据结构driver·：1234567891011121314151617181920struct device_driver &#123; const char *name; /* 驱动名称,在sysfs中以文件夹名出现 */ struct bus_type *bus; /* 驱动属于的总线，总线上可以有很多设备 */ struct module *owner; /* 设备驱动自身模块 */ const char *mod_name; /* 驱动模块名字 */ bool suppress_bind_attrs; /* disables bind/unbind via sysfs */ const struct of_device_id *of_match_table; /*检测设备方法，并检测设备驱动可以控制那些设备*/ int (*probe) (struct device *dev); int (*remove) (struct device *dev); /*移除设备时调用的方法*/ void (*shutdown) (struct device *dev); /*关闭设备时调用的方法*/ int (*suspend) (struct device *dev, pm_message_t state); /*处于低功耗时调用的方法*/ int (*resume) (struct device *dev); /*恢复正常状态时调用的方法*/ const struct attribute_group **groups; /*属性组*/ const struct dev_pm_ops *pm; /*用于电源管理*/ struct driver_private *p; /* 定义device_driver中的私有数据类型 */ &#125;; 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"}]},{"title":"Linux常用命令","date":"2017-03-12T15:14:00.000Z","path":"2017/03/12/Linux常用命令/","text":"本文主要汇总一些常用且不太熟练的Liunx命令，不定期更新。 1. tar作用：打包（拆包）/压缩（解压）文件； 语法：tar [主选项+辅选项] 文件或目录 主选项： c ：打包文件； x ：拆包文件； t ：列出包/压缩文件里有哪些文件。辅选项： z ：具有 gzip 属性；格式为xx.tar.gz或xx. tgz； j ：具有 bzip2 属性；格式为xx.tar.bz2； v ：显示压缩文件过程； f ：在其后必须是文件名； - -exclude xxx：打包除xxx文件之外的文件；示例：1234567$ tar cf test.tar test #打包test文件/文件夹为test.tar;$ tar xf test.tar #拆包test.tar；$ tar czf test.tar.gz test #压缩test文件/文件夹为test.tar.gz；$ tar xzf test.tar.gz #解压test.tar.gz；$ tar cjf test.bzip2 test #压缩test文件/文件夹为test.bzip2；$ tar xjf test.bzip2 #解压test.bzip2；$ tar cf test.tar --exclude test.txt test #打包test文件夹里除test.txt之外的为test.tar 2. grep作用：查找字符串； 语法：grep [选项] ‘搜寻字符串’ 文件名 选项： -c ：计算找到 ‘搜寻字符串’ 的次数; -i ：忽略大小写; -n ：顺便输出行号; -v ：反向选择，即显示出没有 ‘搜寻字符串’ 内容的那一行;示例：1$ grep -n &apos;test&apos; test.txt #搜索test.txt中含test的行，且显示对应行号； 3. find作用：选项较多，这里暂仅使用name选项查找文件； 语法：find 路径 -name “文件名”示例：1$ find -name &quot;test&quot; #在当前文件下找test文件； 4. ifconfig作用：网卡配置； 语法：ifconfig [网络设备] [参数]”示例：12345678#设置网卡1的地址 192.168.1.44，掩码为255.255.255.0（即默认）；$ ifconfig eth0 192.168.1.44 netmask 255.255.255.0#捆绑网卡1的第二个地址为 192.168.1.x$ ifconfig eth0:x 192.168.1.x#打开网卡1$ ifconfig eth0 up#关闭网卡1$ ifconfig eth0 down 5. mount作用：目前只用来挂载NFS； 语法：mount -t nfs 服务器ip:挂载目录 挂载到本地哪里”示例：12#把主机(192.168.1.44)的/work/hceng/nfs_rootfs挂载到本地/tmp目录下；$ mount -t nfs 192.168.1.44:/work/hceng/nfs_rootfs /tmp 6. 查看Linux版本信息示例：1234$ uname -a #显示电脑以及操作系统的相关信；$ cat /proc/version #正在运行的内核版本；$ cat /etc/issue #显示的是发行版本信息；$ lsb_release -a #列出所有版本信息； 7. 关闭防火墙示例：12$ ufw disable #关闭ubuntu的防火墙 ；$ ufw enable #开启防火墙； 7. source作用：免重启更新环境变量；示例：1$ source /etc/environment 8. vim作用：vim里代码自动格式化；示例：123ggvG= 最后修改时间：2017/3/31 19:57:49 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux基础/"}]},{"title":"Makefile小结","date":"2017-03-11T09:44:00.000Z","path":"2017/03/11/Makefile小结/","text":"本文主要是记录一些遇到的Makefile知识。 Makefile以韦东山老师第一期裸板视频中的 第8课LCD实验的配套代码lcd_3.5_4.3 中的Makefile为例，该工程有两个Makefile,分别位于根目录和lib目录中：[根目录Makefile]123456789101112131415161718192021222324252627282930313233CC = arm-linux-gccLD = arm-linux-ldAR = arm-linux-arOBJCOPY = arm-linux-objcopyOBJDUMP = arm-linux-objdumpINCLUDEDIR := $(shell pwd)/includeCFLAGS := -Wall -O2CPPFLAGS := -nostdinc -I$(INCLUDEDIR)export CC LD AR OBJCOPY OBJDUMP INCLUDEDIR CFLAGS CPPFLAGSobjs := head.o init.o nand.o interrupt.o serial.o lcddrv.o/ framebuffer.o lcdlib.o main.o lib libc.alcd.bin: $(objs) $&#123;LD&#125; -Tlcd.lds -o lcd_elf $^ $&#123;OBJCOPY&#125; -O binary -S lcd_elf $@ $&#123;OBJDUMP&#125; -D -m arm lcd_elf &gt; lcd.dis.PHONY : lib/libc.alib/libc.a: cd lib; make; cd .. %.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;clean: make clean -C lib rm -f lcd.bin lcd_elf lcd.dis *.o 主Makefile总领全局的就这句:1lcd.bin: $(objs)要生成lcd.bin，依赖于objs列举的一堆文件：head.o init.o nand.o interrupt.o serial.o lcddrv.o framebuffer.o lcdlib.o main.o lib libc.a，所以要先找到这些文件，几个.o，还有一个.a。 .o目标文件怎么生成？%.o:%.c和%.o:%.S是生成规则，就是依赖于.c或.S文件，使用交叉编译命令生成。 .a目标文件怎么生成？.a是库文件，到lib子目录里去找，在子目录里用make命令生成。 注:链接：将多.o文件，或者.o文件和库文件链接成为可被操作系统执行的可执行程序（Linux环境下，可执行文件的格式为“ELF”格式）。链接器不检查函数所在的源文件，只检查所有.o文件中的定义的符号。将.o文件中使用的函数和其它.o或者库文件中的相关符号进行合并，对所有文件中的符号进行重新安排（重定位），并链接系统相关文件（程序启动文件等）最终生成可执行程序。链接过程使用GNU 的“ld”工具。静态库：又称为文档文件（Archive File）。它是多个.o文件的集合。Linux中静态库文件的后缀为“.a”。静态库中的各个成员（.o文件）没有特殊的存在格式，仅仅是一个.o文件的集合。使用“ar”工具维护和管理静态库。共享库：也是多个.o文件的集合，但是这些.o文件时有编译器按照一种特殊的方式生成（Linux中，共享库文件格式通常为“ELF”格式。共享库已经具备了可执行条件）。模块中各个成员的地址（变量引用和函数调用）都是相对地址。使用此共享库的程序在运行时，共享库被动态加载到内存并和主程序在内存中进行连接。多个可执行程序可共享库文件的代码段（多个程序可以共享的使用库中的某一个模块，共享代码，不共享数据）。另外共享库的成员对象可被执行（由libdl.so提供支持）。 下面进行分析： 第一至五行：12345CC = arm-linux-gccLD = arm-linux-ldAR = arm-linux-arOBJCOPY = arm-linux-objcopyOBJDUMP = arm-linux-objdump 作用：将右边工具链名赋值给左边变量，为了简化书写； 分析： arm-linux-gcc：编译.c或.s头的C文件或汇编程序； arm-linux-ld：连接器，把多个.o文件或库文件连接成一个可执行文件； arm-linux-ar：库管理器，把多个.o文件合并成一个.o文件或静态库文件（.a文件）； arm-linux-objcopy：转换可执行文件的格式； arm-linux-objdump：生成反汇编； 第七行：1INCLUDEDIR := $(shell pwd)/include 作用：将shell命令和include组成的路径立即赋值给左边变量，为了简化书写； 分析：Makefile中调用shell命令：$(shell 命令)； ‘ = ’与‘ := ’的区别注： - “ = ”：make会将整个Makefile展开后，再决定变量的值。也就是说，变量的值将会是整个,Makefile中最后被指定的值。看例子： 123x = fooy = $(x) barx = xyz 在上例中，y的值将会是 xyz bar ，而不是 foo bar 。- “ := ”表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。 123x := fooy := $(x) barx := xyz 在上例中，y的值将会是 foo bar ，而不是 xyz bar 了。 第八行：1CFLAGS := -Wall -O2 作用：将gcc的编译参数赋值给左边变量，为了简化书写； 分析：-Wall显示所有编译错误或警告；-O2优化选项，编译时使用2级优化 第九行：1CPPFLAGS := -nostdinc -I$(INCLUDEDIR) 作用：将gcc编译路径参数赋值给左边变量，为了简化书写； 分析：-nostdinc忽略系统库目录（这里我们自定义了printf等系统函数，不能再包含系统文件里的相关函数）；-I指定搜索路径； 第十一行：1export CC LD AR OBJCOPY OBJDUMP INCLUDEDIR CFLAGS CPPFLAGS 作用：将变量传递到下级Makefile，类似于宏； 分析：本文件中指的是生成lib/libc.a库文件时的Makefile； 第十三行：12objs := head.o init.o nand.o interrupt.o serial.o lcddrv.o/ framebuffer.o lcdlib.o main.o lib libc.a 作用：定义变量objs，包含了生成目标文件所需的文件，为了简化书写； 分析：一行代码写不完，使用/符号可继续在下行写； 第十六行：1lcd.bin: $(objs) 作用：定义生成目标lcd.bin，依赖于objs对象； 分析：执行这条命令时，先生成所有依赖文件，然后依次执行后面三条命令； 第十七行：1$&#123;LD&#125; -Tlcd.lds -o lcd_elf $^ 作用：根据链接脚本lcd.lds链接，输出目的文件lcd_elf,依赖全部文件； 分析：-T指定链接脚本；$^表示全部依赖文件； 第十八行：1$&#123;OBJCOPY&#125; -O binary -S lcd_elf $@ 作用：将lcd_elf文件转换成二进制文件； 分析：-O表示输出格式;-S表示不从源文件中复制重定位信息和符号信息到目标文件中；$@表示全部目标文件； 第十九行：1$&#123;OBJDUMP&#125; -D -m arm lcd_elf &gt; lcd.dis 作用：将lcd_elf文件反汇编为lcd.dis文件； 分析：-m后面跟的是cpu构架;&gt;表示将这个程序的反汇编程序写入到led.dis这个文件中,在终端中不显示出来； 第二十一行：1.PHONY : lib/libc.a 作用：.PHONY伪目标，不要管lib/libc.a文件是否存在，都执行后面的指令； 分析：通常为了避免伪目标和文件重名的这种情况，使用特殊的记“.PHONY”来显示地指明一个目标是“伪目标”； 第二十二、二十三行：12lib/libc.a: cd lib; make; cd .. 作用：执行lib文件夹的Makefile，从而生成libc.a； 分析：执行shell指令，进入lib目录，make，退出； 第二十五至二十九行：1234%.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt; 作用：依赖所有的.c和.S文件，生成所有的.o文件； 分析：%通配符；-c编译不链接;$@表示目标文件;$&lt;表示第一个依赖文件; 第三十一至三十三行：1234%.o:%.Sclean: make clean -C lib rm -f lcd.bin lcd_elf lcd.dis *.o 作用：清理所有生成文件； 分析：-C lib即清理包括lib文件夹下生成的文件; 下面是lib目录Makefile: [lib目录Makefile]123456789101112131415objs := div64.o lib1funcs.o ctype.o muldi3.o printf.o string.o/vsprintf.olibc.a: $(objs) $&#123;AR&#125; -r -o $@ $^ %.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;clean: rm -f libc.a *.o 第一、二行：12objs := div64.o lib1funcs.o ctype.o muldi3.o printf.o string.o/vsprintf.o 作用：定义变量objs，包含了生成目标文件所需的文件，为了简化书写； 分析：一行代码写不完，使用/符号可继续在下行写； 第四、五行：12libc.a: $(objs) $&#123;AR&#125; -r -o $@ $^ 作用：使用库管理器生成lib.a； 分析：$@表示目标文件;$^所有依赖文件； 第七至十一行：1234%.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt; 作用：依赖所有的.c和.S文件，生成所有的.o文件； 分析：%通配符；-c编译不链接;$@表示目标文件;$&lt;表示第一个依赖文件; 第十三、十四行：123%.o:%.Sclean: rm -f libc.a *.o 作用：清理所有生成文件； 分析：-f强制删除; 参考博文：sekon LCD实验学习笔记（一）：Makefile 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"Makefile","slug":"Makefile","permalink":"http://yoursite.com/tags/Makefile/"}]},{"title":"汇编指令小结","date":"2017-03-10T03:55:00.000Z","path":"2017/03/10/汇编指令小结/","text":"本文主要是记录一些遇到的ARM汇编知识。 汇编代码以韦东山老师的 第7章nand flash实验配套代码13th_link_4096 中的start.S为例：[start.S]12345678910111213141516171819202122232425262728293031323334353637383940414243.globl _start_start:/* 硬件相关的设置 : 把外设的基地址告诉CPU*/ /* Peri port setup */ ldr r0, =0x70000000 orr r0, r0, #0x13 mcr p15,0,r0,c15,c2,4 @ 256M(0x70000000-0x7fffffff) /* 关看门狗 *//* 往WTCON(0x7E004000)写0 */ ldr r0, =0x7E004000 mov r1, #0 str r1, [r0]/* 重定位 */ adr r0, _start /* _start当前指令地址 */ ldr r1, =_start /* _start的编译地址 */ ldr r2, =bss_start cmp r0, r1 beq clean_bsscopy_loop: ldr r3, [r0], #4 str r3, [r1], #4 cmp r1, r2 bne copy_loop /* 清BSS段 */clean_bss: ldr r0, =bss_start ldr r1, =bss_end mov r2, #0clean_loop: str r2, [r0], #4 cmp r0, r1 bne clean_loop /* 设置栈 */ ldr sp, =8*1024 ldr pc, =main /* 重定位完后, 使用位置相关的指令跳转 */ bl mainhalt: b halt 第六行：1ldr r0, =0x70000000 格式：ldr&emsp;目的寄存器&emsp;&lt;存储器地址&gt; 作用：将 存储器地址 所指地址处连续的4个字节（1个字）的数据传送到目的寄存器中。 第七行：1orr r0, r0, #0x13 格式：orr&emsp;目的寄存器，&emsp;操作数 1，&emsp;操作数 2 作用：常用于设置操作数1 的某些位，在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中。操作数1 应是一个寄存器，操作数2 可以是一个寄存器、被移位的寄存器或一个立即数。 第八行：1mcr p15,0,r0,c15,c2,4 格式：mcr&emsp;协处理器编码，&emsp;协处理器操作码1，&emsp;源寄存器，&emsp;目的寄存器1，&emsp;目的寄存器2，&emsp;协处理器操作码2 作用：将ARM处理器寄存器中的数据传送到协处理器寄存器中,若协处理器不能成功完成操作，则产生未定义指令异常。其中协处理器操作码1 和协处理器操作码2 为协处理器将要执行的操作，源寄存器为ARM处理器的寄存器，目的寄存器1和目的寄存器2均为协处理器的寄存器。 第十四行：1str r1, [r0] 格式：str&emsp;源寄存器&emsp;&lt;存储器地址&gt; 作用：用于从源寄存器中将一个32位的字数据传送到存储器中。在ARM架构下, 数据从内存到CPU之间的移动只能通过ldr/str指令来完成。而mov只能在寄存器之间移动数据,或者把立即数移动到寄存器中,并且数据的长度不能超过8位。 第十七行：1adr r0, _start 格式：adr&emsp;目的寄存器&emsp;程序相对的表达式 作用：可将一个立即值与pc值相加，并将结果写入目标寄存器。adr可生成与位置无关的代码，因为地址相对于程序或寄存器。详见ARM指令adr。 第二十行：1cmp r0, r1 格式：cmp&emsp;操作数1，&emsp;操作数2 作用：用于把一个寄存器的内容和另一个寄存器的内容或立即数进行比较，同时更新CPSR中条件标志位的值。该指令进行一次减法运算，但不存储结果，只更改条件标志位。标志位表示的是操作数1与操作数2的关系(大、小、相等)，例如，当操作数1大于操作操作数2，则此后的有GT 后缀的指令将可以执行。 CPSR注： Z标志：是否为0；如比较指令产生相等的结果、计算结果为0； N标志：是否为负；如果指令的结果被认为是有符号数，而它的第31位为1，那就会被设置为1； C标志：是否有产生进位/借位，以及进行移位操作时作移出位使用； V标志：有符号数进行运算，结果是否有溢出。 第二十一行：1beq clean_bss 格式：beq&emsp;标签 作用：数据跳转指令，标志寄存器中Z标志位等于零时, 跳转到beq后标签处。 第二十六行：1bne copy_loop 格式：bne&emsp;标签 作用：数据跳转指令，标志寄存器中Z标志位不等于零时, 跳转到bne后标签处。 第四十一行：1bl main 格式：bl&emsp;子程序名 作用：b或bl指令引起处理器转移到子程序名处开始执行。两者的不同之处在于bl指令在转移到子程序执行之前，将其下一条指令的地址拷贝到R14（LR,链接寄存器）。由于bl指令保存了下条指令的地址，因此使用指令“mov pc, lr”即可实现子程序的返回。而b指令则无法实现子程序的返回，只能实现单纯的跳转。 ARM处理器控制程序执行方式注： 流水方式执行程序：PC的值是下一条指令的地址，即每执行一条指令PC都加一个字的偏移。 通过跳转指令来控制程序执行:b-跳转到指定的指令处执行;bl-跳转执行，保存子程序地址并返回;bx-跳转执行并切换到Thumb状态;blx-三种方式组合。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/tags/汇编/"}]},{"title":"GitHub+Hexo博客搭建及优化","date":"2017-03-06T11:26:00.000Z","path":"2017/03/06/GitHub+Hexo搭建及优化/","text":"本文主要是记录本博客的搭建和优化。 为什么做独立博客？我想大概就是激励自己去持续学习和思考。 首先说下本博客搭建的大致流程:1.有一个GitHub账号，同时配置GitHub Pages；2.安装、配置Hexo；3.配置博客、Markdown写文章；4.绑定自己域名（可选）；5.优化日常操作（可选）； 1.Github Pages Github Pages是GitHub提供的免费静态站点； 创建Github Pages后，在里面存放网页源码，然后在对应网址就可看到对应网页效果； 使用GitHub账号创建一个仓库，但是这个仓库是有规则的，其格式必须为：yourusername.github.io； 注： yourusername必须是自己的GitHub账号名； 类型只能选Public； 2.安装、配置Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。1、安装 Node.js;2、下载Cmder代替Windows自带cmd;3、安装 Git;4、添加本机密钥到GitHub;5、安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，在Git上设置username和email；其中3-5步在前一篇博文Git日常使用小结中已设置过了，无需再设置。6、安装 Hexo：使用 npm 安装 Hexo。1$ npm install -g hexo-cli至此，已经安装完Hexo,后续进行相关配置。7、在电脑上选一个盘，建个文件夹存放博客数据，例我的：E:\\blog；然后打开cmder，输入:12$ e: &amp; cd blog #进入所建文件夹$ hexo init blog #初始化blog成功初始化blog后将出现：1INFO Start blogging with Hexo!8、最后再生成静态网页，即可看到网页模板：12$ hexo generate # 启动本地服务器$ hexo server # 在浏览器输入 http://localhost:4000/就可以看见网页和模板了完成后，将会看到如下提示：12INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.此时，打开浏览器，输入http://localhost:4000/就可以看见默认的网页和模板了。 3.配置博客、发表文章 在blog目录下，用Sublime Text(使用它的原因是默认是UTF-8编码，中文不会乱码)打开_config.yml文件，修改参数信息； 注：在每个参数的”：”后都要加一个空格修改网站相关信息; 3.1修改网站相关信息：1234567# Sitetitle: hceng blogsubtitle: Linux/Android驱动 description: 生命不息、折腾不止author: hcenglanguage: zh-CNtimezone: Asia/Shenzhen 3.2修改配置部署相关信息：123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: 'git@github.com:hceng/hceng.github.io.git' branch: master- type: git repo: 'git@git.coding.net:hceng/hceng.git' branch: coding-pages 这里由于我同时提交到了GitHub和Coding,用于测试百度收录，所以有两个，写一个也没事。 注:如果在执行 hexo deploy 后,出现 error deployer not found:github(git) 的错误，执行： 1$ npm install hexo-deployer-git --save 3.3修改主题： 为了让博客更加美观和符合自己需求，可以修改Hexo主题来满足自己需求。Hexo 安装主题的方式非常简单，只需要将主题文件放置于站点目录的 themes 目录下，然后修改下配置文件即可。 Hexo 有两份主要的配置文件（_config.yml），一份位于站点根目录下，另一份位于主题目录下。为了描述方便，在以下说明中，将前者称为 站点配置文件，后者称为 主题配置文件。 下载hexo-theme-yilia主题,解压放入themes文件夹下，如：E:\\blog\\blog\\themes，根据自己需求修改主题配置文件，最后再修改站点配置文件里的theme:1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-yilia 在主题配置文件里，修改头像、颜色、标签等，都有相应的注释写得非常清楚，按需修改。 3.4发表文章： 在Cmder中输入：12$ hexo new \"blog tags\"INFO Created: E:\\blog\\blog\\source\\_posts\\blog-tags.md 根据提示得路径，即可找到新建得文件，该文件使用Markdown语法，下载MarkdownPad2进行编辑。先修改相关的文章信息：123456---title: blog tagstags: - 随笔--- 本文主要是总结blog预计的标签，并不定时更新。 可修改标题、标签（本有日期的修改选项，但有日期就不能显示文章，怀疑是主题或者其它地方干扰了，文章日期就是文件创建日期）。然后简单说下Markdown语法： 3.4.1标题和引用 行首插入 1 到 6 个 # ，对应到标题 1 到 6 级标题： 123# 一级标题## 二级标题## 三标题 效果：见本文（影响目录效果，就不示例了）。 区块引用则使用 ‘&gt;’ 角括号来表示： 1&gt; 这是引用 效果： 这是引用 3.4.2列表和强调 列表分有序的1、2、3和无序的·：12- 列表1- 列表2 效果： 列表1 列表2 强调有加粗和斜体，用”*”来表示： 12**加粗***斜体* 效果：加粗斜体 3.4.3超链接和图片 在方括号”[]”写要显示标，在小括号”()”写链接：1[hceng blog](http://hceng.cn/)效果：hceng blog 在文章如果需要加入图片，先需要把图片传到床图网站，生成链接后插入使用，格式如下：1![](图片网址) 3.4.4加入代码 Markdown支持插入代码，使用单引号”`“来标注,注意是英文输入法下，左上角那个按键：1`hello`效果：hello 这种方式感觉不够醒目，而且不支持语法高亮，所以我一般使用Codeblock，语法见网站，效果如下：123456#include &lt;stdio.h&gt;int main(void)&#123; printf(\"hello,world!\"); return 0;&#125; 4.绑定自己域名（可选） 完成以上步骤后，默认域名是GitHub提供的二级域名：yoursname.github.io,下面开始绑定自己的域名： 4.1购买域名 推荐GoDaddy或万网； 我是在万网买的，首推买.com，其次.me、.top、.cn系列，根据自己喜好来，各有特色优缺点； 然后继续交实名认证、审核，还是比较快；4.2绑定域名 保证上述工作完成，域名可用； 修改DNS，分别修改为：f1g1ns1.dnspod.net和f1g1ns2.dnspod.net 本地站点目录里的source目录下添加一个CNAME文件，里面写上网址； 注:CNAME不要有任何后缀；网址不要写www或http：//,直接写hceng.cn这种； 注册DNSpod，然后添加域名，添加记录： 参考红线部分填写，一个主机纪录是@，记录类型是CNAME，线路类型填默认（图片中略有不同，是我测试百度抓取用的，暂时可不管），记录值写对应的GitHub Pages的地址；另一个主机纪录填www，其它和上面的一样。 最后把本地的Hexo生成一下，再提交到Github pages上； 5.优化日常操作（可选）5.1 hexo命令简写12345$ hexo n “新文章” == hexo new “新文章” #新建文章$ hexo c == hexo clear #清理静态文件$ hexo g == hexo generate #生成静态文件$ hexo s == hexo server #启动本地预览$ hexo d == hexo deploy #上传部署 5.2 添加版权信息1.在博客根目录下（和 source 同级），新建一个名为 scripts 的文件夹；2.在 scripts 文件夹内, 新建一个 AddTail.js 脚本文件，脚本具体内容详见下文；3.在博客根目录下，新建一个 tail.md 文件，里面写想要展示的版本说明内容;AddTail.js 脚本文件：1234567891011121314151617181920212223242526272829303132333435// Filename: AddTail.js// Author: Colin// Date: 2016/06/02// Based on the script by KUANG Qi: http://kuangqi.me/tricks/append-a-copyright-info-after-every-post/// Add a tail to every post from tail.md// Great for adding copyright infovar fs = require('fs');hexo.extend.filter.register('before_post_render', function(data)&#123; if(data.copyright == false) return data; // Add seperate line data.content += '\\n___\\n'; // Try to read tail.md try &#123; var file_content = fs.readFileSync('tail.md'); if(file_content &amp;&amp; data.content.length &gt; 50) &#123; data.content += file_content; &#125; &#125; catch (err) &#123; if (err.code !== 'ENOENT') throw err; // No process for ENOENT error &#125; // 添加具体文章链接, 不需要去掉即可 //var permalink = '\\n本文链接：' + data.permalink; //data.content += permalink; return data;&#125;);tail.md 文件：去Creative Commons根据自己需求，生成合适的许可，然后复制到tail.md 文件中； 参考博客：如何添加版权信息 5.3 自动添加目录(已舍弃) 20180105更新：舍弃本块功能；原因:更新主题后，发现主题自带目录，且比原来的更好； 修改主题的ejs文件 打开文件：themes/你的主题/layout/_partial/article.ejs 在这个文件中找到&lt;%- post.content %&gt;，并在这之前加入以下代码：1234567&lt;!-- Table of Contents --&gt;&lt;% if (!index &amp;&amp; post.toc)&#123; %&gt;&lt;div id=\"toc\" class=\"toc-article\"&gt;&lt;strong class=\"toc-title\"&gt;文章目录&lt;/strong&gt;&lt;%- toc(post.content, &#123;list_number: false&#125;) %&gt;&lt;/div&gt;&lt;% &#125; %&gt; 这里if语句中有两个条件，!index是为了不在首页的文章摘要中生成目录，post.toc确保了只在显式地标记了toc: true的文章中生成目录。若这两个条件满足，则创建一个目录的div。第五行表示不自动生成标号，不然加上自己的标号会有两个。 为需要的文章添加标记 5.4 添加访问人数统计(已更新) 20180105更新：舍弃本块功能；原因:底部信息太多了，访问统计在实际使用中感觉并没用，故舍弃； 20190506更新：添加本块功能；原因:不在最底部添加，而是在每篇博客下面添加，这样不会占用多余空间，另外作者更新了脚本； 安装脚本： 打开themes/你的主题/layout/_partial/footer.ejs添加下面脚本：12&lt;script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 在需要的位置添加添加显示： 需求是在每篇博客下面添加，于是在article.ejs中间添加如下代码：1234567891011121314151617181920212223242526272829 &lt;%- partial('post/tag') %&gt; &lt;%- partial('post/category') %&gt; &lt;% if (index &amp;&amp; theme.show_all_link)&#123; %&gt; &lt;p class=\"article-more-link\"&gt; &lt;a class=\"article-more-a\" href=\"&lt;%- url_for(post.path) %&gt;\"&gt;&lt;%= theme.show_all_link %&gt; &gt;&gt;&lt;/a&gt; &lt;/p&gt; &lt;% &#125; %&gt; &lt;!-- 访问统计:添加开始位置 --&gt; &lt;div style=\"position: absolute; left: 50%;\"&gt; &lt;div style=\"position: relative; left: -50%; color: #ccc;font-size:14px\"&gt; &lt;span id=\"busuanzi_container_page_pv\" &gt; 本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次 &lt;/span&gt; &lt;span style=\"font-size:15px; color:#ccc;\"&gt;|&lt;/span&gt; &lt;span id=\"busuanzi_container_site_pv\" &gt; 本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次 &lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- 访问统计:添加结束位置 --&gt; &lt;% if (!index &amp;&amp; theme.share_jia)&#123; %&gt; &lt;%- partial('post/share') %&gt; &lt;% &#125; %&gt; 参考链接：不蒜子 5.5 脚本自动化(已舍弃) 20180105更新：舍弃本块功能；原因:使用自己写的HexoBlogClient客户端，实际体验更好，其原理还是用的如下脚本。 每次发布文章大致分为清理静态文件、生成静态文件、启动本地预览或上传部署，连续这么多命令何不合成一个，于是在windows下，可新建几个批处理脚本:[make1.bat]12#生成最新本地预览hexo clean &amp; hexo g &amp;hexo s[make2.bat]12#发布生成最新博客hexo clean &amp; hexo g &amp; hexo d[make3.bat]123#发成最新博客并上传源码到Coding私有库，以便在其它电脑上编辑hexo clean &amp; hexo g &amp; hexo d &amp; git add -A &amp; git commit -m &quot;from make3&quot; &amp; \\git push origin master 在Cmder中，输入对应的makeN,即可自动完成一系列命令。 5.6 提交搜索引擎（百度+谷歌+必应）稳定测试已完成。在百度/谷歌/必应搜索“hceng”或者博客内容关键字都会有相关结果。直接在搜索引擎输入：1site:hceng.cn即可检测收录文章数量。 这块内容也不复杂，主要参考的这篇博客，感兴趣的去摸索下。 5.7 添加评论模块(已舍弃) 20190504更新：舍弃本块功能；原因:gitment其实蛮好用，但因为原作者弃坑，逐渐出现了一些问题，更改评论模块，详见后面； 国内目前由不少的第三方评论系统，比如：多说、畅言、友言、网易云跟贴、disqus等。很多都陆续停止服务或者国情原因并不好用，设置也麻烦。2018年初升级主题的时候发现支持gitment了，一款基于GitHub Issues的评论系统。有如下特性： 在前端直接引入，不需要任何后端代码 使用 GitHub 账号登录 可以在页面进行查看、发送评论，点赞，@ 等操作 可以在 GitHub 进行编辑、删除评论等操作 有完整的 Markdown / GFM 支持 支持代码高亮 基于 GitHub 的通知 用Github登陆b格满满，还支持代码高亮，基于GitHub Issues也不容易挂掉，初步感觉很符合要求。设置步骤如下： a. 申请一个Github OAuth ApplicationGithub头像下拉菜单-&gt;Settings-&gt;左边Developer settings下的OAuth Application-&gt;Register a new application，填写相关信息： Application name, Homepage URL, Application description都可以随意填写，Authorization callback URL一定要写自己博客的的URL。 填写完上述信息后按Register application按钮，得到Client ID和Client Secret b. 修改配置文件yilia主题已经集成了gitment，只需修改主题路径下的_config.yml配置文件即可使用：123456#5、Gitmentgitment_owner: hceng gitment_repo: &apos;hceng.github.io&apos; gitment_oauth: client_id: &apos;xxxxxxxxxxxxxxxxxx&apos; client_secret: &apos;xxxxxxxxxxxxxxxxxxxxxxxxxxx&apos; gitment_owner为GitHub用户名；gitment_repo填写用来存放评论的GitHub仓库，由于评论是通过issues来存放的，建议这里直接填Github Pages个人博客所在的仓库；client_id为申请到的应用的Client ID；client_secret为申请到的应用的Client Secret； 然后重新清理，生成，上传(由于要求回调URL和当前地址一样，这里必须要上传后才能测试后续的操作，本地调试是不行的)。 c. 初始化评论系统Gitment的原理是为每一遍博文以其URL作为标识创建一个GitHub issue，对该篇博客的评论就是对这个issue的评论。因此，需要为每篇博文初始化一下评论系统，初始化后，就在Github上会创建相对应的issue。 前面重新上传后，打开博客，可以在博文页下面看到一个评论框，还有看到以下错误Error: Comments Not Initialized，提示该篇博文的评论系统还没初始化。 点击Login with GitHub后，使用自己的GitHub账号登录后，就可以在上面错误信息处看到一个Initialize Comments的按钮。 点击Initialize Comments按钮后，就可以开始对该篇博文开始评论了， 同时也可以在对应的GitHub仓库看到相应的issue。 d. 解决标题过长，无法初始化gitmentthemes\\yilia\\layout\\_partial\\post\\gitment.ejs是yilia主题集成的gitment源码，里面使用文章标题url作为id，GitHub的issue标题有字数限制，因此可能出现自己文章的标题过长，导致无法初始化gitment，因此这里修改源码，改为使用时间作为标题：[gitment.ejs]12345678910111213141516&lt;div id=&quot;gitment-ctn&quot;&gt;&lt;/div&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;//imsun.github.io/gitment/style/default.css&quot;&gt;&lt;script src=&quot;//imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var gitment = new Gitment(&#123; //id: &quot;&lt;%=url%&gt;&quot;, id: &quot;&lt;%= page.date%&gt;&quot;, owner: &apos;&lt;%=theme.gitment_owner%&gt;&apos;, repo: &apos;&lt;%=theme.gitment_repo%&gt;&apos;, oauth: &#123; client_id: &apos;&lt;%=theme.gitment_oauth.client_id%&gt;&apos;, client_secret: &apos;&lt;%=theme.gitment_oauth.client_secret%&gt;&apos;, &#125;,&#125;)gitment.render(&apos;gitment-ctn&apos;)&lt;/script&gt;注释掉了第六行，改为了第七行。 5.8 添加字数统计a. 安装hexo-wordcount在博客根目录下，执行：1npm install --save hexo-wordcount b. 文件配置在themes\\yilia\\layout\\_partial\\post\\date.ejs下创建date.ejs文件：1234567891011121314151617181920212223242526&lt;a href=\"&lt;%- url_for(post.path) %&gt;\" class=\"&lt;%= class_name %&gt;\"&gt; &lt;!-- 开始添加字数统计--&gt; &lt;span class=\"post-time\"&gt; &lt;span class=\"icon-word icon\" style=\"color:#9a989b\"&gt; &lt;span class=\"post-meta-item-text\"&gt; &lt;span style=\"font-size:15px; color:#9a989b;\"&gt;字数统计: &lt;/span&gt; &lt;/span&gt; &lt;span class=\"post-count\"&gt; &lt;span style=\"font-size:15px; color:#9a989b;\"&gt; &lt;%= wordcount(post.content) %&gt; &lt;/span&gt; &lt;span style=\"font-size:15px; color:#9a989b;\"&gt;字 &lt;/span&gt; &lt;/span&gt; &lt;/span&gt; &lt;/span&gt; &lt;span class=\"post-time\"&gt; &lt;span style=\"font-size:15px; color:#9a989b;\"&gt;| &lt;/span&gt; &amp;nbsp; &lt;span class=\"icon-clock icon\" style=\"color:#9a989b\"&gt; &lt;span class=\"post-meta-item-text\"&gt; &lt;span style=\"font-size:15px; color:#9a989b;\"&gt;阅读时长: &lt;/span&gt; &lt;/span&gt; &lt;span class=\"post-count\"&gt; &lt;span style=\"font-size:15px; color:#9a989b;\"&gt; &lt;%= min2read(post.content) %&gt; &lt;/span&gt; &lt;span style=\"font-size:15px; color:#9a989b;\"&gt;分 &lt;/span&gt; &lt;/span&gt; &lt;/span&gt; &lt;/span&gt; &lt;!-- 添加完成 --&gt; &lt;!-- 修改原来的date,使样式保持一致 --&gt; &lt;span style=\"font-size:15px; color:#9a989b;\"&gt;| &lt;/span&gt; &amp;nbsp; &lt;time datetime=\"&lt;%= date_xml(post.date) %&gt;\" itemprop=\"datePublished\"&gt;&lt;i class=\"icon-calendar icon\" style=\"color:#9a989b\" &gt;&lt;/i&gt; &lt;span style=\"font-size:15px; color:#9a989b;\"&gt; &lt;%= date(post.date, date_format) %&gt;&lt;/time&gt; &lt;/span&gt; &lt;/a&gt;这里可自定义图标，修改字体的大小，间距，颜色，内容。对于图标的修改，增添，参考黑群晖-4.2 将NAS入口添加到博客如果出现中文字体乱码，把word.ejs编码格式改为UTF-8 无BOM格式。 5.9 添加live2d看板动画(已舍弃) 20190504更新：舍弃本块功能；原因:略占资源，导致卡顿，新鲜感已过，实用价值比较低； a. 安装hexo-helper-live2d在博客根目录下，执行：1npm install --save hexo-helper-live2d 对应的卸载命令为：1npm uninstall hexo-helper-live2d b. 安装动画模型可使用的Live2D动画模型效果参考：hexo live2d插件 2.0 !这里以hijiki为例。可以去Github下载，也可以使用命令下载：1npm install live2d-widget-model-hijiki 博客根目录下新建个live2d_models目录。如果是Github下载，将packages里的live2d-widget-model-hijiki拷贝到live2d_models。如果是通过命令下载，将博客根目录下node_modules里的live2d-widget-model-hijiki拷贝到live2d_models。 c. 配置动画模型 打开博客根目录的配置文件_config.yml，添加如下内容：12345678910111213141516171819202122# Live2D## https://github.com/xiazeyu/live2d-widget.js## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-initlive2d: model: scale: 1 hHeadPos: 0.5 vHeadPos: 0.618 use: live2d-widget-model-hijiki //模型名称 display: superSample: 2 width: 120 //模型宽度 height: 200 position: left //模型在网页的位置 hOffset: 90 //水平偏移 vOffset: -30 mobile: show: false //是否在移动端显示 scale: 0.5 react: opacityDefault: 0.7 opacityOnHover: 0.2 然后执行hexo clean清理缓存，执行hexo g重新生成博客文件，最后执行hexo d上传到仓库。因为新增上传过程会比较慢， 5.10 添加评论模块Valine舍弃了gitment，尝试使用Valine评论。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Git日常使用小结","date":"2017-03-02T06:14:00.000Z","path":"2017/03/02/Git日常使用小结/","text":"本文主要是记录一些Git的配置和命令。关于代码托管，我目前主要使用两个： GitHub：主要用于托管公开代码和利用GitHub Pages搭建本博客； Coding：主要用于同步GitHub代码和托管私人代码；下面纪录下Git的安装、配置、使用。 1.安装GitWindows：git-for-windowsysGitMac OS:从AppStore安装Xcode,选择菜单“Xcode”-&gt;“Preferences”，找到“Downloads”，选择“Command Line Tools”，点“Install”。Linux:1$ sudo apt-get install git 2.创建本地仓库并上传2.1在本地创建仓库 第一次打开Git时,首先要在Git上设置username和email；12$ git config --global user.name &quot;hceng&quot; #与注册的账号邮箱一致；$ git config --global user.email &quot;huangcheng.job@foxmail.com&quot; 在命令行里(这里使用Cmder软件)先进入欲作为仓库的文件夹（如：E:/blog文件夹），然后初始化——创建本地仓库:12$ e: &amp; cd blog #进入E盘的blog文件夹；$ git init #初始化当前文件夹作为仓库（生成.git文件夹）； 这时生成一个”.git”目录，该目录是Git来跟踪管理版本，一般情况勿动；2.2添加文件到本地仓库12$ touch readme.txt #创建一个测试文件；$ git add readme.txt #将当前更改或者新增的文件加入到临时空间中； 注： add 命令只是把文件添加到一个临时空间里，需要执行第3 步的commit 命令才会正式提交到仓库中； 如果文件太多，可以使用以下命令一次性提交所有文件(.gitignore 文件指定的除外)；1$ git add -A 可以在当前目录下新建一个名为“.gitignore”的文件，它里面的内容用来表示某类/某个文件将不会被提交到仓库。 2.3提交文件到本地仓库执行以下命令，这会把临时空间的内容存入本地仓库，并添加注释：1$ git commit -m &quot;blog, add 1 files&quot; 可以使用以下命令查看记录：1$ git log --pretty=oneline得到类似信息，前面为版本号，后面为注释：112ewdqe2q... blog, add 1 files可以给某个版本号打上一个标签，命令如下：1$ git tag v1 12ew可以使用以下命令查看已有的标签：1$ git tag 2.4提交文件到GitHub/Coding第一次提交前，需要将本机密钥上传到GitHub/Coding；2.4.1.创建SSH Key：在用户主目录下，看看有没有.ssh 目录，如果有，再看看这个目录下有没有id_rsa 和id_rsa.pub 这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Git Bash，创建SSH Key，命令如下：1$ ssh-keygen -t rsa -C &quot;huangcheng.job@foxmail.com&quot;然后一路回车，使用默认值即可。这样在用户主目录里就会生成.ssh 目录，里面有id_rsa 和id_rsa.pub 两个文件，它们是SSH Key 的秘钥对。id_rsa 是私钥，不能泄露出去；id_rsa.pub 是公钥，可以放心地告诉任何人。 2.4.2.在GitHub 里添加SSH Key：电脑登陆GitHub,在自己账户的”Settings”-“SSH Key”中添加id_rsa.pub 文件的内容；2.4.3.创建一个仓库如:git_hexo,第一次上传需要指定GitHub/Coding仓库，如Coding的git_hexo：1$ git remote add origin https://git.coding.net/hceng/git_hexo.git然后根据提示输入账号、密码，最后执行以下指令提交至GitHub/Coding；12$ git push -u origin master$ git push origin --tags 2.5以后如果修改文件后再次提交12345$ git add –A # 添加修改文件到临时空间；$ git commit -m &quot;blog, git use&quot; # 添加本地仓库和添加备注；$ git tag v2 # 打标签；$ git push origin master # 上传到服务器的master；$ git push origin --tags # 上传标签到服务器； 3.Git 获取GitHub/Coding源码 执行以下命令，可以复制他人public代码，这称为“克隆”：1$ git clone https://github.com/hceng/hceng.github.io 当源码作者再次修改了源码后，可以进入对应目录，然后使用以下命令再次获得最新的：1$ git pull origin 查看信息纪录：1$ git log --pretty=oneline 查看标签：1$ git tag 获得指定版本的源码：123$ git checkout &lt;commit id&gt;或$ git checkout &lt;tag_name&gt; 4.分支管理4.1查看所有分支：1$ git branch --all # 本地主分支：master；远程主分支：origin/master； 4.2创建本地分支：12$ git branch bak # 创建本地分支；$ git branch # 查看本分支；&quot;*&quot;号表示当前所在分支； 4.3发布新分支：即：将本地新建的bak分支同步到远程服务器GitHub/Coding;12$ git push origin bak # 这样远程仓库也有一个bak分支了；$ git checkout bak # 切换到bak分支操作；第一种情况：bak分支开发完成，合并到主分支：12345$ git checkout master # 切换到主分支；$ git merge bak # 把bak分支的更改和master合并；$ git push # 提交主分支代码远程；$ git checkout bak # 切换到bak远程分支；$ git push # 提交bak分支到远程； 第二种情况：bak分支没开发完，推送保存，下次再开发：123$ git add -A # 添加修改文件到临时空间；$ git commit -m &quot;bak branch&quot; # 提交本地bak分支仓库；$ git push # 提交bak分支到远程； 4.4删除分支：12345# 删除远程bak分支，危险命令；$ git push origin :bak # 下面两条是删除本地分支;$ git checkout master # 切换到master分支$ git branch -d bak # 删除本地dev分支 参考：A successful Git branching model 5.其它常用指令12345678910 $ git status #查看仓库状态; $ git diff XX #查看XX文件修改了那些内容;$ git log #查看历史记录;$ git reflog #查看历史记录(含回退纪录)；$ git reset –hard HEAD^ #回退到上一个版本; $ git reset –hard HEAD~ #回退到上一个版本;$ git reset –hard HEAD~100 #回退到100个版本;$ git checkout – XX #把XX文件在工作区的修改全部撤销； $ git rm XX #删除XX文件； 参考资料：韦东山Android系统视频使用手册20160303 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"SkillTree","date":"2017-03-01T00:00:00.000Z","path":"2017/03/01/SkillTree/","text":"My SkillTree. SkillTree 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]