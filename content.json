[{"title":"移植MiniGUI到JZ2440","date":"2017-05-26T01:46:37.000Z","path":"2017/05/26/移植MiniGUI到JZ2440/","text":"尝试将MiniGUI到JZ2440上。移植所需文件： 文件包名 作用 libminigui-1.6.10.tar.gz MiniGUI开发库 minigui-res-1.6.10.tar.gz MiniGUI资源文件 mg-samples-1.6.10.tar.gz MiniGUI示例程序 tslib-1.4.tar.gz 触摸屏功能 1.移植MiniGUI1.1 解压、编译MiniGUI开发库123456tar xzf libminigui-1.6.10.tar.gzcd libminigui-1.6.10/mkdir tmp./configure CC=arm-linux-gcc --prefix=$&#123;PWD&#125;/tmp --build=i386-linux --host=arm-linux --target=arm-linuxmakemake install 完成上面操作，即可在tmp目录下生成以下文件： 将生成的/lib下所有文件(和共享库相关)拷贝到开发板/lib目录下，将生成的/etc下的MiniGUI.cfg也拷贝到开发板/etc目录下:12cp –rfd ./lib/* /work/hceng/nfs_rootfs/libcp ./etc/* /work/hceng/nfs_rootfs/etc 1.2 解压MiniGUI资源文件12tar xzf minigui-res-1.6.10.tar.gzcd minigui-res-1.6.10/ 修改config.linux，指定生成文件路径： 编译生成：1make install 此时会在指定的/tmp目录下生成以下文件： 这些文件包含了MiniGUI会使用到的资源，包括基本字体、图标、位图和鼠标光标等，将这些文件全部复制到开发板的/usr/local/lib/minigui/res/路径下，这个路径是前面MiniGUI.cfg指定的。 1.3 编译MiniGUI示例程序 解压、配置、编译：12345tar xzf mg-samples-1.6.10.tar.gzcd mg-samples-1.6.10.tar.gz/./configure CC=arm-linux-gcc --build=i386-linux --host=arm-linux -target=arm-linux CFLAGS=-I/work/minigui/libminigui-1.6.10/tmp/include LDFLAGS=-L/work/minigui/libminigui-1.6.10/tmp/libmakemake install 此时会在/src目录下生成示例程序： 复制示例程序到开发板里面去，注意有些程序需要本目录下的图片文件，需要一同拷贝过去。这里以helloworld为例：1cp helloworld /work/hceng/nfs_rootfs/ 1.4 其他修改 修改前面复制到开发板/etc目录下的MiniGUI.cfg以适应JZ2440。 在开发板的/etc目录下建立ld.so.conf文件，并添加如下内容：123/usr/local/lib/usr/lib/lib 在/etc/init.d/rcS脚本文件里添加如下内容(非必需)：1/bin/ln –s /dev/vc/0 /dev/tty0 移植MiniGUI完成，运行应用程序： 2.移植tslib2.1 安装一些工具123sudo apt-get install autoconfsudo apt-get install automakesudo apt-get install libtool 2.2 解压、编译123456789tar xzf tslib-1.4.tar.gzcd tslib./autogen.sh mkdir tmpecho &quot;ac_cv_func_malloc_0_nonnull=yes&quot; &gt;arm-linux.cache./configure --host=arm-linux --cache-file=arm-linux.cache --prefix=$(pwd)/tmpmakemake install 2.3 安装12cd tmpcp * -rfd /work/hceng/nfs_rootfs 2.4 修改/etc/ts.conf第1行(去掉#号和第一个空格)1# module_raw input 改为：1module_raw input 2.5 在开发板设置环境变量123456export TSLIB_TSDEVICE=/dev/event0export TSLIB_CALIBFILE=/etc/pointercalexport TSLIB_CONFFILE=/etc/ts.confexport TSLIB_PLUGINDIR=/lib/tsexport TSLIB_CONSOLEDEVICE=noneexport TSLIB_FBDEVICE=/dev/fb0 2.6 运行校准示例程序1ts_calibrate 如果在运行程序的时候，出现提示：1selected device is not a touchscreen I understand 有显示，但无法触屏，可能是编译器版本和内核版本不一致，解决方法如下： 修改编译器的input.h：12cd /usr/local/arm/4.3.2/arm-none-linux-gnueabi/libc/usr/include/linuxsudo vim input.h 将1#define EV_VERSION 0x010000 改为：1#define EV_VERSION 0x010001 重新进行前面的编译即可，编译后，记得改回编译器的版本。 3.MiniGUI和tslib链接 此时虽然分别移植好了MiniGUI和tslib，但触屏并不能正常的控制GUI，需要进行将MiniGUI和tslib进行链接。 使用MiniGUI 的 IAL 引擎，修改/libminigui-1.6.10/src/ial/下的dummy.c成如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include \"common.h\"#include \"tslib.h\"#ifdef _DUMMY_IAL#include &lt;sys/ioctl.h&gt;#include &lt;sys/poll.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;linux/kd.h&gt;#include \"ial.h\"#include \"dummy.h\"#ifndef _DEBUG#define _DEBUG // for debugging#endif/* for storing data reading from /dev/touchScreen/0raw */typedef struct &#123; unsigned short pressure; unsigned short x; unsigned short y; unsigned short pad;&#125; TS_EVENT;static unsigned char state [NR_KEYS];static int mousex = 0;static int mousey = 0;static TS_EVENT ts_event;static struct tsdev *ts;/************************ Low Level Input Operations **********************//** Mouse operations -- Event*/static int mouse_update(void)&#123; return 1;&#125;static void mouse_getxy(int *x, int* y)&#123; if (mousex &lt; 0) mousex = 0; if (mousey &lt; 0) mousey = 0; if (mousex &gt; 639) mousex = 639; if (mousey &gt; 479) mousey = 479;#ifdef _DEBUG // printf (\"mousex = %d, mousey = %d/n\", mousex, mousey);#endif *x = mousex; *y = mousey;&#125;static int mouse_getbutton(void)&#123; return ts_event.pressure;&#125;#ifdef _LITE_VERSIONstatic int wait_event (int which, int maxfd, fd_set *in, fd_set *out, fd_set *except, struct timeval *timeout)#elsestatic int wait_event (int which, fd_set *in, fd_set *out, fd_set *except, struct timeval *timeout)#endif&#123; struct ts_sample sample; int ret = 0; int fd; fd_set rfds; int e; if (!in) &#123; in = &amp;rfds; FD_ZERO (in); &#125;fd = ts_fd(ts); if ((which &amp; IAL_MOUSEEVENT) &amp;&amp; fd &gt;= 0) &#123; FD_SET (fd, in);#ifdef _LITE_VERSION if (fd &gt; maxfd) maxfd = fd;#endif &#125;#ifdef _LITE_VERSION e = select (maxfd + 1, in, out, except, timeout) ;#else e = select (FD_SETSIZE, in, out, except, timeout) ;#endif if (e &gt; 0) &#123; // input events is coming if (fd &gt; 0 &amp;&amp; FD_ISSET (fd, in)) &#123; FD_CLR (fd, in); ts_event.x=0; ts_event.y=0; ret = ts_read(ts, &amp;sample, 1); if (ret &lt; 0) &#123; perror(\"ts_read()\"); exit(-1); &#125; ts_event.x = sample.x; ts_event.y = sample.y; ts_event.pressure = (sample.pressure &gt; 0 ? 4:0); // if (ts_event.pressure &gt; 0 &amp;&amp; if((ts_event.x &gt;= 0 &amp;&amp; ts_event.x &lt;= 639) &amp;&amp; (ts_event.y &gt;= 0 &amp;&amp; ts_event.y &lt;= 479)) &#123; mousex = ts_event.x; mousey = ts_event.y; // printf(\"ts_event.x is %d, ts_event.y is %d-------------------------------------&gt;/n\",ts_event.x ,ts_event.y); &#125;//#ifdef _DEBUG // if (ts_event.pressure &gt; 0) &#123; // printf (\"mouse down: ts_event.x = %d, ts_event.y = %d,ts_event.pressure = %d/n\",ts_event.x,ts_event.y,ts_event.pressure); // &#125;//#endif ret |= IAL_MOUSEEVENT; return (ret); &#125; &#125; else if (e &lt; 0) &#123; return -1; &#125; return (ret);&#125;BOOL InitDummyInput(INPUT* input, const char* mdev, const char* mtype)&#123; char *ts_device = NULL; if ((ts_device = getenv(\"TSLIB_TSDEVICE\")) != NULL) &#123; // open touch screen event device in blocking mode ts = ts_open(ts_device, 0); &#125; else &#123;#ifdef USE_INPUT_API ts = ts_open(\"/dev/input/0raw\", 0);#else ts = ts_open(\"/dev/touchscreen/ucb1x00\", 0);#endif &#125;#ifdef _DEBUG printf (\"TSLIB_TSDEVICE is open!!!!!!!!!!!/n\");#endif if (!ts) &#123; perror(\"ts_open()\"); exit(-1); &#125; if (ts_config(ts)) &#123; perror(\"ts_config()\"); exit(-1); &#125; input-&gt;update_mouse = mouse_update; input-&gt;get_mouse_xy = mouse_getxy; input-&gt;set_mouse_xy = NULL; input-&gt;get_mouse_button = mouse_getbutton; input-&gt;set_mouse_range = NULL; input-&gt;wait_event = wait_event; mousex = 0; mousey = 0; ts_event.x = ts_event.y = ts_event.pressure = 0; return TRUE;&#125;void TermDummyInput(void)&#123; if (ts) ts_close(ts);&#125;#endif /* _DUMMY_IAL */ 指定tslib 相关的头文件和共享库文件重新编译libminigui: 12cd /work/minigui/libminigui-1.6.10/./configure CC=arm-linux-gcc --prefix=$&#123;PWD&#125;/tmp --build=i386-linux --host=arm-linux --target=arm-linux CFLAGS=&quot;-I/work/minigui/tslib/tmp/include -L/work/minigui/tslib/tmp/lib -lts&quot; 将新生成的/tmp/lib下的文件覆盖掉开发板原来的文件： 1cp –rfd ./lib/* /work/hceng/nfs_rootfs/lib 因为共享文件变了，这里重新编译示例程序libminigui: 1./configure CC=arm-linux-gcc --build=i386-linux --host=arm-linux -target=arm-linux CFLAGS=-I/work/minigui/libminigui-1.6.10/tmp/include LDFLAGS=-L/work/minigui/libminigui-1.6.10/tmp/lib 再将生成的应用程序复制到开发板重新运行： 1cp painter /work/hceng/nfs_rootfs/ 在开发板运行： 1./ painter 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/环境搭建/"}]},{"title":"PCB_Ruler","date":"2017-05-18T13:48:04.000Z","path":"2017/05/18/PCB-Ruler/","text":"这是一个毕业的故事。0x00 初衷： 即将大学毕业，大家在一起了四年，所以想在毕业之际准备个小东西作为纪念品。在考虑专业特色、有意义（有一定实用性）且价格不贵这些因素后，我想到做这个PCB_Ruler也许可以。 0x01 过程： 整个过程 两个人利用空闲时间制作，进行了一个多月，进行了三次大修改和PCB打样，投入1000多元。最后做了150块，分别送给了两个班87名同学、若干本专业的任课老师和行政老师等。 0x02 功能： 主要功能是测量，有cm和mil两种，其中cm是日常常用的，mil是pcb制作中一种比较通用的单位。 正面：直尺功能、有常见的电阻电容、元器件的封装参考；过孔的孔径大小参考； 背面：走线线宽参考；元器件的脚间距参考；纪念信息； 0x03 效果： 0x04 致谢： 感谢和我一起制作的同学@小冲冲，抽出空余时间，一同完成本设计。 0x05 权限：东西开源啦，开源地址：https://github.com/hceng/learn/tree/master/PCB_Ruler 0x06 毕业照： 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"PCB","slug":"PCB","permalink":"http://yoursite.com/tags/PCB/"}]},{"title":"Linux环境编程学习","date":"2017-04-30T15:55:30.000Z","path":"2017/04/30/Linux环境编程/","text":"记录Linux环境下的编程，0基础开始，不断更新。最近在学习Linux环境编程，仿佛打开了新世界的大门。初学，认知有局限，不断修正。 文件相关1.fopen[1-fopen.c]link1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; FILE * fp; unsigned int i = 0; fp = fopen(argv[1], \"w\"); if(fp == NULL) &#123; printf(\"Unable to fopen \\n\"); return -1; &#125;/* printf(\"argc = %d\\n\",argc); for(i; i&lt;argc; i++) &#123; printf(\"argv[%d]=%s\\n\",i,argv[i]); &#125;*/ printf(\"read success \\n\"); fclose(fp); return 0;&#125; 测试结果：分析： fopen的第一个参数：argv[1]，是运行fopen时传入的参数 hceng.txt.fopen对其写操作，但没有这个文件，就自动创建了该文件。 2.fopen_max[2-fopen_max.c]link1234567891011121314#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; FILE * fp; int count = 0; fclose(stdin); while((fp = fopen(argv[1], \"r\")) != NULL) count++; printf(\"count = %d \\n\", count); return 0;&#125; 测试结果：分析： 意味着一个文件最多被打开1022次。 3. fgetc[3-fgetc.c]link123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; FILE * fp; fp = fopen(argv[1], \"r\"); if(fp == NULL) &#123; printf(\"Unable to fopen\\n\"); return -1; &#125; char ch = fgetc(fp); ch = fgetc(fp); ch = fgetc(fp); //printf(\"ch = %c \\n\", ch); fputc(ch, stdout); putchar(10); fclose(fp); return 0;&#125; 测试结果：分析： fgetc每次得到一个字符（且自动跳到下一个字符），fputc这里指定ch写到标准输出流。putchar是输出一个字符的意思，这里参数10换成ascii码是换行。 4. cat[4-cat.c]link1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; FILE *fp_r; char ch; fp_r = fopen(argv[1], \"r\"); if(fp_r == NULL) &#123; // printf(\"Unable to fopen \\n\"); fprintf(stdout, \"Unable to fopen \\n\"); return -1; &#125; while((ch = fgetc(fp_r)) != EOF) &#123; //printf(\"%c\",ch); fputc(ch, stdout); &#125; fclose(fp_r); return 0;&#125; 测试结果：分析： 实现类似cat的命令，fgetc一直获取字符到结尾，然后fputc依次打印出来。 5. cp[5-cp.c]link123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; FILE *fp_r, *fp_w; char ch; fp_r = fopen(argv[1], \"r\"); if(fp_r == NULL) &#123; fprintf(stdout,\"Unable to fopen fp_r\\n\"); return -1; &#125; fp_w = fopen(argv[2], \"w\"); if(fp_w == NULL) &#123; fprintf(stdout, \"Unable to fopen fp_w \\n\"); &#125; while((ch = fgetc(fp_r)) != EOF) &#123; fputc(ch, fp_w); &#125; fclose(fp_r); fclose(fp_w); return 0;&#125; 测试结果：分析： 实现类似cp的命令，fgetc一直获取argv[1]字符到结尾，然后fputc写到argv[2]。 6. line[6-line.c]link1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; FILE *fp_r; char ch; int line = 0; fp_r = fopen(argv[1], \"r\"); if(fp_r == NULL) &#123; fprintf(stdout, \"Unable to fopen \\n\"); return -1; &#125; while((ch = fgetc(fp_r)) != EOF) &#123; if(ch == '\\n') line++; &#125; printf(\"line = %d \\n\",line); fclose(fp_r); return 0;&#125; 测试结果：分析： 获取文件行数，fgetc一直读到结尾，遇到\\n则表示换行，即行数+1。 7. fgets[7-fgets.c]link1234567891011121314151617181920212223#include &lt;stdio.h&gt;#define N 32int main(int argc, const char *argv[])&#123; FILE *fp_r; char buf[N] = &#123;0&#125;; fp_r = fopen(argv[1], \"r\"); if(fp_r == NULL) &#123; fprintf(stdout, \"Unable to fopen fp_r \\n\"); return -1; &#125; fgets(buf, 32, fp_r); fputs(buf, stdout); fclose(fp_r); return 0;&#125; 测试结果：分析： 获取文件字符串，这里要设置读取的字符串的长度，感觉有点局限。应该是识别以\\n结尾，这里一次只读取了一行。 8. fgets_cp[8-fgets_cp.c]link123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#define N 32int main(int argc, const char *argv[])&#123; FILE *fp_r, *fp_w; char buf[N] = &#123;0&#125;; fp_r = fopen(argv[1], \"r\"); if(fp_r == NULL) &#123; fprintf(stdout, \"Unable to fopen fp_r \\n\"); return -1; &#125; fp_w = fopen(argv[2], \"w\"); if(fp_w == NULL) &#123; fprintf(stdout, \"Unable to fopen fp_w \\n\"); return -1; &#125; while(fgets(buf, 16, fp_r) != NULL) fputs(buf, fp_w); fclose(fp_r); fclose(fp_w); return 0;&#125; 测试结果：分析： 以fgets的方式获取一行，写入另一个文件，以实现cp的功能。判断的依据是fgets获取的是非空 9. fread_fwrite[9-fread_fwrite.c]link12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#define N 32int main(int argc, const char *argv[])&#123; FILE *fp_r, *fp_w; char buf[N] = &#123;0&#125;; fp_r = fopen(argv[1], \"r\"); if(fp_r == NULL) &#123; fprintf(stdout, \"Unable to fopen fp_r\\n\"); return -1; &#125; fp_w = fopen(argv[2], \"w\"); if(fp_w == NULL) &#123; fprintf(stdout, \"Unable to fopen fp_w\\n\"); return -1; &#125; size_t bytes = fread(buf, 5, 3, fp_r); fwrite(buf, 5, 2, fp_w); //printf(\"bytes = %d \\n\",bytes); return 0;&#125; 测试结果：分析： fread/ fwrite第一个参数是指向读取/写入的缓冲数据，第二个参数是定义每个数据类型的大小，第三个是定义的数据类型个数，最后是指向操作的文件指针。 10.实例 时间编程题目要求：编程读写一个文件test.txt，每隔1秒向文件中写入一行数据，类似这样：1, 2007-7-30 15:16:422, 2007-7-30 15:16:43该程序应该无限循环，直到按Ctrl-C中断程序。再次启动程序写文件时可以追加到原文件之后，并且序号能够接续上次的序号，比如：1, 2007-7-30 15:16:422, 2007-7-30 15:16:433, 2007-7-30 15:19:024, 2007-7-30 15:19:035, 2007-7-30 15:19:04 提示：要追加写入文件，同时要读取该文件的内容以决定下一个序号是几，应该用什么模式打开文件？首先判断一下打开的文件是否为新文件，如果是新文件，就从序号1开始写入；如果不是新文件，则统计原来有多少行，比如有n行，然后从序号n+1开始写入。以后每写一行就把行号加1。获取当前的系统时间需要调用函数time()，得到的结果是一个time_t类型，其实就是一个大整数，其值表示从UTC时间1970年1月1日00:00:00（称为UNIX的Epoch时间）到当前时刻的秒钟数。然后调用localtime()将time_t所表示的UTC时间转换为本地时间（我们是+8区，比UTC多8个小时）并转成struct tm类型，该类型的各数据成员分别表示年月日时分秒，请自己写出转换格式的代码，不要使用ctime()或asctime()函数。具体用法请查阅man page。time和localtime函数需要头文件time.h。调用sleep(n)可使程序睡眠n秒，该函数需要头文件unistd.h [hceng_time.c]link1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/************************************************************************* &gt; File Name: hceng_time.c &gt; Author:hceng &gt; Mail: huangcheng.job@foxmail.com &gt; Created Time: Wed 26 Apr 2017 06:48:22 AM UTC ************************************************************************/#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;int main(int argc, const char *argv[])&#123; FILE *fd; char ch; unsigned int line = 0; time_t *get_time; struct tm *local_time; //add data to file fd = fopen(argv[1], \"a+\"); if(fd == NULL) &#123; fprintf(stderr,\"can't open file!\"); return -1; &#125; //get line while((ch = fgetc(fd)) != EOF) &#123; if(ch == '\\n') ++line; &#125; //show while(1) &#123; time(get_time); local_time = localtime(get_time); fprintf(fd,\"%d. %d-%d-%d %d:%d:%d\\n\",++line,local_time-&gt;tm_year+1900,local_time-&gt;tm_mon,local_time-&gt;tm_mday,local_time-&gt;tm_hour,local_time-&gt;tm_min,local_time-&gt;tm_sec); printf(\"%d. %d-%d-%d %d:%d:%d\\n\",line,local_time-&gt;tm_year+1900,local_time-&gt;tm_mon,local_time-&gt;tm_mday,local_time-&gt;tm_hour,local_time-&gt;tm_min,local_time-&gt;tm_sec); fflush(fd); sleep(1); &#125; fclose(fd); return 0;&#125; 测试结果：分析： 先以追加的方式打开文件（没有则创建），然后获取文件行数，再获取时间且转换成本地时间，然后按格式要求打印信息。 进程相关1.fork1[fork.c]link12345678910111213141516171819202122232425262728293031#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; pid_t pid; printf(\"hello world\\n\"); pid = fork(); printf(\"pid = %d\\n\",pid); if(pid &lt; 0) &#123; perror(\"Unable to fork\"); return -1; &#125; if(pid == 0) &#123; //子进程 printf(\"child process parent %d ,child = %d\\n\",getppid(), getpid()); &#125; else &#123; //父进程: printf(\"parent process = %d, child = %d\\n\", getpid(), pid); &#125; while(1); return 0;&#125; 测试结果：分析： 首先父进程fork了自己，返回了子进程的PID，并打印出来。然后继续执行，打印出自己的PID和子进程PID。子进程产生了和父进程一模一样的代码，然后从fork处开始执行，子进程fork返回的的固定为0，然后getppi打印出父进程PID，getpid打印出自己的PID。 从PS可以看到父进程PID为：11370，子进程为：11371. 注：一般fork后是父进程继续运行，但如果父进程时间片用完了，则子进程会先进行，所以这里的打印顺序是不确定的，如果要确定，需要同步。 2.fork2[fork_1.c]link12345678910111213141516171819202122232425262728#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; pid_t pid; pid = fork(); if(pid &lt; 0) &#123; perror(\"Unable to fork\"); return -1; &#125; if(pid == 0) &#123; //子进程 printf(\"child process parent %d ,child = %d\\n\",getppid(), getpid()); &#125; else &#123; //父进程: printf(\"parent process = %d, child = %d\\n\", getpid(), pid); while(1); &#125; return 0;&#125; 测试结果：分析： 这里父进程有个whileh会一直执行，二子程序没有。在PS中可以看到子进程（12173）被标记为defunct(僵尸进程)。 在Linux系统中，一个进程结束了，但是他的父进程没有等待(调用wait / waitpid)他，那么他将变成一个僵尸进程。当用ps命令观察进程的执行状态时，看到这些进程的状态栏为defunct。僵尸进程是一个早已死亡的进程，但在进程表（processs table）中仍占了一个位置（slot）。 但是如果该进程的父进程已经先结束了，那么该进程就不会变成僵尸进程。因为每个进程结束的时候,系统都会扫描当前系统中所运行的所有进程，看看有没有哪个进程是刚刚结束的这个进程的子进程，如果是的话，就由Init进程来接管他，成为他的父进程，从而保证每个进程都会有一个父进程。而Init进程会自动wait其子进程,因此被Init接管的所有进程都不会变成僵尸进程。 3.fork3[fork_2.c]link123456789101112131415161718192021222324252627282930313233343536#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;wait.h&gt;int main(int argc, const char *argv[])&#123; pid_t pid; pid = fork(); if(pid &lt; 0) &#123; perror(\"Unable to fork\"); return -1; &#125; if(pid == 0) &#123; //子进程 printf(\"child process parent %d ,child = %d\\n\",getppid(), getpid()); exit(0); &#125; else &#123; //父进程: int status; sleep(4); wait(&amp;status); printf(\"child exit\\n\"); sleep(4); printf(\"parent status = %d\\n\", status); &#125; return 0;&#125; 测试结果：分析： 这里多了个wait来监控子进程。当父进程执行wait时，立即被阻塞，直到子进程退出，才继续执行后续的。第一个sleep(4)时，PS看到父进程为15167,子进程15168为僵尸状态，执行wait时，自动回收僵尸进程。等回收完了，父进程结束阻塞，继续执行到结束。 4.exit和_exit12345678910111213#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;//#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; printf(\"hello world\"); _exit(5); //exit(5); printf(\"hello Shenzhen\\n\"); return 0;&#125; 123456789101112#include &lt;stdio.h&gt;//#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; printf(\"hello world\"); //_exit(5); exit(5); printf(\"hello Shenzhen\\n\"); return 0;&#125; 123456789101112#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;//#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; printf(\"hello world\\n\"); _exit(5); //exit(5); printf(\"hello Shenzhen\\n\"); return 0;&#125; 分析： _exit()执行后立即返回给内核，而exit()要先执行一些清除操作，然后将控制权交给内核。调用_exit函数时，其会关闭进程所有的文件描述符，清理内存以及其他一些内核清理函数，但不会刷新流(stdin, stdout, stderr …)。exit函数是在_exit函数之上的一个封装，其会调用_exit，并在调用之前先刷新流。因此才会看到遇到_exit并不会打印，因为数据在“IO缓存”，而exit会刷新流，导致打印输出。 带三个例子加个\\n，使用_exit也打印出来了， printf函数就是使用缓冲I/O的方式，该函数在遇到“\\n”换行符时自动的从缓冲区中将记录读出。 参考文章 5.daemon1、何为守护进程？（1）daemon:守护进程、 后台程序简称是d，（一般带有d的都是守护进程）（2）长期运行： 从系统启动时开始运行，到系统关闭时结束(运行周期)（3）与控制台脱离（终端）：守护进程启动后，脱离控制台，不受终端控制，背后的问题是会话（4）服务器：是一个应用程序，使用时直接调用定义： 是一个在后台运行，并且不受终端控制的服务程序！2、编写守护进程（1）创建父子进程，父进程退出 （孤儿进程）（2）在子进程中设置新的会话 （setsid）（3）改变当前目录为根目录（4）重设文件权限掩码 （增加对文件操作灵活性）（5）关闭所有文件描述符创建完守护进程之后，要加入服务程序，并且要在while循环之中实现。参考文章1；参考文章2； [dameon.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; pid_t pid; pid = fork(); if(pid &lt; 0) &#123; perror(\"Unable to fork\"); exit(1); &#125; if(pid == 0) &#123; //创建新的会话，让子进程成为会话组的领导者，不受终端控制 setsid(); //改变当前目录为根目录 chdir(\"/\"); //重设文件权限掩码 umask(0); //关闭打开的文件描述符 int i, fd_w; char buf[] = &#123;\"hello world\\n\"&#125;; //getdtablesize()返回这个进程的文件描述表的项数 for(i = 0; i &lt; getdtablesize(); i++) close(i); fd_w = open(\"/test123.txt\", O_CREAT | O_WRONLY | O_APPEND, 0666); if(fd_w &lt; 0) &#123; perror(\"Unalbe to open\"); exit(1); &#125; while(1) &#123; write(fd_w, buf, 20); sleep(1); &#125; close(fd_w); &#125; else &#123; exit(0); &#125; return 0;&#125; 测试结果：ps -ajx分析： 守护进程用于一直后台运行，且不受终端控制。编写守护程序有5步，参考前面的介绍。 6.exec[exec.c]link12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; printf(\"hello start \\n\");#if 1 if(execl(\"/bin/ls\", \"ls\", \"-l\", \"-a\", NULL) &lt; 0) &#123; perror(\"Unable to execl\"); exit(1); &#125;#endif#if 0 if(execlp(\"ls\", \"ls\", \"-l\", \"-a\", NULL) &lt; 0) &#123; perror(\"Unable to execl\"); exit(1); &#125;#endif#if 0 char *arg[] = &#123;\"ls\", \"-la\", NULL&#125;; if(execv(\"/bin/ls\", arg) &lt; 0) &#123; perror(\"Unable to execl\"); exit(1); &#125;#endif printf(\"hello end \\n\"); return 0;&#125; 测试结果：分析： 这里的三个exec系列函数的效果都是一样的。调用某个新程序后，就把自己覆盖了，所以最后的hello end才没打印。 区别如下： 带“p”的表示PATH有关； 带“l”的表示list,与数组有关； 带“v”的表示vector； 带“e”的表示environment，将使用调用者的environ； 线程相关 线程是什么？线程是一个轻量级的进程，内核也会调度线程，线程在进程当中创建。 进程和线程的区别？线程没有自己独享的资源，因此没有自己的地址空间，他要依附在进程的地址空间中借助进程的资源运行。线程优点：数据共享很简单，创建线程的要快于创建进程；线程缺点：安全性、相互之间容易影响、有限的虚拟地址空间； 线程间如何实现通信？ 全局变量、数组 线程标识符：用来唯一的表示一个线程，通过调用线程库来实现对线程的访问操作。 线程相关函数：1、创建 –》 pthread_create2、回收线程 –》 pthread_join3、结束线程 –》 pthread_exit4、线程销毁 –》 pthread_destroy 1.pthread1234567891011int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);功能：创建线程参数：thread 线程对象attr 线程属性默认为NULL，栈的空间大小是8Mstart_routine 函数指针，用来指向函数名arg 参数，作为函数指针的参数返回值：成功： 0失败： 错误码 123void pthread_exit(void *arg)功能： 线程结束函数参数： 传递线程退出时的状态值 12345pthread_join（pthread_t pthread， void**retval）功能：线程回收函数（阻塞等待，直到等到线程退出了，会立即释放）参数： pthread 线程对象retval 线程退出时的状态值 [pthread.c]link12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void *pthread_fun(void * arg)&#123; int i = 20; printf(\"*arg = %d \\n\", *(int *)arg); while(i--) &#123; printf(\"pthread i = %d \\n\", i); sleep(1); if(i == 10) pthread_exit(\"pthread exit\"); &#125;&#125;int main(int argc, const char *argv[])&#123; pthread_t tid; int num = 18; if(pthread_create(&amp;tid, NULL, pthread_fun, &amp;num) != 0) &#123; perror(\"Unable to pthread_create\"); exit(1); &#125; printf(\"pthread start \\n\"); void * ret; pthread_join(tid, &amp;ret); printf(\"pthread end %s \\n\", (char *)ret); return 0;&#125; 测试结果：分析： pthread_create创建线程pthread_fun，并传入参数&amp;num，然后主进程调用pthread_join等待线程。线程每隔1s打印输出，直到i = 10时，调用pthread_exit结束线程，同时传递状态值pthread exit到pthread_join。主进程再打印出状态值后退出。 注意：编译的时候加上-pthread 2.mutex不加互斥锁：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;pthread_mutex_t lock;int value_1, value_2;void *pthread_fun(void * arg)&#123; while(1) &#123; //pthread_mutex_lock(&amp;lock); if(value_1 == value_2) &#123; printf(\"value_1 = %d, value_2 = %d\\n\", value_1, value_2); &#125; //pthread_mutex_unlock(&amp;lock); &#125;&#125;int main(int argc, const char *argv[])&#123; int count = 0; pthread_t pthread; if(pthread_mutex_init(&amp;lock, NULL) &lt; 0) &#123; perror(\"fail to pthread_mutex_init \"); exit(1); &#125; if(pthread_create(&amp;pthread, NULL, pthread_fun, NULL) &lt; 0) &#123; perror(\"fail to pthread_create \"); exit(1); &#125; while(1) &#123; count++; //pthread_mutex_lock(&amp;lock); value_1 = count; value_2 = count; //pthread_mutex_unlock(&amp;lock); &#125; pthread_join(pthread, NULL); return 0;&#125;测试结果： 加上互斥锁：[pthread_mutex.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;pthread_mutex_t lock;int value_1, value_2;void *pthread_fun(void * arg)&#123; while(1) &#123; pthread_mutex_lock(&amp;lock); if(value_1 == value_2) &#123; printf(\"value_1 = %d, value_2 = %d\\n\", value_1, value_2); &#125; pthread_mutex_unlock(&amp;lock); &#125;&#125;int main(int argc, const char *argv[])&#123; int count = 0; pthread_t pthread; if(pthread_mutex_init(&amp;lock, NULL) &lt; 0) &#123; perror(\"fail to pthread_mutex_init \"); exit(1); &#125; if(pthread_create(&amp;pthread, NULL, pthread_fun, NULL) &lt; 0) &#123; perror(\"fail to pthread_create \"); exit(1); &#125; while(1) &#123; count++; pthread_mutex_lock(&amp;lock); value_1 = count; value_2 = count; pthread_mutex_unlock(&amp;lock); &#125; pthread_join(pthread, NULL); return 0;&#125;测试结果：分析： 假如不加互斥锁，可能出现这种情况：主进程里将count赋值给value_1和value_2，此时value_1=value_2，线程里面的if(value_1 == value_2)通过了，这时线程的时间片用完，主进程执行count++和value_1 = count，此时主进程的时间片用完，线程继续执行，打印出value_1和value_2，就会发现value_1不等于value_2。 现在加上互斥锁，主进程count++,然后上锁，此时不能系统中断后续的count赋值给value_1和value_2，然后主线程再解锁。线程在if(value_1 == value_2)也上锁，保证后面的不被中断，打印出value_1和value_2，再解锁，整个过程，value_1一直value_2。 3.syns[pthread_syns.c]link1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;semaphore.h&gt;#define N 32char buf[N] = &#123;0&#125;;sem_t mysem;void *pthread_fun(void * arg)&#123; while(1) &#123; sem_wait(&amp;mysem); printf(\"--&gt; %s\\n\",buf); &#125;&#125;int main(int argc, const char *argv[])&#123; pthread_t tid; sem_init(&amp;mysem, 0, 0); if(pthread_create(&amp;tid, NULL, pthread_fun, NULL) != 0) &#123; perror(\"Unable to pthread_create\"); exit(1); &#125; while(1) &#123; fgets(buf, 32, stdin); sem_post(&amp;mysem); &#125; return 0;&#125; 测试结果：分析： 这里利用了信号同步。主线程调用fgets等待输入，输入完成后使用sem_post发送mysem信号，线程一直调用sem_wait等待信号，一旦信号到来，就打印出buf. 进程通信 条件变量： 定义：一个线程临界资源状态的变化，会通知另外一个线程去做相应的功能处理；条件变量跟互斥锁配合使用； 特点:具有阻塞功能、唤醒；为什么需要进程间通信？ 1、数据交互 2、共享资源 3、信号通知 4、同步或者互斥进程间通信方式介绍： 1、传统的进程间通信 无名管道、有名管道、信号通知 2、sytem V – IPC 共享内存、消息队列、信号量 前面六种只能用于单台的计算机中使用 3、套接字 1.kill[kill.c]link12345678910111213#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; if(kill(atoi(argv[1]), atoi(argv[2])) &lt; 0) &#123; perror(\"Unable to kill\"); exit(1); &#125; return 0;&#125; 测试结果：分析： kill()有两个参数，第一个是操作进程的PID，第二个是信号种类的编号。其中2是SIGINT结束进程，所以发送这个信号后，signal就打印hello world。结束进程。 2.raise[raise.c]link123456789101112131415#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; printf(\"hello wrold.\\n\"); if(raise(atoi(argv[1])) &lt; 0) &#123; perror(\"Unable to raise\"); exit(1); &#125;while(1); return 0;&#125; 测试结果：分析： raise()只能给自己发送信号，而且还不能发送SIGQUIT。这里raise自己发送SIGINT结束了自己。 3.signal12345678signal（int signum， sighandler_t handler）功能：信号响应函数参数：1. signum：信号种类中的一种，跟handler关联起来，执行相应的处理方式2. 忽略 SIG_IGN、 默认 SIG_DFL、 捕捉 --&gt;自己定义一个信号处理函数，类型跟sighandler_t的形式一致 把linux中已经定义好的62种信号中的一种信号跟linux传递给进程的信号signo做判断，看是那种信号，再做相应的处理 常用信号编号 种类 默认操作：结束进程2 SIGINT ctrl+c 结束进程3 SIGQUIT ctrl+\\ 结束进程9 SIGKILL 结束进程10 SIGUSR1 结束进程12 SIGUSR2 结束进程14 SIGALRM 结束进程19 SIGSTOP 暂停进程20 SIGTSTP ctrl+z 暂停进程注：SIGKILL 和SIGSTOP不能被忽略或者捕捉[signal.c]link12345678910111213141516171819202122#include &lt;signal.h&gt;#include &lt;stdio.h&gt;//signo代表内核相当前进程发送的信号时什么,而我们又不清楚时那个信号//需要用if语句做判断void fun(int signo)&#123; if(signo == SIGINT) &#123; printf(\"hello world \\n\"); &#125;&#125;int main(int argc, const char *argv[])&#123; //信号处理函数，本身不具有阻塞作用 //第一个参数： 要出里的信号是什么？62中的一种 //第二个参数： 三种相应方式： //忽略（SIG_IGN）、默认(SIG_DFL)、捕捉(用户自定义函数) signal(SIGINT, fun); pause(); return 0;&#125;测试结果：分析： 主函数调用signal安装信号，第一个参数指定了信号类型为按下CTRL+C产生，第二个为捕捉到信号后相应操作。然后信号的处理函数判断出信号类型后执行对应的操作。 pause()功能：引起调用进程进程阻塞，知道收到信号才会立即结束 4.alarm[alarm.c]link1234567891011121314151617#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; int ret = -1; ret = alarm(9); printf(\"ret = %d \\n\", ret); sleep(3); ret = alarm(10); printf(\"ret = %d \\n\", ret); pause(); printf(\"hello world \\n\"); //while(1); return 0;&#125; 测试结果：分析： 先给ret赋值个-1，然后调用alarm设置为9，因为之前没有设置过alarm，所以返回0.然后休眠3秒后，有赋值为10，此时返回的为6，即上次设置后剩下的时间9-3=6.然后程序调用pause挂起程序，直到10秒后，闹钟到了，发送SIGALRM信号结束进程。 5.pipe[pipe.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, const char *argv[])&#123; int fd[2]; pid_t pid; char buf[1024] = &#123;0&#125;; int count = 0; if(pipe(fd) &lt; 0) &#123; perror(\"Unable to pipe\"); exit(1); &#125;#if 1 pid = fork(); if(pid &lt; 0) &#123; perror(\"Unable to fork\"); exit(1); &#125; if(pid == 0) &#123;// printf(\"fd[0] = %d , fd[1] = %d \\n\", fd[0], fd[1]); while(1) &#123; read(fd[0], buf, 32);//如果管道中没有数据，读操作会阻塞 if(strncmp(buf, \"quit\", 4) == 0) break; printf(\"--&gt; %s \\n\", buf); &#125; &#125; else &#123;// printf(\"fd[0] = %d , fd[1] = %d \\n\", fd[0], fd[1]); while(1) &#123; fgets(buf, 32, stdin); write(fd[1], buf, strlen(buf) + 1); if(strncmp(buf, \"quit\", 4) == 0) break; &#125; wait(NULL); &#125;#endif#if 0 while(1) &#123;//如果缓冲区慢，则会阻塞在write函数 write(fd[1], buf, 1024); count++; if(count == 64) &#123; read(fd[0], buf, 1024); read(fd[0], buf, 1024); read(fd[0], buf, 1024); read(fd[0], buf, 1024); &#125; printf(\"count = %d \\n\", count); &#125;#endif close(fd[0]); write(fd[1], buf, 1024); return 0;&#125; 测试结果：分析： 这里创建一个管道完成进程间的通信，父进程负责写数据，子进程负责读数据。 首先是pipe()创建了一个管道，其中fd[0]是标准输入，fd[1]是标准输出。然后在fork()创建了个子进程。 父进程的工作：不断从键盘获得数据，存入buf。然后将buf数据写入fd[1]。如果收到“quit”字符即退出，调用wait()等待子进程结束。 子进程的工作：不断从fd[0]读取数据到buf，打印buf，如果遇到“quit”字符即退出。 管道的意义就是，连通了fb[0]和fb[1]，实现了进程间数据/信号的单向传输。 6.fifo[mkfifo_w.c]link123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#define N 32int main(int argc, const char *argv[])&#123; int fd_r, fd_w; size_t bytes = 0; char buf[N] = &#123;0&#125;; if(mkfifo(\"myfifo\", 0666) &lt; 0) &#123; perror(\"Unable to mkfifo\"); // exit(1); &#125; fd_w = open(\"myfifo\", O_WRONLY); if(fd_w &lt; 0) &#123; perror(\"Unable to open fd_w.\"); exit(1); &#125; printf(\"fifo write\\n\"); while(1) &#123; fgets(buf, 32, stdin); write(fd_w, buf, strlen(buf) + 1); if(strncmp(buf, \"quit\", 4) == 0) break; &#125; return 0;&#125; [mkfifo_r.c]link12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#define N 32int main(int argc, const char *argv[])&#123; int fd_r; size_t bytes = 0; char buf[N] = &#123;0&#125;; fd_r = open(\"myfifo\", O_RDONLY); if(fd_r &lt; 0) &#123; perror(\"Unable to open fd_r\"); exit(1); &#125; while(1) &#123; read(fd_r, buf, 32); if(strncmp(buf, \"quit\", 4) == 0) break; printf(\"--&gt; %s \\n\", buf); &#125; return 0;&#125; 测试结果：分析： FIFO的功能与管道差不多，但FIFO在文件系统中拥有一个名称，其打开方式和打开普通文件是一样的，这样就可以实现非相关的进程通信。 写入端/发送端：首先创建一个名叫“myfifo“，权限为666的FIFO。然后打开这个FIFO，不断从键盘获得数据写入FIFO里面，直到遇到”quit“退出。 读出端/接收端：打开同名FIFO，不断从中读取数据打印出来，直到遇到”quit“退出。 7.ftok[ftok.c]link1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; key_t key; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"Unable to ftok\"); exit(1); &#125; printf(\"key = %#x \\n\", key); return 0;&#125; 测试结果： 分析： 这里ftok应该是产生一个唯一的标识，因为路径是唯一的，对应的key有是唯一的。后面的IPC对象：共享内存、消息队列、信号灯，通过key找到内核对象。通过shell命令ipcs来查看对象信息。 编程框架：1、通过ftok函数得到key值，让不同的进程找到内核对象2、创建或者打开内核对象（共享内存、消息队列、信号灯集）3、操作内核对象 共享内存 ：通过shmat映射内核中的共享内存到用户空间， 解除映射shmdt，不能再操作共享内存。 消息队列：通过msgsnd发送消息，msgrcv接收消息4、删除内核对象 删除共享内存shmctl 删除消息队列msgctl 8.msg【1】消息队列机制1234特点： 1、先进先出 2、按照类型发送、读取消息 使用ipcs -q查看系统中的消息 【2】如何创建消息队列1234567msggetint msgget(key_t key, int msgflg);功能：创建或者打开消息队列key:让不同的进程找到同一个消息队列msgflg： IPC_CREAT | IPC_EXCL | 0666 创建 防止重复创建 权限 【3】发送消息/接收消息123456789101112131415161718192021结构体： struct msgbuf &#123; long mtype; /* message type, must be &gt; 0 */消息类型 char mtext[1]; /* message data */消息正文 &#125;;msgsnd/msgrcv:int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); 功能： msgid： 消息队列标示符 （用于操作消息队列发送或者接收消息） msgp：首先定义一个消息队列的结构体，类型如上所示结构体1 msgsz：消息队列正文（text）的大小 msgflg：设置为阻塞的方式0 非阻塞的方式 IPC_NOWAITssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); msgid： 消息队列标示符 （用于操作消息队列发送或者接收消息） msgp：首先定义一个消息队列的结构体，类型如上所示结构体1 msgsz：消息队列正文（text）的大小 msgtyp：消息的类型（必须是大于0的整数） msgflg：设置为阻塞的方式0 非阻塞的方式 IPC_NOWAIT 【4】控制(删除)消息队列msgctl1234 int msgctl(int msqid, int cmd, struct msqid_ds *buf); msgid： 消息队列标示符 （用于操作消息队列发送或者接收消息） cmd：操作消息队列的命令 IPC_STAT 获取消息队列属性信息的命令，需要定义一个struct msqid_ds结构体 [msg_w.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/msg.h&gt;struct msgbuf&#123; long type; char text[32];&#125;;#define MSG_SIZE (sizeof(struct msgbuf) - sizeof(long))int main(int argc, const char *argv[])&#123; key_t key; int msgid; struct msgbuf mymsg; char buf[32] = &#123;0&#125;; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"Unable to ftok\"); exit(1); &#125; msgid = msgget(key, IPC_CREAT | IPC_EXCL | 0666); if(msgid &lt; 0) &#123; if(errno == EEXIST) &#123; msgid = msgget(key, 0666); &#125; else &#123; perror(\"Unable to msgget\"); exit(1); &#125; &#125; system(\"ipcs -q\"); mymsg.type = 100; //strcpy(mymsg.text,\"hello world\"); while(1) &#123; fgets(buf, 32, stdin); strcpy(mymsg.text, buf); if(msgsnd(msgid, &amp;mymsg, MSG_SIZE, 0) &lt; 0) &#123; perror(\"Unable to msgsnd\"); exit(1); &#125; &#125; system(\"ipcs -q\"); return 0;&#125; [msg_r.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/msg.h&gt;#include &lt;string.h&gt;struct msgbuf&#123; long type; char text[32];&#125;;#define MSG_SIZE (sizeof(struct msgbuf) - sizeof(long))int main(int argc, const char *argv[])&#123; key_t key; int msgid; struct msgbuf mymsg; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"Unable to ftok\"); exit(1); &#125; msgid = msgget(key, IPC_CREAT | IPC_EXCL | 0666); if(msgid &lt; 0) &#123; if(errno == EEXIST) &#123; msgid = msgget(key, 0666); &#125; else &#123; perror(\"Unable to msgget\"); exit(1); &#125; &#125; while(1) &#123; if(msgrcv(msgid, &amp;mymsg, MSG_SIZE, 100, 0) &lt; 0) &#123; perror(\"Unable to msgsnd\"); exit(1); &#125; system(\"ipcs -q\"); printf(\"--&gt;%ld %s \\n\", mymsg.type, mymsg.text); &#125; if(msgctl(msgid, IPC_RMID, NULL) &lt; 0) &#123; perror(\"Unable to msgctl\"); exit(1); &#125; system(\"ipcs -q\"); return 0;&#125; 测试结果：分析： 消息队列是让进程以消息的形式交换数据。 写入端/发送端：定义一个消息msgbuf的结构体，其中一个是类型，一个是数据。调用ftok()创建唯一的key。调用msgget()创建或打开消息队列，调用shell显示当前的ipc中的消息队列信息。设置类型为100，不断从键盘获取数据复制到mymsg.text，并调用msgsnd()发送出去。 读出端/接收端：使用调用ftok()传入相同的参数，得到相同的key，调用msgget()打开同一个消息队列。调用msgcrv()接收消息，接收到则打印书类型和数据。后面的消息队列控制函数并没有调用到，第二个参数IPC_RMID表示立即删除队列消息。这里使用shell命令：ipcrm -q [msgid]手动删除。 9.sem[1]信号灯机制123信号量的集合（一个或者多个信号量，信号量是一类资源，资源的值代表了资源的数量） 实现同步：按照约定的先后顺序执行 互斥： 可以用两个信号量实现互斥操作 [2]打开或者创建信号灯semget123456789101112int semget(key_t key, int nsems, int semflg);功能：打开或者创建信号量参数 nsems： 信号量的数量是多少个？系统从0开始分配 举例：当nsems = 1则信号量是0 当nsems = 2则信号量分别是 0 和 1 当nsems = 3则信号量分别是 0 和 1 和 2 semflg：设置semget函数的功能： IPC_CREAT | IPC_EXCL | 0666 创建 防止重复创建 有效权限位返回值： 成功返回信号量操作表示符 失败 -1 [3]信号灯初始化semctl12345678910111213141516171819 int semctl(int semid, int semnum, int cmd, ...); 功能：信号量控制函数 参数： semnum 操作第几个信号量 举例 semnum 是 0，表示操作第0个信号量 举例 semnum 是 1，表示操作第1个信号量 cmd： 对信号量使用的命令 IPC_STAT 获取信号量的属性信息 SETVAL 初始化信号量的值，需要定义一个联合体 类型如下所示：union semun &#123; int val; /* Value for SETVAL */ struct semid_ds *buf;/* Buffer for IPC_STAT, IPC_SET */ unsigned short *array;/* Array for GETALL, SETALL */struct seminfo *__buf;/* Buffer for IPC_INFO(Linux-specific) */&#125;; …：表示参数不确定如果使用IPC_STAT、SETVAL命令，必须使用第四个参数定义一个联合体变量来接收如果定义IPC_RMID则不用使用第四个参数 [4]信号量操作方式123456789int semop(int semid, struct sembuf *sops, unsigned nsops); 功能：信号量的pv操作 sops：对信号量的操作方式 unsigned short sem_num; /* 第几个信号量*/ short sem_op; /* 信号量的PV操作,正数表示释放操作、负数表示申请操作 */ short sem_flg; /*0表示阻塞方式,IPC_NOWAIT表示非阻塞方式*/ nsops：表示操作几个信号量，从0开始 P申请操作 V释放操作 [sem_w.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/shm.h&gt;union semun&#123; int val;&#125;;int main(int argc, const char *argv[])&#123; key_t key; int semid; union semun mysem; struct sembuf mybuf; char buf1[32] = &#123;0&#125;; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"fail to ftok\"); exit(1); &#125; semid = semget(key, 2, IPC_CREAT | IPC_EXCL | 0666); if(semid &lt; 0) &#123; if(errno == EEXIST) semid = semget(key, 2, 0666); else &#123; perror(\"fail to semget\"); exit(1); &#125; &#125; else &#123; mysem.val = 0; semctl(semid, 0, SETVAL, mysem); mysem.val = 1; semctl(semid, 1, SETVAL, mysem); &#125; int shmid = shmget(key, 128, IPC_CREAT | 0666); if(shmid &lt; 0) &#123; if(errno == EEXIST) &#123; shmid = shmget(key, 128, 0666); &#125; else&#123; perror(\"fail to shmget\"); exit(1); &#125; &#125; char *buf = (char *)shmat(shmid, NULL, 0); if(buf == (char *)-1) &#123; perror(\"fail to shmat\"); exit(1); &#125; while(1) &#123; fgets(buf1, 32, stdin); mybuf.sem_num = 1; mybuf.sem_op = -1; mybuf.sem_flg = 0; semop(semid, &amp;mybuf, 1); strcpy(buf,buf1); mybuf.sem_num = 0; mybuf.sem_op = 1; mybuf.sem_flg = IPC_NOWAIT; semop(semid, &amp;mybuf, 1); &#125; system(\"ipcs -s\"); return 0;&#125; [sem_rw.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt;union semun&#123; int val;&#125;;int main(int argc, const char *argv[])&#123; key_t key; int semid; union semun mysem; struct sembuf mybuf; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"fail to ftok\"); exit(1); &#125; semid = semget(key, 2, IPC_CREAT | IPC_EXCL | 0666); if(semid &lt; 0) &#123; if(errno == EEXIST) semid = semget(key, 2, 0666); else &#123; perror(\"fail to semget\"); exit(1); &#125; &#125; else &#123; mysem.val = 0; semctl(semid, 0, SETVAL, mysem); mysem.val = 1; semctl(semid, 1, SETVAL, mysem); &#125; int shmid = shmget(key, 128, IPC_CREAT | 0666); if(shmid &lt; 0) &#123; if(errno == EEXIST) &#123; shmid = shmget(key, 128, 0666); &#125; else&#123; perror(\"fail to shmget\"); exit(1); &#125; &#125; char *buf = (char *)shmat(shmid, NULL, 0); if(buf == (char *)-1) &#123; perror(\"fail to shmat\"); exit(1); &#125; while(1) &#123; mybuf.sem_num = 0; mybuf.sem_op = -1; mybuf.sem_flg = 0; semop(semid, &amp;mybuf, 1); printf(\"--&gt; %s \\n\", buf); mybuf.sem_num = 1; mybuf.sem_op = 1; mybuf.sem_flg = IPC_NOWAIT; semop(semid, &amp;mybuf, 1); &#125; system(\"ipcs -s\"); return 0;&#125; 测试结果：分析： 信号量不是用来在进程间传输数据的，而是用来同步数据的。这里里共享内存为例，完成两个进程的同步。 写入端/发送端：首先调用ftok()创建唯一的key。调用semget ()创建或打开信号量集，其中第二个参数表示创建两个信号量。然后调用控制函数semctl()分别设置两个的值为0和1。然后创建一个共享内存，映射到用户空间，不断从键盘获得输入。mybuf.sem_num表示设置第1个信号量，mybuf.sem_op为负表示期望减，mybuf.sem_flg为0为阻塞，IPC_NOWAIT为非阻塞。然后在调用semop()进行设置刚才初始化的sembuf。即读去到数据则欲将第一个信号量减1。复制好后，再将第0个信号量欲加1. 读出端/接收端：前面部分都是对应的，在循环部分，先欲把第0个信号量减1，等打印完后，再欲把第1个信号量设置为1。 即整个流程，先信号量0和1分别为0和1。sem.w收到数据，则欲将第1个信号量减1，成功，继续执行执行strcpy()，然后将信号量0设置为1。这时sem.r中，之前欲将第0个参数减1，但为0，减不动，阻塞着，现在发现第0个信号量被设置为1，于是继续执行，打印了出来。然后设置第1个参数为1。这时，sem.w中刚走完一个循环，且收到了键盘数据，但现在第1个信号量是0，无法拷贝，现在发现第1个参数被设置为了1，于是又继续执行后续的拷贝和设置信号量。如此往复。 10.shm 共享内存：内核空间中的一块区域，由用户创建，系统维护里面的数据结构，通过获取到的描述符shmget的返回值，对共享内存进行操作； 特点： 1、高效，因为用户可以直接对内和对象进行操作，并不需要把数据在写到自己的用户空间里，在所有的进程间通信对象中是最快的。 注意： 1、映射，共享内存的映射，就是把共享内存段的地址传递给用户空间相应数据类型的指针变量。 2、同步和互斥：对共享内存进行循环操作的时候，容易出现一个进程在写操作的时候，另一个已经打读了好多次，为了能够完成写一次读一次操作，需要进行同步或者互斥。 步骤：【1】共享内存创建 1234567shmgetint shmget(key_t key, size_t size, int shmflg);功能： 创建或者打开共享内存key： 通过ftok函数返回，用于让不同的进程找到内核区域中的内核对象（共享内存）size：指定共享内存的大小，以字节为单位shmflg：指定创建的共享内存具有什么权限 IPC_CREAT | IPC_EXCL | ０６６６ 【2】映射共享内存1234567shmatvoid *shmat(int shmid, const void *shmaddr, int shmflg);功能：把内核空间的共享内存映射到用户空间，（因为用户空间根内核空间不能直接访问，所以通过映射的方式，简介得到这块共享内存地址）shmid:【操作】共享内存的表示符shmaddr： NULL有系统来分配一块共享内存shmflg： 0 【3】解除映射1shmdt 【4】删除共享内存12345678shmctlint shmctl(int shmid, int cmd, struct shmid_ds *buf);功能：共享内存对象控制函数通过命令，也就是第二个参数设置：IPC_STAT用来获取共享内存的一些属性信息IPC_RMID用来删除共享内存对象buf：用来存储共享内存的属性信息的，需要定义一个struct shmid_ds 的结构体 [shm_w.c]link1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/shm.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;int main(int argc, const char *argv[])&#123; key_t key; int shmid; char * ptr; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"Unable to ftok\"); exit(1); &#125; printf(\"key = %#x \\n\", key); shmid = shmget(key, 128, IPC_CREAT | IPC_EXCL | 0666); if(shmid &lt; 0) &#123; if(errno == EEXIST) &#123; shmid = shmget(key, 128, 0666); &#125; else &#123; perror(\"Unable to shmget\"); exit(1); &#125; &#125; if((ptr = shmat(shmid, NULL, 0)) == (char *)-1) &#123; perror(\"Unable to shmat\"); exit(1); &#125; strcpy(ptr, \"hello world\"); if(shmdt(ptr) &lt; 0) &#123; perror(\"Unable to shmdt\"); exit(1); &#125;#if 0 if(shmctl(shmid, IPC_RMID, NULL) &lt; 0) &#123; perror(\"Unable to shmctl\"); exit(1); &#125;#endif return 0;&#125; [shm_r.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/shm.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;int main(int argc, const char *argv[])&#123; key_t key; int shmid; char * ptr; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"Unable to ftok\"); exit(1); &#125; shmid = shmget(key, 128, IPC_CREAT | IPC_EXCL | 0666); if(shmid &lt; 0) &#123; if(errno == EEXIST) &#123; shmid = shmget(key, 128, 0666); &#125; else &#123; perror(\"Unable to shmget\"); exit(1); &#125; &#125; if((ptr = shmat(shmid, NULL, 0)) == (char *)-1) &#123; perror(\"Unable to shmat\"); exit(1); &#125; printf(\"--&gt; %s \\n\",ptr); if(shmdt(ptr) &lt; 0) &#123; perror(\"Unable to shmdt\"); exit(1); &#125; if(shmctl(shmid, IPC_RMID, NULL) &lt; 0) &#123; perror(\"Unable to shmctl\"); exit(1); &#125; return 0;&#125; 测试结果：分析： 写入端写入数据到共享内存，读取端读出并释放。 写入端/发送端：首先调用ftok()创建一个key，调用shmget()分配一个所需共享内存，得到shmid。然后调用shmat()再将内核中的共享内存映射到用户空间，最后调用strcpy()将“hello world“写入到这个空间，并释放用户空间。 读出端/接收端：使用调用ftok()传入相同的参数，得到相同的key，调用shmget也得到同样的shmid，再调用shmat()映射，打印出之前的数据。最后 调用shmdt()和shmctl()释放用户空间和内核空间。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux环境编程","slug":"Linux环境编程","permalink":"http://yoursite.com/tags/Linux环境编程/"}]},{"title":"Linux自动挂载/卸载U盘","date":"2017-04-22T03:10:55.000Z","path":"2017/04/22/Linux自动挂载卸载U盘/","text":"记录在mdev机制下不能自动卸载U盘的解决方法。 加载USB驱动有两种方式： 一是将模块编译到内核，再把新内核下载到开发板。 二是将驱动作为模块，内核启动后再加载驱动模块。 在主机中编译模块，在Linux中的/work/hceng/linux-3.4.2目录下执行：1$ make moudles 复制主机生成的drivers/usb/storage/usb-storage.ko到开发板中:1cp drivers/usb/storage/usb-storage.ko /work/hceng/nfs_rootfs 在开发板中，加载USB驱动模块：1$ insmod usb-storage.ko 然后在开发板插上U盘后，再手动挂载U盘即可访问数据:1$ mount /dev/sda1 /mnt 这里存在两个问题，一是需要手动加载usb-storage.ko，二是需要手动挂载U盘。 第一个问题通过将模块加载命令放在启动脚本里实现开机自动加载，/etc/init.d/rcS,加入如下命令：1insmod usb-storage.ko 第二个问题利用mdev机制进行自动挂载U盘，首先修改/etc/medv.conf，将下面代码加入行底：12sd[a-z][0-9] 0:0 666 @/etc/mdev/udisk_insert sd[a-z] 0:0 666 $/etc/mdev/udisk_remove 在/bin/hotplug.sh中把 “case $MDEV in”修改成如下：123456789case $MDEV insd[a-z][0-9]) DEVNAME=udisk MOUNTPOINT=/udisk ;;sda1) DEVNAME=udisk MOUNTPOINT=/udisk ;; 完成上面的设置后，U盘确实能够自动挂载，但拔U盘却不能自动卸载，这样会导致下次插入U盘相应的节点会自动增加，且访问原来的节点报错。 查阅相关资料并无解决方案，多次实验后，发现插上U盘后会自动在/sys/bus/usb/devices/1-1:1.0下生成U盘的信息文件，利用这一点进行检测U盘，在无奈的情况下写了个程序解决这个问题，代码如下：[usb.c]link1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*检查是否有U盘插上，没有则卸载一次/media/sda1，保证下次自动挂载U盘正常*//*定时器相关*/static int count = 0; static struct itimerval oldtv; static unsigned char usb_umount_ok = 0;void set_timer() &#123; struct itimerval itv; itv.it_interval.tv_sec = 1; itv.it_interval.tv_usec = 0; itv.it_value.tv_sec = 1; itv.it_value.tv_usec = 0; setitimer(ITIMER_REAL, &amp;itv, &amp;oldtv); &#125; /*查看/sys/bus/usb/devices/目录下是否有1-1，有则表示有U盘*/static unsigned int judge_usb(void) &#123; FILE *fd; fd = fopen(\"/sys/bus/usb/devices/1-1/version\",\"r\"); if(fd == NULL) return 0; else fclose(fd); usb_umount_ok = 0; return 1;&#125;/*检查usb是否拔出，从而确定是否卸载*/static void colse_usb(void)&#123; if(!judge_usb() &amp;&amp; usb_umount_ok==0) &#123; system(\"cd /;umount /media/sda1;rm -r /media/sd*;echo umount usb ok!\"); usb_umount_ok = 1; &#125; &#125;void signal_handler(int m) &#123; colse_usb(); &#125; int main(void)&#123; signal(SIGALRM, signal_handler); set_timer(); while(1); return 0;&#125; 编译后，运行测试，最后再放在上述启动脚本里：12arm-linux-gcc -o usb usb.c./app/usb&amp; 最后效果： 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"USB","slug":"USB","permalink":"http://yoursite.com/tags/USB/"}]},{"title":"自己写bootloader","date":"2017-04-13T00:35:55.000Z","path":"2017/04/13/自己写bootloader/","text":"参考写了个bootloader。 0.编写bootloader步骤 初始化硬件：关看门狗、设置时钟、设置SDRAM、初始化NAND FLASH; 因为bootloader比较大（大于4K），需要重定位到SDRAM; 把内核从NAND FLASH读到SDRAM; 设置“要传给内核的参数”; 跳转启动内核; 1.初始化硬件1.1 关看门狗[start.S]1234567.text.global _start_start:/* 1. 关看门狗 ：向寄存器WTCON(0x53000000)写0即可；P462；*/ ldr r0, =0x53000000 //将0x53000000放入r0； mov r1, #0 //将0放入r1中； str r1, [r0] //将r1中的0放入r0所指的存储器中； 1.2 设置时钟[start.S]1234567891011121314151617/* 2. 设置时钟：配置寄存器CLKDIVN(0x4C000014)设置分频；P260； */ ldr r0, =0x4c000014 mov r1, #0x05; //FCLK:HCLK:PCLK=1:4:8 str r1, [r0]/* 如果HDIVN非0，CPU的总线模式应设置为“asynchronous bus mode”;P244 */ mrc p15, 0, r1, c1, c0, 0 //读出控制寄存器； orr r1, r1, #0xc0000000 //设置为“asynchronous bus mode”； mcr p15, 0, r1, c1, c0, 0 //写入控制寄存器； /* 设置MPLLCON = S3C2440_MPLL_400MHZ; P256 */ ldr r0, =0x4c000004 ldr r1, =(0x5c&lt;&lt;12)|(0x01&lt;&lt;4)|(0x01) str r1, [r0] /*优化速度： 启动ICACHE */ mrc p15, 0, r0, c1, c0, 0 @ read control reg orr r0, r0, #(1&lt;&lt;12) mcr p15, 0, r0, c1, c0, 0 @ write it back 1.3 初始化SDRAM[start.S]12345678910111213141516171819202122232425 /*初始化SDRAM：依次向SDRAM寄存器 写入sdram_config中的值*/ ldr r0, = 0x48000000 //将SDRAM寄存器基地址写入r0； adr r1, sdram_config //将sdram_config的当前地址写入r1; add r3, r0, #(13*4) //r3=r0+13*4,即为SDRAM寄存器结尾地址；1: ldr r2, [r1], #4 //将r1寄存器的值放入r2，并将r1的地址+4; str r2, [r0], #4 //将r2的值写入r0，并将r0的地址+4; cmp r0, r3 //比较r0和r3，判断是否设置到了最后一个寄存器；bne 1b //不相等即没有设置完，跳到前面(b)的1处； … … … …sdram_config: //把要设置的值，存在这里；P56; .long 0x22011110 //BWSCON .long 0x00000700 //BANKCON0 .long 0x00000700 //BANKCON1 .long 0x00000700 //BANKCON2 .long 0x00000700 //BANKCON3 .long 0x00000700 //BANKCON4 .long 0x00000700 //BANKCON5 .long 0x00018005 //BANKCON6 .long 0x00018005 //BANKCON7 .long 0x008C04F4 //REFRESH .long 0x000000B1 //BANKSIZE .long 0x00000030 //MRSRB6 .long 0x00000030 //MRSRB7 2.重定位[start.S]123456789101112/*把bootloader本身的代码从flash复制到它的链接地址去*/ ldr sp, =0x34000000 //在调用C语言前，需要先设置栈，即SP指向一个地址；[1] bl nand_init //初始化nand flash；[2] mov r0, #0 //设置copy_code_to_sdram传入参数；参数1：r0=0； ldr r1, =_start //参数2：r1=_start； ldr r2, =__bss_start //r2=__bss_start sub r2, r2, r1 //参数3：r2=r2-r1 即除去_bss段的部分； bl copy_code_to_sdram //执行复制代码到SDRAM的函数；[3] bl clear_bss //执行清理_bss段函数；[4] [1]:为什么是0x34000000？ 栈是由上向下增加的，只要SP指向SDRAM最高处就行。 [2]:为何在这里初始化Nand Flash？ 不管后面的copy_code_to_sdram是Nand启动还是Nor启动，最后都会拷贝Nand上面的内核到SDRAM，所以早晚都得初始化。 [init.c]12345678void nand_init(void)&#123; #define TACLS 0 #define TWRPH0 1 #define TWRPH1 0 NFCONF = (TACLS&lt;&lt;12)|(TWRPH0&lt;&lt;8)|(TWRPH1&lt;&lt;4); //设置时序；P225; NFCONT = (1&lt;&lt;4)|(1&lt;&lt;1)|(1&lt;&lt;0); //使能NAND Flash控制器, 初始化ECC, 禁止片选；P226;&#125; [3]: copy_code_to_sdram具体实现？ start.S中的所有的C函数都在init.c中(除了最后的main)，copy_code_to_sdram()先判断是Nor启动还是Nand启动。 如果是Nor启动：由于Nor Flash特性（可以像内存一样读，但不能像内存一样写），直接复制上面的代码到SDRAM中的链接地址即可； 如果是Nand启动：2440上电后，硬件上将Nand上前4k拷贝到内部RAM中运行，这4k代码再将后续的整个代码拷贝到SDRAM中的链接地址。 [init.c]123456789101112131415161718//传入参数：*src源地址；*dest目的地地址；len数据长度；void copy_code_to_sdram(unsigned char *src, unsigned char *dest, unsigned int len)&#123; int i = 0; if (isBootFromNorFlash()) //如果是NOR启动； &#123; while (i &lt; len) //将len长度的数据，从源地址复制到目标地址上去； &#123; dest[i] = src[i]; i++; &#125; &#125; else &#123; nand_read((unsigned int)src, dest, len); //nand_read较麻烦，再后面介绍； &#125;&#125; 判断是Nand还是Nor：（利用Nor Flash可以像内存一样读，但不能像内存一样写的特性）[init.c]1234567891011121314151617int isBootFromNorFlash(void)&#123; volatile int *p = (volatile int *)0; int val; val = *p; //备份原来0地址的值； *p = 0x12345678; //向0地址写值； if (*p == 0x12345678) //判断是否写入成功； &#123; *p = val; //写成功, 是nand启动，恢复原来的值； return 0; &#125; else &#123; return 1; //NOR不能像内存一样写； &#125;&#125;Nand Flash结构：Nand Flash读操作：[init.c]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576void nand_read(unsigned int addr, unsigned char *buf, unsigned int len)&#123; int col = addr % 2048; int i = 0; /* 1. 选中 */ nand_select(); while (i &lt; len) &#123; /* 2. 发出读命令00h */ nand_cmd(0x00); /* 3. 发出地址(分5步发出) */ nand_addr(addr); /* 4. 发出读命令30h */ nand_cmd(0x30); /* 5. 判断状态 */ nand_wait_ready(); /* 6. 读数据 */ for (; (col &lt; 2048) &amp;&amp; (i &lt; len); col++) //处理没有从最左边开始的情况； &#123; buf[i] = nand_data(); i++; addr++; &#125; col = 0; &#125; /* 7. 取消选中 */ nand_deselect();&#125;/* nand_read 涉及的子函数*//* 1.选中Nand；P226*/ void nand_select(void)&#123; NFCONT &amp;= ~(1&lt;&lt;1); &#125;/* 2.取消选中Nand */ void nand_deselect(void)&#123; NFCONT |= (1&lt;&lt;1); &#125;/* 3.nand命令 */ void nand_cmd(unsigned char cmd)&#123; volatile int i; NFCMMD = cmd; for (i = 0; i &lt; 10; i++);&#125;/* 4.nand地址 */ void nand_addr(unsigned int addr)&#123; unsigned int col = addr % 2048; //对2k取余，得到列； unsigned int page = addr / 2048; //对2k取整，得到行； volatile int i; NFADDR = col &amp; 0xff; //列的7-0位； for (i = 0; i &lt; 10; i++); NFADDR = (col &gt;&gt; 8) &amp; 0xff; //列的15-8位； for (i = 0; i &lt; 10; i++); NFADDR = page &amp; 0xff; //行的7-0位； for (i = 0; i &lt; 10; i++); NFADDR = (page &gt;&gt; 8) &amp; 0xff; //行的15-8位； for (i = 0; i &lt; 10; i++); NFADDR = (page &gt;&gt; 16) &amp; 0xff; //行的23-16位； for (i = 0; i &lt; 10; i++); &#125;/* 5.等待读结束 */ void nand_wait_ready(void)&#123; while (!(NFSTAT &amp; 1));&#125;/* 6.nand数据 */ unsigned char nand_data(void)&#123; return NFDATA;&#125; 清理_bss段： 在start.S跳转到main前，还需要清理_bss段。_bss段存放的是未初始化的全局变量或者初始化为0的全局变量，用于处理可能过多0占用过多空间的情况。现在清0，后续要使用时，再赋0使用。[init.c]12345678void clear_bss(void)&#123; extern int __bss_start, __bss_end; //声明链接脚本的链接地址; int *p = &amp;__bss_start; for (; p &lt; &amp;__bss_end; p++) //以_bss_start开始，清理到_bss_end; *p = 0;&#125; 链接脚本：[boot.lds]123456789101112131415SECTIONS &#123; . = 0x33f80000; .text : &#123; *(.text) &#125; //代码段在0x33f80000，即链接地址，重定位后程序运行的地址； . = ALIGN(4); //四字节对齐（32位）； .rodata : &#123;*(.rodata*)&#125; //只读数据段 . = ALIGN(4); .data : &#123; *(.data) &#125; //数据段 . = ALIGN(4); __bss_start = .; //_bss开始 .bss : &#123; *(.bss) *(COMMON) &#125; __bss_end = .; //_bss结束&#125; 3.把内核读到SDRAM 前面start.S中调用init.c中的nand_init初始化了Nand Flahsh和写好了nand_read()函数。start.S最后跳到main函数中，而mian函数boot.c中。[boot.c]12/* 0. 帮内核设置串口: 内核启动的开始部分会从串口打印一些信息,但是内核一开始没有初始化串口 */ uart0_init(); //略，看相应章节设置；把内核读到SDRAM:[boot.c]12/* 1. 从NAND FLASH里把内核读入内存 */ nand_read(0x60000+64, (unsigned char *)0x30008000, 0x400000); 第一个参数：源地址：0x60000+64 Nand Flash一般分区情况如图，kernel设计的位置在0x60000，这里加64是因为内核格式为uImage，uImage结构是64字节头+zImage。 第二个参数：目的地址：0x3000 8000 即为Nand Flash的起始地址。 第三个参数：长度：0x200000 内核大小，后面内核大于2M，这里为0x4000 0000。 4.设置要传给内核的参数[boot.c]12345 /* 2. 设置参数 */ setup_start_tag(); setup_memory_tags(); setup_commandline_tag(\"noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0,115200 rootfstype=yaffs2\");setup_end_tag(); 主要分四部分：开始、内存信息、命令信息、结束。 5.跳转启动内核[boot.c]123/* 3. 跳转执行 */ theKernel = (void (*)(int, int, unsigned int))0x30008000; theKernel(0, 362, 0x30000100); 函数指针指向0x3000 8000,即指向内核位置，跳转到内核。theKernel()参数： 第一个参数：固定的0； 第二个参数：机器ID； 第三个参数：要传入给内核的参数位置； 6.测试相关源码参考：韦东山老师毕业班视频； 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"bootloader","slug":"bootloader","permalink":"http://yoursite.com/tags/bootloader/"}]},{"title":"软件癖","date":"2017-04-06T03:06:19.000Z","path":"2017/04/06/软件癖/","text":"软件“洁癖”。 折腾Windows久了，渐渐的对软件有了“洁癖”。带广告的要想办法去掉广告，有绿色版的要绿色版本优先，能精简的必须精简，收费的也无耻的去百度云找找，有功能限制一定要想办法去掉限制，有最新版的稳定情况下一定使用最新的。 经过时间的过滤，有些软件忍受住了我的“洁癖”，幸存了下来，他们有的堪称“神器”，有的良心无比让人敬佩。谨以此文感谢这些提高工作效率和创造安静的环境的软件，对作者深感敬佩。 Chrome:Windows端的主力浏览器，干净简洁的界面、强大的插件，一直在心中都是无可替代的存在。 SoureInsight:Windows端代码神器，最开始使用的时候是拒绝的，xp时代的审美风格，非常抵触，除去外观，实用性上无话可说，几乎成为每天必开的软件。最近升级到4.0，界面没什么大变化，功能上也少有眼前一亮的更新，站在顶端，难有进步。 OneNote:笔记软件神器，配合数位板手写笔记，神器中的神器。最近看Datasheet，手写笔迹注释，看英语都没那么排斥了，唯一不足是插入任何格式的文档，都是以图片的形式打印输出，查单词没戏了。 PowerPoint:估计是大学玩得最多的软件，几乎可以背到任何一个按钮的位置。上可配合Pr做视频，下可当Ps修图/做图。现在基本没做PPT，但作为做图神器，现在所有的平面图都是在这上面做，胜任了Ps和Visio的功能。 Adobe Acrobat DC:在尝试使用其他PDF查看软件后，最终还是觉得Adobe Acrobat DC是最好用的，所有对PDF的“遐想”，几乎都可以完成，比如：分割/合并PDF、添加页眉/页码、设置是导出PDF的表格到Excel，总是一种深藏不漏的感觉，只要是我能想到的，用心去找，总能找到解决方法。 WePE:这个真的是情怀，在那个以装系统为家常便饭的时光里，老毛桃带来的除了便利还有捆绑软件和绑定首页，尽管关掉了捆绑软件，绑定首页也是不能忍的。一直希望找到一个干净的PE，现在终于找到了，感谢UEPON。 Everything:积累的文件资料越来越多，时间久了，记不到放在哪了。Windows自带的搜索基本是废的，就没见到过进度条走完过。直到使用Everything才成功解决这一问题，现在使用，仍有那种不可思议的感觉。 huorong:一直都没怎么用过第三方的杀毒软件，Windows Defender基本够用了。出于对垃圾清理和流量状态显示的需求，在经历多种替代方案后，最终决定使用huorong，干净、简洁。我需要的功能都有，附加点可能需要的，我不想的绝对不要出现，挺符合要求的。 Bandzip:用了很久的好压，之前也没怎么1觉得有问题，后来有次发现Edeg首页被劫持了，最后发现是它搞的“鬼”。一直对2345这种门户网站没什么好感，这次算彻底失望了。Bandzip还是很不错的，除了干净，可以预览压缩包的图片，这个还是挺实用的。还有就是图标挺新鲜的。 Snipaste:平时基本使用Ctrl+Alt+Q的QQ截图，挺方便的，但有些小功能QQ没有，这个算互补，软件也很良心。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Linux并发控制机制","date":"2017-04-05T15:55:00.000Z","path":"2017/04/05/Linux并发控制/","text":"本文主要是简单记录下驱动中的并发控制。 1.并发控制 2.原子变量操作测试代码：[atomic_drv.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;linux/module.h&gt; #include &lt;linux/init.h&gt; #include &lt;asm/atomic.h&gt;//原子变量操作的头文件#include &lt;asm/bitops.h&gt;//原子位操作的头文件atomic_t a1 = ATOMIC_INIT(1);//定义和设置原子量；unsigned long int a2;//操作函数传入参数的数据类型是unsigned long int；static int test_drv_init(void)&#123; //测试原子变量操作： printk(\"test a1\\nKERN_INFO:atomic_read(): a1 = %d\\n\", a1); atomic_add(4, &amp;a1); printk(\"KERN_INFO:atomic_add(): a1 = %d\\n\", a1); atomic_dec(&amp;a1); printk(\"KERN_INFO:atomic_dec(): a1 = %d\\n\", a1); printk(\"KERN_INFO:atomic_dec_and_test(): judge_a1 = %d, new_a1 = %d\\n\",\\ atomic_dec_and_test(&amp;a1),atomic_read(&amp;a1)); //测试原子位操作： set_bit(0,&amp;a2);//设置a的0位为1; printk(\"test a2\\nKERN_INFO:set_bit(): a2 = %ld\\n\", a2); printk(\"KERN_INFO:test_and_clear_bit(): return_a2 = %d, new_a2 = %ld\\n\",\\ test_and_clear_bit(0, &amp;a2), a2); printk(\"KERN_INFO:test_and_set_bit(): return_a2 = %d, new_a2 = %ld\\n\",\\ test_and_set_bit(0, &amp;a2), a2); return 0;&#125;static void test_drv_exit(void)&#123; &#125;module_init(test_drv_init);module_exit(test_drv_exit);MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"hceng\"); MODULE_DESCRIPTION(\"Learn for atomic\"); 测试结果： 3.自旋锁测试代码：[lock_drv.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*设备驱动中，有些设备只允许打开一次，这里用count计数，lock对count进行保护*/#include &lt;linux/module.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_device.h&gt;#include &lt;linux/spinlock.h&gt;//自旋锁头文件static struct class *testdrv_class;static struct class_device *testdrv_class_dev;int count = 0 ;spinlock_t lock;static int test_drv_open(struct inode *inode, struct file *file)&#123; spin_lock(&amp;lock); if(count) &#123; spin_unlock(&amp;lock); printk(\"kernel: open fail! count = %d\\n\",count); return -EBUSY; &#125; count++; spin_unlock(&amp;lock); printk(\"kernel: open ok! count = %d\\n\",count); return 0;&#125;static int test_drv_release(struct inode *inode, struct file *file)&#123; spin_lock(&amp;lock); count--; spin_unlock(&amp;lock); printk(\"kernel: release ok! count = %d\\n\",count); return 0;&#125;static struct file_operations test_drv_fops = &#123; .owner = THIS_MODULE, .open = test_drv_open, .release = test_drv_release, &#125;;int major;static int test_drv_init(void)&#123; major = register_chrdev(0, \"test_drv\", &amp;test_drv_fops); testdrv_class = class_create(THIS_MODULE, \"testdrv\"); testdrv_class_dev = device_create(testdrv_class, NULL, MKDEV(major, 0), NULL, \"locktest\"); spin_lock_init(&amp;lock); printk(\"kernel: init ok!\\n\"); return 0;&#125;static void test_drv_exit(void)&#123; unregister_chrdev(major, \"test_drv\"); device_destroy(testdrv_class, MKDEV(major, 0)); class_destroy(testdrv_class); printk(\"kernel: exit ok!\\n\");&#125;module_init(test_drv_init);module_exit(test_drv_exit);MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"hceng\"); MODULE_DESCRIPTION(\"Learn for lock\");[lock_test.c]link123456789101112131415161718192021#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; int fd; fd = open(\"/dev/locktest\", O_RDWR); if (fd &lt; 0) &#123; printf(\"app: can't open!\\n\"); &#125; else printf(\"app: open ok!\\n\"); while(1); return 0;&#125; 测试结果： 4.信号量[semaphore_drv.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/*设备驱动中，有些资源只能被单一进程访问，这里用sem确保单一访问*/#include &lt;linux/module.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_device.h&gt;#include &lt;linux/semaphore.h&gt;//信号量头文件static struct class *testdrv_class;static struct class_device *testdrv_class_dev;struct semaphore sem;static int test_drv_open(struct inode *inode, struct file *file)&#123; printk(\"kernel:down before sem.count = %d \\n\", sem.count); down(&amp;sem); /*临界资源*/ printk(\"kernel:down after sem.count = %d \\n\", sem.count); return 0;&#125;static int test_drv_release(struct inode *inode, struct file *file)&#123; printk(\"kernel:up before sem.count = %d \\n\", sem.count); up(&amp;sem); printk(\"kernel:up after sem.count = %d \\n\", sem.count); return 0;&#125;static struct file_operations test_drv_fops = &#123; .owner = THIS_MODULE, .open = test_drv_open, .release = test_drv_release, &#125;;int major;static int test_drv_init(void)&#123; major = register_chrdev(0, \"test_drv\", &amp;test_drv_fops); testdrv_class = class_create(THIS_MODULE, \"testdrv\"); testdrv_class_dev = device_create(testdrv_class, NULL, MKDEV(major, 0), NULL, \"semaphoretest\"); sema_init(&amp;sem, 2);//允许同时2个进程访问临界资源 printk(\"kernel: init ok!\\n\"); return 0;&#125;static void test_drv_exit(void)&#123; unregister_chrdev(major, \"test_drv\"); device_destroy(testdrv_class, MKDEV(major, 0)); class_destroy(testdrv_class); printk(\"kernel: exit ok!\\n\");&#125;module_init(test_drv_init);module_exit(test_drv_exit);MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"hceng\"); MODULE_DESCRIPTION(\"Learn for semaphore\"); [semaphore_test.c]link123456789101112131415161718192021#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; int fd; fd = open(\"/dev/semaphoretest\", O_RDWR); if (fd &lt; 0) &#123; printf(\"app: can't open!\\n\"); &#125; else printf(\"app: open ok!\\n\"); while(1); return 0;&#125; 测试结果： 5.完成量 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"}]},{"title":"从0到Q系列之三（Linux内核结构及移植）","date":"2017-04-01T09:12:00.000Z","path":"2017/04/01/从0到Q系列之三（Linux内核结构及移植）/","text":"该系列主要是为驱动学习提供基石，从0到Qt。本文是该系列的第三篇:对Linux内核的结构进行分析及移植内核. 毕业设计原因，暂停更，其它不变。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/环境搭建/"}]},{"title":"终端复用软件-Tmux","date":"2017-03-31T11:50:00.000Z","path":"2017/03/31/终端复用软件——Tmux/","text":"本文主要记录终端复用软件——Tmux的简单使用。 Tmux是一个可以把终端分屏的软件，最开始知道这货是在酷安下了Termux，酷安大佬们真会完，刷Termu下面的评论中看到了Tmux，觉得还挺好玩的。最近Linux终端用得比较多，尝试安装玩玩，记录下。 1.安装tmux在ubuntu终端中，使用以下命令安装：1$ sudo apt-get install tmux 2.基本使用Tmux为了不和其它软件的快捷键影响，所以它的命令全要加前缀Ctrl+b后再操作，例如新建个窗口的操作步骤： 按下组合键 Ctrl+b; 放开组合键 Ctrl+b; 按下 c 键; Tmux的操作很多，这里我只记录几个我常用的，后续自己有需求再增加： 功能 前缀操作 组合键 创建新窗口 Ctrl+b-&gt;松开 c 水平划分窗口 Ctrl+b-&gt;松开 “ 垂直划分窗口 Ctrl+b-&gt;松开 % 调整窗口大小 Ctrl+b-&gt;不松住 方向键 切换窗口 Ctrl+b-&gt;松开 方向键 显示窗口标号 Ctrl+b-&gt;松开 q 关闭窗口 Ctrl+b-&gt;松开 x-&gt;y 关闭Tmux Ctrl+b-&gt;松开 &amp;-&gt;y 3.其它优化美化的话参考后面给的博客链接，这里我只美化了底边状态栏：进入home目录，新建.tmux.conf12$ cd ~$ vi ~/.tmux.conf加入以下代码： 12345678910111213141516171819# 状态栏# 颜色set -g status-bg blackset -g status-fg white # 对齐方式set-option -g status-justify centre # 左下角set-option -g status-left &apos;#[bg=black,fg=green][#[fg=cyan]#S#[fg=green]]&apos;set-option -g status-left-length 20 # 窗口列表setw -g automatic-rename onset-window-option -g window-status-format &apos;#[dim]#I:#[default]#W#[fg=grey,dim]&apos;set-window-option -g window-status-current-format &apos;#[fg=cyan,bold]#I#[fg=blue]:#[fg=cyan]#W#[fg=dim]&apos; # 右下角set -g status-right &apos;#[fg=green][#[fg=cyan]%Y-%m-%d#[fg=green]]&apos; 最终效果图： 参考博客：Tmux 速成教程：技巧和调整Tmux简单教程 最后修改时间：2017/3/31 19:51:36 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux基础/"}]},{"title":"从0到Q系列之二（U-Boot分析及移植）","date":"2017-03-26T10:39:00.000Z","path":"2017/03/26/从0到Q系列之二（U-Boot分析及移植）/","text":"该系列主要是为驱动学习提供基石，从0到Qt。本文是该系列的第二篇:对U-Boot进行分析及移植. 1.U-Boot结构分析Bootloader一般可以分成两个阶段： 第一个阶段通常使用汇编进行必要的硬件初始化，例如：关看门狗、关中断、设置时钟频率、RAM初始化等。除此之外，还要将第二阶段的代码复制到RAM中，设置好栈，然后跳到第二阶段，该阶段主要是与SOC平台相关。 第二阶段一般是用c语言编写，该阶段主要和开发板板载资源相关。该阶段主要初始化后续的硬件，处理内存映射、以及将内核和根文件系统从Flash“搬运”到RAM中运行，然后传入启动参数，最后启动引导内核，完成使命。 Linux中系统一般的分区结构，如下图： 分区主要分为四个分区：Bootloader、Boot parameters、Kernel、Root filesystem。其中Boot parameters是待传入内核的参数，Kernel即内核、Root filesystem是根文件系统。Bootloader在第一个分区(假设该储存介质为Nand Flash)，则在Nand Flash的地址为0x0000 0000，S3C2440上电后，硬件自动把Nand Flash上前4k代码复杂到自己内部RAM中运行。该4k代码先要初始化一些必要的硬件，如看门狗，中断等，然后准备好SRAM，并将后续的代码复制到SDRAM中，再跳到SDRAM中运行，完成Bootloader第一阶段。此时在SDRAM中的第二阶段代码开始工作，首先还是初始化硬件，处理内存映射，把Nand Flash上内核和根文件系统“搬运”到SDRAM准备运行，然后根据用户通过串口传入的启动参数放在Boot parameters，然后内核启动，完成使命。内核启动后，开始去Boot parameters寻找启动参数，根据启动参数做出相应的操作，如：控制台输出、串口波特率、根文件系统位置。 2.U-Boot源码分析 这里根据u-boot-1.1.6的源码进行分析，，主要工作有： 第一阶段的硬件初始化(CPU模式、看门狗、中断) 准备SDRAM 设置堆栈 搬运FLASH中的代码到SDRAM 清除.bss段并跳转至第二阶段 第二阶段的硬件初始化（时钟、串口） 内存映射 根据传入参数启动内核 2.1第一阶段 该阶段的源码在/arch/cpu/arm920t/start.S中：首先进行硬件初始化，包括设置CPU模式，关闭看门狗、关闭中断。这里把时钟配置放在了第二阶段。 设置CPU模式 把CPU设置为SVC模式，将当前程序状态计数器CPSR的值保存到r0中，利用bic指令清除r0的0x1f并存入r0中，再利用orr指令或运算上0xd3并存入r0，最后r0写回CPSR,这一过程就把CPSR设置为SVC模式：[start.S]123456reset:/* set the cpu to SVC32 mode*/ mrs r0,cpsr bic r0,r0,#0x1f orr r0,r0,#0xd3 msr cpsr,r0 设置看门狗和关闭中断 根据S3C2440的datasheet，将0x00写入pWTCON对应寄存器的地址，完成看门狗的关闭。中断部分也类似，将INTMSK寄存器设置为0xffff ffff即可：[start.S]12345678910111213/* turn off the watchdog */# define pWTCON 0x53000000# define INTMOD 0X4A000004# define INTMSK 0x4A000008 /* Interupt-Controller base addresses */# define INTSUBMSK 0x4A00001C# define CLKDIVN 0x4C000014 /* clock divisor register */ ldr r0, =pWTCON mov r1, #0x0 str r1, [r0]/* turn off the int */ ldr r1, =0x3ff ldr r0, =INTSUBMSK str r1, [r0] 准备SDRAMstart.S中没有初始化SDRAM，而是先跳转到函数cpu_init_crit中，再跳转至lowlevel_init.S中进行初始化SDRAM。adr是一个位置无关指令，将_start的地址读取到r0中，上电后，Flash中的前4k就被拷到S3C2440内部RAM，则这里r0=0。然后再用ldr指令将_TEXT_BASE这个地址（来自链接脚本，代表运行地址）的值放在r1中。然后比较r0和r1的值，如果是相等的，那么证明这个时候代码已经位于了其应该位于的地方，这个时候就不再需要初始化SDRAM去重定位了。如果r1和r0的值不相等，那么将直接跳转cpu_init_crit中。[start.S]1234adr r0, _start /* r0 &lt;- current position of code */ldr r1, _TEXT_BASE /* test if we run from flash or RAM */cmp r0, r1 /* don&apos;t reloc during debug */blne cpu_init_crit [start.S]12345678910111213141516171819202122cpu_init_crit: /*flush v4 I/D caches*/ mov r0, #0 mcr p15, 0, r0, c7, c7, 0 /* flush v3/v4 cache */ mcr p15, 0, r0, c8, c7, 0 /* flush v4 TLB */ /*disable MMU stuff and caches*/ mrc p15, 0, r0, c1, c0, 0 bic r0, r0, #0x00002300 @ clear bits 13, 9:8 (--V- --RS) bic r0, r0, #0x00000087 @ clear bits 7, 2:0 (B--- -CAM) orr r0, r0, #0x00000002 @ set bit 2 (A) Align orr r0, r0, #0x00001000 @ set bit 12 (I) I-Cache mcr p15, 0, r0, c1, c0, 0 /* * before relocating, we have to setup RAM timing * because memory timing is board-dependend, you will * find a lowlevel_init.S in your board directory. */ mov ip, lr bl lowlevel_init mov lr, ip 设置栈 通常为了保存调用C语言时传递参数和保存CPU运行时的现场，需要设置栈，根据定义_TEXT_BASED为代码段的开始地址，然后在代码段的下面留出一段内存实现malloc和全局参数，再留出一点给中断模式的栈和abort异常的栈，剩下的就是栈了：[start.S]12345678910/* Set up the stack */stack_setup: ldr r0, _TEXT_BASE /* upper 128 KiB: relocated uboot */ sub r0, r0, #CFG_MALLOC_LEN /* malloc area */ sub r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo */#ifdef CONFIG_USE_IRQ sub r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)#endif sub sp, r0, #12 /* leave 3 words for abort-stack */ 搬运FLASH中的代码到SDRAM 现在将Bootloader的全部代码复制到RAM中运行： [lowlevel_init.S]1234567891011121314151617relocate: /* relocate U-Boot to RAM */ adr r0, _start /* r0 &lt;- current position of code */ ldr r1, _TEXT_BASE /* test if we run from flash or RAM */ cmp r0, r1 /* don&apos;t reloc during debug */ beq clear_bss ldr r2, _armboot_start ldr r3, _bss_start sub r2, r3, r2 /* r2 &lt;- size of armboot */ bl CopyCode2Ram /* r0: source, r1: dest, r2: size */copy_loop: ldmia r0!, &#123;r3-r10&#125; /* copy from source address [r0] */ stmia r1!, &#123;r3-r10&#125; /* copy to target address [r1] */ cmp r0, r2 /* until source end addreee [r2] */ ble copy_loop 清除.bss段并跳转至第二阶段 bss段部分保存有静态变量、没有初始化或初始化值为0的全局变量，为了减小体积和防止程序在读取它们时，读取的时上次的值，所以需要先清0： [start.S]12345678910clear_bss: ldr r0, _bss_start /* find start of bss segment */ ldr r1, _bss_end /* stop here */ mov r2, #0x00000000 /* clear */clbss_l:str r2, [r0] /* clear loop... */ add r0, r0, #4 cmp r0, r1 ble clbss_lldr pc, _start_armboot 2.2第二阶段 第二阶段的代码在lib_arm/board.c中的start_armboot()函数开始，在内部调用各自函数进行设置： 设置时钟[smdk2410.c]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int board_init (void)&#123; S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER(); S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO(); /* to reduce PLL lock time, adjust the LOCKTIME register */ clk_power-&gt;LOCKTIME = 0xFFFFFF; /* configure MPLL */ clk_power-&gt;MPLLCON = ((M_MDIV &lt;&lt; 12) + (M_PDIV &lt;&lt; 4) + M_SDIV); /* some delay between MPLL and UPLL */ delay (4000); /* configure UPLL */ clk_power-&gt;UPLLCON = ((U_M_MDIV &lt;&lt; 12) + (U_M_PDIV &lt;&lt; 4) + U_M_SDIV); /* some delay between MPLL and UPLL */ delay (8000); /* set up the I/O ports */ gpio-&gt;GPACON = 0x007FFFFF; gpio-&gt;GPBCON = 0x00044555; gpio-&gt;GPBUP = 0x000007FF; gpio-&gt;GPCCON = 0xAAAAAAAA; gpio-&gt;GPCUP = 0x0000FFFF; gpio-&gt;GPDCON = 0xAAAAAAAA; gpio-&gt;GPDUP = 0x0000FFFF; gpio-&gt;GPECON = 0xAAAAAAAA; gpio-&gt;GPEUP = 0x0000FFFF; gpio-&gt;GPFCON = 0x000055AA; gpio-&gt;GPFUP = 0x000000FF; gpio-&gt;GPGCON = 0xFF95FFBA; gpio-&gt;GPGUP = 0x0000FFFF; gpio-&gt;GPHCON = 0x002AFAAA; gpio-&gt;GPHUP = 0x000007FF; /* arch number of SMDK2410-Board */ gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE_SMDK2410; /* adress of boot parameters */ gd-&gt;bd-&gt;bi_boot_params = 0x30000100; icache_enable(); dcache_enable(); return 0;&#125; 初始化串口[serial.c]1234567891011121314151617181920int serial_init (void)&#123; serial_setbrg (); return (0);&#125;/* * Read a single byte from the serial port. Returns 1 on success, 0 * otherwise. When the function is succesfull, the character read is * written into its argument c. */int serial_getc (void)&#123; S3C24X0_UART * const uart = S3C24X0_GetBase_UART(UART_NR); /* wait for character to arrive */ while (!(uart-&gt;UTRSTAT &amp; 0x1)); return uart-&gt;URXH &amp; 0xff;&#125; 监内存映射 在smdk2410.c里的函数dram_init中设置的内存起始地址为0x3000 0000,大小为0x4000 0000:[smdk2410.c]1234567int dram_init (void)&#123; gd-&gt;bd-&gt;bi_dram[0].start = PHYS_SDRAM_1; gd-&gt;bd-&gt;bi_dram[0].size = PHYS_SDRAM_1_SIZE; return 0;&#125; 至此，U-Boot的启动过程基本分析完了，在启动U-Boot后，通过lib_arm/armlinux.c中的do_boot_linux来启动内核。这里总结画个图来记录下，中间的顺序可能有点小差异，但大致没问题：3.U-Boot移植待补充。4.U-Boot使用记录下平时使用U-Boot烧写内核/根文件系统和挂载根文件系统，这里假设如下： Ubuntu中待作为nfs挂载的路径：/work/hceng/nfs_rootfsUbuntu IP：192.168.1.141开发板 IP：192.168.1.142网关 IP：192.168.1.1 这里要提前在Ubuntu虚拟机中进行NFS配置，参考上一篇文章中的：2.3安装、 配置网络服务； 启动U-Boot后，迅速按任意键进入U-Boot的下载模式，再输入”q”退出菜单。 设置开发板ip和nfs挂载的服务ip： 123setenv serverip 192.168.1.141 //设置服务器ubuntu ipsetenv ipaddr 192.168.1.142 //设置开发板ipsaveenv 设置u-boot各分区大小（内核也要相应设置匹配，在Linux-3.4.2内核中，文件在arch/arm/mach-s3c24xx/common-smdk.c中）: 12setenv mtdparts mtdparts=nandflash0:256k@0(bootloader),128k(params),4m(kernel),-(root)saveenv 下载、擦除、烧写内核： 123nfs 30000000 192.168.1.141:/work/hceng/nfs_rootfs/uImagenand erase kernelnand write.jffs2 30000000 kernel 下载、擦除、烧写根文件系统： 123nfs 30000000 192.168.1.141:/work/hceng/nfs_rootfs/fs_mini_mdev_new.yaffs2nand erase rootnand write.yaffs 30000000 4a0000 $(filesize) 根文件系统采用nand启动： 12set bootargs noinitrd root=/dev/mtdblock3 rootfstype=yaffs2 init=/linuxrc console=ttySAC0,115200saveenv 启动后，对应的NFS挂载： 1mount -t nfs 192.168.1.141:/work/hceng/nfs_rootfs /tmp 根文件系统采用nfs启动： 12set bootargs root=/dev/nfs nfsroot=192.168.1.141:/work/hceng/nfs_rootfs ip=192.168.1.142:192.168.1.141:192.168.1.1:255.255.255.0::eth0:off init=/linuxrc console=ttySAC0,115200 saveenv 最后启动：1boot 最后修改时间：2017/4/1 17:06:08 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/环境搭建/"}]},{"title":"从0到Q系列之一（开发环境搭建）","date":"2017-03-23T09:19:00.000Z","path":"2017/03/23/从0到Q系列之一（开发环境搭建）/","text":"该系列主要是为驱动学习提供基石，从0到Qt。本文是该系列的第一篇:在Ubuntu-16.04LTS上搭建好开发环境. 所需材料： 虚拟机：VMware-workstation-full-12.0.0-2985596.exe Ubuntu系统镜像：ubuntu-16.04.1-desktop-amd64.iso 交叉工具链：arm-linux-gcc-4.4.3.tar.gz 安装脚本：install-devel-packages.sh或install-devel-packages-for-16.sh 1.安装Ubuntu-16.04.1 打开安装好的虚拟机，选择创建新的虚拟机： 选择典型配置： 选择浏览找到ubuntu-16.04.1-desktop-amd64.iso并选中： 填入用户名、密码（本机密码：123456）： 设置虚拟机名称和保存路径： 设置虚拟机最大容量（60G差不多了）： 在弹出的向导中选择自定义硬件，设置内存、CPU、网络： 等待一会后，安装完毕，输入之前设置的密码进入系统： 点左上角的Ubuntu搜索图标，，输入t，将出现的Terminal控制台： 2.安装、配置必要软件2.1检查虚拟机网络设置 打开编辑-&gt;虚拟网络编辑器： 更改设置： 检查这三个配置： 输入ifconfig查看网络配置，再ping www.baidu.com测试： 2.2修改软件源 首先备份原来的文件：1$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup 用vi编辑器打开编辑：1$ sudo vi /etc/apt/sources.list 删掉文件中的所有内容，替换为以下文本：123456789101112131415161718# deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricteddeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse 注： 此时vi是不完全版的，很难用，编辑模式下方向键是乱的，使用gedit打开编辑，后面再更新vi：1$ sudo gedit /etc/apt/sources.list 此时Ubuntu默认装了VMware Tools，可以复制windows下的文本，然后ctrl+shift+v在Ubuntu里面粘贴文本。也支持windows里文件和Ubuntu的直接拖拽复制。 完成上面的修改后，再更新软件列表和安装完整的vim：12$ sudo apt-get update$ sudo apt-get install vim 安装过程中根据提示输入yes确认，下同。 2.3安装、 配置网络服务 执行以下命令安装 ftp、ssh、nfs服务：1$ sudo apt-get install vsftpd openssh-server nfs-kernel-server portmap 配置 FTP 服务：修改 vsftpd 的配置文件/etc/vsftpd.conf，检查下面两行前面的“#”号是否去掉。第28行，默认没有#：1local_enable=YES 第31行，默认有#，去掉#：1# write_enable=YES 注： 上面第一个表示是否允许本地用户登录，第二行个示是否允许上传文件。 在vim的命令模式输入如下命令即可显示行号：1:set nu 修改完华之后，执行以下命令重启 ftp 服务：1$ sudo /etc/init.d/vsftpd restart 配置 NFS 服务修改/etc/exports，增加以下内容，以后开发板可以通过网络文件系统访问/work 目录和专门用来作为根文件系统挂载的/work/hceng/nfs_rootfs目录： 12/work *(rw,sync,no_root_squash,no_subtree_check)/work/hceng/nfs_rootfs *(rw,sync,no_root_squash,no_subtree_check) 修改完华之后，执行以下命令重启 nfs 服务： 1$ sudo /etc/init.d/nfs-kernel-server restart 最后，关闭Ubuntu的防火墙：1$ sudo ufw disable 4.安装基本开发环境： 这里使用韦东山老师第四期安卓视频环境搭建提供的脚本，这个脚本会自动安装诸如 g++等工具、 库。但该脚本是为Ubuntu12制作的，Ubuntu16使用需要做一些修改，主要是名字变了。修改变化如下：1libgl1-mesa-glx-lts-quantal:i386 libgl1-mesa-dev-lts-quantal \\ 改为：1libgl1-mesa-glx-lts-xenial:i386 libgl1-mesa-dev-lts-xenial \\ 将修改后的脚本文件改为：install-devel-packages-for-16.sh 拖拽到自己建的/work/tool里面，加入可执行权限，然后执行：12$ sudo chmod +x install-devel-packages-for-16.sh$ sudo ./install-devel-packages-for-16.sh 然后报错,提示差mingw32： 解决：在源中加入如下部分：1deb http://cz.archive.ubuntu.com/ubuntu trusty main universe 再更新列表，再执行就没问题了：12$ sudo apt-get update$ sudo ./install-devel-packages-for-16.sh 3.安装基本开发环境 这里使用arm-linux-gcc-4.4.3.tar.gz，之前用的4.5出了问题，换成这个就好了，暂时用这个版本。把文件拖进/work/tool，解压到根目录：1$ sudo tar xzf arm-linux-gcc-4.4.3.tar.gz –C / 再修改环境变量： 1$ sudo vim /etc/ environment 把工具链目录添加到最后，内容如下： 1PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/opt/FriendlyARM/toolschain/4.4.3/bin&quot; 重启Ubuntu，输入如下命令检测是否正常： 1$ arm-linux-gcc –v 至此，开发环境以基本搭建完成。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/环境搭建/"}]},{"title":"设备驱动模型","date":"2017-03-18T15:44:00.000Z","path":"2017/03/18/设备驱动模型/","text":"最近在看设备驱动模型，记录下分析的结构。 设备驱动模型提供了硬件的抽象，内核可以使用该抽象完成很多硬件重复的工作，这样很多重复的代码就不需要重复编写和调试了。这些抽象包括：电源管理、即插即用设备的支持、与用户空间的通信。 1.sysfs文件系统 sysfs文件系统是Linux众多文件系统中的一个，在Linux中每个文件系统都要自己的特殊的用途。Liunx设备驱动模型由大量的数据结构和算法组成，数据结构之间通过指针相互关联，构成树形或者网状关系。显示这种关系最好的利用树形结构的文件系统，同时还要显示内核中一些关于设备、驱动和驱动的信息，因此内核开发者创造sysfs这种新文件系统来实现上述的要求。 sysfs是一个只存在于内存的文件系统，内核通过这个文件系统将系统信息导出到用户空间，同时用户空间的数据也能通过它传到内核中，实现设置驱动程序的状态和属性。 sysfs文件系统是内核对象（kobject）、属性（kobj_type）及它们互相关系的一种表现机制。内核与sysfs的关系如下： Linux内核中的结构 sysfs中的结构 kobject 目录 kobj_type 属性文件 对象间的关系 符号链接 2.核心数据结构 设备驱动模式由kobject、kset、subsystem这三个核心数据结构组成。 2.1 kobject 在Linux系统中，kobject结构体是组成设备驱动模型的基本结构，提供最基本的设备对象管理能力，每个在内核注册的kobject对象都对应sysfs文件系统中的一个目录。 kobject结构体：1234567891011121314struct kobject &#123; const char *name; /* 对应sysfs的目录名 */ struct list_head entry; /* kobjetct双向链表 ,指向下一个kobject结构*/ struct kobject *parent; /* 指向kset中的kobject，相当于指向父目录 */ struct kset *kset; /*指向所属的kset */ struct kobj_type *ktype; /*指向kobject的类型描述符*/ struct sysfs_dirent *sd; /*对应的sysfs文件目录*/ struct kref kref; /*kobject引用计数，为0释放*/ unsigned int state_initialized:1; /*kobject是否已初始化，1初0未*/ unsigned int state_in_sysfs:1 ; /*kobject是否注册到sysfs*/ unsigned int state_add_uevent_sent:1; unsigned int state_remove_uevent_sent:1; unsigned int uevent_suppress:1;&#125;; kobject操作函数： 2.2 kset kobject通过kset组织层次化，kest是拥有相同类型的kobject的集合。 kset结构体：123456struct kset &#123; struct list_head list; /* 连接所包含的kobject对象的链表头部 */ spinlock_t list_lock; /* 添加/删除kobject时使用的自旋锁 */ struct kobject kobj; /*所有属于该kset的kobject的parent均指向这 */ const struct kset_uevent_ops *uevent_ops; /* 热拔插事件函数集 */&#125;; kset操作函数： kest和kobject关系： 2.3 注册kobject到sysfs中的实例[kobject_test.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/* 目的：在/sys目录下添加一个名为kobject_test的目录名， 并在该目录下添加一个kobject_test_attr的文件，这个文件为属性文件； 功能：koject_test_show()函数显示属性的值； kobject_test_store()函数向属性中写入一个值；*/#include &lt;linux/device.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/sysfs.h&gt;#include &lt;linux/stat.h&gt;/*声明释放kobject结构体函数*/void kobject_test_release(struct kobject *kobject);/*读属性的函数*/ssize_t kobject_test_show(struct kobject *kobject, struct attribute *attr, char *buf);/*写属性的函数*/ssize_t kobject_test_store(struct kobject *kobject, struct attribute *attr, const char *buf, size_t count);/*定义了一个名为kobject_test，可以读写的属性*/struct attribute test_attr = &#123; .name = \"kobject_test_attr\", .mode = S_IRWXUGO,&#125;;/*该object只有一个属性*/static struct attribute *def_attrs[] = &#123; &amp;test_attr, NULL,&#125;;/*操作函数*/struct sysfs_ops obj_test_sysops = &#123; .show = kobject_test_show, .store = kobject_test_store,&#125;;/*kobject属性*/struct kobj_type ktype = &#123; .release = kobject_test_release, .sysfs_ops = &amp;obj_test_sysops, .default_attrs = def_attrs,&#125;; /*释放kobject结构体函数*/void kobject_test_release(struct kobject *kobject)&#123; printk(\"kobject_test: kobject_test_release(). \\n\");&#125;/*该函数用于读取一个属性的名字*/ssize_t kobject_test_show(struct kobject *kobject, struct attribute *attr, char *buf)&#123; printk(\"call kobject_test_show(). \\n\"); printk(\"attrname:%s.\\n\", attr-&gt;name); sprintf(buf, \"%s\\n\", attr-&gt;name); return strlen(attr-&gt;name)+2;&#125;/*该函数用于写入一个属性的值*/ssize_t kobject_test_store(struct kobject *kobject, struct attribute *attr, const char *buf, size_t count)&#123; printk(\"call kobject_test_store(). \\n\"); printk(\"write: %s\\n\", buf); strcpy(attr-&gt;name, buf); return count;&#125;/*入口函数*/struct kobject kobj;static int kobject_test_init()&#123; printk(\"kobject test_init().\\n\"); kobject_init_and_add(&amp;kobj, &amp;ktype, NULL, \"kobject_test\"); return 0;&#125;/*出口函数*/static int kobject_test_exit()&#123; printk(\"kobject test exit.\\n\"); kobject_del(&amp;kobj); return 0;&#125;module_init(kobject_test_init);module_exit(kobject_test_exit);MODULE_AUTHOR(\"hceng\");MODULE_LICENSE(\"Dual BSD/GPL\"); [kobject_app.c]link123456789101112131415161718192021222324252627#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;poll.h&gt;#include &lt;signal.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;/* kobject_test */int fd;int main(int argc, char **argv)&#123; fd = open(\"/dev/kobject_test\", O_RDWR); if (fd &lt; 0) &#123; printf(\"can't open!\\n\"); return -1; &#125; return 0;&#125; 测试结果： 调用关系： 3.三大组件 设备驱动模型中有三个重要的组件：总线（bus_type）、设备（device）、驱动（driver）,三者关系如下： bus_type通过扫描设备链表和驱动链表，使用mach方法查找匹配的设备和驱动，然后将struct device中的*driver设置为匹配的驱动； 将struct device_driver中的device设置为匹配的设备，这就完成了将总线、设备和驱动3者之间的关联； bus_type只有很少的成员必须提供初始化，大部分由设备模型核心控制； 内核提供许多函数实现bus_type的注册注销等操作，新注册的总线可以再/sys/bus目录下看到； 3.1总线 总线数据结构bus_type：1234567891011121314151617181920212223struct bus_type &#123; const char *name; /* 总线类型名 */ struct bus_attribute *bus_attrs; /* 总线的属性、方法 */ struct device_attribute *dev_attrs; /* 设备属性,为每个加入总线的设备建立属性链表 */ struct driver_attribute *drv_attrs; /* 驱动属性,为每个加入总线的驱动建立属性链表 */ /* 驱动与设备匹配函数:当一个新设备或者驱动被添加到这个总线时，这个方法会被调用一次或多次， 若指定的驱动程序能够处理指定的设备，则返回非零值。 必须在总线层使用这个函数, 因为那里存在正确的逻辑，核心内核不知道如何为每个总线类型匹配设备和驱动程序 */ int (*match)(struct device *dev, struct device_driver *drv); /*在为用户空间产生热插拔事件之前，这个方法允许总线添加环境变量（参数和 kset 的uevent方法相同）*/ int (*uevent)(struct device *dev, struct kobj_uevent_env *env); int (*probe)(struct device *dev); int (*remove)(struct device *dev); /* 设备移除调用操作 */ void (*shutdown)(struct device *dev); int (*suspend)(struct device *dev, pm_message_t state); int (*resume)(struct device *dev); const struct dev_pm_ops *pm; /*电源管理相关操作符*/ struct subsys_private *p; /* 一个很重要的域，包含了device链表和drivers链表 */&#125;; 相关操作函数： 3.2设备 设备数据结构device：12345678910111213141516171819202122232425262728293031323334353637struct device &#123; struct device *parent; /* 父设备，总线设备指定为NULL */ struct device_private *p; /* 包含设备链表，driver_data（驱动程序要使用数据）等信息 */ struct kobject kobj; const char *init_name; /* 初始默认的设备名,但@device_add调用之后又重新设为NULL */ struct device_type *type; struct mutex mutex; /* mutex to synchronize calls to its driver */ struct bus_type *bus; /* type of bus device is on */ struct device_driver *driver; /* which driver has allocated this device */ void *platform_data; /* Platform specific data, device core doesn't touch it */ struct dev_pm_info power; #ifdef CONFIG_NUMA int numa_node; /* NUMA node this device is close to */ #endif u64 *dma_mask; /* dma mask (if dma'able device) *///Like dma_mask, but for alloc_coherent mappings as not all hardware supports 64 bit addresses //for consistentallocations such descriptors. u64 coherent_dma_mask; struct device_dma_parameters *dma_parms; struct list_head dma_pools; /* dma pools (if dma'ble) */ struct dma_coherent_mem *dma_mem; /* internal for coherent mem override */ /* arch specific additions */ struct dev_archdata archdata; #ifdef CONFIG_OF struct device_node *of_node; #endif dev_t devt; /* dev_t, creates the sysfs \"dev\" 设备号 */ spinlock_t devres_lock; struct list_head devres_head; struct klist_node knode_class; struct class *class; const struct attribute_group **groups; /* optional groups */ void (*release)(struct device *dev); &#125;; 3.2驱动 驱动数据结构driver·：1234567891011121314151617181920struct device_driver &#123; const char *name; /* 驱动名称,在sysfs中以文件夹名出现 */ struct bus_type *bus; /* 驱动属于的总线，总线上可以有很多设备 */ struct module *owner; /* 设备驱动自身模块 */ const char *mod_name; /* 驱动模块名字 */ bool suppress_bind_attrs; /* disables bind/unbind via sysfs */ const struct of_device_id *of_match_table; /*检测设备方法，并检测设备驱动可以控制那些设备*/ int (*probe) (struct device *dev); int (*remove) (struct device *dev); /*移除设备时调用的方法*/ void (*shutdown) (struct device *dev); /*关闭设备时调用的方法*/ int (*suspend) (struct device *dev, pm_message_t state); /*处于低功耗时调用的方法*/ int (*resume) (struct device *dev); /*恢复正常状态时调用的方法*/ const struct attribute_group **groups; /*属性组*/ const struct dev_pm_ops *pm; /*用于电源管理*/ struct driver_private *p; /* 定义device_driver中的私有数据类型 */ &#125;; 最后修改时间：2017/4/8 19:55:59 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"}]},{"title":"Linux常用命令","date":"2017-03-12T15:14:00.000Z","path":"2017/03/12/Linux常用命令/","text":"本文主要汇总一些常用且不太熟练的Liunx命令，不定期更新。 1. tar作用：打包（拆包）/压缩（解压）文件； 语法：tar [主选项+辅选项] 文件或目录 主选项： c ：打包文件； x ：拆包文件； t ：列出包/压缩文件里有哪些文件。辅选项： z ：具有 gzip 属性；格式为xx.tar.gz或xx. tgz； j ：具有 bzip2 属性；格式为xx.tar.bz2； v ：显示压缩文件过程； f ：在其后必须是文件名； - -exclude xxx：打包除xxx文件之外的文件；示例：1234567$ tar cf test.tar test #打包test文件/文件夹为test.tar;$ tar xf test.tar #拆包test.tar；$ tar czf test.tar.gz test #压缩test文件/文件夹为test.tar.gz；$ tar xzf test.tar.gz #解压test.tar.gz；$ tar cjf test.bzip2 test #压缩test文件/文件夹为test.bzip2；$ tar xjf test.bzip2 #解压test.bzip2；$ tar cf test.tar --exclude test.txt test #打包test文件夹里除test.txt之外的为test.tar 2. grep作用：查找字符串； 语法：grep [选项] ‘搜寻字符串’ 文件名 选项： -c ：计算找到 ‘搜寻字符串’ 的次数; -i ：忽略大小写; -n ：顺便输出行号; -v ：反向选择，即显示出没有 ‘搜寻字符串’ 内容的那一行;示例：1$ grep -n &apos;test&apos; test.txt #搜索test.txt中含test的行，且显示对应行号； 3. find作用：选项较多，这里暂仅使用name选项查找文件； 语法：find 路径 -name “文件名”示例：1$ find -name &quot;test&quot; #在当前文件下找test文件； 4. ifconfig作用：网卡配置； 语法：ifconfig [网络设备] [参数]”示例：12345678#设置网卡1的地址 192.168.1.44，掩码为255.255.255.0（即默认）；$ ifconfig eth0 192.168.1.44 netmask 255.255.255.0#捆绑网卡1的第二个地址为 192.168.1.x$ ifconfig eth0:x 192.168.1.x#打开网卡1$ ifconfig eth0 up#关闭网卡1$ ifconfig eth0 down 5. mount作用：目前只用来挂载NFS； 语法：mount -t nfs 服务器ip:挂载目录 挂载到本地哪里”示例：12#把主机(192.168.1.44)的/work/hceng/nfs_rootfs挂载到本地/tmp目录下；$ mount -t nfs 192.168.1.44:/work/hceng/nfs_rootfs /tmp 6. 查看Linux版本信息示例：1234$ uname -a #显示电脑以及操作系统的相关信；$ cat /proc/version #正在运行的内核版本；$ cat /etc/issue #显示的是发行版本信息；$ lsb_release -a #列出所有版本信息； 7. 关闭防火墙示例：12$ ufw disable #关闭ubuntu的防火墙 ；$ ufw enable #开启防火墙； 7. source作用：免重启更新环境变量；示例：1$ source /etc/environment 最后修改时间：2017/3/31 19:57:49 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux基础/"}]},{"title":"Makefile小结","date":"2017-03-11T09:44:00.000Z","path":"2017/03/11/Makefile小结/","text":"本文主要是记录一些遇到的Makefile知识。 Makefile以韦东山老师第一期裸板视频中的 第8课LCD实验的配套代码lcd_3.5_4.3 中的Makefile为例，该工程有两个Makefile,分别位于根目录和lib目录中：[根目录Makefile]123456789101112131415161718192021222324252627282930313233CC = arm-linux-gccLD = arm-linux-ldAR = arm-linux-arOBJCOPY = arm-linux-objcopyOBJDUMP = arm-linux-objdumpINCLUDEDIR := $(shell pwd)/includeCFLAGS := -Wall -O2CPPFLAGS := -nostdinc -I$(INCLUDEDIR)export CC LD AR OBJCOPY OBJDUMP INCLUDEDIR CFLAGS CPPFLAGSobjs := head.o init.o nand.o interrupt.o serial.o lcddrv.o/ framebuffer.o lcdlib.o main.o lib libc.alcd.bin: $(objs) $&#123;LD&#125; -Tlcd.lds -o lcd_elf $^ $&#123;OBJCOPY&#125; -O binary -S lcd_elf $@ $&#123;OBJDUMP&#125; -D -m arm lcd_elf &gt; lcd.dis.PHONY : lib/libc.alib/libc.a: cd lib; make; cd .. %.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;clean: make clean -C lib rm -f lcd.bin lcd_elf lcd.dis *.o 主Makefile总领全局的就这句:1lcd.bin: $(objs)要生成lcd.bin，依赖于objs列举的一堆文件：head.o init.o nand.o interrupt.o serial.o lcddrv.o framebuffer.o lcdlib.o main.o lib libc.a，所以要先找到这些文件，几个.o，还有一个.a。 .o目标文件怎么生成？%.o:%.c和%.o:%.S是生成规则，就是依赖于.c或.S文件，使用交叉编译命令生成。 .a目标文件怎么生成？.a是库文件，到lib子目录里去找，在子目录里用make命令生成。 注:链接：将多.o文件，或者.o文件和库文件链接成为可被操作系统执行的可执行程序（Linux环境下，可执行文件的格式为“ELF”格式）。链接器不检查函数所在的源文件，只检查所有.o文件中的定义的符号。将.o文件中使用的函数和其它.o或者库文件中的相关符号进行合并，对所有文件中的符号进行重新安排（重定位），并链接系统相关文件（程序启动文件等）最终生成可执行程序。链接过程使用GNU 的“ld”工具。静态库：又称为文档文件（Archive File）。它是多个.o文件的集合。Linux中静态库文件的后缀为“.a”。静态库中的各个成员（.o文件）没有特殊的存在格式，仅仅是一个.o文件的集合。使用“ar”工具维护和管理静态库。共享库：也是多个.o文件的集合，但是这些.o文件时有编译器按照一种特殊的方式生成（Linux中，共享库文件格式通常为“ELF”格式。共享库已经具备了可执行条件）。模块中各个成员的地址（变量引用和函数调用）都是相对地址。使用此共享库的程序在运行时，共享库被动态加载到内存并和主程序在内存中进行连接。多个可执行程序可共享库文件的代码段（多个程序可以共享的使用库中的某一个模块，共享代码，不共享数据）。另外共享库的成员对象可被执行（由libdl.so提供支持）。 下面进行分析： 第一至五行：12345CC = arm-linux-gccLD = arm-linux-ldAR = arm-linux-arOBJCOPY = arm-linux-objcopyOBJDUMP = arm-linux-objdump 作用：将右边工具链名赋值给左边变量，为了简化书写； 分析： arm-linux-gcc：编译.c或.s头的C文件或汇编程序； arm-linux-ld：连接器，把多个.o文件或库文件连接成一个可执行文件； arm-linux-ar：库管理器，把多个.o文件合并成一个.o文件或静态库文件（.a文件）； arm-linux-objcopy：转换可执行文件的格式； arm-linux-objdump：生成反汇编； 第七行：1INCLUDEDIR := $(shell pwd)/include 作用：将shell命令和include组成的路径立即赋值给左边变量，为了简化书写； 分析：Makefile中调用shell命令：$(shell 命令)； ‘ = ’与‘ := ’的区别注： - “ = ”：make会将整个Makefile展开后，再决定变量的值。也就是说，变量的值将会是整个,Makefile中最后被指定的值。看例子： 123x = fooy = $(x) barx = xyz 在上例中，y的值将会是 xyz bar ，而不是 foo bar 。- “ := ”表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。 123x := fooy := $(x) barx := xyz 在上例中，y的值将会是 foo bar ，而不是 xyz bar 了。 第八行：1CFLAGS := -Wall -O2 作用：将gcc的编译参数赋值给左边变量，为了简化书写； 分析：-Wall显示所有编译错误或警告；-O2优化选项，编译时使用2级优化 第九行：1CPPFLAGS := -nostdinc -I$(INCLUDEDIR) 作用：将gcc编译路径参数赋值给左边变量，为了简化书写； 分析：-nostdinc忽略系统库目录（这里我们自定义了printf等系统函数，不能再包含系统文件里的相关函数）；-I指定搜索路径； 第十一行：1export CC LD AR OBJCOPY OBJDUMP INCLUDEDIR CFLAGS CPPFLAGS 作用：将变量传递到下级Makefile，类似于宏； 分析：本文件中指的是生成lib/libc.a库文件时的Makefile； 第十三行：12objs := head.o init.o nand.o interrupt.o serial.o lcddrv.o/ framebuffer.o lcdlib.o main.o lib libc.a 作用：定义变量objs，包含了生成目标文件所需的文件，为了简化书写； 分析：一行代码写不完，使用/符号可继续在下行写； 第十六行：1lcd.bin: $(objs) 作用：定义生成目标lcd.bin，依赖于objs对象； 分析：执行这条命令时，先生成所有依赖文件，然后依次执行后面三条命令； 第十七行：1$&#123;LD&#125; -Tlcd.lds -o lcd_elf $^ 作用：根据链接脚本lcd.lds链接，输出目的文件lcd_elf,依赖全部文件； 分析：-T指定链接脚本；$^表示全部依赖文件； 第十八行：1$&#123;OBJCOPY&#125; -O binary -S lcd_elf $@ 作用：将lcd_elf文件转换成二进制文件； 分析：-O表示输出格式;-S表示不从源文件中复制重定位信息和符号信息到目标文件中；$@表示全部目标文件； 第十九行：1$&#123;OBJDUMP&#125; -D -m arm lcd_elf &gt; lcd.dis 作用：将lcd_elf文件反汇编为lcd.dis文件； 分析：-m后面跟的是cpu构架;&gt;表示将这个程序的反汇编程序写入到led.dis这个文件中,在终端中不显示出来； 第二十一行：1.PHONY : lib/libc.a 作用：.PHONY伪目标，不要管lib/libc.a文件是否存在，都执行后面的指令； 分析：通常为了避免伪目标和文件重名的这种情况，使用特殊的记“.PHONY”来显示地指明一个目标是“伪目标”； 第二十二、二十三行：12lib/libc.a: cd lib; make; cd .. 作用：执行lib文件夹的Makefile，从而生成libc.a； 分析：执行shell指令，进入lib目录，make，退出； 第二十五至二十九行：1234%.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt; 作用：依赖所有的.c和.S文件，生成所有的.o文件； 分析：%通配符；-c编译不链接;$@表示目标文件;$&lt;表示第一个依赖文件; 第三十一至三十三行：1234%.o:%.Sclean: make clean -C lib rm -f lcd.bin lcd_elf lcd.dis *.o 作用：清理所有生成文件； 分析：-C lib即清理包括lib文件夹下生成的文件; 下面是lib目录Makefile: [lib目录Makefile]123456789101112131415objs := div64.o lib1funcs.o ctype.o muldi3.o printf.o string.o/vsprintf.olibc.a: $(objs) $&#123;AR&#125; -r -o $@ $^ %.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;clean: rm -f libc.a *.o 第一、二行：12objs := div64.o lib1funcs.o ctype.o muldi3.o printf.o string.o/vsprintf.o 作用：定义变量objs，包含了生成目标文件所需的文件，为了简化书写； 分析：一行代码写不完，使用/符号可继续在下行写； 第四、五行：12libc.a: $(objs) $&#123;AR&#125; -r -o $@ $^ 作用：使用库管理器生成lib.a； 分析：$@表示目标文件;$^所有依赖文件； 第七至十一行：1234%.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt; 作用：依赖所有的.c和.S文件，生成所有的.o文件； 分析：%通配符；-c编译不链接;$@表示目标文件;$&lt;表示第一个依赖文件; 第十三、十四行：123%.o:%.Sclean: rm -f libc.a *.o 作用：清理所有生成文件； 分析：-f强制删除; 参考博文：sekon LCD实验学习笔记（一）：Makefile 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"Makefile","slug":"Makefile","permalink":"http://yoursite.com/tags/Makefile/"}]},{"title":"汇编指令小结","date":"2017-03-10T03:55:00.000Z","path":"2017/03/10/汇编指令小结/","text":"本文主要是记录一些遇到的ARM汇编知识。 汇编代码以韦东山老师的 第7章nand flash实验配套代码13th_link_4096 中的start.S为例：[start.S]12345678910111213141516171819202122232425262728293031323334353637383940414243.globl _start_start:/* 硬件相关的设置 : 把外设的基地址告诉CPU*/ /* Peri port setup */ ldr r0, =0x70000000 orr r0, r0, #0x13 mcr p15,0,r0,c15,c2,4 @ 256M(0x70000000-0x7fffffff) /* 关看门狗 *//* 往WTCON(0x7E004000)写0 */ ldr r0, =0x7E004000 mov r1, #0 str r1, [r0]/* 重定位 */ adr r0, _start /* _start当前指令地址 */ ldr r1, =_start /* _start的编译地址 */ ldr r2, =bss_start cmp r0, r1 beq clean_bsscopy_loop: ldr r3, [r0], #4 str r3, [r1], #4 cmp r1, r2 bne copy_loop /* 清BSS段 */clean_bss: ldr r0, =bss_start ldr r1, =bss_end mov r2, #0clean_loop: str r2, [r0], #4 cmp r0, r1 bne clean_loop /* 设置栈 */ ldr sp, =8*1024 ldr pc, =main /* 重定位完后, 使用位置相关的指令跳转 */ bl mainhalt: b halt 第六行：1ldr r0, =0x70000000 格式：ldr&emsp;目的寄存器&emsp;&lt;存储器地址&gt; 作用：将 存储器地址 所指地址处连续的4个字节（1个字）的数据传送到目的寄存器中。 第七行：1orr r0, r0, #0x13 格式：orr&emsp;目的寄存器，&emsp;操作数 1，&emsp;操作数 2 作用：常用于设置操作数1 的某些位，在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中。操作数1 应是一个寄存器，操作数2 可以是一个寄存器、被移位的寄存器或一个立即数。 第八行：1mcr p15,0,r0,c15,c2,4 格式：mcr&emsp;协处理器编码，&emsp;协处理器操作码1，&emsp;源寄存器，&emsp;目的寄存器1，&emsp;目的寄存器2，&emsp;协处理器操作码2 作用：将ARM处理器寄存器中的数据传送到协处理器寄存器中,若协处理器不能成功完成操作，则产生未定义指令异常。其中协处理器操作码1 和协处理器操作码2 为协处理器将要执行的操作，源寄存器为ARM处理器的寄存器，目的寄存器1和目的寄存器2均为协处理器的寄存器。 第十四行：1str r1, [r0] 格式：str&emsp;源寄存器&emsp;&lt;存储器地址&gt; 作用：用于从源寄存器中将一个32位的字数据传送到存储器中。在ARM架构下, 数据从内存到CPU之间的移动只能通过ldr/str指令来完成。而mov只能在寄存器之间移动数据,或者把立即数移动到寄存器中,并且数据的长度不能超过8位。 第十七行：1adr r0, _start 格式：adr&emsp;目的寄存器&emsp;程序相对的表达式 作用：可将一个立即值与pc值相加，并将结果写入目标寄存器。adr可生成与位置无关的代码，因为地址相对于程序或寄存器。详见ARM指令adr。 第二十行：1cmp r0, r1 格式：cmp&emsp;操作数1，&emsp;操作数2 作用：用于把一个寄存器的内容和另一个寄存器的内容或立即数进行比较，同时更新CPSR中条件标志位的值。该指令进行一次减法运算，但不存储结果，只更改条件标志位。标志位表示的是操作数1与操作数2的关系(大、小、相等)，例如，当操作数1大于操作操作数2，则此后的有GT 后缀的指令将可以执行。 CPSR注： Z标志：是否为0；如比较指令产生相等的结果、计算结果为0； N标志：是否为负；如果指令的结果被认为是有符号数，而它的第31位为1，那就会被设置为1； C标志：是否有产生进位/借位，以及进行移位操作时作移出位使用； V标志：有符号数进行运算，结果是否有溢出。 第二十一行：1beq clean_bss 格式：beq&emsp;标签 作用：数据跳转指令，标志寄存器中Z标志位等于零时, 跳转到beq后标签处。 第二十六行：1bne copy_loop 格式：bne&emsp;标签 作用：数据跳转指令，标志寄存器中Z标志位不等于零时, 跳转到bne后标签处。 第四十一行：1bl main 格式：bl&emsp;子程序名 作用：b或bl指令引起处理器转移到子程序名处开始执行。两者的不同之处在于bl指令在转移到子程序执行之前，将其下一条指令的地址拷贝到R14（LR,链接寄存器）。由于bl指令保存了下条指令的地址，因此使用指令“mov pc, lr”即可实现子程序的返回。而b指令则无法实现子程序的返回，只能实现单纯的跳转。 ARM处理器控制程序执行方式注： 流水方式执行程序：PC的值是下一条指令的地址，即每执行一条指令PC都加一个字的偏移。 通过跳转指令来控制程序执行:b-跳转到指定的指令处执行;bl-跳转执行，保存子程序地址并返回;bx-跳转执行并切换到Thumb状态;blx-三种方式组合。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/tags/汇编/"}]},{"title":"GitHub+Hexo博客搭建及优化","date":"2017-03-06T11:26:00.000Z","path":"2017/03/06/GitHub+Hexo搭建及优化/","text":"本文主要是记录本博客的搭建和优化。 为什么做独立博客？我想大概就是激励自己去持续学习和思考。 首先说下本博客搭建的大致流程:1.有一个GitHub账号，同时配置GitHub Pages；2.安装、配置Hexo；3.配置博客、Markdown写文章；4.绑定自己域名（可选）；5.优化日常操作（可选）； 1.Github Pages Github Pages是GitHub提供的免费静态站点； 创建Github Pages后，在里面存放网页源码，然后在对应网址就可看到对应网页效果； 使用GitHub账号创建一个仓库，但是这个仓库是有规则的，其格式必须为：yourusername.github.io； 注： yourusername必须是自己的GitHub账号名； 类型只能选Public； 2.安装、配置Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。1、安装 Node.js;2、下载Cmder代替Windows自带cmd;3、安装 Git;4、添加本机密钥到GitHub;5、安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，在Git上设置username和email；其中3-5步在前一篇博文Git日常使用小结中已设置过了，无需再设置。6、安装 Hexo：使用 npm 安装 Hexo。1$ npm install -g hexo-cli至此，已经安装完Hexo,后续进行相关配置。7、在电脑上选一个盘，建个文件夹存放博客数据，例我的：E:\\blog；然后打开cmder，输入:12$ e: &amp; cd blog #进入所建文件夹$ hexo init blog #初始化blog成功初始化blog后将出现：1INFO Start blogging with Hexo!8、最后再生成静态网页，即可看到网页模板：12$ hexo generate # 启动本地服务器$ hexo server # 在浏览器输入 http://localhost:4000/就可以看见网页和模板了完成后，将会看到如下提示：12INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.此时，打开浏览器，输入http://localhost:4000/就可以看见默认的网页和模板了。 3.配置博客、发表文章 在blog目录下，用Sublime Text(使用它的原因是默认是UTF-8编码，中文不会乱码)打开_config.yml文件，修改参数信息； 注：在每个参数的”：”后都要加一个空格修改网站相关信息; 3.1修改网站相关信息：1234567# Sitetitle: 黄成的博客subtitle: Linux/Android驱动 description: 生命不息、折腾不止author: hcenglanguage: zh-CNtimezone: Asia/Shenzhen 3.2修改配置部署相关信息：123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: 'git@github.com:hceng/hceng.github.io.git' branch: master- type: git repo: 'git@git.coding.net:hceng/hceng.git' branch: coding-pages 这里由于我同时提交到了GitHub和Coding,用于测试百度收录，所以有两个，写一个也没事。 注:如果在执行 hexo deploy 后,出现 error deployer not found:github(git) 的错误，执行： 1$ npm install hexo-deployer-git --save 3.3修改主题： 为了让博客更加美观和符合自己需求，可以修改Hexo主题来满足自己需求。Hexo 安装主题的方式非常简单，只需要将主题文件放置于站点目录的 themes 目录下，然后修改下配置文件即可。 Hexo 有两份主要的配置文件（_config.yml），一份位于站点根目录下，另一份位于主题目录下。为了描述方便，在以下说明中，将前者称为 站点配置文件，后者称为 主题配置文件。 下载hexo-theme-yilia主题,解压放入themes文件夹下，如：E:\\blog\\blog\\themes，根据自己需求修改主题配置文件，最后再修改站点配置文件里的theme:1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-yilia 在主题配置文件里，修改头像、颜色、标签等，都有相应的注释写得非常清楚，按需修改。 3.4发表文章： 在Cmder中输入：12$ hexo new \"blog tags\"INFO Created: E:\\blog\\blog\\source\\_posts\\blog-tags.md 根据提示得路径，即可找到新建得文件，该文件使用Markdown语法，下载MarkdownPad2进行编辑。先修改相关的文章信息：123456---title: blog tagstags: - 随笔--- 本文主要是总结blog预计的标签，并不定时更新。 可修改标题、标签（本有日期的修改选项，但有日期就不能显示文章，怀疑是主题或者其它地方干扰了，文章日期就是文件创建日期）。然后简单说下Markdown语法： 3.4.1标题和引用 行首插入 1 到 6 个 # ，对应到标题 1 到 6 级标题： 123# 一级标题## 二级标题## 三标题 效果：见本文（影响目录效果，就不示例了）。 区块引用则使用 ‘&gt;’ 角括号来表示： 1&gt; 这是引用 效果： 这是引用 3.4.2列表和强调 列表分有序的1、2、3和无序的·：12- 列表1- 列表2 效果： 列表1 列表2 强调有加粗和斜体，用”*”来表示： 12**加粗***斜体* 效果：加粗斜体 3.4.3超链接和图片 在方括号”[]”写要显示标，在小括号”()”写链接：1[hceng blog](http://hceng.cn/)效果：hceng blog 在文章如果需要加入图片，先需要把图片传到床图网站，生成链接后插入使用，格式如下：1![](图片网址) 3.4.4加入代码 Markdown支持插入代码，使用单引号”`“来标注,注意是英文输入法下，左上角那个按键：1`hello`效果：hello 这种方式感觉不够醒目，而且不支持语法高亮，所以我一般使用Codeblock，语法见网站，效果如下：123456#include &lt;stdio.h&gt;int main(void)&#123; printf(\"hello,world!\"); return 0;&#125; 4.绑定自己域名（可选） 完成以上步骤后，默认域名是GitHub提供的二级域名：yoursname.github.io,下面开始绑定自己的域名： 4.1购买域名 推荐GoDaddy或万网； 我是在万网买的，首推买.com，其次.me、.top、.cn系列，根据自己喜好来，各有特色优缺点； 然后继续交实名认证、审核，还是比较快；4.2绑定域名 保证上述工作完成，域名可用； 修改DNS，分别修改为：f1g1ns1.dnspod.net和f1g1ns2.dnspod.net 本地站点目录里的source目录下添加一个CNAME文件，里面写上网址； 注:CNAME不要有任何后缀；网址不要写www或http：//,直接写hceng.cn这种； 注册DNSpod，然后添加域名，添加记录： 参考红线部分填写，一个主机纪录是@，记录类型是CNAME，线路类型填默认（图片中是我测试百度抓取用的），记录值写对应的GitHub Pages的地址；另一个主机纪录填www，其它和上面的一样。 最后把本地的Hexo生成一下，再提交到Github pages上； 5.优化日常操作（可选）5.1hexo命令简写：12345$ hexo n “新文章” == hexo new “新文章” #新建文章$ hexo c == hexo clear #清理静态文件$ hexo g == hexo generate #生成静态文件$ hexo s == hexo server #启动本地预览$ hexo d == hexo deploy #上传部署 5.2添加版权信息：1.在博客根目录下（和 source 同级），新建一个名为 scripts 的文件夹；2.在 scripts 文件夹内, 新建一个 AddTail.js 脚本文件，脚本具体内容详见下文；3.在博客根目录下，新建一个 tail.md 文件，里面写想要展示的版本说明内容;AddTail.js 脚本文件：1234567891011121314151617181920212223242526272829303132333435// Filename: AddTail.js// Author: Colin// Date: 2016/06/02// Based on the script by KUANG Qi: http://kuangqi.me/tricks/append-a-copyright-info-after-every-post/// Add a tail to every post from tail.md// Great for adding copyright infovar fs = require('fs');hexo.extend.filter.register('before_post_render', function(data)&#123; if(data.copyright == false) return data; // Add seperate line data.content += '\\n___\\n'; // Try to read tail.md try &#123; var file_content = fs.readFileSync('tail.md'); if(file_content &amp;&amp; data.content.length &gt; 50) &#123; data.content += file_content; &#125; &#125; catch (err) &#123; if (err.code !== 'ENOENT') throw err; // No process for ENOENT error &#125; // 添加具体文章链接, 不需要去掉即可 //var permalink = '\\n本文链接：' + data.permalink; //data.content += permalink; return data;&#125;);tail.md 文件：去Creative Commons根据自己需求，生成合适的许可，然后复制到tail.md 文件中； 参考博客：如何添加版权信息 5.3自动添加目录： 修改主题的ejs文件 打开文件：themes/你的主题/layout/_partial/article.ejs 在这个文件中找到&lt;%- post.content %&gt;，并在这之前加入以下代码：1234567&lt;!-- Table of Contents --&gt;&lt;% if (!index &amp;&amp; post.toc)&#123; %&gt;&lt;div id=\"toc\" class=\"toc-article\"&gt;&lt;strong class=\"toc-title\"&gt;文章目录&lt;/strong&gt;&lt;%- toc(post.content, &#123;list_number: false&#125;) %&gt;&lt;/div&gt;&lt;% &#125; %&gt; 这里if语句中有两个条件，!index是为了不在首页的文章摘要中生成目录，post.toc确保了只在显式地标记了toc: true的文章中生成目录。若这两个条件满足，则创建一个目录的div。第五行表示不自动生成标号，不然加上自己的标号会有两个。 为需要的文章添加标记 5.4添加访问人数统计： 安装脚本： 打开themes/你的主题/layout/_partial/footer.ejs添加下面脚本：12&lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 在需要的位置添加添加显示： 这里我用的Yilia的主题，不蒜子官方给的例子没有成功，这里自己需求是在底部中间显示统计量，于是在footer.ejs中间添加如下代码：123&lt;div class=\"footer-centre\"&gt; &amp;hearts; Total view my blog &lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt; times&lt;/div&gt; 这里我浏览量数据是+2的增加，还无解中。。参考链接：不蒜子5.5脚本自动化： 每次发布文章大致分为清理静态文件、生成静态文件、启动本地预览或上传部署，连续这么多命令何不合成一个，于是在windows下，可新建几个批处理脚本:[make1.bat]12#生成最新本地预览hexo clean &amp; hexo g &amp;hexo s [make2.bat]12#发布生成最新博客hexo clean &amp; hexo g &amp; hexo d [make3.bat]123#发成最新博客并上传源码到Coding私有库，以便在其它电脑上编辑hexo clean &amp; hexo g &amp; hexo d &amp; git add -A &amp; git commit -m &quot;from make3&quot; &amp; \\git push origin master 在Cmder中，输入对应的makeN,即可自动完成一系列命令。 最后修改时间：2017/3/31 20:42:06 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Git日常使用小结","date":"2017-03-02T06:14:00.000Z","path":"2017/03/02/Git日常使用小结/","text":"本文主要是记录一些Git的配置和命令。关于代码托管，我目前主要使用两个： GitHub：主要用于托管公开代码和利用GitHub Pages搭建本博客； Coding：主要用于同步GitHub代码和托管私人代码；下面纪录下Git的安装、配置、使用。 1.安装GitWindows：git-for-windowsysGitMac OS:从AppStore安装Xcode,选择菜单“Xcode”-&gt;“Preferences”，找到“Downloads”，选择“Command Line Tools”，点“Install”。Linux:1$ sudo apt-get install git 2.创建本地仓库并上传2.1在本地创建仓库 第一次打开Git时,首先要在Git上设置username和email；12$ git config --global user.name &quot;hceng&quot; #与注册的账号邮箱一致；$ git config --global user.email &quot;huangcheng.job@foxmail.com&quot; 在命令行里(这里使用Cmder软件)先进入欲作为仓库的文件夹（如：E:/blog文件夹），然后初始化——创建本地仓库:12$ e: &amp; cd blog #进入E盘的blog文件夹；$ git init #初始化当前文件夹作为仓库（生成.git文件夹）； 这时生成一个”.git”目录，该目录是Git来跟踪管理版本，一般情况勿动；2.2添加文件到本地仓库12$ touch readme.txt #创建一个测试文件；$ git add readme.txt #将当前更改或者新增的文件加入到临时空间中； 注： add 命令只是把文件添加到一个临时空间里，需要执行第3 步的commit 命令才会正式提交到仓库中； 如果文件太多，可以使用以下命令一次性提交所有文件(.gitignore 文件指定的除外)；1$ git add -A 可以在当前目录下新建一个名为“.gitignore”的文件，它里面的内容用来表示某类/某个文件将不会被提交到仓库。 2.3提交文件到本地仓库执行以下命令，这会把临时空间的内容存入本地仓库，并添加注释：1$ git commit -m &quot;blog, add 1 files&quot; 可以使用以下命令查看记录：1$ git log --pretty=oneline得到类似信息，前面为版本号，后面为注释：112ewdqe2q... blog, add 1 files可以给某个版本号打上一个标签，命令如下：1$ git tag v1 12ew可以使用以下命令查看已有的标签：1$ git tag 2.4提交文件到GitHub/Coding第一次提交前，需要将本机密钥上传到GitHub/Coding；2.4.1.创建SSH Key：在用户主目录下，看看有没有.ssh 目录，如果有，再看看这个目录下有没有id_rsa 和id_rsa.pub 这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Git Bash，创建SSH Key，命令如下：1$ ssh-keygen -t rsa -C &quot;huangcheng.job@foxmail.com&quot;然后一路回车，使用默认值即可。这样在用户主目录里就会生成.ssh 目录，里面有id_rsa 和id_rsa.pub 两个文件，它们是SSH Key 的秘钥对。id_rsa 是私钥，不能泄露出去；id_rsa.pub 是公钥，可以放心地告诉任何人。 2.4.2.在GitHub 里添加SSH Key：电脑登陆GitHub,在自己账户的”Settings”-“SSH Key”中添加id_rsa.pub 文件的内容；2.4.3.创建一个仓库如:git_hexo,第一次上传需要指定GitHub/Coding仓库，如Coding的git_hexo：12$ git remote add origin https://git.coding.net/hceng/$ git_hexo.git然后根据提示输入账号、密码，最后执行以下指令提交至GitHub/Coding；12$ git push -u origin master$ git push origin --tags 2.5以后如果修改文件后再次提交12345$ git add –A # 添加修改文件到临时空间；$ git commit -m &quot;blog, git use&quot; # 添加本地仓库和添加备注；$ git tag v2 # 打标签；$ git push origin master # 上传到服务器的master；$ git push origin --tags # 上传标签到服务器； 3.Git 获取GitHub/Coding源码 执行以下命令，可以复制他人public代码，这称为“克隆”：1$ git clone https://github.com/hceng/hceng.github.io 当源码作者再次修改了源码后，可以进入对应目录，然后使用以下命令再次获得最新的：1$ git pull origin 查看信息纪录：1$ git log --pretty=oneline 查看标签：1$ git tag 获得指定版本的源码：123$ git checkout &lt;commit id&gt;或$ git checkout &lt;tag_name&gt; 4.分支管理4.1查看所有分支：1$ git branch --all # 本地主分支：master；远程主分支：origin/master； 4.2创建本地分支：12$ git branch bak # 创建本地分支；$ git branch # 查看本分支；&quot;*&quot;号表示当前所在分支； 4.3发布新分支：即：将本地新建的bak分支同步到远程服务器GitHub/Coding;12$ git push origin bak # 这样远程仓库也有一个bak分支了；$ git checkout bak # 切换到bak分支操作；第一种情况：bak分支开发完成，合并到主分支：12345$ git checkout master # 切换到主分支；$ git merge bak # 把bak分支的更改和master合并；$ git push # 提交主分支代码远程；$ git checkout bak # 切换到bak远程分支；$ git push # 提交bak分支到远程； 第二种情况：bak分支没开发完，推送保存，下次再开发：123$ git add -A # 添加修改文件到临时空间；$ git commit -m &quot;bak branch&quot; # 提交本地bak分支仓库；$ git push # 提交bak分支到远程； 4.4删除分支：12345# 删除远程bak分支，危险命令；$ git push origin :bak # 下面两条是删除本地分支;$ git checkout master # 切换到master分支$ git branch -d bak # 删除本地dev分支 参考： 5.其它常用指令12345678910 $ git status #查看仓库状态; $ git diff XX #查看XX文件修改了那些内容;$ git log #查看历史记录;$ git reflog #查看历史记录(含回退纪录)；$ git reset –hard HEAD^ #回退到上一个版本; $ git reset –hard HEAD~ #回退到上一个版本;$ git reset –hard HEAD~100 #回退到100个版本;$ git checkout – XX #把XX文件在工作区的修改全部撤销； $ git rm XX #删除XX文件； 参考资料：韦东山Android系统视频使用手册20160303 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"SkillTree","date":"2017-03-01T00:00:00.000Z","path":"2017/03/01/SkillTree/","text":"My SkillTree. SkillTree 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]