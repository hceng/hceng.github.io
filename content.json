[{"title":"软件癖","date":"2017-04-06T03:06:19.000Z","path":"2017/04/06/软件癖/","text":"软件“洁癖”。 折腾Windows久了，渐渐的对软件有了“洁癖”。带广告的要想办法去掉广告，有绿色版的要绿色版本优先，能精简的必须精简，收费的也无耻的去百度云找找，有功能限制一定要想办法去掉限制，有最新版的稳定情况下一定使用最新的。 经过时间的过滤，有些软件忍受住了我的“洁癖”，幸存了下来，他们有的堪称“神器”，有的良心无比让人敬佩。谨以此文感谢这些提高工作效率和创造安静的环境的软件，对作者深感敬佩。 ChromeSoureInsightOneNotePowerPointAdobe Acrobat DCWePEEverything BandzipSnipaste 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Linux并发控制","date":"2017-04-05T15:55:00.000Z","path":"2017/04/05/Linux并发控制/","text":"本文主要是简单记录下驱动中的并发控制。 1.并发控制 2.原子变量操作测试代码：[atomic_drv.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;linux/module.h&gt; #include &lt;linux/init.h&gt; #include &lt;asm/atomic.h&gt;//原子变量操作的头文件#include &lt;asm/bitops.h&gt;//原子位操作的头文件atomic_t a1 = ATOMIC_INIT(1);//定义和设置原子量；unsigned long int a2;//操作函数传入参数的数据类型是unsigned long int；static int test_drv_init(void)&#123; //测试原子变量操作： printk(\"test a1\\nKERN_INFO:atomic_read(): a1 = %d\\n\", a1); atomic_add(4, &amp;a1); printk(\"KERN_INFO:atomic_add(): a1 = %d\\n\", a1); atomic_dec(&amp;a1); printk(\"KERN_INFO:atomic_dec(): a1 = %d\\n\", a1); printk(\"KERN_INFO:atomic_dec_and_test(): judge_a1 = %d, new_a1 = %d\\n\",\\ atomic_dec_and_test(&amp;a1),atomic_read(&amp;a1)); //测试原子位操作： set_bit(0,&amp;a2);//设置a的0位为1; printk(\"test a2\\nKERN_INFO:set_bit(): a2 = %ld\\n\", a2); printk(\"KERN_INFO:test_and_clear_bit(): return_a2 = %d, new_a2 = %ld\\n\",\\ test_and_clear_bit(0, &amp;a2), a2); printk(\"KERN_INFO:test_and_set_bit(): return_a2 = %d, new_a2 = %ld\\n\",\\ test_and_set_bit(0, &amp;a2), a2); return 0;&#125;static void test_drv_exit(void)&#123; &#125;module_init(test_drv_init);module_exit(test_drv_exit);MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"hceng\"); MODULE_DESCRIPTION(\"Learn for atomic\"); 测试结果： 3.自旋锁测试代码：[lock_drv.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*设备驱动中，有些设备只允许打开一次，这里用count计数，lock对count进行保护*/#include &lt;linux/module.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_device.h&gt;#include &lt;linux/spinlock.h&gt;//自旋锁头文件static struct class *testdrv_class;static struct class_device *testdrv_class_dev;int count = 0 ;spinlock_t lock;static int test_drv_open(struct inode *inode, struct file *file)&#123; spin_lock(&amp;lock); if(count) &#123; spin_unlock(&amp;lock); printk(\"kernel: open fail! count = %d\\n\",count); return -EBUSY; &#125; count++; spin_unlock(&amp;lock); printk(\"kernel: open ok! count = %d\\n\",count); return 0;&#125;static int test_drv_release(struct inode *inode, struct file *file)&#123; spin_lock(&amp;lock); count--; spin_unlock(&amp;lock); printk(\"kernel: release ok! count = %d\\n\",count); return 0;&#125;static struct file_operations test_drv_fops = &#123; .owner = THIS_MODULE, .open = test_drv_open, .release = test_drv_release, &#125;;int major;static int test_drv_init(void)&#123; major = register_chrdev(0, \"test_drv\", &amp;test_drv_fops); testdrv_class = class_create(THIS_MODULE, \"testdrv\"); testdrv_class_dev = device_create(testdrv_class, NULL, MKDEV(major, 0), NULL, \"locktest\"); spin_lock_init(&amp;lock); printk(\"kernel: init ok!\\n\"); return 0;&#125;static void test_drv_exit(void)&#123; unregister_chrdev(major, \"test_drv\"); device_destroy(testdrv_class, MKDEV(major, 0)); class_destroy(testdrv_class); printk(\"kernel: exit ok!\\n\");&#125;module_init(test_drv_init);module_exit(test_drv_exit);MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"hceng\"); MODULE_DESCRIPTION(\"Learn for lock\");[lock_test.c]link123456789101112131415161718192021#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; int fd; fd = open(\"/dev/locktest\", O_RDWR); if (fd &lt; 0) &#123; printf(\"app: can't open!\\n\"); &#125; else printf(\"app: open ok!\\n\"); while(1); return 0;&#125; 测试结果： 4.信号量 5.完成量 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"}]},{"title":"从0到Q系列之三（Linux内核结构及移植）","date":"2017-04-01T09:12:00.000Z","path":"2017/04/01/从0到Q系列之三（Linux内核结构及移植）/","text":"该系列主要是为驱动学习提供基石，从0到Qt。本文是该系列的第三篇:对Linux内核的结构进行分析及移植内核. 毕业设计原因，暂停更，其它不变。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/环境搭建/"}]},{"title":"终端复用软件-Tmux","date":"2017-03-31T11:50:00.000Z","path":"2017/03/31/终端复用软件——Tmux/","text":"本文主要记录终端复用软件——Tmux的简单使用。 Tmux是一个可以把终端分屏的软件，最开始知道这货是在酷安下了Termux，酷安大佬们真会完，刷Termu下面的评论中看到了Tmux，觉得还挺好玩的。最近Linux终端用得比较多，尝试安装玩玩，记录下。 1.安装tmux在ubuntu终端中，使用以下命令安装：1$ sudo apt-get install tmux 2.基本使用Tmux为了不和其它软件的快捷键影响，所以它的命令全要加前缀Ctrl+b后再操作，例如新建个窗口的操作步骤： 按下组合键 Ctrl+b; 放开组合键 Ctrl+b; 按下 c 键; Tmux的操作很多，这里我只记录几个我常用的，后续自己有需求再增加： 功能 前缀操作 组合键 创建新窗口 Ctrl+b-&gt;松开 c 水平划分窗口 Ctrl+b-&gt;松开 “ 垂直划分窗口 Ctrl+b-&gt;松开 % 调整窗口大小 Ctrl+b-&gt;不松住 方向键 切换窗口 Ctrl+b-&gt;松开 方向键 显示窗口标号 Ctrl+b-&gt;松开 q 关闭窗口 Ctrl+b-&gt;松开 x-&gt;y 关闭Tmux Ctrl+b-&gt;松开 &amp;-&gt;y 3.其它优化美化的话参考后面给的博客链接，这里我只美化了底边状态栏：进入home目录，新建.tmux.conf12$ cd ~$ vi ~/.tmux.conf加入以下代码： 12345678910111213141516171819# 状态栏# 颜色set -g status-bg blackset -g status-fg white # 对齐方式set-option -g status-justify centre # 左下角set-option -g status-left &apos;#[bg=black,fg=green][#[fg=cyan]#S#[fg=green]]&apos;set-option -g status-left-length 20 # 窗口列表setw -g automatic-rename onset-window-option -g window-status-format &apos;#[dim]#I:#[default]#W#[fg=grey,dim]&apos;set-window-option -g window-status-current-format &apos;#[fg=cyan,bold]#I#[fg=blue]:#[fg=cyan]#W#[fg=dim]&apos; # 右下角set -g status-right &apos;#[fg=green][#[fg=cyan]%Y-%m-%d#[fg=green]]&apos; 最终效果图： 参考博客：Tmux 速成教程：技巧和调整Tmux简单教程 最后修改时间：2017/3/31 19:51:36 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux基础/"}]},{"title":"从0到Q系列之二（U-Boot分析及移植）","date":"2017-03-26T10:39:00.000Z","path":"2017/03/26/从0到Q系列之二（U-Boot分析及移植）/","text":"该系列主要是为驱动学习提供基石，从0到Qt。本文是该系列的第二篇:对U-Boot进行分析及移植. 1.U-Boot结构分析Bootloader一般可以分成两个阶段： 第一个阶段通常使用汇编进行必要的硬件初始化，例如：关看门狗、关中断、设置时钟频率、RAM初始化等。除此之外，还要将第二阶段的代码复制到RAM中，设置好栈，然后跳到第二阶段，该阶段主要是与SOC平台相关。 第二阶段一般是用c语言编写，该阶段主要和开发板板载资源相关。该阶段主要初始化后续的硬件，处理内存映射、以及将内核和根文件系统从Flash“搬运”到RAM中运行，然后传入启动参数，最后启动引导内核，完成使命。 Linux中系统一般的分区结构，如下图： 分区主要分为四个分区：Bootloader、Boot parameters、Kernel、Root filesystem。其中Boot parameters是待传入内核的参数，Kernel即内核、Root filesystem是根文件系统。Bootloader在第一个分区(假设该储存介质为Nand Flash)，则在Nand Flash的地址为0x0000 0000，S3C2440上电后，硬件自动把Nand Flash上前4k代码复杂到自己内部RAM中运行。该4k代码先要初始化一些必要的硬件，如看门狗，中断等，然后准备好SRAM，并将后续的代码复制到SDRAM中，再跳到SDRAM中运行，完成Bootloader第一阶段。此时在SDRAM中的第二阶段代码开始工作，首先还是初始化硬件，处理内存映射，把Nand Flash上内核和根文件系统“搬运”到SDRAM准备运行，然后根据用户通过串口传入的启动参数放在Boot parameters，然后内核启动，完成使命。内核启动后，开始去Boot parameters寻找启动参数，根据启动参数做出相应的操作，如：控制台输出、串口波特率、根文件系统位置。 2.U-Boot源码分析 这里根据u-boot-1.1.6的源码进行分析，，主要工作有： 第一阶段的硬件初始化(CPU模式、看门狗、中断) 准备SDRAM 设置堆栈 搬运FLASH中的代码到SDRAM 清除.bss段并跳转至第二阶段 第二阶段的硬件初始化（时钟、串口） 内存映射 根据传入参数启动内核 2.1第一阶段 该阶段的源码在/arch/cpu/arm920t/start.S中：首先进行硬件初始化，包括设置CPU模式，关闭看门狗、关闭中断。这里把时钟配置放在了第二阶段。 设置CPU模式 把CPU设置为SVC模式，将当前程序状态计数器CPSR的值保存到r0中，利用bic指令清除r0的0x1f并存入r0中，再利用orr指令或运算上0xd3并存入r0，最后r0写回CPSR,这一过程就把CPSR设置为SVC模式：[start.S]123456reset:/* set the cpu to SVC32 mode*/ mrs r0,cpsr bic r0,r0,#0x1f orr r0,r0,#0xd3 msr cpsr,r0 设置看门狗和关闭中断 根据S3C2440的datasheet，将0x00写入pWTCON对应寄存器的地址，完成看门狗的关闭。中断部分也类似，将INTMSK寄存器设置为0xffff ffff即可：[start.S]12345678910/* turn off the watchdog */# define pWTCON 0x53000000# define INTMOD 0X4A000004# define INTMSK 0x4A000008 /* Interupt-Controller base addresses */# define INTSUBMSK 0x4A00001C# define CLKDIVN 0x4C000014 /* clock divisor register *//* turn off the int */ ldr r1, =0x3ff ldr r0, =INTSUBMSK str r1, [r0] 准备SDRAMstart.S中没有初始化SDRAM，而是先跳转到函数cpu_init_crit中，再跳转至lowlevel_init.S中进行初始化SDRAM。adr是一个位置无关指令，将_start的地址读取到r0中，上电后，Flash中的前4k就被拷到S3C2440内部RAM，则这里r0=0。然后再用ldr指令将_TEXT_BASE这个地址（来自链接脚本，代表运行地址）的值放在r1中。然后比较r0和r1的值，如果是相等的，那么证明这个时候代码已经位于了其应该位于的地方，这个时候就不再需要初始化SDRAM去重定位了。如果r1和r0的值不相等，那么将直接跳转cpu_init_crit中。[start.S]1234adr r0, _start /* r0 &lt;- current position of code */ldr r1, _TEXT_BASE /* test if we run from flash or RAM */cmp r0, r1 /* don&apos;t reloc during debug */blne cpu_init_crit [start.S]12345678910111213141516171819202122cpu_init_crit: /*flush v4 I/D caches*/ mov r0, #0 mcr p15, 0, r0, c7, c7, 0 /* flush v3/v4 cache */ mcr p15, 0, r0, c8, c7, 0 /* flush v4 TLB */ /*disable MMU stuff and caches*/ mrc p15, 0, r0, c1, c0, 0 bic r0, r0, #0x00002300 @ clear bits 13, 9:8 (--V- --RS) bic r0, r0, #0x00000087 @ clear bits 7, 2:0 (B--- -CAM) orr r0, r0, #0x00000002 @ set bit 2 (A) Align orr r0, r0, #0x00001000 @ set bit 12 (I) I-Cache mcr p15, 0, r0, c1, c0, 0 /* * before relocating, we have to setup RAM timing * because memory timing is board-dependend, you will * find a lowlevel_init.S in your board directory. */ mov ip, lr bl lowlevel_init mov lr, ip 设置栈 通常为了保存调用C语言时传递参数和保存CPU运行时的现场，需要设置栈，根据定义_TEXT_BASED为代码段的开始地址，然后在代码段的下面留出一段内存实现malloc和全局参数，再留出一点给中断模式的栈和abort异常的栈，剩下的就是栈了：[start.S]12345678910/* Set up the stack */stack_setup: ldr r0, _TEXT_BASE /* upper 128 KiB: relocated uboot */ sub r0, r0, #CFG_MALLOC_LEN /* malloc area */ sub r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo */#ifdef CONFIG_USE_IRQ sub r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)#endif sub sp, r0, #12 /* leave 3 words for abort-stack */ 搬运FLASH中的代码到SDRAM 现在将Bootloader的全部代码复制到RAM中运行： [lowlevel_init.S]1234567891011121314151617relocate: /* relocate U-Boot to RAM */ adr r0, _start /* r0 &lt;- current position of code */ ldr r1, _TEXT_BASE /* test if we run from flash or RAM */ cmp r0, r1 /* don&apos;t reloc during debug */ beq clear_bss ldr r2, _armboot_start ldr r3, _bss_start sub r2, r3, r2 /* r2 &lt;- size of armboot */ bl CopyCode2Ram /* r0: source, r1: dest, r2: size */copy_loop: ldmia r0!, &#123;r3-r10&#125; /* copy from source address [r0] */ stmia r1!, &#123;r3-r10&#125; /* copy to target address [r1] */ cmp r0, r2 /* until source end addreee [r2] */ ble copy_loop 清除.bss段并跳转至第二阶段 bss段部分保存有静态变量、没有初始化或初始化值为0的全局变量，为了减小体积和防止程序在读取它们时，读取的时上次的值，所以需要先清0： [start.S]12345678910clear_bss: ldr r0, _bss_start /* find start of bss segment */ ldr r1, _bss_end /* stop here */ mov r2, #0x00000000 /* clear */clbss_l:str r2, [r0] /* clear loop... */ add r0, r0, #4 cmp r0, r1 ble clbss_lldr pc, _start_armboot 2.2第二阶段 第二阶段的代码在lib_arm/board.c中的start_armboot()函数开始，在内部调用各自函数进行设置： 设置时钟[smdk2410.c]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int board_init (void)&#123; S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER(); S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO(); /* to reduce PLL lock time, adjust the LOCKTIME register */ clk_power-&gt;LOCKTIME = 0xFFFFFF; /* configure MPLL */ clk_power-&gt;MPLLCON = ((M_MDIV &lt;&lt; 12) + (M_PDIV &lt;&lt; 4) + M_SDIV); /* some delay between MPLL and UPLL */ delay (4000); /* configure UPLL */ clk_power-&gt;UPLLCON = ((U_M_MDIV &lt;&lt; 12) + (U_M_PDIV &lt;&lt; 4) + U_M_SDIV); /* some delay between MPLL and UPLL */ delay (8000); /* set up the I/O ports */ gpio-&gt;GPACON = 0x007FFFFF; gpio-&gt;GPBCON = 0x00044555; gpio-&gt;GPBUP = 0x000007FF; gpio-&gt;GPCCON = 0xAAAAAAAA; gpio-&gt;GPCUP = 0x0000FFFF; gpio-&gt;GPDCON = 0xAAAAAAAA; gpio-&gt;GPDUP = 0x0000FFFF; gpio-&gt;GPECON = 0xAAAAAAAA; gpio-&gt;GPEUP = 0x0000FFFF; gpio-&gt;GPFCON = 0x000055AA; gpio-&gt;GPFUP = 0x000000FF; gpio-&gt;GPGCON = 0xFF95FFBA; gpio-&gt;GPGUP = 0x0000FFFF; gpio-&gt;GPHCON = 0x002AFAAA; gpio-&gt;GPHUP = 0x000007FF; /* arch number of SMDK2410-Board */ gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE_SMDK2410; /* adress of boot parameters */ gd-&gt;bd-&gt;bi_boot_params = 0x30000100; icache_enable(); dcache_enable(); return 0;&#125; 初始化串口[serial.c]1234567891011121314151617181920int serial_init (void)&#123; serial_setbrg (); return (0);&#125;/* * Read a single byte from the serial port. Returns 1 on success, 0 * otherwise. When the function is succesfull, the character read is * written into its argument c. */int serial_getc (void)&#123; S3C24X0_UART * const uart = S3C24X0_GetBase_UART(UART_NR); /* wait for character to arrive */ while (!(uart-&gt;UTRSTAT &amp; 0x1)); return uart-&gt;URXH &amp; 0xff;&#125; 监内存映射 在smdk2410.c里的函数dram_init中设置的内存起始地址为0x3000 0000,大小为0x4000 0000:[smdk2410.c]1234567int dram_init (void)&#123; gd-&gt;bd-&gt;bi_dram[0].start = PHYS_SDRAM_1; gd-&gt;bd-&gt;bi_dram[0].size = PHYS_SDRAM_1_SIZE; return 0;&#125; 至此，U-Boot的启动过程基本分析完了，在启动U-Boot后，通过lib_arm/armlinux.c中的do_boot_linux来启动内核。这里总结画个图来记录下，中间的顺序可能有点小差异，但大致没问题：3.U-Boot移植待补充。4.U-Boot使用记录下平时使用U-Boot烧写内核/根文件系统和挂载根文件系统，这里假设如下： Ubuntu中待作为nfs挂载的路径：/work/hceng/nfs_rootfsUbuntu IP：192.168.1.141开发板 IP：192.168.1.142网关 IP：192.168.1.1 这里要提前在Ubuntu虚拟机中进行NFS配置，参考上一篇文章中的：2.3安装、 配置网络服务； 启动U-Boot后，迅速按任意键进入U-Boot的下载模式，再输入”q”退出菜单。 设置开发板ip和nfs挂载的服务ip： 123setenv serverip 192.168.1.141 //设置服务器ubuntu ipsetenv ipaddr 192.168.1.142 //设置开发板ipsaveenv 设置u-boot各分区大小（内核也要相应设置匹配，在Linux-3.4.2内核中，文件在arch/arm/mach-s3c24xx/common-smdk.c中）: 12setenv mtdparts mtdparts=nandflash0:256k@0(bootloader),128k(params),4m(kernel),-(root)saveenv 下载、擦除、烧写内核： 123nfs 30000000 192.168.1.141:/work/hceng/nfs_rootfs/uImagenand erase kernelnand write.jffs2 30000000 kernel 下载、擦除、烧写根文件系统： 123nfs 30000000 192.168.1.141:/work/hceng/nfs_rootfs/fs_mini_mdev_new.yaffs2nand erase rootnand write.yaffs 30000000 4a0000 $(filesize) 根文件系统采用nand启动： 12set bootargs noinitrd root=/dev/mtdblock3 rootfstype=yaffs2 init=/linuxrc console=ttySAC0,115200saveenv 启动后，对应的NFS挂载： 1mount -t nfs 192.168.1.141:/work/hceng/nfs_rootfs /tmp 根文件系统采用nfs启动： 12set bootargs root=/dev/nfs nfsroot=192.168.1.141:/work/hceng/nfs_rootfs ip=192.168.1.142:192.168.1.141:192.168.1.1:255.255.255.0::eth0:off init=/linuxrc console=ttySAC0,115200 saveenv 最后启动：1boot 最后修改时间：2017/4/1 17:06:08 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/环境搭建/"}]},{"title":"从0到Q系列之一（开发环境搭建）","date":"2017-03-23T09:19:00.000Z","path":"2017/03/23/从0到Q系列之一（开发环境搭建）/","text":"该系列主要是为驱动学习提供基石，从0到Qt。本文是该系列的第一篇:在Ubuntu-16.04LTS上搭建好开发环境. 所需材料： 虚拟机：VMware-workstation-full-12.0.0-2985596.exe Ubuntu系统镜像：ubuntu-16.04.1-desktop-amd64.iso 交叉工具链：arm-linux-gcc-4.4.3.tar.gz 安装脚本：install-devel-packages.sh或install-devel-packages-for-16.sh 1.安装Ubuntu-16.04.1 打开安装好的虚拟机，选择创建新的虚拟机： 选择典型配置： 选择浏览找到ubuntu-16.04.1-desktop-amd64.iso并选中： 填入用户名、密码（本机密码：123456）： 设置虚拟机名称和保存路径： 设置虚拟机最大容量（60G差不多了）： 在弹出的向导中选择自定义硬件，设置内存、CPU、网络： 等待一会后，安装完毕，输入之前设置的密码进入系统： 点左上角的Ubuntu搜索图标，，输入t，将出现的Terminal控制台： 2.安装、配置必要软件2.1检查虚拟机网络设置 打开编辑-&gt;虚拟网络编辑器： 更改设置： 检查这三个配置： 输入ifconfig查看网络配置，再ping www.baidu.com测试： 2.2修改软件源 首先备份原来的文件：1$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup 用vi编辑器打开编辑：1$ sudo vi /etc/apt/sources.list 删掉文件中的所有内容，替换为以下文本：123456789101112131415161718# deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricteddeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse 注： 此时vi是不完全版的，很难用，编辑模式下方向键是乱的，使用gedit打开编辑，后面再更新vi：1$ sudo gedit /etc/apt/sources.list 此时Ubuntu默认装了VMware Tools，可以复制windows下的文本，然后ctrl+shift+v在Ubuntu里面粘贴文本。也支持windows里文件和Ubuntu的直接拖拽复制。 完成上面的修改后，再更新软件列表和安装完整的vim：12$ sudo apt-get update$ sudo apt-get install vim 安装过程中根据提示输入yes确认，下同。 2.3安装、 配置网络服务 执行以下命令安装 ftp、ssh、nfs服务：1$ sudo apt-get install vsftpd openssh-server nfs-kernel-server portmap 配置 FTP 服务：修改 vsftpd 的配置文件/etc/vsftpd.conf，检查下面两行前面的“#”号是否去掉。第28行，默认没有#：1local_enable=YES 第31行，默认有#，去掉#：1#local_enable=YES 注： 上面第一个表示是否允许本地用户登录，第二行个示是否允许上传文件。 在vim的命令模式输入如下命令即可显示行号：1:set nu 修改完华之后，执行以下命令重启 ftp 服务：1$ sudo /etc/init.d/vsftpd restart 配置 NFS 服务修改/etc/exports，增加以下内容，以后开发板可以通过网络文件系统访问/work 目录和专门用来作为根文件系统挂载的/work/hceng/nfs_rootfs目录： 12/work *(rw,sync,no_root_squash,no_subtree_check)/work/hceng/nfs_rootfs *(rw,sync,no_root_squash,no_subtree_check) 修改完华之后，执行以下命令重启 nfs 服务： 1$ sudo /etc/init.d/nfs-kernel-server restart 最后，关闭Ubuntu的防火墙：1$ sudo ufw disable 4.安装基本开发环境： 这里使用韦东山老师第四期安卓视频环境搭建提供的脚本，这个脚本会自动安装诸如 g++等工具、 库。但该脚本是为Ubuntu12制作的，Ubuntu16使用需要做一些修改，主要是名字变了。修改变化如下：1libgl1-mesa-glx-lts-quantal:i386 libgl1-mesa-dev-lts-quantal \\ 改为：1libgl1-mesa-glx-lts-xenial:i386 libgl1-mesa-dev-lts-xenial \\ 将修改后的脚本文件改为：install-devel-packages-for-16.sh 拖拽到自己建的/work/tool里面，加入可执行权限，然后执行：12$ sudo chmod +x install-devel-packages-for-16.sh$ sudo ./install-devel-packages-for-16.sh 然后报错,提示差mingw32： 解决：在源中加入如下部分：1deb http://cz.archive.ubuntu.com/ubuntu trusty main universe 再更新列表，再执行就没问题了：12$ sudo apt-get update$ sudo ./install-devel-packages-for-16.sh 3.安装基本开发环境 这里使用arm-linux-gcc-4.4.3.tar.gz，之前用的4.5出了问题，换成这个就好了，暂时用这个版本。把文件拖进/work/tool，解压到根目录：1$ sudo tar xzf arm-linux-gcc-4.4.3.tar.gz –C / 再修改环境变量： 1$ sudo vim /etc/ environment 把工具链目录添加到最后，内容如下： 1PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/opt/FriendlyARM/toolschain/4.4.3/bin&quot; 重启Ubuntu，输入如下命令检测是否正常： 1$ arm-linux-gcc –v 至此，开发环境以基本搭建完成。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/环境搭建/"}]},{"title":"设备驱动模型","date":"2017-03-18T15:44:00.000Z","path":"2017/03/18/设备驱动模型/","text":"最近在学设备驱动模型，东西比较多，时间比较紧，占个坑，回头分析完了再写。 设备驱动模型提供了硬件的抽象，内核可以使用该抽象完成很多硬件重复的工作，这样很多重复的代码就不需要重复编写和调试了。这些抽象包括：电源管理、即插即用设备的支持、与用户空间的通信。 1.sysfs文件系统 sysfs文件系统是Linux众多文件系统中的一个，在Linux中每个文件系统都要自己的特殊的用途。Liunx设备驱动模型由大量的数据结构和算法组成，数据结构之间通过指针相互关联，构成树形或者网状关系。显示这种关系最好的利用树形结构的文件系统，同时还要显示内核中一些关于设备、驱动和驱动的信息，因此内核开发者创造sysfs这种新文件系统来实现上述的要求。 sysfs是一个只存在于内存的文件系统，内核通过这个文件系统将系统信息导出到用户空间，同时用户空间的数据也能通过它传到内核中，实现设置驱动程序的状态和属性。 sysfs文件系统是内核对象（kobject）、属性（kobj_type）及它们互相关系的一种表现机制。内核与sysfs的关系如下： Linux内核中的结构 sysfs中的结构 kobject 目录 kobj_type 属性文件 对象间的关系 符号链接 2.核心数据结构 设备驱动模式由kobject、kset、subsystem这三个核心数据结构组成。 2.1 kobject最后修改时间：2017/4/2 1:58:22 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"}]},{"title":"Linux常用命令","date":"2017-03-12T15:14:00.000Z","path":"2017/03/12/Linux常用命令/","text":"本文主要汇总一些常用且不太熟练的Liunx命令，不定期更新。 1. tar作用：打包（拆包）/压缩（解压）文件； 语法：tar [主选项+辅选项] 文件或目录 主选项： c ：打包文件； x ：拆包文件； t ：列出包/压缩文件里有哪些文件。辅选项： z ：具有 gzip 属性；格式为xx.tar.gz或xx. tgz； j ：具有 bzip2 属性；格式为xx.tar.bz2； v ：显示压缩文件过程； f ：在其后必须是文件名； - -exclude xxx：打包除xxx文件之外的文件；示例：1234567$ tar cf test.tar test #打包test文件/文件夹为test.tar;$ tar xf test.tar #拆包test.tar；$ tar czf test.tar.gz test #压缩test文件/文件夹为test.tar.gz；$ tar xzf test.tar.gz #解压test.tar.gz；$ tar cjf test.bzip2 test #压缩test文件/文件夹为test.bzip2；$ tar xjf test.bzip2 #解压test.bzip2；$ tar cf test.tar --exclude test.txt test #打包test文件夹里除test.txt之外的为test.tar 2. grep作用：查找字符串； 语法：grep [选项] ‘搜寻字符串’ 文件名 选项： -c ：计算找到 ‘搜寻字符串’ 的次数; -i ：忽略大小写; -n ：顺便输出行号; -v ：反向选择，即显示出没有 ‘搜寻字符串’ 内容的那一行;示例：1$ grep -n &apos;test&apos; test.txt #搜索test.txt中含test的行，且显示对应行号； 3. find作用：选项较多，这里暂仅使用name选项查找文件； 语法：find 路径 -name “文件名”示例：1$ find -name &quot;test&quot; #在当前文件下找test文件； 4. ifconfig作用：网卡配置； 语法：ifconfig [网络设备] [参数]”示例：12345678#设置网卡1的地址 192.168.1.44，掩码为255.255.255.0（即默认）；$ ifconfig eth0 192.168.1.44 netmask 255.255.255.0#捆绑网卡1的第二个地址为 192.168.1.x$ ifconfig eth0:x 192.168.1.x#打开网卡1$ ifconfig eth0 up#关闭网卡1$ ifconfig eth0 down 5. mount作用：目前只用来挂载NFS； 语法：mount -t nfs 服务器ip:挂载目录 挂载到本地哪里”示例：12#把主机(192.168.1.44)的/work/hceng/nfs_rootfs挂载到本地/tmp目录下；$ mount -t nfs 192.168.1.44:/work/hceng/nfs_rootfs /tmp 6. 查看Linux版本信息示例：1234$ uname -a #显示电脑以及操作系统的相关信；$ cat /proc/version #正在运行的内核版本；$ cat /etc/issue #显示的是发行版本信息；$ lsb_release -a #列出所有版本信息； 7. 关闭防火墙示例：12$ ufw disable #关闭ubuntu的防火墙 ；$ ufw enable #开启防火墙； 7. source作用：免重启更新环境变量；示例：1$ source /etc/environment 最后修改时间：2017/3/31 19:57:49 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux基础/"}]},{"title":"Makefile小结","date":"2017-03-11T09:44:00.000Z","path":"2017/03/11/Makefile小结/","text":"本文主要是记录一些遇到的Makefile知识。 Makefile以韦东山老师第一期裸板视频中的 第8课LCD实验的配套代码lcd_3.5_4.3 中的Makefile为例，该工程有两个Makefile,分别位于根目录和lib目录中：[根目录Makefile]123456789101112131415161718192021222324252627282930313233CC = arm-linux-gccLD = arm-linux-ldAR = arm-linux-arOBJCOPY = arm-linux-objcopyOBJDUMP = arm-linux-objdumpINCLUDEDIR := $(shell pwd)/includeCFLAGS := -Wall -O2CPPFLAGS := -nostdinc -I$(INCLUDEDIR)export CC LD AR OBJCOPY OBJDUMP INCLUDEDIR CFLAGS CPPFLAGSobjs := head.o init.o nand.o interrupt.o serial.o lcddrv.o/ framebuffer.o lcdlib.o main.o lib libc.alcd.bin: $(objs) $&#123;LD&#125; -Tlcd.lds -o lcd_elf $^ $&#123;OBJCOPY&#125; -O binary -S lcd_elf $@ $&#123;OBJDUMP&#125; -D -m arm lcd_elf &gt; lcd.dis.PHONY : lib/libc.alib/libc.a: cd lib; make; cd .. %.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;clean: make clean -C lib rm -f lcd.bin lcd_elf lcd.dis *.o 主Makefile总领全局的就这句:1lcd.bin: $(objs)要生成lcd.bin，依赖于objs列举的一堆文件：head.o init.o nand.o interrupt.o serial.o lcddrv.o framebuffer.o lcdlib.o main.o lib libc.a，所以要先找到这些文件，几个.o，还有一个.a。 .o目标文件怎么生成？%.o:%.c和%.o:%.S是生成规则，就是依赖于.c或.S文件，使用交叉编译命令生成。 .a目标文件怎么生成？.a是库文件，到lib子目录里去找，在子目录里用make命令生成。 注:链接：将多.o文件，或者.o文件和库文件链接成为可被操作系统执行的可执行程序（Linux环境下，可执行文件的格式为“ELF”格式）。链接器不检查函数所在的源文件，只检查所有.o文件中的定义的符号。将.o文件中使用的函数和其它.o或者库文件中的相关符号进行合并，对所有文件中的符号进行重新安排（重定位），并链接系统相关文件（程序启动文件等）最终生成可执行程序。链接过程使用GNU 的“ld”工具。静态库：又称为文档文件（Archive File）。它是多个.o文件的集合。Linux中静态库文件的后缀为“.a”。静态库中的各个成员（.o文件）没有特殊的存在格式，仅仅是一个.o文件的集合。使用“ar”工具维护和管理静态库。共享库：也是多个.o文件的集合，但是这些.o文件时有编译器按照一种特殊的方式生成（Linux中，共享库文件格式通常为“ELF”格式。共享库已经具备了可执行条件）。模块中各个成员的地址（变量引用和函数调用）都是相对地址。使用此共享库的程序在运行时，共享库被动态加载到内存并和主程序在内存中进行连接。多个可执行程序可共享库文件的代码段（多个程序可以共享的使用库中的某一个模块，共享代码，不共享数据）。另外共享库的成员对象可被执行（由libdl.so提供支持）。 下面进行分析： 第一至五行：12345CC = arm-linux-gccLD = arm-linux-ldAR = arm-linux-arOBJCOPY = arm-linux-objcopyOBJDUMP = arm-linux-objdump 作用：将右边工具链名赋值给左边变量，为了简化书写； 分析： arm-linux-gcc：编译.c或.s头的C文件或汇编程序； arm-linux-ld：连接器，把多个.o文件或库文件连接成一个可执行文件； arm-linux-ar：库管理器，把多个.o文件合并成一个.o文件或静态库文件（.a文件）； arm-linux-objcopy：转换可执行文件的格式； arm-linux-objdump：生成反汇编； 第七行：1INCLUDEDIR := $(shell pwd)/include 作用：将shell命令和include组成的路径立即赋值给左边变量，为了简化书写； 分析：Makefile中调用shell命令：$(shell 命令)； ‘ = ’与‘ := ’的区别注： - “ = ”：make会将整个Makefile展开后，再决定变量的值。也就是说，变量的值将会是整个,Makefile中最后被指定的值。看例子： 123x = fooy = $(x) barx = xyz 在上例中，y的值将会是 xyz bar ，而不是 foo bar 。- “ := ”表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。 123x := fooy := $(x) barx := xyz 在上例中，y的值将会是 foo bar ，而不是 xyz bar 了。 第八行：1CFLAGS := -Wall -O2 作用：将gcc的编译参数赋值给左边变量，为了简化书写； 分析：-Wall显示所有编译错误或警告；-O2优化选项，编译时使用2级优化 第九行：1CPPFLAGS := -nostdinc -I$(INCLUDEDIR) 作用：将gcc编译路径参数赋值给左边变量，为了简化书写； 分析：-nostdinc忽略系统库目录（这里我们自定义了printf等系统函数，不能再包含系统文件里的相关函数）；-I指定搜索路径； 第十一行：1export CC LD AR OBJCOPY OBJDUMP INCLUDEDIR CFLAGS CPPFLAGS 作用：将变量传递到下级Makefile，类似于宏； 分析：本文件中指的是生成lib/libc.a库文件时的Makefile； 第十三行：12objs := head.o init.o nand.o interrupt.o serial.o lcddrv.o/ framebuffer.o lcdlib.o main.o lib libc.a 作用：定义变量objs，包含了生成目标文件所需的文件，为了简化书写； 分析：一行代码写不完，使用/符号可继续在下行写； 第十六行：1lcd.bin: $(objs) 作用：定义生成目标lcd.bin，依赖于objs对象； 分析：执行这条命令时，先生成所有依赖文件，然后依次执行后面三条命令； 第十七行：1$&#123;LD&#125; -Tlcd.lds -o lcd_elf $^ 作用：根据链接脚本lcd.lds链接，输出目的文件lcd_elf,依赖全部文件； 分析：-T指定链接脚本；$^表示全部依赖文件； 第十八行：1$&#123;OBJCOPY&#125; -O binary -S lcd_elf $@ 作用：将lcd_elf文件转换成二进制文件； 分析：-O表示输出格式;-S表示不从源文件中复制重定位信息和符号信息到目标文件中；$@表示全部目标文件； 第十九行：1$&#123;OBJDUMP&#125; -D -m arm lcd_elf &gt; lcd.dis 作用：将lcd_elf文件反汇编为lcd.dis文件； 分析：-m后面跟的是cpu构架;&gt;表示将这个程序的反汇编程序写入到led.dis这个文件中,在终端中不显示出来； 第二十一行：1.PHONY : lib/libc.a 作用：.PHONY伪目标，不要管lib/libc.a文件是否存在，都执行后面的指令； 分析：通常为了避免伪目标和文件重名的这种情况，使用特殊的记“.PHONY”来显示地指明一个目标是“伪目标”； 第二十二、二十三行：12lib/libc.a: cd lib; make; cd .. 作用：执行lib文件夹的Makefile，从而生成libc.a； 分析：执行shell指令，进入lib目录，make，退出； 第二十五至二十九行：1234%.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt; 作用：依赖所有的.c和.S文件，生成所有的.o文件； 分析：%通配符；-c编译不链接;$@表示目标文件;$&lt;表示第一个依赖文件; 第三十一至三十三行：1234%.o:%.Sclean: make clean -C lib rm -f lcd.bin lcd_elf lcd.dis *.o 作用：清理所有生成文件； 分析：-C lib即清理包括lib文件夹下生成的文件; 下面是lib目录Makefile: [lib目录Makefile]123456789101112131415objs := div64.o lib1funcs.o ctype.o muldi3.o printf.o string.o/vsprintf.olibc.a: $(objs) $&#123;AR&#125; -r -o $@ $^ %.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;clean: rm -f libc.a *.o 第一、二行：12objs := div64.o lib1funcs.o ctype.o muldi3.o printf.o string.o/vsprintf.o 作用：定义变量objs，包含了生成目标文件所需的文件，为了简化书写； 分析：一行代码写不完，使用/符号可继续在下行写； 第四、五行：12libc.a: $(objs) $&#123;AR&#125; -r -o $@ $^ 作用：使用库管理器生成lib.a； 分析：$@表示目标文件;$^所有依赖文件； 第七至十一行：1234%.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt; 作用：依赖所有的.c和.S文件，生成所有的.o文件； 分析：%通配符；-c编译不链接;$@表示目标文件;$&lt;表示第一个依赖文件; 第十三、十四行：123%.o:%.Sclean: rm -f libc.a *.o 作用：清理所有生成文件； 分析：-f强制删除; 参考博文：sekon LCD实验学习笔记（一）：Makefile 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"Makefile","slug":"Makefile","permalink":"http://yoursite.com/tags/Makefile/"}]},{"title":"汇编指令小结","date":"2017-03-10T03:55:00.000Z","path":"2017/03/10/汇编指令小结/","text":"本文主要是记录一些遇到的ARM汇编知识。 汇编代码以韦东山老师的 第7章nand flash实验配套代码13th_link_4096 中的start.S为例：[start.S]12345678910111213141516171819202122232425262728293031323334353637383940414243.globl _start_start:/* 硬件相关的设置 : 把外设的基地址告诉CPU*/ /* Peri port setup */ ldr r0, =0x70000000 orr r0, r0, #0x13 mcr p15,0,r0,c15,c2,4 @ 256M(0x70000000-0x7fffffff) /* 关看门狗 *//* 往WTCON(0x7E004000)写0 */ ldr r0, =0x7E004000 mov r1, #0 str r1, [r0]/* 重定位 */ adr r0, _start /* _start当前指令地址 */ ldr r1, =_start /* _start的编译地址 */ ldr r2, =bss_start cmp r0, r1 beq clean_bsscopy_loop: ldr r3, [r0], #4 str r3, [r1], #4 cmp r1, r2 bne copy_loop /* 清BSS段 */clean_bss: ldr r0, =bss_start ldr r1, =bss_end mov r2, #0clean_loop: str r2, [r0], #4 cmp r0, r1 bne clean_loop /* 设置栈 */ ldr sp, =8*1024 ldr pc, =main /* 重定位完后, 使用位置相关的指令跳转 */ bl mainhalt: b halt 第六行：1ldr r0, =0x70000000 格式：ldr&emsp;目的寄存器&emsp;&lt;存储器地址&gt; 作用：将 存储器地址 所指地址处连续的4个字节（1个字）的数据传送到目的寄存器中。 第七行：1orr r0, r0, #0x13 格式：orr&emsp;目的寄存器，&emsp;操作数 1，&emsp;操作数 2 作用：常用于设置操作数1 的某些位，在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中。操作数1 应是一个寄存器，操作数2 可以是一个寄存器、被移位的寄存器或一个立即数。 第八行：1mcr p15,0,r0,c15,c2,4 格式：mcr&emsp;协处理器编码，&emsp;协处理器操作码1，&emsp;源寄存器，&emsp;目的寄存器1，&emsp;目的寄存器2，&emsp;协处理器操作码2 作用：将ARM处理器寄存器中的数据传送到协处理器寄存器中,若协处理器不能成功完成操作，则产生未定义指令异常。其中协处理器操作码1 和协处理器操作码2 为协处理器将要执行的操作，源寄存器为ARM处理器的寄存器，目的寄存器1和目的寄存器2均为协处理器的寄存器。 第十四行：1str r1, [r0] 格式：str&emsp;源寄存器&emsp;&lt;存储器地址&gt; 作用：用于从源寄存器中将一个32位的字数据传送到存储器中。在ARM架构下, 数据从内存到CPU之间的移动只能通过ldr/str指令来完成。而mov只能在寄存器之间移动数据,或者把立即数移动到寄存器中,并且数据的长度不能超过8位。 第十七行：1adr r0, _start 格式：adr&emsp;目的寄存器&emsp;程序相对的表达式 作用：可将一个立即值与pc值相加，并将结果写入目标寄存器。adr可生成与位置无关的代码，因为地址相对于程序或寄存器。详见ARM指令adr。 第二十行：1cmp r0, r1 格式：cmp&emsp;操作数1，&emsp;操作数2 作用：用于把一个寄存器的内容和另一个寄存器的内容或立即数进行比较，同时更新CPSR中条件标志位的值。该指令进行一次减法运算，但不存储结果，只更改条件标志位。标志位表示的是操作数1与操作数2的关系(大、小、相等)，例如，当操作数1大于操作操作数2，则此后的有GT 后缀的指令将可以执行。 CPSR注： Z标志：是否为0；如比较指令产生相等的结果、计算结果为0； N标志：是否为负；如果指令的结果被认为是有符号数，而它的第31位为1，那就会被设置为1； C标志：是否有产生进位/借位，以及进行移位操作时作移出位使用； V标志：有符号数进行运算，结果是否有溢出。 第二十一行：1beq clean_bss 格式：beq&emsp;标签 作用：数据跳转指令，标志寄存器中Z标志位等于零时, 跳转到beq后标签处。 第二十六行：1bne copy_loop 格式：bne&emsp;标签 作用：数据跳转指令，标志寄存器中Z标志位不等于零时, 跳转到bne后标签处。 第四十一行：1bl main 格式：bl&emsp;子程序名 作用：b或bl指令引起处理器转移到子程序名处开始执行。两者的不同之处在于bl指令在转移到子程序执行之前，将其下一条指令的地址拷贝到R14（LR,链接寄存器）。由于bl指令保存了下条指令的地址，因此使用指令“mov pc, lr”即可实现子程序的返回。而b指令则无法实现子程序的返回，只能实现单纯的跳转。 ARM处理器控制程序执行方式注： 流水方式执行程序：PC的值是下一条指令的地址，即每执行一条指令PC都加一个字的偏移。 通过跳转指令来控制程序执行:b-跳转到指定的指令处执行;bl-跳转执行，保存子程序地址并返回;bx-跳转执行并切换到Thumb状态;blx-三种方式组合。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/tags/汇编/"}]},{"title":"GitHub+Hexo博客搭建及优化","date":"2017-03-06T11:26:00.000Z","path":"2017/03/06/GitHub+Hexo搭建及优化/","text":"本文主要是记录本博客的搭建和优化。 为什么做独立博客？我想大概就是激励自己去持续学习和思考。 首先说下本博客搭建的大致流程:1.有一个GitHub账号，同时配置GitHub Pages；2.安装、配置Hexo；3.配置博客、Markdown写文章；4.绑定自己域名（可选）；5.优化日常操作（可选）； 1.Github Pages Github Pages是GitHub提供的免费静态站点； 创建Github Pages后，在里面存放网页源码，然后在对应网址就可看到对应网页效果； 使用GitHub账号创建一个仓库，但是这个仓库是有规则的，其格式必须为：yourusername.github.io； 注： yourusername必须是自己的GitHub账号名； 类型只能选Public； 2.安装、配置Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。1、安装 Node.js;2、下载Cmder代替Windows自带cmd;3、安装 Git;4、添加本机密钥到GitHub;5、安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，在Git上设置username和email；其中3-5步在前一篇博文Git日常使用小结中已设置过了，无需再设置。6、安装 Hexo：使用 npm 安装 Hexo。1$ npm install -g hexo-cli至此，已经安装完Hexo,后续进行相关配置。7、在电脑上选一个盘，建个文件夹存放博客数据，例我的：E:\\blog；然后打开cmder，输入:12$ e: &amp; cd blog #进入所建文件夹$ hexo init blog #初始化blog成功初始化blog后将出现：1INFO Start blogging with Hexo!8、最后再生成静态网页，即可看到网页模板：12$ hexo generate # 启动本地服务器$ hexo server # 在浏览器输入 http://localhost:4000/就可以看见网页和模板了完成后，将会看到如下提示：12INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.此时，打开浏览器，输入http://localhost:4000/就可以看见默认的网页和模板了。 3.配置博客、发表文章 在blog目录下，用Sublime Text(使用它的原因是默认是UTF-8编码，中文不会乱码)打开_config.yml文件，修改参数信息； 注：在每个参数的”：”后都要加一个空格修改网站相关信息; 3.1修改网站相关信息：1234567# Sitetitle: 黄成的博客subtitle: Linux/Android驱动 description: 生命不息、折腾不止author: hcenglanguage: zh-CNtimezone: Asia/Shenzhen 3.2修改配置部署相关信息：123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: 'git@github.com:hceng/hceng.github.io.git' branch: master- type: git repo: 'git@git.coding.net:hceng/hceng.git' branch: coding-pages 这里由于我同时提交到了GitHub和Coding,用于测试百度收录，所以有两个，写一个也没事。 注:如果在执行 hexo deploy 后,出现 error deployer not found:github(git) 的错误，执行： 1$ npm install hexo-deployer-git --save 3.3修改主题： 为了让博客更加美观和符合自己需求，可以修改Hexo主题来满足自己需求。Hexo 安装主题的方式非常简单，只需要将主题文件放置于站点目录的 themes 目录下，然后修改下配置文件即可。 Hexo 有两份主要的配置文件（_config.yml），一份位于站点根目录下，另一份位于主题目录下。为了描述方便，在以下说明中，将前者称为 站点配置文件，后者称为 主题配置文件。 下载hexo-theme-yilia主题,解压放入themes文件夹下，如：E:\\blog\\blog\\themes，根据自己需求修改主题配置文件，最后再修改站点配置文件里的theme:1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-yilia 在主题配置文件里，修改头像、颜色、标签等，都有相应的注释写得非常清楚，按需修改。 3.4发表文章： 在Cmder中输入：12$ hexo new \"blog tags\"INFO Created: E:\\blog\\blog\\source\\_posts\\blog-tags.md 根据提示得路径，即可找到新建得文件，该文件使用Markdown语法，下载MarkdownPad2进行编辑。先修改相关的文章信息：123456---title: blog tagstags: - 随笔--- 本文主要是总结blog预计的标签，并不定时更新。 可修改标题、标签（本有日期的修改选项，但有日期就不能显示文章，怀疑是主题或者其它地方干扰了，文章日期就是文件创建日期）。然后简单说下Markdown语法： 3.4.1标题和引用 行首插入 1 到 6 个 # ，对应到标题 1 到 6 级标题： 123# 一级标题## 二级标题## 三标题 效果：见本文（影响目录效果，就不示例了）。 区块引用则使用 ‘&gt;’ 角括号来表示： 1&gt; 这是引用 效果： 这是引用 3.4.2列表和强调 列表分有序的1、2、3和无序的·：12- 列表1- 列表2 效果： 列表1 列表2 强调有加粗和斜体，用”*”来表示： 12**加粗***斜体* 效果：加粗斜体 3.4.3超链接和图片 在方括号”[]”写要显示标，在小括号”()”写链接：1[hceng blog](http://hceng.cn/)效果：hceng blog 在文章如果需要加入图片，先需要把图片传到床图网站，生成链接后插入使用，格式如下：1![](图片网址) 3.4.4加入代码 Markdown支持插入代码，使用单引号”`“来标注,注意是英文输入法下，左上角那个按键：1`hello`效果：hello 这种方式感觉不够醒目，而且不支持语法高亮，所以我一般使用Codeblock，语法见网站，效果如下：123456#include &lt;stdio.h&gt;int main(void)&#123; printf(\"hello,world!\"); return 0;&#125; 4.绑定自己域名（可选） 完成以上步骤后，默认域名是GitHub提供的二级域名：yoursname.github.io,下面开始绑定自己的域名： 4.1购买域名 推荐GoDaddy或万网； 我是在万网买的，首推买.com，其次.me、.top、.cn系列，根据自己喜好来，各有特色优缺点； 然后继续交实名认证、审核，还是比较快；4.2绑定域名 保证上述工作完成，域名可用； 修改DNS，分别修改为：f1g1ns1.dnspod.net和f1g1ns2.dnspod.net 本地站点目录里的source目录下添加一个CNAME文件，里面写上网址； 注:CNAME不要有任何后缀；网址不要写www或http：//,直接写hceng.cn这种； 注册DNSpod，然后添加域名，添加记录： 参考红线部分填写，一个主机纪录是@，记录类型是CNAME，线路类型填默认（图片中是我测试百度抓取用的），记录值写对应的GitHub Pages的地址；另一个主机纪录填www，其它和上面的一样。 最后把本地的Hexo生成一下，再提交到Github pages上； 5.优化日常操作（可选）5.1hexo命令简写：12345$ hexo n “新文章” == hexo new “新文章” #新建文章$ hexo c == hexo clear #清理静态文件$ hexo g == hexo generate #生成静态文件$ hexo s == hexo server #启动本地预览$ hexo d == hexo deploy #上传部署 5.2添加版权信息：1.在博客根目录下（和 source 同级），新建一个名为 scripts 的文件夹；2.在 scripts 文件夹内, 新建一个 AddTail.js 脚本文件，脚本具体内容详见下文；3.在博客根目录下，新建一个 tail.md 文件，里面写想要展示的版本说明内容;AddTail.js 脚本文件：1234567891011121314151617181920212223242526272829303132333435// Filename: AddTail.js// Author: Colin// Date: 2016/06/02// Based on the script by KUANG Qi: http://kuangqi.me/tricks/append-a-copyright-info-after-every-post/// Add a tail to every post from tail.md// Great for adding copyright infovar fs = require('fs');hexo.extend.filter.register('before_post_render', function(data)&#123; if(data.copyright == false) return data; // Add seperate line data.content += '\\n___\\n'; // Try to read tail.md try &#123; var file_content = fs.readFileSync('tail.md'); if(file_content &amp;&amp; data.content.length &gt; 50) &#123; data.content += file_content; &#125; &#125; catch (err) &#123; if (err.code !== 'ENOENT') throw err; // No process for ENOENT error &#125; // 添加具体文章链接, 不需要去掉即可 //var permalink = '\\n本文链接：' + data.permalink; //data.content += permalink; return data;&#125;);tail.md 文件：去Creative Commons根据自己需求，生成合适的许可，然后复制到tail.md 文件中； 参考博客：如何添加版权信息 5.3自动添加目录： 修改主题的ejs文件 打开文件：themes/你的主题/layout/_partial/article.ejs 在这个文件中找到&lt;%- post.content %&gt;，并在这之前加入以下代码：1234567&lt;!-- Table of Contents --&gt;&lt;% if (!index &amp;&amp; post.toc)&#123; %&gt;&lt;div id=\"toc\" class=\"toc-article\"&gt;&lt;strong class=\"toc-title\"&gt;文章目录&lt;/strong&gt;&lt;%- toc(post.content, &#123;list_number: false&#125;) %&gt;&lt;/div&gt;&lt;% &#125; %&gt; 这里if语句中有两个条件，!index是为了不在首页的文章摘要中生成目录，post.toc确保了只在显式地标记了toc: true的文章中生成目录。若这两个条件满足，则创建一个目录的div。第五行表示不自动生成标号，不然加上自己的标号会有两个。 为需要的文章添加标记 5.4添加访问人数统计： 安装脚本： 打开themes/你的主题/layout/_partial/footer.ejs添加下面脚本：12&lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 在需要的位置添加添加显示： 这里我用的Yilia的主题，不蒜子官方给的例子没有成功，这里自己需求是在底部中间显示统计量，于是在footer.ejs中间添加如下代码：123&lt;div class=\"footer-centre\"&gt; &amp;hearts; Total view my blog &lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt; times&lt;/div&gt; 这里我浏览量数据是+2的增加，还无解中。。参考链接：不蒜子5.5脚本自动化： 每次发布文章大致分为清理静态文件、生成静态文件、启动本地预览或上传部署，连续这么多命令何不合成一个，于是在windows下，可新建几个批处理脚本:[make1.bat]12#生成最新本地预览hexo clean &amp; hexo g &amp;hexo s [make2.bat]12#发布生成最新博客hexo clean &amp; hexo g &amp; hexo d [make3.bat]123#发成最新博客并上传源码到Coding私有库，以便在其它电脑上编辑hexo clean &amp; hexo g &amp; hexo d &amp; git add -A &amp; git commit -m &quot;from make3&quot; &amp; \\git push origin master 在Cmder中，输入对应的makeN,即可自动完成一系列命令。 最后修改时间：2017/3/31 20:42:06 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Git日常使用小结","date":"2017-03-02T06:14:00.000Z","path":"2017/03/02/Git日常使用小结/","text":"本文主要是记录一些Git的配置和命令。关于代码托管，我目前主要使用两个： GitHub：主要用于托管公开代码和利用GitHub Pages搭建本博客； Coding：主要用于同步GitHub代码和托管私人代码；下面纪录下Git的安装、配置、使用。 1.安装GitWindows：git-for-windowsysGitMac OS:从AppStore安装Xcode,选择菜单“Xcode”-&gt;“Preferences”，找到“Downloads”，选择“Command Line Tools”，点“Install”。Linux:1$ sudo apt-get install git 2.创建本地仓库并上传2.1在本地创建仓库 第一次打开Git时,首先要在Git上设置username和email；12$ git config --global user.name &quot;hceng&quot; #与注册的账号邮箱一致；$ git config --global user.email &quot;huangcheng.job@foxmail.com&quot; 在命令行里(这里使用Cmder软件)先进入欲作为仓库的文件夹（如：E:/blog文件夹），然后初始化——创建本地仓库:12$ e: &amp; cd blog #进入E盘的blog文件夹；$ git init #初始化当前文件夹作为仓库（生成.git文件夹）； 这时生成一个”.git”目录，该目录是Git来跟踪管理版本，一般情况勿动；2.2添加文件到本地仓库12$ touch readme.txt #创建一个测试文件；$ git add readme.txt #将当前更改或者新增的文件加入到临时空间中； 注： add 命令只是把文件添加到一个临时空间里，需要执行第3 步的commit 命令才会正式提交到仓库中； 如果文件太多，可以使用以下命令一次性提交所有文件(.gitignore 文件指定的除外)；1$ git add -A 可以在当前目录下新建一个名为“.gitignore”的文件，它里面的内容用来表示某类/某个文件将不会被提交到仓库。 2.3提交文件到本地仓库执行以下命令，这会把临时空间的内容存入本地仓库，并添加注释：1$ git commit -m &quot;blog, add 1 files&quot; 可以使用以下命令查看记录：1$ git log --pretty=oneline得到类似信息，前面为版本号，后面为注释：112ewdqe2q... blog, add 1 files可以给某个版本号打上一个标签，命令如下：1$ git tag v1 12ew可以使用以下命令查看已有的标签：1$ git tag 2.4提交文件到GitHub/Coding第一次提交前，需要将本机密钥上传到GitHub/Coding；2.4.1.创建SSH Key：在用户主目录下，看看有没有.ssh 目录，如果有，再看看这个目录下有没有id_rsa 和id_rsa.pub 这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Git Bash，创建SSH Key，命令如下：1$ ssh-keygen -t rsa -C &quot;huangcheng.job@foxmail.com&quot;然后一路回车，使用默认值即可。这样在用户主目录里就会生成.ssh 目录，里面有id_rsa 和id_rsa.pub 两个文件，它们是SSH Key 的秘钥对。id_rsa 是私钥，不能泄露出去；id_rsa.pub 是公钥，可以放心地告诉任何人。 2.4.2.在GitHub 里添加SSH Key：电脑登陆GitHub,在自己账户的”Settings”-“SSH Key”中添加id_rsa.pub 文件的内容；2.4.3.创建一个仓库如:git_hexo,第一次上传需要指定GitHub/Coding仓库，如Coding的git_hexo：12$ git remote add origin https://git.coding.net/hceng/$ git_hexo.git然后根据提示输入账号、密码，最后执行以下指令提交至GitHub/Coding；12$ git push -u origin master$ git push origin --tags 2.5以后如果修改文件后再次提交12345$ git add –A # 添加修改文件到临时空间；$ git commit -m &quot;blog, git use&quot; # 添加本地仓库和添加备注；$ git tag v2 # 打标签；$ git push origin master # 上传到服务器的master；$ git push origin --tags # 上传标签到服务器； 3.Git 获取GitHub/Coding源码 执行以下命令，可以复制他人public代码，这称为“克隆”：1$ git clone https://github.com/hceng/hceng.github.io 当源码作者再次修改了源码后，可以进入对应目录，然后使用以下命令再次获得最新的：1$ git pull origin 查看信息纪录：1$ git log --pretty=oneline 查看标签：1$ git tag 获得指定版本的源码：123$ git checkout &lt;commit id&gt;或$ git checkout &lt;tag_name&gt; 4.分支管理4.1查看所有分支：1$ git branch --all # 本地主分支：master；远程主分支：origin/master； 4.2创建本地分支：12$ git branch bak # 创建本地分支；$ git branch # 查看本分支；&quot;*&quot;号表示当前所在分支； 4.3发布新分支：即：将本地新建的bak分支同步到远程服务器GitHub/Coding;12$ git push origin bak # 这样远程仓库也有一个bak分支了；$ git checkout bak # 切换到bak分支操作；第一种情况：bak分支开发完成，合并到主分支：12345$ git checkout master # 切换到主分支；$ git merge bak # 把bak分支的更改和master合并；$ git push # 提交主分支代码远程；$ git checkout bak # 切换到bak远程分支；$ git push # 提交bak分支到远程； 第二种情况：bak分支没开发完，推送保存，下次再开发：123$ git add -A # 添加修改文件到临时空间；$ git commit -m &quot;bak branch&quot; # 提交本地bak分支仓库；$ git push # 提交bak分支到远程； 4.4删除分支：12345# 删除远程bak分支，危险命令；$ git push origin :bak # 下面两条是删除本地分支;$ git checkout master # 切换到master分支$ git branch -d bak # 删除本地dev分支 参考： 5.其它常用指令12345678910 $ git status #查看仓库状态; $ git diff XX #查看XX文件修改了那些内容;$ git log #查看历史记录;$ git reflog #查看历史记录(含回退纪录)；$ git reset –hard HEAD^ #回退到上一个版本; $ git reset –hard HEAD~ #回退到上一个版本;$ git reset –hard HEAD~100 #回退到100个版本;$ git checkout – XX #把XX文件在工作区的修改全部撤销； $ git rm XX #删除XX文件； 参考资料：韦东山Android系统视频使用手册20160303 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"blog tags","date":"2017-03-01T00:00:00.000Z","path":"2017/03/01/tags/","text":"本文主要是总结blog预计的标签，并不定时更新。 驱动相关 Linux驱动 Android驱动 环境搭建 调试技巧 Linux基础 Makefile 汇编 裸机 STM32 硬件 PCB 设计 PS AE/PR PPT Git git hexo 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]