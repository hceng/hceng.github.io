[{"title":"Makefile小结","date":"2017-03-11T06:40:04.291Z","path":"2017/03/11/Makefile小结/","text":"本文主要是纪录一些遇到的Makefile知识。 Makefile以韦东山老师第一期裸板视频中的 第8课LCD实验的配套代码lcd_3.5_4.3 中的Makefile为例，该工程有两个Makefile,分别位于根目录和lib目录中：[根目录Makefile]123456789101112131415161718192021222324252627282930313233CC = arm-linux-gccLD = arm-linux-ldAR = arm-linux-arOBJCOPY = arm-linux-objcopyOBJDUMP = arm-linux-objdumpINCLUDEDIR := $(shell pwd)/includeCFLAGS := -Wall -O2CPPFLAGS := -nostdinc -I$(INCLUDEDIR)export CC LD AR OBJCOPY OBJDUMP INCLUDEDIR CFLAGS CPPFLAGSobjs := head.o init.o nand.o interrupt.o serial.o lcddrv.o/ framebuffer.o lcdlib.o main.o lib libc.alcd.bin: $(objs) $&#123;LD&#125; -Tlcd.lds -o lcd_elf $^ $&#123;OBJCOPY&#125; -O binary -S lcd_elf $@ $&#123;OBJDUMP&#125; -D -m arm lcd_elf &gt; lcd.dis.PHONY : lib/libc.alib/libc.a: cd lib; make; cd .. %.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;clean: make clean -C lib rm -f lcd.bin lcd_elf lcd.dis *.o 主Makefile总领全局的就这句:1lcd.bin: $(objs)要生成lcd.bin，依赖于objs列举的一堆文件：head.o init.o nand.o interrupt.o serial.o lcddrv.o framebuffer.o lcdlib.o main.o lib libc.a，所以要先找到这些文件，几个.o，还有一个.a。 .o目标文件怎么生成？%.o:%.c和%.o:%.S是生成规则，就是依赖于.c或.S文件，使用交叉编译命令生成。 .a目标文件怎么生成？.a是库文件，到lib子目录里去找，在子目录里用make命令生成。 注:链接：将多.o文件，或者.o文件和库文件链接成为可被操作系统执行的可执行程序（Linux环境下，可执行文件的格式为“ELF”格式）。链接器不检查函数所在的源文件，只检查所有.o文件中的定义的符号。将.o文件中使用的函数和其它.o或者库文件中的相关符号进行合并，对所有文件中的符号进行重新安排（重定位），并链接系统相关文件（程序启动文件等）最终生成可执行程序。链接过程使用GNU 的“ld”工具。静态库：又称为文档文件（Archive File）。它是多个.o文件的集合。Linux中静态库文件的后缀为“.a”。静态库中的各个成员（.o文件）没有特殊的存在格式，仅仅是一个.o文件的集合。使用“ar”工具维护和管理静态库。共享库：也是多个.o文件的集合，但是这些.o文件时有编译器按照一种特殊的方式生成（Linux中，共享库文件格式通常为“ELF”格式。共享库已经具备了可执行条件）。模块中各个成员的地址（变量引用和函数调用）都是相对地址。使用此共享库的程序在运行时，共享库被动态加载到内存并和主程序在内存中进行连接。多个可执行程序可共享库文件的代码段（多个程序可以共享的使用库中的某一个模块，共享代码，不共享数据）。另外共享库的成员对象可被执行（由libdl.so提供支持）。 下面进行分析： 第一至五行：12345CC = arm-linux-gccLD = arm-linux-ldAR = arm-linux-arOBJCOPY = arm-linux-objcopyOBJDUMP = arm-linux-objdump 作用：将右边工具链名赋值给左边变量，为了简化书写； 分析： arm-linux-gcc：编译.c或.s头的C文件或汇编程序； arm-linux-ld：连接器，把多个.o文件或库文件连接成一个可执行文件； arm-linux-ar：库管理器，把多个.o文件合并成一个.o文件或静态库文件（.a文件）； arm-linux-objcopy：转换可执行文件的格式； arm-linux-objdump：生成反汇编； 第七行：1INCLUDEDIR := $(shell pwd)/include 作用：将shell命令和include组成的路径立即赋值给左边变量，为了简化书写； 分析：Makefile中调用shell命令：$(shell 命令)； ‘ = ’与‘ := ’的区别注： - “ = ”：make会将整个Makefile展开后，再决定变量的值。也就是说，变量的值将会是整个,Makefile中最后被指定的值。看例子： 123x = fooy = $(x) barx = xyz 在上例中，y的值将会是 xyz bar ，而不是 foo bar 。- “ := ”表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。 123x := fooy := $(x) barx := xyz 在上例中，y的值将会是 foo bar ，而不是 xyz bar 了。 第八行：1CFLAGS := -Wall -O2 作用：将gcc的编译参数赋值给左边变量，为了简化书写； 分析：-Wall显示所有编译错误或警告；-O2优化选项，编译时使用2级优化 第九行：1CPPFLAGS := -nostdinc -I$(INCLUDEDIR) 作用：将gcc编译路径参数赋值给左边变量，为了简化书写； 分析：-nostdinc忽略系统库目录（这里我们自定义了printf等系统函数，不能再包含系统文件里的相关函数）；-I指定搜索路径； 第十一行：1export CC LD AR OBJCOPY OBJDUMP INCLUDEDIR CFLAGS CPPFLAGS 作用：将变量传递到下级Makefile，类似于宏； 分析：本文件中指的是生成lib/libc.a库文件时的Makefile； 第十三行：12objs := head.o init.o nand.o interrupt.o serial.o lcddrv.o/ framebuffer.o lcdlib.o main.o lib libc.a 作用：定义变量objs，包含了生成目标文件所需的文件，为了简化书写； 分析：一行代码写不完，使用/符号可继续在下行写； 第十六行：1lcd.bin: $(objs) 作用：定义生成目标lcd.bin，依赖于objs对象； 分析：执行这条命令时，先生成所有依赖文件，然后依次执行后面三条命令； 第十七行：1$&#123;LD&#125; -Tlcd.lds -o lcd_elf $^ 作用：根据链接脚本lcd.lds链接，输出目的文件lcd_elf,依赖全部文件； 分析：-T指定链接脚本；$^表示全部依赖文件； 第十八行：1$&#123;OBJCOPY&#125; -O binary -S lcd_elf $@ 作用：将lcd_elf文件转换成二进制文件； 分析：-O表示输出格式;-S表示不从源文件中复制重定位信息和符号信息到目标文件中；$@表示全部目标文件； 第十九行：1$&#123;OBJDUMP&#125; -D -m arm lcd_elf &gt; lcd.dis 作用：将lcd_elf文件反汇编为lcd.dis文件； 分析：-m后面跟的是cpu构架;&gt;表示将这个程序的反汇编程序写入到led.dis这个文件中,在终端中不显示出来； 第二十一行：1.PHONY : lib/libc.a 作用：.PHONY伪目标，不要管lib/libc.a文件是否存在，都执行后面的指令； 分析：通常为了避免伪目标和文件重名的这种情况，使用特殊的记“.PHONY”来显示地指明一个目标是“伪目标”； 第二十二、二十三行：12lib/libc.a: cd lib; make; cd .. 作用：执行lib文件夹的Makefile，从而生成libc.a； 分析：执行shell指令，进入lib目录，make，退出； 第二十五至二十九行：1234%.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt; 作用：依赖所有的.c和.S文件，生成所有的.o文件； 分析：%通配符；-c编译不链接;$@表示目标文件;$&lt;表示第一个依赖文件; 第三十一至三十三行：1234%.o:%.Sclean: make clean -C lib rm -f lcd.bin lcd_elf lcd.dis *.o 作用：清理所有生成文件； 分析：-C lib即清理包括lib文件夹下生成的文件; 下面是lib目录Makefile: [lib目录Makefile]123456789101112131415objs := div64.o lib1funcs.o ctype.o muldi3.o printf.o string.o/vsprintf.olibc.a: $(objs) $&#123;AR&#125; -r -o $@ $^ %.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;clean: rm -f libc.a *.o 第一、二行：12objs := div64.o lib1funcs.o ctype.o muldi3.o printf.o string.o/vsprintf.o 作用：定义变量objs，包含了生成目标文件所需的文件，为了简化书写； 分析：一行代码写不完，使用/符号可继续在下行写； 第四、五行：12libc.a: $(objs) $&#123;AR&#125; -r -o $@ $^ 作用：使用库管理器生成lib.a； 分析：$@表示目标文件;$^所有依赖文件； 第七至十一行：1234%.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt; 作用：依赖所有的.c和.S文件，生成所有的.o文件； 分析：%通配符；-c编译不链接;$@表示目标文件;$&lt;表示第一个依赖文件; 第十三、十四行：123%.o:%.Sclean: rm -f libc.a *.o 作用：清理所有生成文件； 分析：-f强制删除; 参考博文：sekon LCD实验学习笔记（一）：Makefile 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自Hceng’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"Makefile","slug":"Makefile","permalink":"http://yoursite.com/tags/Makefile/"}]},{"title":"汇编指令小结","date":"2017-03-10T13:10:21.279Z","path":"2017/03/10/汇编指令小结/","text":"本文主要是纪录一些遇到的ARM汇编知识。 汇编代码以韦东山老师的 第7章nand flash实验配套代码13th_link_4096 中的start.S为例：[start.S]12345678910111213141516171819202122232425262728293031323334353637383940414243.globl _start_start:/* 硬件相关的设置 : 把外设的基地址告诉CPU*/ /* Peri port setup */ ldr r0, =0x70000000 orr r0, r0, #0x13 mcr p15,0,r0,c15,c2,4 @ 256M(0x70000000-0x7fffffff) /* 关看门狗 *//* 往WTCON(0x7E004000)写0 */ ldr r0, =0x7E004000 mov r1, #0 str r1, [r0]/* 重定位 */ adr r0, _start /* _start当前指令地址 */ ldr r1, =_start /* _start的编译地址 */ ldr r2, =bss_start cmp r0, r1 beq clean_bsscopy_loop: ldr r3, [r0], #4 str r3, [r1], #4 cmp r1, r2 bne copy_loop /* 清BSS段 */clean_bss: ldr r0, =bss_start ldr r1, =bss_end mov r2, #0clean_loop: str r2, [r0], #4 cmp r0, r1 bne clean_loop /* 设置栈 */ ldr sp, =8*1024 ldr pc, =main /* 重定位完后, 使用位置相关的指令跳转 */ bl mainhalt: b halt 第六行：1ldr r0, =0x70000000 格式：ldr&emsp;目的寄存器&emsp;&lt;存储器地址&gt; 作用：将 存储器地址 所指地址处连续的4个字节（1个字）的数据传送到目的寄存器中。 第七行：1orr r0, r0, #0x13 格式：orr&emsp;目的寄存器，&emsp;操作数 1，&emsp;操作数 2 作用：常用于设置操作数1 的某些位，在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中。操作数1 应是一个寄存器，操作数2 可以是一个寄存器、被移位的寄存器或一个立即数。 第八行：1mcr p15,0,r0,c15,c2,4 格式：mcr&emsp;协处理器编码，&emsp;协处理器操作码1，&emsp;源寄存器，&emsp;目的寄存器1，&emsp;目的寄存器2，&emsp;协处理器操作码2 作用：将ARM处理器寄存器中的数据传送到协处理器寄存器中,若协处理器不能成功完成操作，则产生未定义指令异常。其中协处理器操作码1 和协处理器操作码2 为协处理器将要执行的操作，源寄存器为ARM处理器的寄存器，目的寄存器1和目的寄存器2均为协处理器的寄存器。 第十四行：1str r1, [r0] 格式：str&emsp;源寄存器&emsp;&lt;存储器地址&gt; 作用：用于从源寄存器中将一个32位的字数据传送到存储器中。在ARM架构下, 数据从内存到CPU之间的移动只能通过ldr/str指令来完成。而mov只能在寄存器之间移动数据,或者把立即数移动到寄存器中,并且数据的长度不能超过8位。 第十七行：1adr r0, _start 格式：adr&emsp;目的寄存器&emsp;程序相对的表达式 作用：可将一个立即值与pc值相加，并将结果写入目标寄存器。adr可生成与位置无关的代码，因为地址相对于程序或寄存器。详见ARM指令adr。 第二十行：1cmp r0, r1 格式：cmp&emsp;操作数1，&emsp;操作数2 作用：用于把一个寄存器的内容和另一个寄存器的内容或立即数进行比较，同时更新CPSR中条件标志位的值。该指令进行一次减法运算，但不存储结果，只更改条件标志位。标志位表示的是操作数1与操作数2的关系(大、小、相等)，例如，当操作数1大于操作操作数2，则此后的有GT 后缀的指令将可以执行。 CPSR注： Z标志：是否为0；如比较指令产生相等的结果、计算结果为0； N标志：是否为负；如果指令的结果被认为是有符号数，而它的第31位为1，那就会被设置为1； C标志：是否有产生进位/借位，以及进行移位操作时作移出位使用； V标志：有符号数进行运算，结果是否有溢出。 第二十一行：1beq clean_bss 格式：beq&emsp;标签 作用：数据跳转指令，标志寄存器中Z标志位等于零时, 跳转到beq后标签处。 第二十六行：1bne copy_loop 格式：bne&emsp;标签 作用：数据跳转指令，标志寄存器中Z标志位不等于零时, 跳转到bne后标签处。 第四十一行：1bl main 格式：bl&emsp;子程序名 作用：b或bl指令引起处理器转移到子程序名处开始执行。两者的不同之处在于bl指令在转移到子程序执行之前，将其下一条指令的地址拷贝到R14（LR,链接寄存器）。由于bl指令保存了下条指令的地址，因此使用指令“mov pc, lr”即可实现子程序的返回。而b指令则无法实现子程序的返回，只能实现单纯的跳转。 ARM处理器控制程序执行方式注： 流水方式执行程序：PC的值是下一条指令的地址，即每执行一条指令PC都加一个字的偏移。 通过跳转指令来控制程序执行:b-跳转到指定的指令处执行;bl-跳转执行，保存子程序地址并返回;bx-跳转执行并切换到Thumb状态;blx-三种方式组合。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自Hceng’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/tags/汇编/"}]},{"title":"GitHub+Hexo博客搭建及优化","date":"2017-03-06T07:17:58.000Z","path":"2017/03/06/GitHub+Hexo搭建及优化/","text":"本文主要是纪录本博客的搭建和优化。 为什么做独立博客？我想主要是激励自己去持续学习和思考。 首先说下本博客搭建的大致流程:1.有一个GitHub账号，同时配置GitHub Pages；2.安装、配置Hexo；3.配置博客、Markdown写文章；4.绑定自己域名（可选）；5.优化日常操作（可选）； 1.Github PagesGithub Pages是GitHub提供的免费静态站点；创建Github Pages后，在里面存放网页源码，然后在对应网址就可看到对应网页效果；使用GitHub账号创建一个仓库，但是这个仓库是有规则的，其格式必须为：yourusername.github.io； 注： yourusername必须是自己的GitHub账号名； 类型只能选Public； 2.安装、配置HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。1、安装 Node.js;2、下载cmder代替Windows自带cmd;3、安装 Git;4、添加本机密钥到GitHub;5、安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，在Git上设置username和email；12$ git config --global user.name &quot;hceng&quot;$ git config --global user.email &quot;huangcheng.job@foxmail.com&quot;其中3-4步在前一篇博文Git日常使用小结中已设置过了，无需再设置。6、安装 Hexo：使用 npm 安装 Hexo。1$ npm install -g hexo-cli至此，已经安装完Hexo,后续进行相关配置。7、在电脑上选一个盘，建个文件夹存放博客数据，例我的：E:\\blog；然后打开cmder，输入:12$ e:&amp;cd blog #进入所建文件夹$ hexo init blog #初始化blog成功初始化blog后将出现：1INFO Start blogging with Hexo!8、最后再生成静态网页，即可看到网页模板：12$ hexo generate # 启动本地服务器$ hexo server # 在浏览器输入 http://localhost:4000/就可以看见网页和模板了完成后，将会看到如下提示：12INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.此时，打开浏览器，输入http://localhost:4000/就可以看见默认的网页和模板了。 3.配置博客、发表文章在blog目录下，用sublime打开_config.yml文件，修改参数信息； 注：在每个参数的：后都要加一个空格修改网站相关信息 修改网站相关信息：1234567# Sitetitle: 黄成的博客subtitle: Linux/Android驱动 description: 生命不息、折腾不止author: hcenglanguage: zh-CNtimezone: Asia/Shenzhen 修改配置部署相关信息：123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/hceng/hceng.github.io.git branch: master 修改主题：为了让博客更加美观和符合自己需求，可以修改Hexo主题来满足自己需求。Hexo 安装主题的方式非常简单，只需要将主题文件放置于站点目录的 themes 目录下，然后修改下配置文件即可。Hexo 有两份主要的配置文件（_config.yml），一份位于站点根目录下，另一份位于主题目录下。为了描述方便，在以下说明中，将前者称为 站点配置文件，后者称为 主题配置文件。下载hexo-theme-yilia主题,解压放入themes文件夹下，如：E:\\blog\\blog\\themes，根据自己需求修改主题配置文件，最后再修改站点配置文件里的theme:1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-yilia 。。。未完待续 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自Hceng’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Git日常使用小结","date":"2017-03-01T19:15:17.000Z","path":"2017/03/02/Git日常使用小结/","text":"本文主要是纪录一些Git的配置和命令。关于代码托管，我目前主要使用两个： GitHub：主要用于托管公开代码和利用GitHub Pages搭建本博客； Coding：主要用于同步GitHub代码和托管私人代码；下面纪录下Git的安装、配置、使用。 1.安装GitWindows：git-for-windowsysGitMac OS:从AppStore安装Xcode,选择菜单“Xcode”-&gt;“Preferences”，找到“Downloads”，选择“Command Line Tools”，点“Install”。Linux:1$ sudo apt-get install git 2.创建本地仓库并上传2.1在本地创建仓库 第一次打开Git时,首先要在Git上设置username和email；12$ git config --global user.name &quot;hceng&quot; #与注册的账号邮箱一致；$ git config --global user.email &quot;huangcheng.job@foxmail.com&quot; 在命令行里(这里使用Cmder软件)先进入欲作为仓库的文件夹（如：E:/blog文件夹），然后初始化——创建本地仓库:12$ e: &amp; cd blog #进入E盘的blog文件夹；$ git init #初始化当前文件夹作为仓库（生成.git文件夹）； 这时生成一个”.git”目录，该目录是Git来跟踪管理版本，一般情况勿动；2.2添加文件到本地仓库12$ touch readme.txt #创建一个测试文件；$ git add readme.txt #将当前更改或者新增的文件加入到临时空间中； 注： add 命令只是把文件添加到一个临时空间里，需要执行第3 步的commit 命令才会正式提交到仓库中； 如果文件太多，可以使用以下命令一次性提交所有文件(.gitignore 文件指定的除外)；1$ git add -A 可以在当前目录下新建一个名为“.gitignore”的文件，它里面的内容用来表示某类/某个文件将不会被提交到仓库。 2.3提交文件到本地仓库执行以下命令，这会把临时空间的内容存入本地仓库，并添加注释：1$ git commit -m &quot;blog, add 1 files&quot; 可以使用以下命令查看记录：1$ git log --pretty=oneline得到类似信息，前面为版本号，后面为注释：112ewdqe2q... blog, add 1 files可以给某个版本号打上一个标签，命令如下：1$ git tag v1 12ew可以使用以下命令查看已有的标签：1$ git tag 2.4提交文件到GitHub/Coding第一次提交前，需要将本机密钥上传到GitHub/Coding；2.4.1.创建SSH Key：在用户主目录下，看看有没有.ssh 目录，如果有，再看看这个目录下有没有id_rsa 和id_rsa.pub 这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Git Bash，创建SSH Key，命令如下：1$ ssh-keygen -t rsa -C &quot;huangcheng.job@foxmail.com&quot;然后一路回车，使用默认值即可。这样在用户主目录里就会生成.ssh 目录，里面有id_rsa 和id_rsa.pub 两个文件，它们是SSH Key 的秘钥对。id_rsa 是私钥，不能泄露出去；id_rsa.pub 是公钥，可以放心地告诉任何人。 2.4.2.在GitHub 里添加SSH Key：电脑登陆GitHub,在自己账户的”Settings”-“SSH Key”中添加id_rsa.pub 文件的内容；2.4.3.创建一个仓库如:git_hexo,第一次上传需要指定GitHub/Coding仓库，如Coding的git_hexo：12$ git remote add origin https://git.coding.net/hceng/$ git_hexo.git然后根据提示输入账号、密码，最后执行以下指令提交至GitHub/Coding；12$ git push -u origin master$ git push origin --tags2.5以后如果修改文件后再次提交 12345$ git add –A # 添加修改文件到临时空间；$ git commit -m &quot;blog, git use&quot; # 添加本地仓库和添加备注；$ git tag v2 # 打标签；$ git push origin master # 上传到服务器的master；$ git push origin --tags # 上传标签到服务器、；3.Git 获取GitHub/Coding源码 执行以下命令，可以复制他人public代码，这称为“克隆”：1$ git clone https://github.com/hceng/hceng.github.io 当源码作者再次修改了源码后，可以进入对应目录，然后使用以下命令再次获得最新的：1$ git pull origin 查看信息纪录：1$ git log --pretty=oneline 查看标签：1$ git tag 获得指定版本的源码：123$ git checkout &lt;commit id&gt;或$ git checkout &lt;tag_name&gt; 4.分支管理4.1查看所有分支：1$ git branch --all # 本地主分支：master；远程主分支：origin/master；4.2创建本地分支：12$ git branch bak # 创建本地分支；$ git branch # 查看本分支；&quot;*&quot;号表示当前所在分支；4.3发布新分支：即：将本地新建的bak分支同步到远程服务器GitHub/Coding;12$ git push origin bak # 这样远程仓库也有一个bak分支了；$ git checkout bak # 切换到bak分支操作；第一种情况：bak分支开发完成，合并到主分支：12345$ git checkout master # 切换到主分支；$ git merge bak # 把bak分支的更改和master合并；$ git push # 提交主分支代码远程；$ git checkout bak # 切换到bak远程分支；$ git push # 提交bak分支到远程； 第二种情况：bak分支没开发完，推送保存，下次再开发：123$ git add -A # 添加修改文件到临时空间；$ git commit -m &quot;bak branch&quot; # 提交本地bak分支仓库；$ git push # 提交bak分支到远程；4.4删除分支：12345# 删除远程bak分支，危险命令；$ git push origin :bak # 下面两条是删除本地分支;$ git checkout master # 切换到master分支$ git branch -d bak # 删除本地dev分支参考： 5.其它常用指令12345678910 $ git status #查看仓库状态; $ git diff XX #查看XX文件修改了那些内容;$ git log #查看历史记录;$ git reflog #查看历史记录(含回退纪录)；$ git reset –hard HEAD^ #回退到上一个版本; $ git reset –hard HEAD~ #回退到上一个版本;$ git reset –hard HEAD~100 #回退到100个版本;$ git checkout – XX #把XX文件在工作区的修改全部撤销； $ git rm XX #删除XX文件； 参考资料：韦东山Android系统视频使用手册20160303 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自Hceng’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"blog tags","date":"2017-03-01T04:31:04.299Z","path":"2017/03/01/tags/","text":"本文主要是总结blog预计的标签，并不定时更新。 驱动相关 Linux驱动 Android驱动 环境搭建 调试技巧 Linux基础 Makefile 汇编 裸机 STM32 硬件 PCB 设计 PS AE/PR PPT Git git hexo 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自Hceng’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]