[{"title":"Linux摄像头驱动1——vivid","date":"2018-03-08T07:59:30.000Z","path":"2018/03/08/Linux摄像头驱动1——vivid/","text":"Linux摄像头驱动学习第一篇，对虚拟视频驱动Virtual Video Driver(vivid)进行测试、分析、编写。 V4L2(Video for Linux two)是Linux内核中关于视频设备的内核驱动框架，为上层的访问底层的视频设备提供了统一的接口。 V4L2可以支持多种设备,它可以有以下几种接口: Video capture interface(视频采集接口):从摄像头等设备上获取视频数据,是V4L2设计最初功能； Video output interface(视频输出接口):驱动计算机的外围视频、图像显示设备； Video overlay interface(直接传输视频接口):把从视频采集设备采集过来的信号直接输出到输出设备之上,而不用经过CPU； Video output overlay device(视频输出覆盖设备):也被称为OSD(On-Screen Display),即在显示画面上叠加一层显示，比如菜单设置界面； VBI interface(视频间隔消隐信号接口):提供对VBI(Vertical Blanking Interval)数据的控制,它可以使应用可以访问传输消隐期的视频信号； Radio interface(收音机接口):处理从AM或FM高频头设备接收来的音频流； 1.V4L2框架分析 2.测试vivid这里目的先加载vivid驱动，然后运行应用程序调用vivid驱动，初步体验效果。 2.1加载驱动先在Ubuntu16.04上输入uname -a，可以得到当前Ubuntu内核版本号：1Linux ubuntu 4.4.0-116-generic #140-Ubuntu SMP Mon Feb 12 21:23:04 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux 当前内核版本是4.4.0-116-generic，然后去Linux内核官网下载对应的内核，提取出其中的linux-4.13.9/drivers/media/文件夹。 修改media/platform/vivid/下的Makefile:12345678910111213141516KERN_DIR = /usr/src/linux-headers-4.4.0-116-genericvivid-objs := vivid-core.o vivid-ctrls.o vivid-vid-common.o vivid-vbi-gen.o \\ vivid-vid-cap.o vivid-vid-out.o vivid-kthread-cap.o vivid-kthread-out.o \\ vivid-radio-rx.o vivid-radio-tx.o vivid-radio-common.o \\ vivid-rds-gen.o vivid-sdr-cap.o vivid-vbi-cap.o vivid-vbi-out.o \\ vivid-osd.o vivid-tpg.o vivid-tpg-colors.o all: make -C $(KERN_DIR) M=`pwd` modules clean: make -C $(KERN_DIR) M=`pwd` modules clean rm -rf modules.orderobj-$(CONFIG_VIDEO_VIVID) += vivid.o 然后执行make编译，获得vivid.ko此时加载模块sudo insmod vivid.ko，发现报错如下：1insmod: ERROR: could not insert module vivid.ko: Unknown symbol in module 原因是模块中的一些依赖函数的模块，没有加载，通过dmesg命令，可以看到得到很多函数：12345678[ 488.786285] vivid: Unknown symbol vb2_queue_init (err 0)[ 488.786295] vivid: Unknown symbol v4l2_ctrl_poll (err 0)[ 488.786304] vivid: Unknown symbol v4l2_enum_dv_timings_cap (err 0)[ 488.786314] vivid: Unknown symbol video_ioctl2 (err 0)[ 488.786364] vivid: Unknown symbol v4l2_get_timestamp (err 0)[ 488.786389] vivid: Unknown symbol v4l2_device_put (err 0)[ 488.786418] vivid: Unknown symbol vb2_ioctl_streamoff (err 0)………… 需要先加载这些函数所在的模块才行。这里有两个方法：一是找到函数对应的文件，修改Makefile，编译出来，先加载。二是找到函数对应的文件，其实模块都已经编译好了，路径在/lib/modules/4.4.0-116-generic/kernel/drivers/media/v4l2-core/里面，直接加载即可。 这两种方式都需要慢慢找对应的文件，比较麻烦，直接:123sudo modprobe vivid //安装自带vivid及依赖sudo rmmod vivid //卸载自带的vividsudo insmod ./vivid.ko //安装自己编译的vivid.ko 这里先使用modprobr加载vivid，会将其依赖一并加载，然后再卸载vivid，最后加载上我们编译的vivid.ko。 这里为什么使用自己编译的vivid.ko，而不使用自带的？因为这样后面修改vivid源码后，重新加载驱动，才知道修改后的效果。 2.2应用程序Linux摄像头测试软件webcam、spcaview、luvcview、xawtv等，经测试，luvcview和xawtv比较靠谱。 luvcview 1234luvcview -h //帮助信息luvcview -d /dev/videoX //指定设备luvcview -L //查询当前摄像头所支持的所有数据格式以及分辨率信息 luvcview //运行摄像头 xawtv 1234xawtv -h //帮助信息xawtv -c /dev/videoX //指定设备xawtv -noalsa //关闭声卡启动xawtv //运行摄像头 这里加载vivid驱动后，运行xawtv效果如下： 3.分析vivid第一次接触V4L2，直接对内核提供的Virtual Video Driver(vivid)进行分析，只要熟悉了vivid，后续再对摄像头再进行分析，就会轻松很多。 vivid是内核提供的一个虚拟机的视频设备驱动，内核提供的vivid源码在linux-4.13.9/drivers/media/platform/vivid/。 3.1 初始化、注册分析在vivid_init()里分别注册了vivid_pdev和vivid_pdrv，注册后，由于两者name一致，则会调用probe()。在probe()里面主要进行初始化、注册等相关流程。 可以看到，在probe()里，会调用vivid_create_instance()，让后在里面先分配一个video_device，然后设置video_device，包括操作函数ops，ioctl操作函数，设备等。然后对ctrl属性进行详细的设置，最后注册video_device，和进行常规的字符设备注册。 因此，写摄像头驱动程序的流程如下: 分配video_device:video_device_alloc()或kzalloc()； 设置video_device:.fops、.ioctl_ops、dev； 注册video_device: video_register_device()； 3.2 操作函数分析再来看看操作函数是如何调用的： 当应用层open()/read()/write()操作/dev/videox时，先找到v4l2_fops，然后调用v4l2_open/v4l2_read/v4l2_write(drivers/media/v4l2-core/v4l2-dev.c)，再通过video_devdata根据次设备号从数组中得到video_device，再找到vivid_fops里对应的操作函数。 ioctl的前面流程类似，后面通过video_usercopy()获取传入的ioctl类型，找到对应ioctl_ops，调用不同的ioctl。 3.3 ioctl_ops分析摄像头驱动有众多的ioctl，这些ioctl实现了对设备的控制：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122static const struct v4l2_ioctl_ops vivid_ioctl_ops = &#123; /* 表示它是一个摄像头设备 */ .vidioc_querycap = vidioc_querycap, /* 摄像头数据格式的操作 */ .vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid, //列举格式 .vidioc_g_fmt_vid_cap = vidioc_g_fmt_vid_cap, //获取格式 .vidioc_try_fmt_vid_cap = vidioc_try_fmt_vid_cap, //测试格式 .vidioc_s_fmt_vid_cap = vidioc_s_fmt_vid_cap, //设置格式 /* 支持multi-planar */ .vidioc_enum_fmt_vid_cap_mplane = vidioc_enum_fmt_vid_mplane, .vidioc_g_fmt_vid_cap_mplane = vidioc_g_fmt_vid_cap_mplane, .vidioc_try_fmt_vid_cap_mplane = vidioc_try_fmt_vid_cap_mplane, .vidioc_s_fmt_vid_cap_mplane = vidioc_s_fmt_vid_cap_mplane, /* 数据输出操作 */ .vidioc_enum_fmt_vid_out = vidioc_enum_fmt_vid, //枚举输出格式 .vidioc_g_fmt_vid_out = vidioc_g_fmt_vid_out, //获取输出格式 .vidioc_try_fmt_vid_out = vidioc_try_fmt_vid_out, //测试输出格式 .vidioc_s_fmt_vid_out = vidioc_s_fmt_vid_out, //设置输出格式 /* 支持multi-planar */ .vidioc_enum_fmt_vid_out_mplane = vidioc_enum_fmt_vid_mplane, .vidioc_g_fmt_vid_out_mplane = vidioc_g_fmt_vid_out_mplane, .vidioc_try_fmt_vid_out_mplane = vidioc_try_fmt_vid_out_mplane, .vidioc_s_fmt_vid_out_mplane = vidioc_s_fmt_vid_out_mplane, .vidioc_g_selection = vidioc_g_selection, //获取选择矩形 .vidioc_s_selection = vidioc_s_selection, //设置选择矩形 .vidioc_cropcap = vidioc_cropcap, //查询裁剪限制 .vidioc_g_fmt_vbi_cap = vidioc_g_fmt_vbi_cap, //获取指向原始数据VBI的指针 .vidioc_try_fmt_vbi_cap = vidioc_g_fmt_vbi_cap, .vidioc_s_fmt_vbi_cap = vidioc_s_fmt_vbi_cap, .vidioc_g_fmt_sliced_vbi_cap = vidioc_g_fmt_sliced_vbi_cap, .vidioc_try_fmt_sliced_vbi_cap = vidioc_try_fmt_sliced_vbi_cap, .vidioc_s_fmt_sliced_vbi_cap = vidioc_s_fmt_sliced_vbi_cap, .vidioc_g_sliced_vbi_cap = vidioc_g_sliced_vbi_cap, .vidioc_g_fmt_vbi_out = vidioc_g_fmt_vbi_out, .vidioc_try_fmt_vbi_out = vidioc_g_fmt_vbi_out, .vidioc_s_fmt_vbi_out = vidioc_s_fmt_vbi_out, .vidioc_g_fmt_sliced_vbi_out = vidioc_g_fmt_sliced_vbi_out, .vidioc_try_fmt_sliced_vbi_out = vidioc_try_fmt_sliced_vbi_out, .vidioc_s_fmt_sliced_vbi_out = vidioc_s_fmt_sliced_vbi_out, .vidioc_enum_fmt_sdr_cap = vidioc_enum_fmt_sdr_cap, .vidioc_g_fmt_sdr_cap = vidioc_g_fmt_sdr_cap, .vidioc_try_fmt_sdr_cap = vidioc_try_fmt_sdr_cap, .vidioc_s_fmt_sdr_cap = vidioc_s_fmt_sdr_cap, .vidioc_overlay = vidioc_overlay, .vidioc_enum_framesizes = vidioc_enum_framesizes, .vidioc_enum_frameintervals = vidioc_enum_frameintervals, .vidioc_g_parm = vidioc_g_parm, .vidioc_s_parm = vidioc_s_parm, .vidioc_enum_fmt_vid_overlay = vidioc_enum_fmt_vid_overlay, .vidioc_g_fmt_vid_overlay = vidioc_g_fmt_vid_overlay, .vidioc_try_fmt_vid_overlay = vidioc_try_fmt_vid_overlay, .vidioc_s_fmt_vid_overlay = vidioc_s_fmt_vid_overlay, .vidioc_g_fmt_vid_out_overlay = vidioc_g_fmt_vid_out_overlay, .vidioc_try_fmt_vid_out_overlay = vidioc_try_fmt_vid_out_overlay, .vidioc_s_fmt_vid_out_overlay = vidioc_s_fmt_vid_out_overlay, .vidioc_g_fbuf = vidioc_g_fbuf, .vidioc_s_fbuf = vidioc_s_fbuf, /* 缓冲区操作 */ .vidioc_reqbufs = vb2_ioctl_reqbufs, //申请 .vidioc_create_bufs = vb2_ioctl_create_bufs, //创建 .vidioc_prepare_buf = vb2_ioctl_prepare_buf, //准备 .vidioc_querybuf = vb2_ioctl_querybuf, //查询 .vidioc_qbuf = vb2_ioctl_qbuf, //放入 .vidioc_dqbuf = vb2_ioctl_dqbuf, //取出 .vidioc_expbuf = vb2_ioctl_expbuf, //导出 .vidioc_streamon = vb2_ioctl_streamon, //启动 .vidioc_streamoff = vb2_ioctl_streamoff, //停止 /* 输入源操作 */ .vidioc_enum_input = vidioc_enum_input, //枚举输入源 .vidioc_g_input = vidioc_g_input, //获取输入源 .vidioc_s_input = vidioc_s_input, //设置输入源 .vidioc_s_audio = vidioc_s_audio, //设置音频 .vidioc_g_audio = vidioc_g_audio, //获取音频 .vidioc_enumaudio = vidioc_enumaudio, //枚举音频 .vidioc_s_frequency = vidioc_s_frequency, //设置频率 .vidioc_g_frequency = vidioc_g_frequency, //获取输入源 .vidioc_s_tuner = vidioc_s_tuner, //设置调谐器 .vidioc_g_tuner = vidioc_g_tuner, //获取调谐器 .vidioc_s_modulator = vidioc_s_modulator, //设置调制器 .vidioc_g_modulator = vidioc_g_modulator, //获取调制器 .vidioc_s_hw_freq_seek = vidioc_s_hw_freq_seek, //硬件频率搜索 .vidioc_enum_freq_bands = vidioc_enum_freq_bands, //枚举调谐器或调制器支持的频段 /* 输出端操作 */ .vidioc_enum_output = vidioc_enum_output, //枚举视频输出端 .vidioc_g_output = vidioc_g_output, //获取视频输出 .vidioc_s_output = vidioc_s_output, //设置视频输出 .vidioc_s_audout = vidioc_s_audout, //设置音频输出 .vidioc_g_audout = vidioc_g_audout, //获取音频输出 .vidioc_enumaudout = vidioc_enumaudout, //枚举视频输出端 /* 制式操作 */ .vidioc_querystd = vidioc_querystd, //查询制式 .vidioc_g_std = vidioc_g_std, //获取制式 .vidioc_s_std = vidioc_s_std, //设置制式 .vidioc_s_dv_timings = vidioc_s_dv_timings, //设置DV时序 .vidioc_g_dv_timings = vidioc_g_dv_timings, //获取DV时序 .vidioc_query_dv_timings = vidioc_query_dv_timings, //查询DV时序 .vidioc_enum_dv_timings = vidioc_enum_dv_timings, //枚举DV时序 .vidioc_dv_timings_cap = vidioc_dv_timings_cap, //查询DV应用程序功能 .vidioc_g_edid = vidioc_g_edid, //获取EDID数据块 .vidioc_s_edid = vidioc_s_edid, //设置EDID数据块 /* 调试操作 */ .vidioc_log_status = vidioc_log_status, //输出设备状态到内核日志 .vidioc_subscribe_event = vidioc_subscribe_event, //订阅V4L2事件 .vidioc_unsubscribe_event = v4l2_event_unsubscribe, //取消订阅V4L2事件&#125;; 提取出11个必须的ioctl:12345678910111213141516/* 表示它是一个摄像头设备 */.vidioc_querycap = vidioc_querycap, /* 摄像头数据格式的操作 */.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid, //列举格式.vidioc_g_fmt_vid_cap = vidioc_g_fmt_vid_cap, //获取格式.vidioc_try_fmt_vid_cap = vidioc_try_fmt_vid_cap, //测试格式.vidioc_s_fmt_vid_cap = vidioc_s_fmt_vid_cap, //设置格式/* 缓冲区操作 */.vidioc_reqbufs = vb2_ioctl_reqbufs, //申请.vidioc_querybuf = vb2_ioctl_querybuf, //查询.vidioc_qbuf = vb2_ioctl_qbuf, //放入.vidioc_dqbuf = vb2_ioctl_dqbuf, //取出.vidioc_streamon = vb2_ioctl_streamon, //启动.vidioc_streamoff = vb2_ioctl_streamoff, //停止 3.4 数据获取过程分析1.请求分配缓冲区12app:ioctl(fd, VIDIOC_REQBUFS, xx) videobuf_reqbufs(vdev-&gt;queue, p-&gt;memory, &amp;p-&gt;count);//没分配真正buf 2.查询映射缓冲区12345678app:ioctl(fd, VIDIOC_QUERYBUF, xx) videobuf_querybuf //获得buf的数据格式、大小、每一行长度、高度 v4l2_mmap vb2_fop_mmap videobuf_mmap_mapper __videobuf_mmap_mapper mem-&gt;vaddr = vmalloc_user(pages); //这里分配buf 3.把缓冲区放入队列12345app:ioctl(fd, VIDIOC_QBUF, xx) videobuf_qbuf q-&gt;ops-&gt;buf_prepare(q, buf, field); //调用驱动程序提供的函数做预处理 list_add_tail(&amp;buf-&gt;stream, &amp;q-&gt;stream); //把缓冲区放入队列的尾部 q-&gt;ops-&gt;buf_queue(q, buf); //用驱动程序提供的&quot;入队列函数&quot; 4.启动摄像头 123app:ioctl(fd, VIDIOC_STREAMON, xx) videobuf_streamon q-&gt;streaming = 1; 5.用select查询是否有数据123456789101112v4l2_poll vdev-&gt;fops-&gt;poll(); vivi_poll videobuf_poll_stream buf = list_entry(); //从队列的头部获得buf poll_wait(); //如果没有数据则休眠 vivid_thread_vid_cap //内核进程唤醒 vivid_thread_vid_cap_tick vivid_fillbuff //构造数据 vb2_buffer_done wake_up(); //唤醒进程 6.有数据后,从队列取出缓冲区 app:ioctl(fd, VIDIOC_DQBUF, xx) //使用VIDIOC_DQBUF获取buf状态 videobuf_dqbuf stream_next_buffer //在队列里获得有数据的缓冲区 list_del //把它从队列中删掉 videobuf_status //把这个缓冲区的状态返回给APP 7.读取对应地址缓冲区应用程序根据VIDIOC_DQBUF所得到缓冲区状态，知道是哪一个缓冲区有数据,就去读对应的地址(该地址来自前面的mmap) 调试技巧: 1.得到xawtv进行了哪些系统调用:sudo strace -o xawtv.log xawtv2.当无法修改Ubuntu打印等级(sudo echo “8 4 1 7” &gt;/proc/sys/kernel/printk 提示权限不够)时：tail -f /var/log/kern.log &amp;可实现内核打印增量显示。 4.编写vivid 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"摄像头","slug":"摄像头","permalink":"http://yoursite.com/tags/摄像头/"}]},{"title":"博客一周年","date":"2018-03-01T05:02:26.000Z","path":"2018/03/01/博客一周年/","text":"2017-2018，博客一周年数据统计。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Linux电源管理","date":"2018-01-18T06:32:20.000Z","path":"2018/01/18/Linux电源管理/","text":"探究Linux电源管理模型，并为Tiny4412的LCD驱动添加电源管理。这是2018的第一篇博客，选了一个几乎没有接触过的角度作为开篇，希望2018年学习更多，记录更多。 1.电源管理的两种模型以往接触的Linux驱动，没遇到使用电池供电的情况，因此几乎没关注电源的管理。然而实际中，不少使用电池供电的硬件平台，例如手机、POS机等，就需要对电源进行管理，比如在不使用设备的时候，休眠屏幕省电。 Linux电源管理模型有两种：系统睡眠模型suspend和Runtime电源管理模型。 1.1系统睡眠模型Suspend On (on) S0 - WorkingStandby (standby） S1 - CPU and RAM are powered but not executedSuspend to RAM (mem) S3 - RAM is powered and the running content is saved to RAMSuspend to Disk, Hibernation (disk) S4 - All content is saved to Disk and power down S3 aka STR(suspend to ram),挂起到内存，简称待机。计算机将目前的运行状态等数据存放在内存，关闭硬盘、外设等设备，进入等待状态。此时内存仍然需要电力维持其数据，但整机耗电很少。恢复时计算机从内存读出数据，回到挂起前的状态，恢复速度较快。对DDR的耗电情况进行优化是S3性能的关键，大多数手持设备都是用S3待机。 S4 aka STD(suspend to disk),挂起到硬盘，简称休眠。把运行状态等数据存放在硬盘上某个文件或者某个特定的区域，关闭硬盘、外设等设备，进入关机状态。此时计算机完全关闭，不耗电。恢复时计算机从休眠文件/分区中读出数据，回到休眠前的状态，恢复速度较慢。 系统休眠模型给我的感觉是以整机角度进行省电。S3类似电脑的睡眠，在教长时间不使用电脑后，电脑黑屏，再次敲击键盘迅速显示桌面，原来的工作内容仍不变。S4类似电脑的休眠，在长时间不使用电脑后，电脑黑屏，再次敲击键盘无反应，按下电源键，开机，原来的工作内容仍不变。 对于嵌入式设备，更多的是使用S3，将数据暂时放在内存里，以实现快速恢复，就像手机的电源键按下黑屏，再次按下迅速亮屏。 在Linux中，通过cat /sys/power/state可以得知当前设备支持的节能模式，一般情况有如下选项： freeze:不涉及具体的Hardware或Driver，只是冻结所有的进程，包括用户空间进程及内核线程，能节省的能量较少，使用场景不多； standby:前面的S1状态，CPU处于浅睡眠模式，主要针对CPU功耗； mem:前面的S3状态，Suspend to RAM； disk:前面的S4状态，Suspend to Disk； 需要设置以上模式，只需echo mem &gt; /sys/power/state即可。 1.2 Runtime电源管理模型Runtime电源管理模型给我的感觉是以模块角度进行省电。某种程度上是“高内聚和低耦合”的体现。每个设备（包括CPU）都处理好自身的电源管理工作，尽量以最低的能耗完成交代的任务，尽量在不需要工作的时候进入低功耗状态，尽量不和其它模块有过多耦合。每个设备都是最节省的话，整个系统一定是最节省的。 2. 系统睡眠模型suspend2.1 Suspend流程分析suspend的流程还是挺复杂的，向/sys/power/state写入命令后再到唤醒，将进行以下流程： 对源码进行分析，其休眠过程如下：驱动程序里休眠相关的电源管理函数的调用过程:prepare—&gt;suspend—&gt;suspend_late—&gt;suspend_noirq 对源码进行分析，其唤醒过程如下：驱动程序里唤醒相关的电源管理函数的调用过程:resume_noirq—&gt;resume_early—&gt;resume-&gt;complete 对于驱动程序，我们主要关心Device PM(针对每一个驱动)和少量Platform dependent PM(针对CPU芯片相关)的内容。 2.2 使用Suspend功能首先将suspend功能加入内核：12Power management options ---&gt; [*] Suspend to RAM and standby 这里默认是勾选上了的，就不管了。 进入Tiny4412内核，尝试休眠echo mem &gt; /sys/power/state，系统提示No wake-up sources!。可见，要进入休眠，必须要有唤醒源，没有唤醒源，休眠也没有意义。 2.2.1 设置唤醒源唤醒源最常见的就是按键中断，就如同手机进入锁屏状态下，按下电源键唤醒一样，因此先写一个按键驱动。 原理图：底板上有四个按键，分别连在GPX3_2、GPX3_3、GPX3_4、GPX3_5，引脚状态常高，按键按下变低电平。 设备树： 1234567button_interrupt: button_interrupt &#123; compatible = &quot;tiny4412,button_interrupt&quot;; tiny4412,gpx3_2 = &lt;&amp;gpx3 2 GPIO_ACTIVE_HIGH&gt;; tiny4412,gpx3_3 = &lt;&amp;gpx3 3 GPIO_ACTIVE_HIGH&gt;; tiny4412,gpx3_4 = &lt;&amp;gpx3 4 GPIO_ACTIVE_HIGH&gt;; tiny4412,gpx3_5 = &lt;&amp;gpx3 5 GPIO_ACTIVE_HIGH&gt;;&#125;; 按键驱动： 12//设置为中断唤醒源irq_set_irq_wake(irq, 1); usb4604驱动：前面的Exynos4412——网卡移植和NFS启动里面，移植USB4604驱动时，删除了电源管理的代码，实际测试中唤醒时USB设备会报错，添加上电源管理相关代码即可： 123456789101112131415161718192021222324#ifdef CONFIG_PM_SLEEPstatic int usb4604_i2c_suspend(struct device *dev)&#123; struct i2c_client *client = to_i2c_client(dev); struct usb4604 *hub = i2c_get_clientdata(client); usb4604_switch_mode(hub, USB4604_MODE_STANDBY); return 0;&#125;static int usb4604_i2c_resume(struct device *dev)&#123; struct i2c_client *client = to_i2c_client(dev); struct usb4604 *hub = i2c_get_clientdata(client); usb4604_switch_mode(hub, hub-&gt;mode); return 0;&#125;#endifstatic SIMPLE_DEV_PM_OPS(usb4604_i2c_pm_ops, usb4604_i2c_suspend, usb4604_i2c_resume); 2.2.2 休眠唤醒(未成功)加入中断源后，休眠过程不再提示No wake-up sources!，看样子休眠应该成功了。此时，按下按键，板子并未唤醒，琢磨了一阵，初步怀疑有以下原因： 唤醒的时候，应该需要uboot配合，uboot读取某个寄存器来判断是正常启动还是唤醒； Exynos4412的PMU特性没摸透，可能需要其它额外的操作； Exynos4412启动时的BL1和BL2，可能也有影响； 这里先卡住，继续后面。 2.3 使驱动支持Suspend2.3.1 通知Notifier前面的suspend流程分析里面，在冻结APP之前,使用pm_notifier_call_chain(PM_SUSPEND_PREPARE)来通知驱动程序;在重启APP之后,使用pm_notifier_call_chain(PM_POST_SUSPEND)来通知驱动程序; 因此，如果驱动程序有事情在上述时机要处理，可以使用notifier机制。使用步骤： a.定义notifier_block结构体123static struct notifier_block lcd_pm_notif_block = &#123; .notifier_call = lcd_suspend_notifier,&#125;; b.notifier操作函数1234567891011121314static int lcd_suspend_notifier(struct notifier_block *nb, unsigned long event, void *dummy)&#123; switch (event) &#123; case PM_SUSPEND_PREPARE: printk(&quot;lcd suspend notifiler test: PM_SUSPEND_PREPARE\\n&quot;); return NOTIFY_OK; case PM_POST_SUSPEND: printk(&quot;lcd suspend notifiler test: PM_POST_SUSPEND\\n&quot;); return NOTIFY_OK; default: return NOTIFY_DONE; &#125;&#125; c.注册notifier在驱动init()或probe()里注册：12345ret = register_pm_notifier(&amp;lcd_pm_notif_block); if(ret) &#123; printk(&quot;failed to register pm notifier.\\n&quot;); return -EINVAL; &#125; 在前面LCD驱动上修改lcd_drv.c，测试如下： 2.3.2 Suspend和Resume前面的notifier只是通知，在冻结APP之前和重启APP之后通知，而电源管理应该刚好相反，是在冻结APP之后和重启APP之前对驱动的电源进行控制，这就需要suspend和resume来实现。 a.在platform_driver里的driver里添加pm结构体: 12345678910static struct platform_driver lcd_driver =&#123; .driver = &#123; .name = &quot;lcd_s702&quot;, .pm = &amp;lcd_pm, .of_match_table = of_match_ptr(lcd_dt_ids), &#125;, .probe = lcd_probe, .remove = lcd_remove,&#125;; b.设置pm成员函数： 1234static struct dev_pm_ops lcd_pm = &#123; .suspend = s702_lcd_suspend, .resume = s702_lcd_resume, &#125;; c.编写成员函数: 12345678910111213141516171819202122232425262728static int s702_lcd_suspend(struct device *dev)&#123; //lcd休眠操作 //Direct Off: ENVID and ENVID_F are set to \"0\" simultaneously. unsigned int temp; printk(\"enter %s\\n\", __func__); temp = readl(lcd_regs_base + VIDCON0); temp &amp;= ~(0x01 &lt;&lt; 1 | 0x01 &lt;&lt; 0); writel(temp, lcd_regs_base + VIDCON0); return 0;&#125;static int s702_lcd_resume(struct device *dev)&#123; //lcd唤醒操作 //Display On: ENVID and ENVID_F are set to \"1\". unsigned int temp; printk(\"enter %s\\n\", __func__); temp = readl(lcd_regs_base + VIDCON0); writel(temp | (0x01 &lt;&lt; 1) | (0x01 &lt;&lt; 0), lcd_regs_base + VIDCON0); return 0;&#125; 这里只是简单的关闭/打开显示，理论上的操作应该是：休眠时先备份所有LCD相关寄存器，恢复时再恢复所有寄存器，以及其它可能操作，比如重新开启时钟等。 同理，因为LCD显示和backlight是分开的，因此需要在backlight里也进行类似操作。 3.Runtime电源管理模型前面的suspend系统睡眠模型是将整个系统进行休眠，但如果需要在系统运行时，单独对某个模块进行休眠，就需要Runtime电源管理模型，这两个模型互相协作，才能最大的发挥电源管理的效果。 Runtime电源管理模型的原理比较简单，就是计数，当该设备驱动被使用时就加1，放弃使用时就减1，计数大于1时，就打开该设备的电源，等于0时就关闭电源。 Runtime PM相关的函数：a. 使能/禁止 Runtime PM：pm_runtime_enable / pm_runtime_disable (修改disable_depth变量)b. 增加计数/减少计数：pm_runtime_get_sync / pm_runtime_put_sync (修改usage_count变量)c. 回调函数 暂停/恢复/空闲：runtime_suspend / runtime_resume / runtime_idle 3.1 Runtime流程分析 调用pm_runtime_get_sync去增加使用次数以及恢复的流程如下： 调用pm_runtime_put_sync去减少使用次数以及暂停的流程如下： 前面的两个流程，只看到了runtime_resume和runtime_idle的调用，没有看到runtime_suspend，实际上，如果设备不提供runtime_idle, 则最终会调用runtime_suspend。 3.2 使用Runtime功能首先将Runtime功能加入内核，但本内核4.13.9里没找到相关选项，应该默认已经加入到内核里面了。 调用方式一：驱动程序提供接口, APP来调用。在驱动函数的open()、close()里，增加和减少引用计数。APP调用驱动的时候就能相应的恢复、暂停设备。 调用方式二：直接操作应用层文件：恢复： 1echo on &gt; /sys/devices/.../power/control 流程：control_store(drivers\\base\\power\\sysfs.c) -&gt; pm_runtime_forbid -&gt; atomic_inc -&gt; rpm_resume 暂停：1echo auto &gt; /sys/devices/.../power/control 流程：control_store(drivers\\base\\power\\sysfs.c) -&gt; pm_runtime_allow -&gt; atomic_dec_and_test -&gt; rpm_idle 3.3 使驱动支持Runtime a.在platform_driver里的driver里添加pm结构体:(和前面的一样，这里就无需操作) 12345678910static struct platform_driver lcd_driver =&#123; .driver = &#123; .name = &quot;lcd_s702&quot;, .pm = &amp;lcd_pm, .of_match_table = of_match_ptr(lcd_dt_ids), &#125;, .probe = lcd_probe, .remove = lcd_remove,&#125;; b.设置pm成员函数： 1234567static struct dev_pm_ops lcd_pm =&#123; .suspend = s702_lcd_suspend, .resume = s702_lcd_resume, .runtime_suspend = s702_lcd_suspend, .runtime_resume = s702_lcd_resume,&#125;; 添加runtime_suspend和runtime_resume，runtime和suspend的暂停配置是一样的，直接使用前面的。 c.编写成员函数:(和前面的一样，这里就无需操作) 12345678910111213141516171819202122232425262728static int s702_lcd_suspend(struct device *dev)&#123; //lcd休眠操作 //Direct Off: ENVID and ENVID_F are set to \"0\" simultaneously. unsigned int temp; printk(\"enter %s\\n\", __func__); temp = readl(lcd_regs_base + VIDCON0); temp &amp;= ~(0x01 &lt;&lt; 1 | 0x01 &lt;&lt; 0); writel(temp, lcd_regs_base + VIDCON0); return 0;&#125;static int s702_lcd_resume(struct device *dev)&#123; //lcd唤醒操作 //Display On: ENVID and ENVID_F are set to \"1\". unsigned int temp; printk(\"enter %s\\n\", __func__); temp = readl(lcd_regs_base + VIDCON0); writel(temp | (0x01 &lt;&lt; 1) | (0x01 &lt;&lt; 0), lcd_regs_base + VIDCON0); return 0;&#125; d.使能Runtime:对于Runtime PM,默认状态下设备的状态是Suspended,如果硬件上它是运行状态,需要调用pm_runtime_set_active()来修改它的状态,然后调用pm_runtime_enable()来使能Runtime PM。 在probe()函数的后面添加：12pm_runtime_set_active(&amp;pdev-&gt;dev);pm_runtime_enable(&amp;pdev-&gt;dev); 反之，还要在remove()里禁止：1pm_runtime_disable(&amp;pdev-&gt;dev); e.修改计数:一般在open()和release()里面增加和减少引用计数： 1234567891011121314151617181920212223242526272829303132333435363738static int s702_lcd_open(struct fb_info *info, int user)&#123; struct device *dev = info-&gt;dev; int ret; printk(\"enter %s\\n\", __func__); ret = pm_runtime_get_sync(dev); if (ret &lt; 0 &amp;&amp; ret != -EACCES) &#123; pm_runtime_put_sync(dev); return ret; &#125; return 0;&#125;static int s702_lcd_release(struct fb_info *info, int user)&#123; struct device *dev = info-&gt;dev; printk(\"enter %s\\n\", __func__); pm_runtime_put_sync(dev); return 0;&#125;static struct fb_ops tiny4412_lcdfb_ops =&#123; .owner = THIS_MODULE, .fb_setcolreg = cfb_setcolreg, //设置调色板，实现伪颜色表 .fb_fillrect = cfb_fillrect, //填充矩形 .fb_copyarea = cfb_copyarea, //数据复制 .fb_imageblit = cfb_imageblit, //图形填充 .fb_open = s702_lcd_open, .fb_release = s702_lcd_release&#125;; f.优化——加入延时机制:现在的程序基本完成，测试的时候，先加载backlight驱动insmod backlight_drv.ko，运行背光应用程序设置亮度./app 200；然后加载LCD驱动insmod lcd_drv.ko，运行图片显示应用程序jpg_rgb显示图像./jpg_rgb cq.jpg，结果并没有显示图像，手动的echo on &gt; /sys/devices/platform/11c00000.lcd_s702/power/control才正常显示图像。 上述流程中，运行图片显示应用程序时，先open()了一次，引用计数加1，程序调用完又马上close，引用计数减1，导致看不到显示，重新操作/sys/devices/platform/11c00000.lcd_s702/power/control就立即显示了图像。 对于正常的使用情景是，运行应用程序，立即图片显示，然后维持显示一段时间，如果有操作继续显示，没有的话再自己熄灭。因此，想要实现上面的功能，还需要加入自动休眠。 在之前的probe()中加入pm_runtime_use_autosuspend():123456//Runtimepm_runtime_use_autosuspend(&amp;pdev-&gt;dev);//add autosleeppm_runtime_set_autosuspend_delay(&amp;pdev-&gt;dev, 5000);pm_runtime_set_active(&amp;pdev-&gt;dev);pm_runtime_enable(&amp;pdev-&gt;dev); 同时，release()也要修改:1234567891011121314151617181920212223242526272829static int s702_lcd_open(struct fb_info *info, int user)&#123; struct device *dev = info-&gt;dev; int ret; printk(\"enter %s\\n\", __func__); ret = pm_runtime_get_sync(dev); if (ret &lt; 0 &amp;&amp; ret != -EACCES) &#123; pm_runtime_put_sync(dev); return ret; &#125; return 0;&#125;static int s702_lcd_release(struct fb_info *info, int user)&#123; struct device *dev = info-&gt;dev; printk(\"enter %s\\n\", __func__); //pm_runtime_put_sync(dev); pm_runtime_mark_last_busy(dev); pm_runtime_put_sync_autosuspend(dev); return 0;&#125; 此时，加载驱动后，运行应用程序，屏幕显示，5s后，屏幕自动熄灭，再次运行程序或者修改control来重新显示。 通过函数pm_runtime_set_autosuspend_delay()或修改echo xx &gt; /sys/devices/.../power/autosuspend_delay_ms来修改自动休眠时间。 完整代码见Github。 4.regulator系统前面的两个电源管理模型偏“软”，regulator系统偏“硬”，在复杂的单板中，有专门的电源管理芯片控制各个模块电源，regulator系统就是为这个电源芯片编写驱动，实现电源管理。 4.1 regulator框架 ①Regulator(稳定器):指可以自动维持恒定电压(voltage)或电流(current)的装置，一般指电源芯片。在嵌入式设备中，基本上每一种电压，都是经过regulator输出的；②③Consumer(使用者):使用电源的装置，Regulator是给Consumer供电的；④Machine(单板):使用软件语言(struct regulator_init_data)，静态的描述regulator在板级的物理现状，包含： a.级联关系:Regulator A的输出是Regulator B的输入，Regulator A就是Supply regulator，B是Consumer regulator； b.约束限制:Regulator Constraints，比如电压/电流最大值/最小值、允许的操作等； 从设备驱动的角度看，regulator系统比较简单，Machine提供Supply与Consumer的对应关系、单板相关的约束条件(device)；Regulator提供电源芯片的控制函数，如使能/去能、设置电压/电流等(driver)；Consumer调用Regulator相关函数控制电源的开关、调节(use)；即一个描述关系,一个提供相关函数，一个调用相关函数。 4.2 regulator流程 4.3 regulator驱动regulator系统仍然是采用总线设备驱动模型。device采用c文件或设备树的形式，提供硬件相关信息;driver加载后，一但和device名字匹配，就调用probe()函数注册register，并绑定操作函数； 后面将使用两种实现regulator驱动。这两种方式的核心都是一样的，device先提供Supply与Consumer的对应关系、单板相关的约束条件;driver提供电源芯片的控制函数，如使能/去能、设置电压/电流等。 4.3.1 C文件方式 device:在一个单板C文件里，提供级联关系regulator_consumer_supply,约束条件regulator_init_data: [machine.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/err.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/regulator/driver.h&gt;#include &lt;linux/mfd/core.h&gt;#include &lt;linux/regulator/machine.h&gt;#if 1static struct regulator_consumer_supply tiny4412_regulator_supplies[] =&#123; REGULATOR_SUPPLY(\"VCC_LCD\", \"11c00000.lcd_s702\"),//consumer的电源引脚名称;consumer的名字&#125;;#elsestatic struct regulator_consumer_supply tiny4412_regulator_supplies[] =&#123; REGULATOR_SUPPLY(\"VCC_LCD\", \"lcd_s702\"),&#125;;#endifstatic struct regulator_init_data tiny4412_regulator_init_data =&#123; .constraints = &#123; //.name = \"tiny4412_regulator\", .min_uV = 1000000, .max_uV = 1000000, .valid_modes_mask = REGULATOR_MODE_NORMAL, .valid_ops_mask = REGULATOR_CHANGE_STATUS, .boot_on = 0, .always_on = 0, &#125;, .num_consumer_supplies = 1, .consumer_supplies = tiny4412_regulator_supplies,&#125;;static void tiny4412_regulator_release(struct device *dev)&#123;&#125;static struct platform_device tiny4412_regulator_dev =&#123; .name = \"tiny4412_regulator\", .id = -1, .dev = &#123; .release = tiny4412_regulator_release, .platform_data = &amp;tiny4412_regulator_init_data, &#125;,&#125;;static int tiny4412_regulator_machine_init(void)&#123; printk(\"enter %s\\n\", __func__); platform_device_register(&amp;tiny4412_regulator_dev); return 0;&#125;static void tiny4412_regulator_machine_exit(void)&#123; printk(\"enter %s\\n\", __func__); platform_device_unregister(&amp;tiny4412_regulator_dev);&#125;module_init(tiny4412_regulator_machine_init);module_exit(tiny4412_regulator_machine_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"Tiny4412 machine driver.\");MODULE_ALIAS(\"Exynos4412_machine\");MODULE_VERSION(\"V1.0\"); driver提供操作函数并注册regulator: [regulator.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/err.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/regulator/driver.h&gt;#include &lt;linux/mfd/core.h&gt;#include &lt;linux/io.h&gt;static int regulator_states = 0;static int tiny4412_regulator_enable(struct regulator_dev *rdev)&#123; printk(\"enter %s\\n\", __func__); printk(\"------LCD Power Open.------\\n\"); regulator_states = 1; return 0;&#125;static int tiny4412_regulator_disable(struct regulator_dev *rdev)&#123; printk(\"enter %s\\n\", __func__); printk(\"------LCD Power Close.------\\n\"); regulator_states = 0; return 0;&#125;static int tiny4412_regulator_is_enabled(struct regulator_dev *rdev)&#123; printk(\"enter %s\\n\", __func__); printk(\"------LCD Power Test.------\\n\"); if (regulator_states) return 1; else return 0;&#125;static struct regulator_ops tiny4412_regulator_ops =&#123; .enable = tiny4412_regulator_enable, .disable = tiny4412_regulator_disable, .is_enabled = tiny4412_regulator_is_enabled,&#125;;static struct regulator_desc tiny4412_regulator_desc =&#123; .name = \"tiny4412_regulator\", .ops = &amp;tiny4412_regulator_ops, .type = REGULATOR_VOLTAGE,//电压源 .id = 0, .owner = THIS_MODULE, .n_voltages = 1,//能提供的电压数量&#125;;static struct regulator_dev *tiny4412_regulator_dev;static int tiny4412_regulator_probe(struct platform_device *pdev)&#123; struct regulator_config config = &#123; &#125;; config.dev = &amp;pdev-&gt;dev; config.init_data = dev_get_platdata(&amp;pdev-&gt;dev); printk(\"enter %s\\n\", __func__); tiny4412_regulator_dev = devm_regulator_register(&amp;pdev-&gt;dev, &amp;tiny4412_regulator_desc, &amp;config); if (IS_ERR(tiny4412_regulator_dev)) &#123; printk(\"devm_regulator_register error!\\n\"); return PTR_ERR(tiny4412_regulator_dev); &#125; return 0;&#125;static int tiny4412_regulator_remove(struct platform_device *pdev)&#123; printk(\"enter %s\\n\", __func__); devm_regulator_unregister(&amp;pdev-&gt;dev, tiny4412_regulator_dev); return 0;&#125;struct platform_driver tiny4412_regulator_drv =&#123; .probe = tiny4412_regulator_probe, .remove = tiny4412_regulator_remove, .driver = &#123; .name = \"tiny4412_regulator\", &#125;&#125;;static int tiny4412_regulator_init(void)&#123; printk(\"enter %s\\n\", __func__); platform_driver_register(&amp;tiny4412_regulator_drv); return 0;&#125;static void tiny4412_regulator_exit(void)&#123; printk(\"enter %s\\n\", __func__); platform_driver_unregister(&amp;tiny4412_regulator_drv);&#125;module_init(tiny4412_regulator_init);module_exit(tiny4412_regulator_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"Tiny4412 regulator driver.\");MODULE_ALIAS(\"Exynos4412_regulator\");MODULE_VERSION(\"V1.0\"); lcd_drv加载前面的machine.ko和regulator.ko，名字匹配后调用probe()注册regulator。在LCD驱动中，若想使用regulator系统，需要先在LCD驱动的probe()根据名字获取对应regulator： 1234567//regulatortiny4412_regulator = regulator_get(&amp;pdev-&gt;dev, &quot;VCC_LCD&quot;);if (IS_ERR(tiny4412_regulator))&#123; printk(&quot;regulator_get error!\\n&quot;); return -EIO;&#125; 再在suspend()和resume()封面便调用regulator_disable()和regulator_enable()。 此时，如果使用 系统睡眠模型 或 Runtime电源模型 进行休眠操作，就会调用到regulator系统的操作函数，实现电源管理芯片的关闭。 使用完后，释放regulator：12345678910111213141516171819static int lcd_remove(struct platform_device *pdev)&#123; //Direct Off: ENVID and ENVID_F are set to &quot;0&quot; simultaneously. unsigned int temp; temp = readl(lcd_regs_base + VIDCON0); temp &amp;= ~(0x01 &lt;&lt; 1 | 0x01 &lt;&lt; 0); writel(temp, lcd_regs_base + VIDCON0); regulator_put(tiny4412_regulator); pm_runtime_disable(&amp;pdev-&gt;dev); unregister_framebuffer(tiny4412_lcd); dma_free_writecombine(NULL, tiny4412_lcd-&gt;fix.smem_len, tiny4412_lcd-&gt;screen_base, tiny4412_lcd-&gt;fix.smem_start); framebuffer_release(tiny4412_lcd); return 0;&#125; 4.3.2 设备树方式与前面的操作几乎一样，只不过是在dts实现device。 dts在regulators节点下添加新的regulator，设置约束条件：1234567891011121314151617181920regulators &#123; compatible = &quot;simple-bus&quot;; #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;; mmc_reg: regulator@0&#123; compatible = &quot;regulator-fixed&quot;; reg = &lt;0&gt;; regulator-name = &quot;VMEM_VDD_2.8V&quot;; regulator-min-microvolt = &lt;2800000&gt;; regulator-max-microvolt = &lt;2800000&gt;; &#125;; lcd_reg: regulator@1&#123; compatible = &quot;tiny4412,lcd_regulator&quot;; regulator-name = &quot;VCC_LCD&quot;; regulator-min-microvolt = &lt;1200000&gt;; regulator-max-microvolt = &lt;1200000&gt;; &#125;;&#125;; 在lcd节点下，添加级联关系：12345678910lcd_s702@11C00000 &#123; compatible = &quot;tiny4412, lcd_s702&quot;; reg = &lt;0x11C00000 0x20c0 0x10010210 0x08 0x10023c80 0x04 0x1003c000 0x1000&gt;; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;lcd_s702&gt;; clocks = &lt;&amp;clock CLK_FIMD0 &amp;clock CLK_ACLK160&gt;; clock-names = &quot;fimd0&quot;,&quot;aclk160&quot;; vlcd-supply = &lt;&amp;lcd_reg&gt;; status = &quot;okay&quot;;&#125;; 其中vlcd-supply与前面的regulator联系了起来。 driver提供操作函数及注册： [regulator.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/err.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/regulator/driver.h&gt;#include &lt;linux/mfd/core.h&gt;#include &lt;linux/io.h&gt;#include &lt;linux/of.h&gt;static int regulator_states = 0;static int tiny4412_regulator_enable(struct regulator_dev *rdev)&#123; printk(\"enter %s\\n\", __func__); printk(\"------LCD Power Open.------\\n\"); regulator_states = 1; return 0;&#125;static int tiny4412_regulator_disable(struct regulator_dev *rdev)&#123; printk(\"enter %s\\n\", __func__); printk(\"------LCD Power Close.------\\n\"); regulator_states = 0; return 0;&#125;static int tiny4412_regulator_is_enabled(struct regulator_dev *rdev)&#123; printk(\"enter %s\\n\", __func__); printk(\"------LCD Power Test.------\\n\"); if (regulator_states) return 1; else return 0;&#125;static struct regulator_ops tiny4412_regulator_ops =&#123; .enable = tiny4412_regulator_enable, .disable = tiny4412_regulator_disable, .is_enabled = tiny4412_regulator_is_enabled,&#125;;static struct regulator_desc tiny4412_regulator_desc =&#123; .name = \"tiny4412_regulator_dev\", .ops = &amp;tiny4412_regulator_ops, .type = REGULATOR_VOLTAGE,//电压源 .id = 0, .owner = THIS_MODULE, .n_voltages = 1,//能提供的电压数量&#125;;static struct regulator_dev *tiny4412_regulator_dev;static int tiny4412_regulator_probe(struct platform_device *pdev)&#123; struct regulator_config config = &#123; &#125;; config.dev = &amp;pdev-&gt;dev; config.init_data = dev_get_platdata(&amp;pdev-&gt;dev); printk(\"enter %s\\n\", __func__); tiny4412_regulator_dev = devm_regulator_register(&amp;pdev-&gt;dev, &amp;tiny4412_regulator_desc, &amp;config); if (IS_ERR(tiny4412_regulator_dev)) &#123; printk(\"devm_regulator_register error!\\n\"); return PTR_ERR(tiny4412_regulator_dev); &#125; return 0;&#125;static int tiny4412_regulator_remove(struct platform_device *pdev)&#123; printk(\"enter %s\\n\", __func__); devm_regulator_unregister(&amp;pdev-&gt;dev, tiny4412_regulator_dev); return 0;&#125;static const struct of_device_id regulators_of_match[] =&#123; &#123; .compatible = \"tiny4412,lcd_regulator\" &#125;, &#123; &#125;,&#125;;MODULE_DEVICE_TABLE(of, regulators_of_match);struct platform_driver tiny4412_regulator_drv =&#123; .probe = tiny4412_regulator_probe, .remove = tiny4412_regulator_remove, .driver = &#123; .name = \"tiny4412_regulator_drv\", .of_match_table = of_match_ptr(regulators_of_match), &#125;&#125;;static int tiny4412_regulator_init(void)&#123; printk(\"enter %s\\n\", __func__); platform_driver_register(&amp;tiny4412_regulator_drv); return 0;&#125;static void tiny4412_regulator_exit(void)&#123; printk(\"enter %s\\n\", __func__); platform_driver_unregister(&amp;tiny4412_regulator_drv);&#125;module_init(tiny4412_regulator_init);module_exit(tiny4412_regulator_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"Tiny4412 regulator driver.\");MODULE_ALIAS(\"Exynos4412_regulator\");MODULE_VERSION(\"V1.0\"); lcd_drv和前面的使用完全一致。 参考资料：韦东山第三期项目视频_电源管理蜗窝科技 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"Exynos4412","slug":"Exynos4412","permalink":"http://yoursite.com/tags/Exynos4412/"},{"name":"电源管理","slug":"电源管理","permalink":"http://yoursite.com/tags/电源管理/"}]},{"title":"嵌入式Linux网络编程——TCP/UDP","date":"2017-12-30T01:55:13.000Z","path":"2017/12/30/嵌入式Linux网络编程——TCP_UDP/","text":"本文主要记录TCP/UDP网络编程的基础知识，采用TCP/UDP实现宿主机和目标机之间的网络通信。回想去年校招那会，笔试题老是出现TCP/UDP相关的内容。那时候的我，熟悉点硬件，勉强会点STM32，哪知道什么TCP/UDP……渐渐的，TCP/UDP似乎就成了一个挥之不去的阴影。赶在今年年底，简单的入下门，明年估计会用上。 1.目标暂时想不出什么好的应用场景，目前想到目标就是实现让两个设备通过网络传输数据，比如开发板和Linux主机之间传数据，以后就可以实现开发板通过网络上报数据或者主机通过网络控制开发板。 此外，暂时不想关心具体的网络模型，更注重于网络相关函数的直接使用。 2.Linux网络编程基础2.1 嵌套字多个TCP连接或者多个应用程序进程 可能需要同一个TCP端口传输数据。为了区分不同应用程序进程和连接，许多计算机操作系统为应用程序与TCP/IP交互提供了称为嵌套字(Socket)的接口。Linux中的网络编程正是通过Socket接口实现的，Socket是一种文件描述符。 常用的TCP/IP有以下三种类型的嵌套字： 流式嵌套字（SOCK_STREAM）用于提供面向连接的、可靠的数据传输服务，即使用TCP进行传输。 数据报嵌套字（SOCK_DGRAM）用于提供无连接的服务，即使用UDP进行传输。 原始嵌套字（SOCK_RAW）可以读写内核没有处理的IP数据报，而流式嵌套字只能读取TCP的数据，数据报嵌套字只能读取UDP的数据。 因此，如果要访问其它协议发送的数据必须使用原始嵌套字，它允许对底层协议(如IP或ICMP)直接访问。 2.2 端口TCP/IP协议中的端口，端口号的范围从0~65535。一类是由互联网指派名字和号码公司ICANN负责分配给一些常用的应用程序固定使用的“周知的端口”，其值一般为0~1023。例如http的端口号是80，FTP为21，SSH为22，Telnet为23等。还有一类是用户自己定义的，通常是大于1024的整型值。 2.3 网络地址网络通信，归根到底还是进程间的通信(不同计算机上的进程间通信)。在网络中，每一个节点(计算机或路由)都有一个网络地址，如192.168.1.4，也就是IP地址。两个进程通信时，首先要确定各自所在的网络节点的网络地址。 但是，网络地址只能确定进程所在的计算机，而一台计算机上很可能同时运行着多个进程，所以仅凭网络地址还不能确定到底是和网络中的哪一个进程进行通信，因此套接口中还需要包括其他的信息，也就是端口号（PORT）。在一台计算机中，一个端口号一次只能分配给一个进程，也就是说，在一台计算机中，端口号和进程之间是一一对应关系。 所以，使用端口号和网络地址的组合可以唯一的确定整个网络中的一个网络进程。 例如，如网络中某一台计算机的IP为192.168.1.4，操作系统分配给计算机中某一应用程序进程的端口号为1500，则此时192.168.1.4 1500就构成了一个套接口。 2.2.1 网络地址的格式在Socket程序设计中，struct sockaddr用于记录网络地址，其格式如下：12345struct sockaddr&#123; unsigned short sa_family; /*协议族，采用AF_XXX的形式，例如AF_INET(IPv4协议族)*/ char sa_data[14]; /*14字节的协议地址，包含该socket的IP地址和端口号。*/&#125;;但在实际编程中，并不针对sockaddr数据结构进行操作，而是用与其等价的sockaddr_in数据结构：1234567struct sockaddr_in&#123; short int sa_family; /*地址族*/ unsigned short int sin_port; /*端口号*/ struct in_addr sin_addr; /*IP地址*/ unsigned char sin_zero[8]; /*填充0 以保持与struct sockaddr同样大小*/&#125;; 2.2.1 网络地址的转换IP地址通常用数字加点(如192.168.1.4)表示，而在struct in_addr中使用的式32位整数表示。因此，Linux提供如下函数进行两者之间的转换： inet_aton()函数： 所需要头文件：#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;函数格式：int inet_aton(const char *cp, struct in_addr *inp);函数功能：将a.b.c.d字符串形式的IP地址转换成32位网络序号IP地址；*cp:存放字符串形式的IP地址的指针*inp:存放32位的网络序号IP地址返回值：转换成功，返回非0，否则返回0； inet_ntoa()函数：客户机端: 所需要头文件：#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;函数格式：char *inet_ntoa(struct in_addr in);函数功能：将32位网络序号IP地址转换成a.b.c.d字符串形式的IP地址；in：Internet主机地址的结构返回值：转换成功，返回一个字符指针，否则返回NULL； 2.4 字节序不同的CPU采用对变量的字节存储顺序可能不同。常用的X86结构是小端模式，很多的ARM，DSP都为小端模式，即内存的低地址存储数据的低字节，高地址存储数据的高字节。而KEIL C51则为大端模式，内存的高地址存储数据的低字节，低地址存储数据高字节。 对于网络传输来说，数据顺序必须是一致的，网络字节顺序采用大端字节序方式。下面是四个常用的转换函数： 主机转网络： htons()函数： 所需要头文件：#include &lt;netinet/in.h&gt;函数格式：unsigned short int htons(unsigned short int hostshort)函数功能：将参数指定的16位主机(host)字符顺序转换成网络(net)字符顺序；hostshort：待转换的16位主机字符顺序数返回值：返回对应的网络字符顺序数； htonl()函数： 所需要头文件：#include &lt;netinet/in.h&gt;函数格式：unsigned long int htons(unsigned long int hostlong)函数功能：将参数指定的32位主机(host)字符顺序转换成网络(net)字符顺序；hostlong：待转换的32位主机字符顺序数返回值：返回对应的网络字符顺序数； 网络转主机： ntohs()函数： 所需要头文件：#include &lt;netinet/in.h&gt;函数格式：unsigned short int ntohs(unsigned short int netshort)函数功能：将参数指定的16位网络(net)字符顺序转换成主机(host)字符顺序；netshort：待转换的16位网络字符顺序数返回值：返回对应的主机字符顺序数； ntohl()函数： 所需要头文件：#include &lt;netinet/in.h&gt;函数格式：unsigned long int ntohl(unsigned long int netlong)函数功能：将参数指定的32位网络(net)字符顺序转换成主机(host)字符顺序；netshort：待转换的32位网络字符顺序数返回值：返回对应的主机字符顺序数； 3.TCPTCP有专门的传递保证机制，收到数据时会自动发送确认消息，发送方收到确认消息后才会继续发送消息，否则继续等待。这样的好处是传输的数据是可靠的，此外它是有连接的传输，大多数网络传输都是用的TCP。 3.1 TCP流程图 3.2 TCP步骤分析程序分为服务器端和客户机端，先从服务器端开始分析。 服务器端:a. 创建socket123456sock_fd = socket(AF_INET, SOCK_STREAM, 0);//AF_INET:IPV4;SOCK_STREAM:TCPif (-1 == sock_fd)&#123; fprintf(stderr,\"socket error:%s\\n\\a\", strerror(errno)); exit(1);&#125; 所需要头文件：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数格式：int socket(int domain, int type, int protocol);函数功能：创建一个套接字；domain:协议域(族)，决定了套接字的地址类型，例如AF_INET决定了要用IPv4地址(32位)与端口号(16位)的组合。常见的协议族有：AF_INET、AF_INET6、AF_LOCAL(或称AF_UNIX)、AF_ROUTE等；type：指定套接字类型，SOCK_STREAM(TCP)、SOCK_DGRAM(UDP)、SOCK_RAWprotocol:指定socket所使用的传输协议编号，通常为0返回值：若成功，返回一个套接字描述符，否则返回-1； Socket就是一种文件描述符，和普通的打开文件一样，需要检测其返回结果。 b. 设置socket1234memset(&amp;server_addr, 0, sizeof(struct sockaddr_in));//clearserver_addr.sin_family = AF_INET;server_addr.sin_addr.s_addr = htonl(INADDR_ANY);//INADDR_ANY:This machine all IPserver_addr.sin_port = htons(PORT_NUMBER);设置何种协议族，设置本机IP和端口，也就有了唯一性。 c. 绑定socket1234567ret = bind(sock_fd, (struct sockaddr *)(&amp;server_addr), sizeof(struct sockaddr));if(-1 == ret)&#123; fprintf(stderr,\"bind error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1);&#125; 所需要头文件：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数格式：int bind(int sockfd, struct sockaddr *addr, int addrlen);函数功能：把套接字绑定到本地计算机的某一个端口上；sockfd:待绑定的套接字描述符addr：一个struct sockaddr *指针，指定要绑定给sockfd的协议地址。内容结构由前面的协议族决定。addrlen:地址的长度返回值：若成功，返回0，否则返回-1，错误信息存在errno中； d. 开始监听1234567ret = listen(sock_fd, BACKLOG);if (-1 == ret)&#123; fprintf(stderr,\"listen error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1);&#125; 所需要头文件：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数格式：int listen(int sockfd, int backlog);函数功能：使服务器的这个端口和IP处于监听状态，等待网络中某一客户机的连接请求，最大连接数量为backlog≤128；sockfd:待监听的套接字描述符backlog：最大可监听和连接的客户端数量返回值：若成功，返回0，否则返回-1； e. 阻塞，等待连接12345678addr_len = sizeof(struct sockaddr);new_fd = accept(sock_fd, (struct sockaddr *)&amp;client_addr, &amp;addr_len);if (-1 == new_fd)&#123; fprintf(stderr,\"accept error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1);&#125; 所需要头文件：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数格式：int accept(int sockfd, struct sockaddr *addr, int *addrlen);函数功能：接受连接请求，建立起与客户机之间的通信连接。服务器处于监听状态时，如果某时刻获得客户机的连接请求，此时并不是立即处理这个请求，而是将这个请求放在等待队列中，当系统空闲时再处理客户机的连接请求；当accept函数接受一个连接时，会返回一个新的socket标识符，以后的数据传输和读取就要通过这个新的socket编号来处理，原来参数中的socket也可以继续使用，继续监听其它客户机的连接请求；accept连接成功时，参数addr所指的结构体会填入所连接机器的地址数据；sockfd:待监听的套接字描述符addr:指向struct sockaddr的指针，用于返回客户端的协议地址addrlen:协议地址的长度返回值：若成功，返回一个由内核自动生成的一个全新描述字，代表与返回客户的TCP连接，否则返回-1，错误信息存在errno中； f. 接收数据123456789101112recv_len = recv(new_fd, recv_buf, 999, 0);if (recv_len &lt;= 0)&#123; fprintf(stderr, \"recv error:%s\\n\\a\", strerror(errno))； close(new_fd); exit(1);&#125;else&#123; recv_buf[recv_len] = '\\0'; printf(\"Get msg from client%d: %s\\n\", client_num, recv_buf);&#125; 所需要头文件：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数格式：int recv(int sockfd, void *buf, size_t len, int flags);函数功能：用新的套接字来接收远端主机传来的数据，并把数据存到由参数buf指向的内存空间；sockfd:sockfd为前面accept的返回值，即new_fd，也就是新的套接字buf:指明一个缓冲区len:指明缓冲区的长度flags:通常为0返回值：若成功，返回接收到的字节数，另一端已关闭则返回0，否则返回-1，错误信息存在errno中； g. 关闭socket12close(sock_fd);exit(0); 为了应对多个连接，并保证它们之间相互独立，实际编程中往往还要加入多进程fork()。让子进程接收数据，父进程继续监听新的连接。 客户机端: a. 创建socket123456sock_fd = socket(AF_INET, SOCK_STREAM, 0);//AF_INET:IPV4;SOCK_STREAM:TCPif (-1 == sock_fd)&#123; fprintf(stderr,\"socket error:%s\\n\\a\", strerror(errno)); exit(1);&#125; b. 设置socket123memset(&amp;server_addr, 0, sizeof(struct sockaddr_in));//clearserver_addr.sin_family = AF_INET;server_addr.sin_port = htons(PORT_NUMBER);其中注意的是，这里设置的socket内容是指 希望连接的服务器IP和端口号信息，IP地址来自用户的输入，并转换格式得到。因此，这里的设置和服务器的设置，要保持内容上的一致。1234567ret = inet_aton(argv[1], &amp;server_addr.sin_addr);if(0 == ret)&#123; fprintf(stderr,\"server_ip error.\\n\"); close(sock_fd); exit(1);&#125; c. 连接1234567ret = connect(sock_fd, (const struct sockaddr *)&amp;server_addr, sizeof(struct sockaddr)); if (-1 == ret)&#123; fprintf(stderr,\"connect error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1);&#125; 所需要头文件：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数格式：int connect (int sockfd, struct sockaddr *serv_addr, int addrlen);函数功能：用来请求连接远程服务器，将参数sockfd的socket连至参数serv_addr所指定的服务器IP和端口号上去；sockfd:客户端的socket套接字serv_addr:一个struct sockaddr类型的结构体指针变量，存储着远程服务器的IP与端口号信息addrlen:结构体变量的长度返回值：若成功，返回0，否则返回-1，错误信息存在errno中； d. 发送1234567send_buf = send(sock_fd, send_buf, strlen(send_buf), 0);if (send_buf &lt;= 0)&#123; fprintf(stderr,\"send error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1);&#125; 所需要头文件：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数格式：int send(int sockfd, const void *buf, int len, int flags);函数功能：用来发送数据给指定的远端主机；sockfd:客户端的socket套接字buf:指明一个缓冲区len:指明缓冲区的长度flags:通常为0返回值：若成功，返回发送的字节数，否则返回-1，错误信息存在errno中 d. 关闭socket12close(sock_fd);exit(0); 3.3 TCP完整代码[tcp_server.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** tcp_server.c# Copyright (C) 2017 hceng, &lt;huangcheng.job@foxmail.com&gt;# Licensed under terms of GPLv2## This program is used for TCP / UDP learning.# https://hceng.cn/*/#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#define PORT_NUMBER 8888#define BACKLOG 10/* socket-&gt;bind-&gt;listen-&gt;accept-&gt;send/recv-&gt;close*/int main(int argc, char **argv)&#123; int sock_fd, new_fd; struct sockaddr_in server_addr; struct sockaddr_in client_addr; int ret; int addr_len; int recv_len; unsigned char recv_buf[1000]; int client_num = -1; signal(SIGCHLD,SIG_IGN); /* socket */ sock_fd = socket(AF_INET, SOCK_STREAM, 0);//AF_INET:IPV4;SOCK_STREAM:TCP if (-1 == sock_fd) &#123; fprintf(stderr,\"socket error:%s\\n\\a\", strerror(errno)); exit(1); &#125; /* set server sockaddr_in */ memset(&amp;server_addr, 0, sizeof(struct sockaddr_in));//clear server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = htonl(INADDR_ANY);//INADDR_ANY:This machine all IP server_addr.sin_port = htons(PORT_NUMBER); /* bind */ ret = bind(sock_fd, (struct sockaddr *)(&amp;server_addr), sizeof(struct sockaddr)); if(-1 == ret) &#123; fprintf(stderr,\"bind error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1); &#125; /* listen */ ret = listen(sock_fd, BACKLOG); if (-1 == ret) &#123; fprintf(stderr,\"listen error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1); &#125; /* accept */ while(1) &#123; addr_len = sizeof(struct sockaddr); new_fd = accept(sock_fd, (struct sockaddr *)&amp;client_addr, &amp;addr_len); if (-1 == new_fd) &#123; fprintf(stderr,\"accept error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1); &#125; client_num++; fprintf(stderr, \"Server get connetion form client%d: %s\\n\", client_num, inet_ntoa(client_addr.sin_addr)); if (!fork()) &#123; /* Child process */ while (1) &#123; /* recv */ recv_len = recv(new_fd, recv_buf, 999, 0); if (recv_len &lt;= 0) &#123; fprintf(stderr, \"recv error:%s\\n\\a\", strerror(errno)); close(new_fd); exit(1); &#125; else &#123; recv_buf[recv_len] = '\\0'; printf(\"Get msg from client%d: %s\\n\", client_num, recv_buf); &#125; &#125; close(new_fd); &#125; &#125; /* close */ close(sock_fd); exit(0); &#125; [tcp_client.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** tcp_client.c# Copyright (C) 2017 hceng, &lt;huangcheng.job@foxmail.com&gt;# Licensed under terms of GPLv2## This program is used for TCP / UDP learning.# https://hceng.cn/*/#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;netdb.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#define PORT_NUMBER 8888/* socket-&gt;connect-&gt;send-&gt;close*/int main(int argc, char *argv[])&#123; int sock_fd; struct sockaddr_in server_addr; int ret; unsigned char send_buf[1000]; int send_len; if(argc != 2) &#123; fprintf(stderr, \"Usage:%s hostname\\n\\a\", argv[0]); exit(1); &#125; /* socket */ sock_fd = socket(AF_INET, SOCK_STREAM, 0);//AF_INET:IPV4;SOCK_STREAM:TCP if (-1 == sock_fd) &#123; fprintf(stderr,\"socket error:%s\\n\\a\", strerror(errno)); exit(1); &#125; /* set sockaddr_in parameter*/ memset(&amp;server_addr, 0, sizeof(struct sockaddr_in));//clear server_addr.sin_family = AF_INET; server_addr.sin_port = htons(PORT_NUMBER); ret = inet_aton(argv[1], &amp;server_addr.sin_addr); if(0 == ret) &#123; fprintf(stderr,\"server_ip error.\\n\"); close(sock_fd); exit(1); &#125; /* connect */ ret = connect(sock_fd, (const struct sockaddr *)&amp;server_addr, sizeof(struct sockaddr)); if (-1 == ret) &#123; fprintf(stderr,\"connect error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1); &#125; while (1) &#123; if (fgets(send_buf, 999, stdin)) &#123; /* send */ send_len = send(sock_fd, send_buf, strlen(send_buf), 0); if (send_len &lt;= 0) &#123; fprintf(stderr,\"send error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1); &#125; &#125; &#125; /* close */ close(sock_fd); exit(0);&#125; 3.4 测试结果先在Ubuntu主机上交叉编译服务器端代码，再在Ubuntu主机上编译客户端代码。在开发板上运行服务器端代码，在Ubuntu主机先启动tmux分屏，再分别运行客户端代码。 服务器端 客户机端 4.UDPUDP没有传递保证机制，如果传输中数据丢失，协议不会有任何的检测或提示。这样的好处是传输的数据是持续的，此外它是无连接的传输，比如实时视频时，如果采用TCP，中途有一点点数据出错都会卡住，进行等待，产生延时。加入使用UDP，尽管有少量的丢帧，但数据是实时的。 4.1 UDP流程图 4.2 UDP步骤分析从流程图可以看出，UDP比TCP的步骤少多了。 服务器端: a. 创建socket123456sock_fd = socket(AF_INET, SOCK_DGRAM, 0);//AF_INET:IPV4;SOCK_DGRAM:UDPif (-1 == sock_fd)&#123; fprintf(stderr,\"socket error:%s\\n\\a\", strerror(errno)); exit(1);&#125;协议族改成SOCK_DGRAM。 b. 设置socket1234memset(&amp;server_addr, 0, sizeof(struct sockaddr_in));//clearserver_addr.sin_family = AF_INET;server_addr.sin_addr.s_addr = htonl(INADDR_ANY);//INADDR_ANY:This machine all IPserver_addr.sin_port = htons(PORT_NUMBER);和前面的TCP设置还是一样的。 c. 绑定socket1234567ret = bind(sock_fd, (struct sockaddr *)(&amp;server_addr), sizeof(struct sockaddr));if(-1 == ret)&#123; fprintf(stderr,\"bind error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1);&#125;绑定的操作也没有变。 d. 接收数据12345678910111213addr_len = sizeof(struct sockaddr);recv_len = recvfrom(sock_fd, recv_buf, 999, 0, (struct sockaddr *)&amp;server_addr, &amp;addr_len);if (recv_len &lt;= 0)&#123; fprintf(stderr, \"recvfrom error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1);&#125;else&#123; recv_buf[recv_len] = '\\0'; printf(\"Get msg from client%d: %s\\n\", client_num, recv_buf);&#125; 所需要头文件：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数格式：int recvfrom(int sockfd, char FAR *buf, int len, int flags, struct sockaddr FAR *from, int FAR *fromlen);函数功能：从套接字上接收一个数据报并保存源地址；sockfd:标识一个已连接套接字的描述符buf:接收数据缓冲区len:接收数据缓冲区长度flags:调用操作方式，由以下零个或多个组成 flags 说明 recv send MSG_DONTROUTE 绕过路由表查找 • MSG_DONTWAIT 仅本操作非阻塞 • • MSG_OOB 发送或接收带外数据 • • MSG_PEEK 窥看外来消息 • MSG_WAITALL 等待所有数据 • from:(可选)指针，指向装有源地址的缓冲区fromlen:(可选)指针，指向from缓冲区长度值返回值：若成功，返回读入的字节数，否则返回0； e. 关闭12close(sock_fd);exit(0); 客户机端: a. 创建socket123456sock_fd = socket(AF_INET, SOCK_DGRAM, 0);//AF_INET:IPV4;SOCK_DGRAM:UDPif (-1 == sock_fd)&#123; fprintf(stderr,\"socket error:%s\\n\\a\", strerror(errno)); exit(1);&#125;协议族改成SOCK_DGRAM。 b. 设置socket12345678910memset(&amp;server_addr, 0, sizeof(struct sockaddr_in));//clearserver_addr.sin_family = AF_INET;server_addr.sin_port = htons(PORT_NUMBER);ret = inet_aton(argv[1], &amp;server_addr.sin_addr);if(0 == ret)&#123; fprintf(stderr,\"server_ip error.\\n\"); close(sock_fd); exit(1);&#125; c. 发送数据12345678addr_len = sizeof(struct sockaddr);send_len = sendto(sock_fd, send_buf, strlen(send_buf), 0, (const struct sockaddr *)&amp;server_addr, addr_len);if (send_len &lt;= 0)&#123; fprintf(stderr,\"send error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1);&#125; 所需要头文件：#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数格式：int sendto(int sockfd, char FAR *buf, int len, int flags, struct sockaddr FAR *to, int FAR *tolen);函数功能：向一指定目的地发送数据；sockfd:一个标识套接字的描述字buf:发送数据缓冲区len:发送数据缓冲区长度flags:调用方式标志位to:(可选)指针，指向目的的套接字的地址tolen:目的套接字地址的长度返回值：若成功，返回发送的字节数，如果连接已中止，返回0，如果发生错误，返回-1； d. 关闭12close(sock_fd);exit(0);UDP传输的客户端少了connect()，原本该在connect()函数里传入服务器地址相关信息，现在变成了在sendto()里传入。 4.3 UDP完整代码[udp_client.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** udp_server.c# Copyright (C) 2017 hceng, &lt;huangcheng.job@foxmail.com&gt;# Licensed under terms of GPLv2## This program is used for TCP / UDP learning.# https://hceng.cn/*/#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#define PORT_NUMBER 8888/* socket-&gt;bind-&gt;recvfrom/sendto-&gt;close */int main(int argc, char **argv)&#123; int sock_fd; struct sockaddr_in server_addr; struct sockaddr_in client_addr; int ret; int addr_len; int recv_len; unsigned char recv_buf[1000]; /* socket */ sock_fd = socket(AF_INET, SOCK_DGRAM, 0);//AF_INET:IPV4;SOCK_DGRAM:UDP if (-1 == sock_fd) &#123; fprintf(stderr,\"socket error:%s\\n\\a\", strerror(errno)); exit(1); &#125; /* set sockaddr_in parameter*/ memset(&amp;server_addr, 0, sizeof(struct sockaddr_in));//clear server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = htonl(INADDR_ANY);//INADDR_ANY:This machine all IP server_addr.sin_port = htons(PORT_NUMBER); /* bind */ ret = bind(sock_fd, (struct sockaddr *)(&amp;server_addr), sizeof(struct sockaddr)); if(-1 == ret) &#123; fprintf(stderr,\"bind error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1); &#125; while (1) &#123; /* recvfrom */ addr_len = sizeof(struct sockaddr); recv_len = recvfrom(sock_fd, recv_buf, 999, 0, (struct sockaddr *)&amp;client_addr, &amp;addr_len); if (recv_len &lt;= 0) &#123; fprintf(stderr, \"recvfrom error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1); &#125; else &#123; recv_buf[recv_len] = '\\0'; printf(\"Get msg from client:%s: %s\\n\", inet_ntoa(client_addr.sin_addr), recv_buf); &#125; &#125; /* close */ close(sock_fd); exit(0); &#125; [udp_client.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** udp_client.c# Copyright (C) 2017 hceng, &lt;huangcheng.job@foxmail.com&gt;# Licensed under terms of GPLv2## This program is used for TCP / UDP learning.# https://hceng.cn/*/#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;netdb.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#define PORT_NUMBER 8888/* socket-&gt;bind-&gt;recvfrom/sendto-&gt;close */int main(int argc, char *argv[])&#123; int sock_fd; struct sockaddr_in server_addr; int ret; unsigned char send_buf[1000]; int send_len; int addr_len; if(argc != 2) &#123; fprintf(stderr, \"Usage:%s hostname\\n\\a\", argv[0]); exit(1); &#125; /* socket */ sock_fd = socket(AF_INET, SOCK_DGRAM, 0);//AF_INET:IPV4;SOCK_DGRAM:UDP if (-1 == sock_fd) &#123; fprintf(stderr,\"socket error:%s\\n\\a\", strerror(errno)); exit(1); &#125; /* set sockaddr_in parameter*/ memset(&amp;server_addr, 0, sizeof(struct sockaddr_in));//clear server_addr.sin_family = AF_INET; server_addr.sin_port = htons(PORT_NUMBER); ret = inet_aton(argv[1], &amp;server_addr.sin_addr); if(0 == ret) &#123; fprintf(stderr,\"server_ip error.\\n\"); close(sock_fd); exit(1); &#125; while (1) &#123; if (fgets(send_buf, 999, stdin)) &#123; /* sendto */ addr_len = sizeof(struct sockaddr); send_len = sendto(sock_fd, send_buf, strlen(send_buf), 0, \\(const struct sockaddr *)&amp;server_addr, addr_len); if (send_len &lt;= 0) &#123; fprintf(stderr,\"send error:%s\\n\\a\", strerror(errno)); close(sock_fd); exit(1); &#125; &#125; &#125; /* close */ close(sock_fd); exit(0);&#125; 4.4 测试结果和前面TCP测试方式一样，先在Ubuntu主机上交叉编译服务器端代码，再在Ubuntu主机上编译客户端代码。在开发板上运行服务器端代码，在Ubuntu主机先启动tmux分屏，再分别运行客户端代码。 服务器端 客户机端 参考资料：博客：很全的linux网络编程技巧王粉花. 2016. 嵌入式Linux编程与实践教程.北京: 科学出版社.韦东山第三期项目:第1课第6.1节_一小时学会网络编程_两个简单例子_tcp_udp 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux环境编程","slug":"Linux环境编程","permalink":"http://yoursite.com/tags/Linux环境编程/"},{"name":"TCP/UDP","slug":"TCP-UDP","permalink":"http://yoursite.com/tags/TCP-UDP/"}]},{"title":"Exynos4412——触摸屏驱动","date":"2017-12-26T01:34:47.000Z","path":"2017/12/26/Exynos4412——触摸屏驱动/","text":"移植Exynos4412的I2C接口触摸屏驱动。这应该是Exynos4412 LCD部分的最后一部分了。为了去探索LCD驱动，前面做了一系列的准备工作，最后终于完成了LCD驱动，现在只剩下触摸屏这个最后的“尾巴”。 1.工作原理前面LCD之backligth部分说了，友善之臂这个屏，为了改善大尺寸四线电阻触摸屏的性能，外加了一个低成本的MCU去控制专业的触控芯片，将滤波后的稳定数据通过GPIO传回到ARM上。但我的板子LCD是电容屏，查阅相关资料后得知，是通过一个FT5406触摸屏芯片实现的电容触摸功能。 根据FT5x06.pdf手册可得知其工作的框架：当触摸屏上发生触摸操作时，通过TXn(Transmit output pin)和RXn(Receiver input pins)传输给FT5406，FT5406经过处理后，将坐标信息通过Serial Interface(I2C or SPI)发给Host(开发板)。 查阅FT5x06.pdf，可以看到FT5x06对外有如下接口： I2C/SPI：与主机进行数据交换的接口INT：中断信号接口，通知主处理器触摸数据准备好读取WAKE：主机将FT5x06从休眠模式切换到主动模式的中断信号RST：外部低电平信号复位芯片 因此，开发板至少的有I2C/SPI和INT与FT5x06相连。 2.原理图 Tiny4412-1412-Schematic.pdf：I2C使用I2C1，INT使用GPX1_6引脚。 Tiny4412SDK-1506-Schematic.pdf：在底板上经过一次电平转换引出到LCD1接口上。 LCD-S702-1509.pdf：LCD上并没有FT5x06的相关信息，只提供了一个CON5接口。友善之臂封装好了LCD和触摸屏，对外只提供I2C接口。 对于驱动来说，触摸屏就是一个带中断的信号的I2C设备。 3. 设备树文件ft5406 作为 i2c_1 的子节点。12345678910111213&amp;i2c_1 &#123; samsung,i2c-sda-delay = &lt;100&gt;; samsung,i2c-max-bus-freq = &lt;400000&gt;; status = &quot;okay&quot;; polytouch: edt-ft5x06@38 &#123; compatible = &quot;edt,edt-ft5406&quot;, &quot;edt,edt-ft5x06&quot;; reg = &lt;0x38&gt;; interrupt-parent = &lt;&amp;gpx1&gt;; interrupts = &lt;6 IRQ_TYPE_EDGE_FALLING&gt;; touchscreen-size-x = &lt;800&gt;; touchscreen-size-y = &lt;480&gt;; &#125;; &#125;; 内核已经有了ft5x06驱动，所有对应的也会有设备树的描述文件：linux-4.13.9/Documentation/devicetree/bindings/input/touchscreen/edt-ft5x06.txtlinux-4.13.9/Documentation/devicetree/bindings/input/touchscreen/touchscreen.txt详细介绍了设备树的必要参数和非必要参数。 4. 驱动程序内核中ft5x06驱动所在路径：linux-4.13.9/drivers/input/touchscreen/edt-ft5x06.c 这块的内容，暂时不想分析，涉及I2C子系统和输入子系统，回头再慢慢分析。 5. 测试程序[app.c]link12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;linux/input.h&gt; int main() &#123; int keys_fd; char ret[2]; struct input_event t; keys_fd = open(\"/dev/input/event0\", O_RDONLY); //打开TP设备 if(keys_fd&lt;=0)&#123; printf(\"open /dev/input/event0 device error!\\n\"); return 0; &#125; while(1) &#123; if(read(keys_fd, &amp;t, sizeof(t))==sizeof(t)) &#123; if (t.type == EV_KEY) &#123; printf(\" type: EV_KEY, event = %s, value = %d \\r\\n\", t.code == BTN_TOUCH ? \"BTN_TOUCH\" : \"Unkown\", t.value); &#125; else if(t.type == EV_ABS) &#123; printf(\" type: EV_ABS, event = %s, value = %d \\r\\n\", t.code == ABS_X ? \"ABS_X\" : t.code == ABS_Y ? \"ABS_Y\" : t.code == ABS_PRESSURE ? \"ABS_PRESSURE\" :\"Unkown\", t.value); &#125; &#125; &#125; close(keys_fd); return 0; &#125; 参考博客：Linux和android下测试键盘和触摸屏 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"Exynos4412","slug":"Exynos4412","permalink":"http://yoursite.com/tags/Exynos4412/"},{"name":"触摸屏","slug":"触摸屏","permalink":"http://yoursite.com/tags/触摸屏/"}]},{"title":"Exynos4412——LCD驱动","date":"2017-12-22T12:15:29.000Z","path":"2017/12/22/Exynos4412——LCD驱动/","text":"Exynos4412的LCD驱动。终于迎来了LCD驱动，本该10月初就搞定的事，一直拖到了12月份。不过，晚来总比不来好，完成这个心结，才好进入下一个阶段。 1. 基础知识开发板的液晶屏型号S702，7寸电容型TFT触摸屏，分辨率为800X480。 先记录下一些图像显示的基本知识。 1.1 颜色的量化显示器的颜色一般采用RGB标准，通过对红(RED)、绿(GREEN)，蓝(BLUE)三个颜色相互叠加得到各种不同的颜色。1）通过对颜色的编码来对颜色进行量化（即转换成数字量，RGB是一种编码方式）；2）每种颜色根据RGB格式不同，每种颜色的量化位不相同；3) 常见的RGB格式有RGB565/RGB888，即: RGB565: red :5 green : 6 blue:5（16BPP） RGB888: red :8 green : 8 blue:8（24BPP）4）有的还会有个alpha参数，用于实现图形渐变效果，以及半透明效果，0xFFF=全透明，0x0=不透明； 1.2 图像的构成像素：显示的最小单位；用若干位数据来表示一个像素，比如使用R8、G8、B8共24位来表示一个像素，这个也称为像素深度，单位为BPP 常见的有16BPP/24BPP；像素越高，则一个像素点所显示的颜色就越多，所显示的颜色更广； 帧：一幅图像被称为一帧，每帧里面由行列排列的像素组成； 调色板：画油画的时候，通常先在调色板里配好想要的颜色，再用画笔沾到画布上作画。LCD控制器里也借用了这个概念，从FrameBuffer获得数据，这个数据作为索引从调色板获得对应数据，再发给电子枪显示出来。如图，假如是16BPP的数据，LCD控制器从FB取出16bit数据，显示到LCD上。当如果想节约内存，对颜色要求也没那么高，就可以采用调色板的方式，调色板里存放了256个16bit的数据，FB只存放每个像素的索引，根据索引去调色板找到对应的数据传给LCD控制器，再通过电子枪显示出来。 1.3 LCD显示原理常见的TFT显示屏幕都会有如下控制信号：1)使用HSYNC信号来控制一行的显示；2)使用VSYNC信号来控制一帧(列)的显示；3)使用VCLK信号来控制一个像素的显示；4)使用VDEN信号来控制数据的输出；想象每个像素点是由电子枪发射出来的，电子枪依次扫描整个LCD界面，就显示了一副完整的图像。当发出一个HSYNC信号后，电子枪就会从行末花费HBP时长移动到行首；然后在VCLK时钟下，在图中阴影区域显示像素；等到了行末后，再等待HFP时长待HSYNC信号到来，再移动到行首，如此往复。因此，HBP和HFP分别决定了左边和右边的黑框。同理，当发出一个VSYNC信号后，电子枪就会从列末花费VBP时长移动到列首；然后在VCLK时钟下，在图中阴影区域显示像素；等到了列末后，再等待VFP时长待VSYNC信号到来，再移动到列首，如此往复。因此，VBP和VFP分别决定了上边和下边的黑框。真实显示区域为图中阴影部分。 1.4 LCD硬件控制思路 查看LCD芯片手册，查看相关的时间参数、分辨率、引脚极性等； 根据以上信息设置LCD控制器寄存器，让其发出正确信号； 在内存里面分配一个FrameBuffer，在里面用若干位表示一个像素，再把首地址告诉LCD控制器； 之后LCD控制器就能周而复始取出FrameBuffer里面的像素数据，配合其它控制信号，发送给电子枪，电子枪再让在LCD上显示出来。以后我们想显示图像，只需要编写程序向FrameBuffer填入相应数据即可，硬件会自动的完成显示操作。 1.5 LCD驱动框架LCD框架的fbmem.c已经帮我们完成了日常驱动程序的工作，如：注册字符设备、分配设备号、创建类等。也有了操作函数fb_fops，但它只是一个框架，在具体执行的时候需要知道硬件具体的一些参数，比如分辨率、数据基地址等信息。因此，我们要利用这一框架，就得构造一个fb_info结构体，完成硬件初始化，设置相关参数等操作，再使用register_framebuffer()将fb_info向上注册。这样，fbmem.c就可以从registered_fb[]这个数组获得fb_info参数，进行相关的硬件操作。比如：应用层app想read()，就会调用fbmem.c的fb_read()，在fb_read里面会先尝试使用xxfb.c提供的read()操作函数，如果没有，再根据fb_info信息得到数据基地址，将基地址开始的数据，返回给应用层，实现读操作。 2. 原理图 Tiny4412SDK-1506-Schematic.pdf： 从上到下，接口依次是： 接口 引脚 含义 1. 图像数据信号接口 B[0:7] 蓝色数据信号线 - G[0:7] 绿色数据信号线 - R[0:7] 红色数据信号线 2. “一线触摸”接口 XEINT10_OUT 用于 触摸/背光 控制 3. 时序信号控制接口 DEN 数据使能信号 - VSYNC 垂直同步信号 - HSYNC 水平同步信号 - VLCK LCD时钟信号 4. I2C接口 i2cSCL1_OUT/i2cSDA1_OUT 用于实现I2C接口的触摸屏驱动 Tiny4412-1412-Schematic.pdf：LCD数据和控制部分使用了GPF0_0-GPF0_7、GPF1_0-GPF1_7、GPF2_0-GPF2_7、GPF3_0-GPF3_5，共3*8+4=28个引脚。 3. 设备树文件123456789101112131415161718192021lcd_s702@11C00000 &#123; compatible = &quot;tiny4412, lcd_s702&quot;; reg = &lt;0x11C00000 0x20c0 0x10010210 0x08 0x10023c80 0x04 0x1003c000 0x1000&gt;; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;lcd_s702&gt;; clocks = &lt;&amp;clock CLK_FIMD0 &amp;clock CLK_ACLK160&gt;; clock-names = &quot;fimd0&quot;,&quot;aclk160&quot;;&#125;;&amp;pinctrl_0 &#123; lcd_s702:lcd &#123; samsung,pins = &quot;gpf0-0&quot;, &quot;gpf0-1&quot;, &quot;gpf0-2&quot;, &quot;gpf0-3&quot;, &quot;gpf0-4&quot;, &quot;gpf0-5&quot;, &quot;gpf0-6&quot;,&quot;gpf0-7&quot;, &quot;gpf1-0&quot;, &quot;gpf1-1&quot;, &quot;gpf1-2&quot;, &quot;gpf1-3&quot;, &quot;gpf1-4&quot;, &quot;gpf1-5&quot;, &quot;gpf1-6&quot;, &quot;gpf1-7&quot;, &quot;gpf2-0&quot;, &quot;gpf2-1&quot;, &quot;gpf2-2&quot;, &quot;gpf2-3&quot;, &quot;gpf2-4&quot;, &quot;gpf2-5&quot;, &quot;gpf2-6&quot;,&quot;gpf2-7&quot;, &quot;gpf3-0&quot;, &quot;gpf3-1&quot;, &quot;gpf3-2&quot;, &quot;gpf3-3&quot;; samsung,pin-function = &lt;2&gt;; samsung,pin-pud = &lt;0&gt;; samsung,pin-drv = &lt;0&gt;; &#125;;&#125;; 其中，0x11C00000是LCD寄存器基地址；0x10010210是LCD时钟寄存器基地址；0x10023c80是LCD时钟寄存器基地址；0x10023c80是LCD时钟寄存器基地址； Samsung GPIO and Pin Mux/Config controller摘录： “samsung,pins” property of the child node. The following pin configuration properties are supported. samsung,pin-val: Initial value of pin output buffer. samsung,pin-pud: Pull up/down configuration. samsung,pin-drv: Drive strength configuration. samsung,pin-pud-pdn: Pull up/down configuration in power down mode. samsung,pin-drv-pdn: Drive strength configuration in power down mode. 4. 驱动分析LCD驱动也属于字符驱动，框架和其它字符驱动差不多，难点是LCD的众多硬件配置。 和以往的框架一样，加载驱动后调用lcd_init()函数，然后lcd_init()调用platform_driver_register(&amp;lcd_driver)注册平台设备，lcd_driver结构体里面的.compatible与设备树里面的compatible进行字符串比较，匹配成功则调用核心的lcd_probe()函数。下面对lcd_probe()函数里面的内容进行详细介绍。 4.1 lcd_probelcd_probe()需要的配置如下： 1.分配一个fb_info2.设置fb_info 2.1 设置 fix 固定的参数 2.2 设置 var 可变的参数 2.3 设置操作函数 2.4 其他的设置3.硬件相关的操作 3.1 配置GPIO用于LCD 3.2 根据LCD手册设置LCD控制器, 比如VCLK的频率等 3.3 分配显存(framebuffer), 并把地址告诉LCD控制器4.注册fb_info 4.1.1 分配一个fb_info1234tiny4412_lcd = framebuffer_alloc(0, NULL); //不要额外空间设置私有数据if(!tiny4412_lcd) &#123; return -ENOMEM;&#125; 4.1.2 设置fb_info4.1.2.1 设置 fix 固定的参数12345strcpy(tiny4412_lcd-&gt;fix.id, \"s702\"); //设置fix名称tiny4412_lcd-&gt;fix.smem_len = LCD_LENTH*LCD_WIDTH*BITS_PER_PIXEL/8; //显存的长度=分辨率*每象素字节数tiny4412_lcd-&gt;fix.type = FB_TYPE_PACKED_PIXELS; //类型:填充式像素(常用在TFT屏幕)tiny4412_lcd-&gt;fix.visual = FB_VISUAL_TRUECOLOR; //TFT 真彩色tiny4412_lcd-&gt;fix.line_length = LCD_LENTH*BITS_PER_PIXEL/8; //每行的长度，以字节为单位 4.1.2.2 设置 var 可变的参数123456789101112131415tiny4412_lcd-&gt;var.xres = LCD_LENTH; //x方向分辨率tiny4412_lcd-&gt;var.yres = LCD_WIDTH; //y方向分辨率tiny4412_lcd-&gt;var.xres_virtual = LCD_LENTH; //x方向虚拟分辨率tiny4412_lcd-&gt;var.yres_virtual = LCD_WIDTH; //y方向虚拟分辨率tiny4412_lcd-&gt;var.xoffset = 0; //x方向真实值和虚拟值得差值tiny4412_lcd-&gt;var.yoffset = 0; //y方向真实值和虚拟值得差值tiny4412_lcd-&gt;var.bits_per_pixel = BITS_PER_PIXEL; //每个像素占多少位/* RGB:888 */tiny4412_lcd-&gt;var.red.length = 8;tiny4412_lcd-&gt;var.red.offset = 16; //红tiny4412_lcd-&gt;var.green.length = 8;tiny4412_lcd-&gt;var.green.offset = 8; //绿tiny4412_lcd-&gt;var.blue.length = 8;tiny4412_lcd-&gt;var.blue.offset = 0; //蓝tiny4412_lcd-&gt;var.activate = FB_ACTIVATE_NOW; //使设置的值立即生效 4.1.2.3 设置操作函数1tiny4412_lcd-&gt;fbops = &amp;tiny4412_lcdfb_ops; //绑定操作函数 这里的绑定的操作函数有：12345678static struct fb_ops tiny4412_lcdfb_ops =&#123; .owner = THIS_MODULE, .fb_setcolreg = cfb_setcolreg, //设置RGB颜色，实现伪颜色表 .fb_fillrect = cfb_fillrect, //矩形填充 .fb_copyarea = cfb_copyarea, //数据复制 .fb_imageblit = cfb_imageblit, //图形填充&#125;;除了cfb_setcolreg()，其它三个函数内核都提供了具体的实现。 4.1.2.4 其他的设置12tiny4412_lcd-&gt;pseudo_palette = pseudo_palette; //存放调色板所调颜色的数组tiny4412_lcd-&gt;screen_size = LCD_LENTH * LCD_WIDTH * BITS_PER_PIXEL / 8; //显存大小 4.1.3 硬件相关的操作4.1.3.1 配置GPIO用于LCD在设备树中，将 GPF0_0-GPF0_7、GPF1_0-GPF1_7、GPF2_0-GPF2_7、GPF3_0-GPF3_3配置为了复用第二功能(LCD)，禁止内部上拉，驱动强度配置设置为0，因此这里就不需要任何设置了。 4.1.3.2 根据LCD手册设置LCD控制器, 比如VCLK的频率等a. 首先是获取设备树中的寄存器资源，并进行映射：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 res0 = platform_get_resource(pdev, IORESOURCE_MEM, 0); if (res0 == NULL) &#123; printk(\"platform_get_resource error.\\n\"); return -EINVAL; &#125; lcd_regs_base = devm_ioremap_resource(&amp;pdev-&gt;dev, res0); if (lcd_regs_base == NULL) &#123; printk(\"devm_ioremap_resource error.\\n\"); return -EINVAL; &#125; res1 = platform_get_resource(pdev, IORESOURCE_MEM, 1); if (res1 == NULL) &#123; printk(\"platform_get_resource error.\\n\"); return -EINVAL; &#125; lcdblk_regs_base = devm_ioremap_resource(&amp;pdev-&gt;dev, res1); if (lcdblk_regs_base == NULL) &#123; printk(\"devm_ioremap_resource error.\\n\"); return -EINVAL; &#125; res2 = platform_get_resource(pdev, IORESOURCE_MEM, 2); if (res2 == NULL) &#123; printk(\"platform_get_resource error.\\n\"); return -EINVAL; &#125; //bug： /* devm_ioremap()和devm_ioremap_resource()区别： devm_ioremap()可以重复map相同的地址空间，devm_ioremap_resource()不可以。 一般SoC的中，各个硬件模块各自的memory region都有严格的划分(比如说USB host的地址空间绝对不会和flash host冲突)， 所以一般的driver使用devm_ioremap()和devm_ioremap_resource()都行。 但这里，应该系统已经映射过一次了，所以使用devm_ioremap_resource()会报错。 */ //lcd0_configuration = devm_ioremap_resource(&amp;pdev-&gt;dev, res2); lcd0_configuration = devm_ioremap(&amp;pdev-&gt;dev, res2-&gt;start, resource_size(res2)); if (lcd0_configuration == NULL) &#123; printk(\"devm_ioremap_resource error.\\n\"); return -EINVAL; &#125; *(unsigned long *)lcd0_configuration = 7; //Reset Value = 0x00000007 res3 = platform_get_resource(pdev, IORESOURCE_MEM, 3); if (res3 == NULL) &#123; printk(\"platform_get_resource error.\\n\"); return -EINVAL; &#125; //clk_regs_base = devm_ioremap_resource(&amp;pdev-&gt;dev, res3);clk_regs_base = devm_ioremap(&amp;pdev-&gt;dev, res3-&gt;start, resource_size(res3)); if (clk_regs_base == NULL) &#123; printk(\"devm_ioremap_resource error.\\n\"); return -EINVAL; &#125;这里后期测试出一个bug: devm_ioremap()和devm_ioremap_resource()区别：devm_ioremap()可以重复map相同的地址空间，devm_ioremap_resource()不可以。一般SoC的中，各个硬件模块各自的memory region都有严格的划分(比如说USB host的地址空间绝对不会和flash host冲突)，所以一般的driver使用devm_ioremap()和devm_ioremap_resource()都行。但这里，应该系统已经映射过一次了，所以使用devm_ioremap_resource()会报错。 b. 设置时钟时钟部分还是有点乱，没有从头开始去分析，当这里的目的是生成VCLK，因此配置出VCLK即可：12345678910111213141516171819202122232425262728293031323334353637383940414243//时钟源选择\\使能时钟//Selects clock source for LCD_BLK//FIMD0_SEL:bit[3:0]=0110=SCLKMPLL_USER_T=800Mtemp = readl(clk_regs_base + CLK_SRC_LCD0);temp &amp;= ~(0x0F&lt;&lt;0);temp |= (0x3&lt;&lt;1);writel(temp, clk_regs_base + CLK_SRC_LCD0);//Clock source mask for LCD_BLK //FIMD0_MASK:Mask output clock of MUXFIMD0 (1=Unmask)temp = readl(clk_regs_base + CLK_SRC_MASK_LCD);temp |= (0x01&lt;&lt;0);writel(temp, clk_regs_base + CLK_SRC_MASK_LCD);//Clock source mask for LCD_BLK //SCLK_FIMD0 = MOUTFIMD0/(FIMD0_RATIO + 1),分频比 1/1temp = readl(clk_regs_base + CLK_DIV_LCD);temp &amp;= ~(0x0F&lt;&lt;0);writel(temp, clk_regs_base + CLK_DIV_LCD);//Controls IP clock gating for LCD_BLK //CLK_FIMD0:Gating all clocks for FIMD0 (1=Pass)temp = readl(clk_regs_base + CLK_GATE_IP_LCD);temp |= (0x01&lt;&lt;0);writel(temp, clk_regs_base + CLK_GATE_IP_LCD);//FIMDBYPASS_LBLK0:FIMD of LBLK0 Bypass Selection (1=FIMD Bypass)temp = readl(lcdblk_regs_base + LCDBLK_CFG);temp |= (0x01&lt;&lt;1);writel(temp, lcdblk_regs_base + LCDBLK_CFG);//MIE0_DISPON:MIE0_DISPON: PWM output control (1=PWM outpupt enable)temp = readl(lcdblk_regs_base + LCDBLK_CFG2);temp |= (0x01&lt;&lt;0);writel(temp, lcdblk_regs_base + LCDBLK_CFG2);mdelay(1000);//LCD时钟: VCLK=FIMD*SCLK/(CLKVAL+1), where CLKVAL&gt;=1//800/(19+1) == 40M&lt;80Mtemp = readl(lcd_regs_base + VIDCON0);temp |= (19&lt;&lt;6);writel(temp, lcd_regs_base + VIDCON0);思路就是选择时钟源，然后启用时钟源，再分频得到所需VCLK。 c. 设置引脚极性和时序 LCD手册“S702-AT070TN92.pdf”中的时序图和时间参数：(PS:手册图片做得真烂，源PDF都模糊)上半部分为水平输入时序图，下半部分为垂直方向输入时序图。 然后是图中的时间参数： Exynos 4412手册“Exynos 4412 SCP_Users Manual.pdf”中的时序图： 我的经验就是结合LCD的时序图和控制器的时序图，对比两者的时序得出关系式和极性。因此，可以得出：极性方面：VS与VSYNC极性相反，HS与HSYNC极性相反，DE与VDEN极性一致，DCLK是在上升沿触发。 对于寄存器VIDCON1：12345678910/* * VIDTCON1: * [5]:IVSYNC ===&gt; 1 : Inverted(反转) * [6]:IHSYNC ===&gt; 1 : Inverted(反转) * [7]:IVCLK ===&gt; 1 : Fetches video data at VCLK rising edge (上降沿触发) * [10:9]:FIXVCLK ====&gt; 01 : VCLK running */temp = readl(lcd_regs_base + VIDCON1);temp |= (1 &lt;&lt; 9) | (1 &lt;&lt; 7) | (1 &lt;&lt; 5) | (1 &lt;&lt; 6);writel(temp, lcd_regs_base + VIDCON1); 时序方面：12345678VSPW+1=tvpw=1~20(暂取11) --&gt; VSPW=10VBPD+1=tvb-tvpw=23-11=12 --&gt; VBPD=11VFPD+1=tvfp=22 --&gt; VFPD=21HSPW+1=hpw=1~40(暂取21) --&gt; HSPW=20HBPD+1=thb-hpw=46-21=25 --&gt; HBPD=24HOZVAL+1=thd=800 --&gt; HOZVAL=799HFPD+1=thfp=210 --&gt; HFPD=209 对于寄存器VIDTCON0：123456789/* * VIDTCON0: * [23:16]: VBPD+1=tvb-tvpw=23-11=12 --&gt; VBPD=11 * [15:8] : VFPD+1=tvfp=22 --&gt; VFPD=21 * [7:0] : VSPW+1=tvpw=1~20(暂取11) --&gt; VSPW=10 */temp = readl(lcd_regs_base + VIDTCON0);temp |= (11 &lt;&lt; 16) | (21 &lt;&lt; 8) | (10 &lt;&lt; 0);writel(temp, lcd_regs_base + VIDTCON0); 对于寄存器VIDTCON1：123456789/* * VIDTCON1: * [23:16]: HBPD+1=thb-hpw=46-21=25 --&gt; HBPD=24 * [15:8] : HFPD+1=thfp=210 --&gt; HFPD=209 * [7:0] : HSPW+1=hpw=1~40(暂取21) --&gt; HSPW=20 */temp = readl(lcd_regs_base + VIDTCON1);temp |= (24 &lt;&lt; 16) | (209 &lt;&lt; 8) | (20 &lt;&lt; 0);writel(temp, lcd_regs_base + VIDTCON1); d. 设置分辨率1234567/* * HOZVAL = (Horizontal display size) - 1 and LINEVAL = (Vertical display size) - 1. * Horizontal(水平) display size : 800 * Vertical(垂直) display size : 480 */temp = ((LCD_WIDTH-1) &lt;&lt; 11) | (LCD_LENTH &lt;&lt; 0);writel(temp, lcd_regs_base + VIDTCON2); e. 设置数据格式如前面可变参数所设置的一样，本次采用的是24BPP格式，每个像素占用32位(实际使用24位)。当使能字节交换时(BSWP=0, HWSWP=0, WSWP=1)，则低位像素存放在低字节，即[23:0]放像素1，[31:24]空，[55:32]放第二个像素，[63:56]空，依次类推，这种存放方式更符合日常习惯。12345678910/* * WINCON0: * [15]:Specifies Word swap control bit. 1 = Enables swap 低位像素存放在低字节 * [5:2]: Selects Bits Per Pixel (BPP) mode for Window image : 1101 ===&gt; Unpacked 25 BPP (non-palletized A:1-R:8-G:8-B:8) * [0]:Enables/disables video output 1 = Enables */temp = readl(lcd_regs_base + WINCON0);temp &amp;= ~(0x0F &lt;&lt; 2);temp |= (0X01 &lt;&lt; 15) | (0x0D &lt;&lt; 2) | (0x01&lt;&lt;0);writel(temp, lcd_regs_base + WINCON0); f. 设置/使能显示窗口12345678910//Enables Channel 0.temp = readl(lcd_regs_base + SHADOWCON);writel(temp | 0x01, lcd_regs_base + SHADOWCON);//Selects Channel 0temp = readl(lcd_regs_base + WINCHMAP2);temp &amp;= ~(7 &lt;&lt; 16);temp |= (0x01 &lt;&lt; 16);//CH0FISEL:Selects Channel 0's channel.001 = Window 0temp &amp;= ~(7 &lt;&lt; 0);temp |= (0x01 &lt;&lt; 0);//W0FISEL:Selects Window 0's channel.001 = Channel 0writel(temp, lcd_regs_base + WINCHMAP2); g. 设置OSD功能 注：OSD是on-screen display的简称，即屏幕菜单式调节方式。即在当前显示上叠加一层显示，就像显示器的调节菜单。 1234567891011121314//设置OSD显示大小//Window Size For example. Height * Width (number of word)temp = (LCD_LENTH * LCD_WIDTH) &gt;&gt; 1;writel(temp, lcd_regs_base + VIDOSD0C);/* * bit0-10 : 指定OSD图像左上像素的垂直屏幕坐标 * bit11-21: 指定OSD图像左上像素的水平屏幕坐标 */writel(0, lcd_regs_base + VIDOSD0A);/* * bit0-10 : 指定OSD图像右下像素的垂直屏幕坐标 * bit11-21: 指定OSD图像右下像素的水平屏幕坐标 */writel(((LCD_LENTH-1) &lt;&lt; 11) | (LCD_WIDTH-1), lcd_regs_base + VIDOSD0B); f. 启动显示 Display On: ENVID and ENVID_F are set to “1”.Direct Off: ENVID and ENVID_F are set to “0” simultaneously.Per Frame Off: ENVID_F is set to “0” and ENVID is set to “1”. 123//Display On: ENVID and ENVID_F are set to \"1\".temp = readl(lcd_regs_base + VIDCON0);writel(temp | (0x01&lt;&lt;0) | (0x01&lt;&lt;1), lcd_regs_base + VIDCON0); 4.1.3.3 分配显存(framebuffer), 并把地址告诉LCD控制器这里因为分配的显存要是连续的，因此不能使用传统的kalloc()函数，这里使用dma_alloc_writecombine()。先用物理地址映射出一块虚拟内存，以后对该虚拟内存操作，就等同于对物理地址数据进行操作。然后把物理地址的起始/结束地址告诉LCD控制器，以后LCD控制器就会去物理地址不断获取显示数据。这样就实现了操作虚拟内存，更新图像数据的效果。12345678// tiny4412_lcd-&gt;screen_base 显存虚拟地址// tiny4412_lcd-&gt;fix.smem_len 显存大小，前面计算的// tiny4412_lcd-&gt;fix.smem_start 显存物理地址tiny4412_lcd-&gt;screen_base = dma_alloc_writecombine(NULL, tiny4412_lcd-&gt;fix.smem_len, (dma_addr_t *)&amp;tiny4412_lcd-&gt;fix.smem_start, GFP_KERNEL);//显存起始地址writel(tiny4412_lcd-&gt;fix.smem_start, lcd_regs_base + VIDW00ADD0B0);//显存结束地址writel(tiny4412_lcd-&gt;fix.smem_start + tiny4412_lcd-&gt;fix.smem_len, lcd_regs_base + VIDW00ADD1B0); 4.1.4 注册fb_info12ret = register_framebuffer(tiny4412_lcd);return ret; 4.2 cfb_setcolreg前面绑定的操作函数中，cfb_fillrect()，cfb_copyarea()、cfb_imageblit()都在内核的其它文件中实现了，无需再构造，剩下的cfb_setcolreg()是和调色板相关的函数，是为了兼容8BPP模式。我们这里一直使用的24BPP，不提供这个函数的实现也行。调色板的介绍前面说过了，就是为了减少数据量，fb只存放数据索引，根据索引再去内存找到对应的颜色数据传给LCD控制器，LCD控制器再控制时序和数据在LCD上显示出来。123456789101112131415161718192021static inline unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)&#123; chan &amp;= 0xFFFF;//保留低16位 chan &gt;&gt;= 16 - bf-&gt;length;//保留高bf-&gt;length位 return chan &lt;&lt; bf-&gt;offset;//返回保留的位，且在原位置&#125;static int cfb_setcolreg(unsigned int regno, unsigned int red, unsigned int green, unsigned int blue, unsigned int transp, struct fb_info *info)&#123; unsigned int color = 0; uint32_t *p; color = chan_to_field(red, &amp;info-&gt;var.red); color |= chan_to_field(green, &amp;info-&gt;var.green); color |= chan_to_field(blue, &amp;info-&gt;var.blue); p = info-&gt;pseudo_palette; p[regno] = color; return 0;&#125; 4.3 lcd_remove需要关闭LCD，注销和释放framebuffer，释放显存：12345678910111213static int lcd_remove(struct platform_device *pdev)&#123; //Direct Off: ENVID and ENVID_F are set to \"0\" simultaneously. unsigned int temp; temp = readl(lcd_regs_base + VIDCON0); temp &amp;= ~(0x01&lt;&lt;1 | 0x01&lt;&lt;0); writel(temp, lcd_regs_base + VIDCON0); unregister_framebuffer(tiny4412_lcd); dma_free_writecombine(NULL, tiny4412_lcd-&gt;fix.smem_len, tiny4412_lcd-&gt;screen_base, tiny4412_lcd-&gt;fix.smem_start); framebuffer_release(tiny4412_lcd); return 0;&#125; 4.4 完整驱动代码[lcd_drv.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/mm.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/fb.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/dma-mapping.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/workqueue.h&gt;#include &lt;linux/wait.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/clk.h&gt;#include &lt;linux/io.h&gt;#include &lt;asm/io.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;asm/div64.h&gt;#include &lt;asm/mach/map.h&gt;#include &lt;linux/fb.h&gt;#include &lt;asm/types.h&gt;#define VIDCON0 0x00#define VIDCON1 0x04#define VIDTCON0 0x10#define VIDTCON1 0x14#define VIDTCON2 0x18#define WINCON0 0x20#define VIDOSD0C 0x48#define SHADOWCON 0x34#define WINCHMAP2 0x3c#define VIDOSD0A 0x40#define VIDOSD0B 0x44#define VIDW00ADD0B0 0xA0#define VIDW00ADD1B0 0xD0#define CLK_SRC_LCD0 0x234#define CLK_SRC_MASK_LCD 0x334#define CLK_DIV_LCD 0x534#define CLK_GATE_IP_LCD 0x934#define LCDBLK_CFG 0x00#define LCDBLK_CFG2 0x04#define LCD_LENTH 800#define LCD_WIDTH 480#define BITS_PER_PIXEL 32static struct fb_info *tiny4412_lcd;static volatile void __iomem *lcd_regs_base;static volatile void __iomem *lcdblk_regs_base;static volatile void __iomem *lcd0_configuration;//Configures power mode of LCD0.0x10020000+0x3C80static volatile void __iomem *clk_regs_base;static u32 pseudo_palette[16];static struct resource *res0, *res1, *res2, *res3;/* from pxafb.c */static inline unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)&#123; chan &amp;= 0xFFFF;//保留低16位 chan &gt;&gt;= 16 - bf-&gt;length;//保留高bf-&gt;length位 return chan &lt;&lt; bf-&gt;offset;//返回保留的位，且在原位置&#125;static int cfb_setcolreg(unsigned int regno, unsigned int red, unsigned int green, unsigned int blue, unsigned int transp, struct fb_info *info)&#123; unsigned int color = 0; uint32_t *p; color = chan_to_field(red, &amp;info-&gt;var.red); color |= chan_to_field(green, &amp;info-&gt;var.green); color |= chan_to_field(blue, &amp;info-&gt;var.blue); p = info-&gt;pseudo_palette; p[regno] = color; return 0;&#125;static struct fb_ops tiny4412_lcdfb_ops =&#123; .owner = THIS_MODULE, .fb_setcolreg = cfb_setcolreg, //设置调色板，实现伪颜色表 .fb_fillrect = cfb_fillrect, //填充矩形 .fb_copyarea = cfb_copyarea, //数据复制 .fb_imageblit = cfb_imageblit, //图形填充&#125;; static int lcd_probe(struct platform_device *pdev)&#123; int ret; unsigned int temp; /* 1. 分配一个fb_info */ tiny4412_lcd = framebuffer_alloc(0, NULL); //不要额外空间设置私有数据 if(!tiny4412_lcd) &#123; return -ENOMEM; &#125; /* 2. 设置 */ /* 2.1 设置 fix 固定的参数 */ strcpy(tiny4412_lcd-&gt;fix.id, \"s702\"); //设置fix名称 tiny4412_lcd-&gt;fix.smem_len = LCD_LENTH*LCD_WIDTH*BITS_PER_PIXEL/8; //显存的长度=分辨率*每象素字节数 tiny4412_lcd-&gt;fix.type = FB_TYPE_PACKED_PIXELS; //类型:填充式像素(常用在TFT屏幕) tiny4412_lcd-&gt;fix.visual = FB_VISUAL_TRUECOLOR; //TFT 真彩色 tiny4412_lcd-&gt;fix.line_length = LCD_LENTH*BITS_PER_PIXEL/8; //每行的长度，以字节为单位 /* 2.2 设置 var 可变的参数 */ tiny4412_lcd-&gt;var.xres = LCD_LENTH; //x方向分辨率 tiny4412_lcd-&gt;var.yres = LCD_WIDTH; //y方向分辨率 tiny4412_lcd-&gt;var.xres_virtual = LCD_LENTH; //x方向虚拟分辨率 tiny4412_lcd-&gt;var.yres_virtual = LCD_WIDTH; //y方向虚拟分辨率 tiny4412_lcd-&gt;var.xoffset = 0; //x方向真实值和虚拟值得差值 tiny4412_lcd-&gt;var.yoffset = 0; //y方向真实值和虚拟值得差值 tiny4412_lcd-&gt;var.bits_per_pixel = BITS_PER_PIXEL; //每个像素占多少位 /* RGB:888 */ tiny4412_lcd-&gt;var.red.length = 8; tiny4412_lcd-&gt;var.red.offset = 16; //红 tiny4412_lcd-&gt;var.green.length = 8; tiny4412_lcd-&gt;var.green.offset = 8; //绿 tiny4412_lcd-&gt;var.blue.length = 8; tiny4412_lcd-&gt;var.blue.offset = 0; //蓝 tiny4412_lcd-&gt;var.activate = FB_ACTIVATE_NOW; //使设置的值立即生效 /* 2.3 设置操作函数 */ tiny4412_lcd-&gt;fbops = &amp;tiny4412_lcdfb_ops; //绑定操作函数 /* 2.4 其他的设置 */ tiny4412_lcd-&gt;pseudo_palette = pseudo_palette; //存放调色板所调颜色的数组 tiny4412_lcd-&gt;screen_size = LCD_LENTH * LCD_WIDTH * BITS_PER_PIXEL / 8; //显存大小 /* 3. 硬件相关的操作 */ /* 3.1 配置GPIO用于LCD */ //在设备树中，将 GPF0_0-GPF0_7、GPF1_0-GPF1_7、GPF2_0-GPF2_7、GPF3_0-GPF3_3 //配置为了复用第二功能(LCD)，禁止内部上拉，驱动强度配置设置为0; /* 3.2 根据LCD手册设置LCD控制器, 比如VCLK的频率等 */ //寄存器映射 res0 = platform_get_resource(pdev, IORESOURCE_MEM, 0); if (res0 == NULL) &#123; printk(\"platform_get_resource error.\\n\"); return -EINVAL; &#125; lcd_regs_base = devm_ioremap_resource(&amp;pdev-&gt;dev, res0); if (lcd_regs_base == NULL) &#123; printk(\"devm_ioremap_resource error.\\n\"); return -EINVAL; &#125; res1 = platform_get_resource(pdev, IORESOURCE_MEM, 1); if (res1 == NULL) &#123; printk(\"platform_get_resource error.\\n\"); return -EINVAL; &#125; lcdblk_regs_base = devm_ioremap_resource(&amp;pdev-&gt;dev, res1); if (lcdblk_regs_base == NULL) &#123; printk(\"devm_ioremap_resource error.\\n\"); return -EINVAL; &#125; res2 = platform_get_resource(pdev, IORESOURCE_MEM, 2); if (res2 == NULL) &#123; printk(\"platform_get_resource error.\\n\"); return -EINVAL; &#125; //bug： /* devm_ioremap()和devm_ioremap_resource()区别： devm_ioremap()可以重复map相同的地址空间，devm_ioremap_resource()不可以。 一般SoC的中，各个硬件模块各自的memory region都有严格的划分(比如说USB host的地址空间绝对不会和flash host冲突)， 所以一般的driver使用devm_ioremap()和devm_ioremap_resource()都行。 但这里，应该系统已经映射过一次了，所以使用devm_ioremap_resource()会报错。 */ //lcd0_configuration = devm_ioremap_resource(&amp;pdev-&gt;dev, res2); lcd0_configuration = devm_ioremap(&amp;pdev-&gt;dev, res2-&gt;start, resource_size(res2)); if (lcd0_configuration == NULL) &#123; printk(\"devm_ioremap_resource error.\\n\"); return -EINVAL; &#125; *(unsigned long *)lcd0_configuration = 7; //Reset Value = 0x00000007 res3 = platform_get_resource(pdev, IORESOURCE_MEM, 3); if (res3 == NULL) &#123; printk(\"platform_get_resource error.\\n\"); return -EINVAL; &#125; //clk_regs_base = devm_ioremap_resource(&amp;pdev-&gt;dev, res3); clk_regs_base = devm_ioremap(&amp;pdev-&gt;dev, res3-&gt;start, resource_size(res3)); if (clk_regs_base == NULL) &#123; printk(\"devm_ioremap_resource error.\\n\"); return -EINVAL; &#125; //时钟源选择\\使能时钟 //Selects clock source for LCD_BLK //FIMD0_SEL:bit[3:0]=0110=SCLKMPLL_USER_T=800M temp = readl(clk_regs_base + CLK_SRC_LCD0); temp &amp;= ~(0x0F&lt;&lt;0); temp |= (0x3&lt;&lt;1); writel(temp, clk_regs_base + CLK_SRC_LCD0); //Clock source mask for LCD_BLK //FIMD0_MASK:Mask output clock of MUXFIMD0 (1=Unmask) temp = readl(clk_regs_base + CLK_SRC_MASK_LCD); temp |= (0x01&lt;&lt;0); writel(temp, clk_regs_base + CLK_SRC_MASK_LCD); //Clock source mask for LCD_BLK //SCLK_FIMD0 = MOUTFIMD0/(FIMD0_RATIO + 1),分频比 1/1 temp = readl(clk_regs_base + CLK_DIV_LCD); temp &amp;= ~(0x0F&lt;&lt;0); writel(temp, clk_regs_base + CLK_DIV_LCD); //Controls IP clock gating for LCD_BLK //CLK_FIMD0:Gating all clocks for FIMD0 (1=Pass) temp = readl(clk_regs_base + CLK_GATE_IP_LCD); temp |= (0x01&lt;&lt;0); writel(temp, clk_regs_base + CLK_GATE_IP_LCD); //FIMDBYPASS_LBLK0:FIMD of LBLK0 Bypass Selection (1=FIMD Bypass) temp = readl(lcdblk_regs_base + LCDBLK_CFG); temp |= (0x01&lt;&lt;1); writel(temp, lcdblk_regs_base + LCDBLK_CFG); //MIE0_DISPON:MIE0_DISPON: PWM output control (1=PWM outpupt enable) temp = readl(lcdblk_regs_base + LCDBLK_CFG2); temp |= (0x01&lt;&lt;0); writel(temp, lcdblk_regs_base + LCDBLK_CFG2); mdelay(1000); //LCD时钟: VCLK=FIMD*SCLK/(CLKVAL+1), where CLKVAL&gt;=1 //800/(19+1) == 40M&lt;80M temp = readl(lcd_regs_base + VIDCON0); temp |= (19&lt;&lt;6); writel(temp, lcd_regs_base + VIDCON0); /* * VIDTCON1: * [5]:IVSYNC ===&gt; 1 : Inverted(反转) * [6]:IHSYNC ===&gt; 1 : Inverted(反转) * [7]:IVCLK ===&gt; 1 : Fetches video data at VCLK rising edge (上降沿触发) * [10:9]:FIXVCLK ====&gt; 01 : VCLK running */ temp = readl(lcd_regs_base + VIDCON1); temp |= (1 &lt;&lt; 9) | (1 &lt;&lt; 7) | (1 &lt;&lt; 5) | (1 &lt;&lt; 6); writel(temp, lcd_regs_base + VIDCON1); /* * VIDTCON0: * [23:16]: VBPD+1=tvb-tvpw=23-11=12 --&gt; VBPD=11 * [15:8] : VFPD+1=tvfp=22 --&gt; VFPD=21 * [7:0] : VSPW+1=tvpw=1~20(暂取11) --&gt; VSPW=10 */ temp = readl(lcd_regs_base + VIDTCON0); temp |= (11 &lt;&lt; 16) | (21 &lt;&lt; 8) | (10 &lt;&lt; 0); writel(temp, lcd_regs_base + VIDTCON0); /* * VIDTCON1: * [23:16]: HBPD+1=thb-hpw=46-21=25 --&gt; HBPD=24 * [15:8] : HFPD+1=thfp=210 --&gt; HFPD=209 * [7:0] : HSPW+1=hpw=1~40(暂取21) --&gt; HSPW=20 */ temp = readl(lcd_regs_base + VIDTCON1); temp |= (24 &lt;&lt; 16) | (209 &lt;&lt; 8) | (20 &lt;&lt; 0); writel(temp, lcd_regs_base + VIDTCON1); /* * HOZVAL = (Horizontal display size) - 1 and LINEVAL = (Vertical display size) - 1. * Horizontal(水平) display size : 800 * Vertical(垂直) display size : 480 */ temp = ((LCD_WIDTH-1) &lt;&lt; 11) | (LCD_LENTH &lt;&lt; 0); writel(temp, lcd_regs_base + VIDTCON2); /* * WINCON0: * [15]:Specifies Word swap control bit. 1 = Enables swap 低位像素存放在低字节 * [5:2]: Selects Bits Per Pixel (BPP) mode for Window image : 1101 ===&gt; Unpacked 25 BPP (non-palletized A:1-R:8-G:8-B:8) * [0]:Enables/disables video output 1 = Enables */ temp = readl(lcd_regs_base + WINCON0); temp &amp;= ~(0x0F &lt;&lt; 2); temp |= (0X01 &lt;&lt; 15) | (0x0D &lt;&lt; 2) | (0x01&lt;&lt;0); writel(temp, lcd_regs_base + WINCON0); //Enables Channel 0. temp = readl(lcd_regs_base + SHADOWCON); writel(temp | 0x01, lcd_regs_base + SHADOWCON); //Selects Channel 0 temp = readl(lcd_regs_base + WINCHMAP2); temp &amp;= ~(7 &lt;&lt; 16); temp |= (0x01 &lt;&lt; 16);//CH0FISEL:Selects Channel 0's channel.001 = Window 0 temp &amp;= ~(7 &lt;&lt; 0); temp |= (0x01 &lt;&lt; 0);//W0FISEL:Selects Window 0's channel.001 = Channel 0 writel(temp, lcd_regs_base + WINCHMAP2); //设置OSD显示大小 //Window Size For example. Height * Width (number of word) temp = (LCD_LENTH * LCD_WIDTH) &gt;&gt; 1; writel(temp, lcd_regs_base + VIDOSD0C); /* * bit0-10 : 指定OSD图像左上像素的垂直屏幕坐标 * bit11-21: 指定OSD图像左上像素的水平屏幕坐标 */ writel(0, lcd_regs_base + VIDOSD0A); /* * bit0-10 : 指定OSD图像右下像素的垂直屏幕坐标 * bit11-21: 指定OSD图像右下像素的水平屏幕坐标 */ writel(((LCD_LENTH-1) &lt;&lt; 11) | (LCD_WIDTH-1), lcd_regs_base + VIDOSD0B); //Display On: ENVID and ENVID_F are set to \"1\". temp = readl(lcd_regs_base + VIDCON0); writel(temp | (0x01&lt;&lt;1) | (0x01&lt;&lt;0), lcd_regs_base + VIDCON0); /* 3.3 分配显存(framebuffer), 并把地址告诉LCD控制器 */ // tiny4412_lcd-&gt;screen_base 显存虚拟地址 // tiny4412_lcd-&gt;fix.smem_len 显存大小，前面计算的 // tiny4412_lcd-&gt;fix.smem_start 显存物理地址 tiny4412_lcd-&gt;screen_base = dma_alloc_writecombine(NULL, tiny4412_lcd-&gt;fix.smem_len, (dma_addr_t *)&amp;tiny4412_lcd-&gt;fix.smem_start, GFP_KERNEL); //显存起始地址 writel(tiny4412_lcd-&gt;fix.smem_start, lcd_regs_base + VIDW00ADD0B0); //显存结束地址 writel(tiny4412_lcd-&gt;fix.smem_start + tiny4412_lcd-&gt;fix.smem_len, lcd_regs_base + VIDW00ADD1B0); /* 4. 注册 */ ret = register_framebuffer(tiny4412_lcd); return ret;&#125;static int lcd_remove(struct platform_device *pdev)&#123; //Direct Off: ENVID and ENVID_F are set to \"0\" simultaneously. unsigned int temp; temp = readl(lcd_regs_base + VIDCON0); temp &amp;= ~(0x01&lt;&lt;1 | 0x01&lt;&lt;0); writel(temp, lcd_regs_base + VIDCON0); unregister_framebuffer(tiny4412_lcd); dma_free_writecombine(NULL, tiny4412_lcd-&gt;fix.smem_len, tiny4412_lcd-&gt;screen_base, tiny4412_lcd-&gt;fix.smem_start); framebuffer_release(tiny4412_lcd); return 0;&#125;static const struct of_device_id lcd_dt_ids[] =&#123; &#123; .compatible = \"tiny4412, lcd_s702\", &#125;, &#123;&#125;,&#125;;MODULE_DEVICE_TABLE(of, lcd_dt_ids);static struct platform_driver lcd_driver =&#123; .driver = &#123; .name = \"lcd_s702\", .of_match_table = of_match_ptr(lcd_dt_ids), &#125;, .probe = lcd_probe, .remove = lcd_remove,&#125;;static int lcd_init(void)&#123; int ret; printk(\"enter %s\\n\", __func__); ret = platform_driver_register(&amp;lcd_driver); if (ret) &#123; printk(KERN_ERR \"lcd: probe fail: %d\\n\", ret); &#125; return ret;&#125;static void lcd_exit(void)&#123; printk(\"enter %s\\n\", __func__); platform_driver_unregister(&amp;lcd_driver);&#125;module_init(lcd_init);module_exit(lcd_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"Tiny4412 LCD driver.\");MODULE_ALIAS(\"Exynos4412_s702\");MODULE_VERSION(\"V1.0\"); 参考博客：设备树学习之（十二）LCD驱动 5.测试程序5.1 图像显示前面完成了驱动，要想显示内容，只需要mmap()一块内存，然后向里面写数据即可。但这种操作一般显示用于显示几何图形，像色块，圆形，矩形等，实用性不大，显示一张图片似乎更有意思。显示图片没那么容易了，像常见的JPEG格式图片，它是一个“压缩文件”，需要解压得到RGB数据。 这就要用到libjpeg-turbo，一个用C语言写的JPEG图像解码器。 5.1.1 移植libjpeg下载目前最新的libjpeg-turbo源码libjpeg-turbo-1.5.3.tar.gz。a. 解压1sudo tar xzf libjpeg-turbo-1.5.3.tar.gz b.设置配置文件--prefix=:指定安装路径--host==:指定目标程序运行主机类型1234567cd libjpeg-turbo-1.5.3 mkdir tmp //创建临时安装路径cd .../configure --prefix=/work/drv/2_lcd/libjpeg_new/libjpeg-turbo-1.5.3/tmp --host=arm-none-linux-gnueabimakemamake install 5.1.2 编写应用程序这块几乎全是参考韦东山老师第三期视频的电子相册项目。 解压操作过程如下:1、分配jpeg对象结构体空间，并初始化2、指定解压数据源3、获取解压文件信息4、为解压设定参数，包括图像大小和颜色空间5、开始解压缩6、取数据并显示7、解压完毕8、释放资源和退出程序 1、分配jpeg对象结构体空间、并初始化解压缩过程中使用的JPEG对象是一个jpeg_decompress_struct的结构体。同时还需要定义一个用于错误处理的结构体对象，IJG中标准的错误结构体是jpeg_error_mgr。12struct jpeg_decompress_struct cinfo;struct jpeg_error_mgr jerr; 绑定jerr错误结构体至jpeg对象结构体。1cinfo.err = jpeg_std_error(&amp;jerr); 这个标准的错误处理结构将使程序在出现错误时调用exit()退出程序，如果不希望使用标准的错误处理方式，则可以通过自定义退出函数的方法自定义错误处理结构。 初始化cinfo结构体。1jpeg_create_decompress(&amp;cinfo); 2、指定解压数据源1234567 FILE * infile;if ((infile = fopen(argv[1], \"rb\")) == NULL) &#123; fprintf(stderr, \"can't open %s\\n\", argv[1]); return -1;&#125;jpeg_stdio_src(&amp;cinfo, infile); 3、获取解压文件信息将图像的缺省信息填充到cinfo结构中以便程序使用。1jpeg_read_header(&amp;cinfo, TRUE);此时，常见的可用信息包括图像的：宽cinfo.image_width，高cinfo.image_height，色彩空间cinfo.jpeg_color_space，颜色通道数cinfo.num_components等。 4、为解压设定参数，包括图像大小和颜色空间比如可以设定解出来的图像的大小，也就是与原图的比例。使用scale_num和scale_denom两个参数，解出来的图像大小就是scale_num/scale_denom，但是IJG当前仅支持1/1, 1/2, 1/4,和1/8这几种缩小比例。123printf(\"enter scale M/N:\\n\");scanf(\"%d/%d\", &amp;cinfo.scale_num, &amp;cinfo.scale_denom);printf(\"scale to : %d/%d\\n\", cinfo.scale_num, cinfo.scale_denom);假如想让图片变为原来的一般，只需要输入1/2即可。 也可以设定输出图像的色彩空间，即cinfo.out_color_space，可以把一个原本彩色的图像由真彩色JCS_RGB变为灰度JCS_GRAYSCALE。1cinfo.out_color_space=JCS_GRAYSCALE; 5、开始解压缩根据设定的解压缩参数进行图像解压缩操作。1jpeg_start_decompress(&amp;cinfo); 在完成解压缩操作后，会将解压后的图像信息填充至cinfo结构中。比如，输出图像宽度cinfo.output_width，输出图像高度cinfo.output_height，每个像素中的颜色通道数cinfo.output_components（比如灰度为1，全彩色为3）等。 一般情况下，这些参数是在jpeg_start_decompress后才被填充到cinfo中的，如果希望在调用jpeg_start_decompress之前就获得这些参数，可以通过调用jpeg_calc_output_dimensions()的方法来实现。 6、取数据并显示解开的数据是按照行取出的，数据像素按照scanline来存储，scanline是从左到右，从上到下的顺序，每个像素对应的各颜色或灰度通道数据是依次存储。比如一个24-bit RGB真彩色的图像中，一个scanline中的数据存储模式是R,G,B,R,G,B,R,G,B,…，每条scanline是一个JSAMPLE类型的数组，一般来说就是 unsigned char，定义于jmorecfg.h中。除了JSAMPLE，图像还定义了JSAMPROW和JSAMPARRAY，分别表示一行JSAMPLE和一个2D的JSAMPLE数组。 在此，我定义一个JSAMPARRAY(unsigned char)类型的缓冲区变量buffer来存放图像数据。123456789101112131415int row_stride;unsigned char *buffer;// 然后是计算每行需要的空间大小，比如RGB图像就是宽度×3，灰度图就是宽度×1row_stride = cinfo.output_width * cinfo.output_components;buffer = malloc(row_stride);// 循环调用jpeg_read_scanlines来一行一行地获得解压的数据while (cinfo.output_scanline &lt; cinfo.output_height) &#123; (void) jpeg_read_scanlines(&amp;cinfo, &amp;buffer, 1);//每次读取1行 // 写到LCD去 fb_show_line(0, cinfo.output_width, cinfo.output_scanline, buffer);&#125; 然后需要实现函数fb_show_line()显示每行数据，要实现fb_show_line()还得先实现每个像素点的描绘fb_show_pixel()。因此需要先初始化fb，获取LCD参数信息，如分辨率，多少BPP。再实现显示每个像素点，最后实现每一行的显示。 初始化：1234567891011121314151617181920212223242526272829303132333435363738394041static int fb_device_init(void)&#123; int ret; fd = open(FB_DEVICE_NAME, O_RDWR); if (fd &lt; 0) &#123; printf(\"Can't open %s\\n\", FB_DEVICE_NAME); return -1; &#125; //获取可变信息 ret = ioctl(fd, FBIOGET_VSCREENINFO, &amp;fb_var); if (ret &lt; 0) &#123; printf(\"Can't get fb's var\\n\"); return -1; &#125; //获取固定信息 ret = ioctl(fd, FBIOGET_FSCREENINFO, &amp;fb_fix); if (ret &lt; 0) &#123; printf(\"Can't get fb's fix\\n\"); return -1; &#125; //映射fb screen_size = fb_var.xres * fb_var.yres * fb_var.bits_per_pixel / 8; fb_mem = (unsigned char *)mmap(NULL , screen_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if (fb_mem &lt; 0) &#123; printf(\"Can't mmap\\n\"); return -1; &#125; line_width = fb_var.xres * fb_var.bits_per_pixel / 8; pixel_width = fb_var.bits_per_pixel / 8; return 0;&#125; 显示每个像素点：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static int fb_show_pixel(int x, int y, unsigned int color)&#123; unsigned char *fb_show; unsigned short *fb_show_16bpp; unsigned int *fb_show_32bpp; unsigned short fb_show_16bpp_new; /* 565 */ int red; int green; int blue; if ((x &gt;= fb_var.xres) || (y &gt;= fb_var.yres)) &#123; printf(\"Out of region\\n\"); return -1; &#125; fb_show = fb_mem + line_width * y + pixel_width * x;//定位 fb_show_16bpp = (unsigned short *)fb_show; fb_show_32bpp = (unsigned int *)fb_show; switch (fb_var.bits_per_pixel) &#123; case 8: &#123; *fb_show = (unsigned char)color; break; &#125; case 16: &#123; red = (color &gt;&gt; (16+3)) &amp; 0x1F; green = (color &gt;&gt; (8+2)) &amp; 0x3F; blue = (color &gt;&gt; 3) &amp; 0x1F; fb_show_16bpp_new = (red &lt;&lt; 11) | (green &lt;&lt; 5) | blue; *fb_show_16bpp = fb_show_16bpp_new; break; &#125; case 32: &#123; *fb_show_32bpp = color; break; &#125; default : &#123; printf(\"Can't support %d bpp\\n\", fb_var.bits_per_pixel); return -1; &#125; &#125; return 0;&#125; 显示每行：1234567891011121314151617181920212223242526static int fb_show_line(int x_start, int x_end, int y, unsigned char *color_array)&#123; int i = x_start * 3; int x; unsigned int color; if (y &gt;= fb_var.yres) return -1; if (x_start &gt;= fb_var.xres) return -1; if (x_end &gt;= fb_var.xres) &#123; x_end = fb_var.xres; &#125; for (x = x_start; x &lt; x_end; x++) &#123; /* 0xRRGGBB */ color = (color_array[i]&lt;&lt;16) + (color_array[i+1]&lt;&lt;8) + (color_array[i+2]&lt;&lt;0); i += 3; fb_show_pixel(x, y, color); &#125; return 0;&#125; 除此之外，每次显示前还需要清除原来的显示信息，也就是清空显示信息一次。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static int fb_clean_screen(unsigned int back_color)&#123; unsigned char *fb_show; unsigned short *fb_show_16bpp; unsigned int *fb_show_32bpp; unsigned short fb_show_16bpp_new; /* 565 */ int red; int green; int blue; int i = 0; fb_show = fb_mem; fb_show_16bpp = (unsigned short *)fb_show; fb_show_32bpp = (unsigned int *)fb_show; switch (fb_var.bits_per_pixel) &#123; case 8: &#123; memset(fb_mem, back_color, screen_size); break; &#125; case 16: &#123; red = (back_color &gt;&gt; (16+3)) &amp; 0x1F; green = (back_color &gt;&gt; (8+2)) &amp; 0x3F; blue = (back_color &gt;&gt; 3) &amp; 0x1F; fb_show_16bpp_new = (red &lt;&lt; 11) | (green &lt;&lt; 5) | blue; while (i &lt; screen_size) &#123; *fb_show_16bpp = fb_show_16bpp_new; fb_show_16bpp++; i += 2; &#125; break; &#125; case 32: &#123; while (i &lt; screen_size) &#123; *fb_show_32bpp = back_color; fb_show_32bpp++; i += 4; &#125; break; &#125; default : &#123; printf(\"Can't support %d bpp\\n\", fb_var.bits_per_pixel); return -1; &#125; &#125; return 0;&#125; 7、解压完毕1jpeg_finish_decompress(&amp;cinfo); 8、释放资源和退出程序123free(buffer);jpeg_destroy_decompress(&amp;cinfo); fclose(infile); 参考博客：libjpeg库的简单使用使用—-jpeg图片解压 5.1.3 完整应用程序[jpg_rgb.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include &lt;stdio.h&gt;#include \"jpeglib.h\"#include &lt;setjmp.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;linux/fb.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define FB_DEVICE_NAME \"/dev/fb0\"static int fd;static struct fb_var_screeninfo fb_var;static struct fb_fix_screeninfo fb_fix; static unsigned char *fb_mem;static unsigned int screen_size;static unsigned int line_width;static unsigned int pixel_width;static int fb_device_init(void)&#123; int ret; fd = open(FB_DEVICE_NAME, O_RDWR); if (fd &lt; 0) &#123; printf(\"Can't open %s\\n\", FB_DEVICE_NAME); return -1; &#125; //获取可变信息 ret = ioctl(fd, FBIOGET_VSCREENINFO, &amp;fb_var); if (ret &lt; 0) &#123; printf(\"Can't get fb's var\\n\"); return -1; &#125; //获取固定信息 ret = ioctl(fd, FBIOGET_FSCREENINFO, &amp;fb_fix); if (ret &lt; 0) &#123; printf(\"Can't get fb's fix\\n\"); return -1; &#125; //映射fb screen_size = fb_var.xres * fb_var.yres * fb_var.bits_per_pixel / 8; fb_mem = (unsigned char *)mmap(NULL , screen_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if (fb_mem &lt; 0) &#123; printf(\"Can't mmap\\n\"); return -1; &#125; line_width = fb_var.xres * fb_var.bits_per_pixel / 8; pixel_width = fb_var.bits_per_pixel / 8; return 0;&#125;//color:0x00RRGGBBstatic int fb_show_pixel(int x, int y, unsigned int color)&#123; unsigned char *fb_show; unsigned short *fb_show_16bpp; unsigned int *fb_show_32bpp; unsigned short fb_show_16bpp_new; /* 565 */ int red; int green; int blue; if ((x &gt;= fb_var.xres) || (y &gt;= fb_var.yres)) &#123; printf(\"Out of region\\n\"); return -1; &#125; fb_show = fb_mem + line_width * y + pixel_width * x;//定位 fb_show_16bpp = (unsigned short *)fb_show; fb_show_32bpp = (unsigned int *)fb_show; switch (fb_var.bits_per_pixel) &#123; case 8: &#123; *fb_show = (unsigned char)color; break; &#125; case 16: &#123; red = (color &gt;&gt; (16+3)) &amp; 0x1F; green = (color &gt;&gt; (8+2)) &amp; 0x3F; blue = (color &gt;&gt; 3) &amp; 0x1F; fb_show_16bpp_new = (red &lt;&lt; 11) | (green &lt;&lt; 5) | blue; *fb_show_16bpp = fb_show_16bpp_new; break; &#125; case 32: &#123; *fb_show_32bpp = color; break; &#125; default : &#123; printf(\"Can't support %d bpp\\n\", fb_var.bits_per_pixel); return -1; &#125; &#125; return 0;&#125;static int fb_clean_screen(unsigned int back_color)&#123; unsigned char *fb_show; unsigned short *fb_show_16bpp; unsigned int *fb_show_32bpp; unsigned short fb_show_16bpp_new; /* 565 */ int red; int green; int blue; int i = 0; fb_show = fb_mem; fb_show_16bpp = (unsigned short *)fb_show; fb_show_32bpp = (unsigned int *)fb_show; switch (fb_var.bits_per_pixel) &#123; case 8: &#123; memset(fb_mem, back_color, screen_size); break; &#125; case 16: &#123; red = (back_color &gt;&gt; (16+3)) &amp; 0x1F; green = (back_color &gt;&gt; (8+2)) &amp; 0x3F; blue = (back_color &gt;&gt; 3) &amp; 0x1F; fb_show_16bpp_new = (red &lt;&lt; 11) | (green &lt;&lt; 5) | blue; while (i &lt; screen_size) &#123; *fb_show_16bpp = fb_show_16bpp_new; fb_show_16bpp++; i += 2; &#125; break; &#125; case 32: &#123; while (i &lt; screen_size) &#123; *fb_show_32bpp = back_color; fb_show_32bpp++; i += 4; &#125; break; &#125; default : &#123; printf(\"Can't support %d bpp\\n\", fb_var.bits_per_pixel); return -1; &#125; &#125; return 0;&#125;static int fb_show_line(int x_start, int x_end, int y, unsigned char *color_array)&#123; int i = x_start * 3; int x; unsigned int color; if (y &gt;= fb_var.yres) return -1; if (x_start &gt;= fb_var.xres) return -1; if (x_end &gt;= fb_var.xres) &#123; x_end = fb_var.xres; &#125; for (x = x_start; x &lt; x_end; x++) &#123; /* 0xRRGGBB */ color = (color_array[i]&lt;&lt;16) + (color_array[i+1]&lt;&lt;8) + (color_array[i+2]&lt;&lt;0); i += 3; fb_show_pixel(x, y, color); &#125; return 0;&#125;/* * Uage: jpg_rgb &lt;jpg_file&gt; */int main(int argc, char **argv)&#123; //1、分配jpeg对象结构体空间、并初始化 struct jpeg_decompress_struct cinfo; struct jpeg_error_mgr jerr; FILE * infile; int row_stride; unsigned char *buffer; if (argc != 2) &#123; printf(\"Usage: \\n\"); printf(\"%s &lt;jpg_file&gt;\\n\", argv[0]); return -1; &#125; if (fb_device_init()) &#123; return -1; &#125; fb_clean_screen(0); //绑定jerr错误结构体至jpeg对象结构体 cinfo.err = jpeg_std_error(&amp;jerr); //初始化cinfo结构体 jpeg_create_decompress(&amp;cinfo); //2、指定解压数据源 if ((infile = fopen(argv[1], \"rb\")) == NULL) &#123; fprintf(stderr, \"can't open %s\\n\", argv[1]); return -1; &#125; jpeg_stdio_src(&amp;cinfo, infile); //3、获取解压文件信息 jpeg_read_header(&amp;cinfo, TRUE); /* 源信息 */ printf(\"image_width = %d\\n\", cinfo.image_width); printf(\"image_height = %d\\n\", cinfo.image_height); printf(\"num_components = %d\\n\", cinfo.num_components); //4、为解压设定参数，包括图像大小和颜色空间 printf(\"enter scale M/N:\\n\"); scanf(\"%d/%d\", &amp;cinfo.scale_num, &amp;cinfo.scale_denom); printf(\"scale to : %d/%d\\n\", cinfo.scale_num, cinfo.scale_denom); //5、开始解压缩 jpeg_start_decompress(&amp;cinfo); /* 输出的图象的信息 */ printf(\"output_width = %d\\n\", cinfo.output_width); printf(\"output_height = %d\\n\", cinfo.output_height); printf(\"output_components = %d\\n\", cinfo.output_components); //6、取数据并显示 //一行的数据长度 row_stride = cinfo.output_width * cinfo.output_components; buffer = malloc(row_stride); // 循环调用jpeg_read_scanlines来一行一行地获得解压的数据 while (cinfo.output_scanline &lt; cinfo.output_height) &#123; (void) jpeg_read_scanlines(&amp;cinfo, &amp;buffer, 1); // 写到LCD去 fb_show_line(0, cinfo.output_width, cinfo.output_scanline, buffer); &#125; //7、解压完毕 jpeg_finish_decompress(&amp;cinfo); //8、释放资源和退出程序 free(buffer); jpeg_destroy_decompress(&amp;cinfo); return 0;&#125; 5.1.4 交叉编译应用程序方法一：jpg_rgb.c要想在开发板上运行，就得先交叉编译，里面用到了一非系统的头文件和函数，因此还需要指定头文件和库路径。-I:指定头文件路径-L:指定库路径-i:指定具体哪个库1234arm-none-linux-gnueabi-gcc -o jpg_rgb jpg_rgb.c \\-I /work/drv/2_lcd/libjpeg_new/libjpeg-turbo-1.5.3/tmp/include \\-L /work/drv/2_lcd/libjpeg_new/libjpeg-turbo-1.5.3/tmp/lib \\-ljpeg 方法二：前面的方法，每次编译都要指定一堆路径，比较麻烦，解决方法是将头文件和库复制到交叉编译工具链所在的路径：12345678910//拷贝头文件cd /work/drv/2_lcd/show_jpeg/libjpeg-turbo-1.5.3/tmp/include/cp * /work/arm-2014.05/arm-none-linux-gnueabi/libc/usr/include//拷贝库cd /work/drv/2_lcd/show_jpeg/libjpeg-turbo-1.5.3/tmp/lib/cp * /work/arm-2014.05/arm-none-linux-gnueabi/libc/lib//编译arm-none-linux-gnueabi-gcc -o jpg_rgb jpg_rgb.c -ljpeg 5.1.5 运行应用程序a. 先把应用程序和动态库拷贝到开发板上：12cp jpg_rgb /work/nfs_rootfs/cp libjpeg-turbo-1.5.3/tmp/lib/*so* /work/nfs_rootfs/lib/ -d b. 加载背光和LCD驱动：12insmod backlight_drv.koinsmod lcd_drv.ko c. 开启背光：1./app 200 d. 运行应用程序：1./jpg_rgb cq.jpg 5.1.6 实际效果 5.2移除左上角光标现在已经实现了图片的显示，仔细观察，发现左上角有个小光标一直在闪烁。查阅了相关资料，解决方案如下: 修改Linux内核中的文件：drivers/video/console/fbcon.c 去掉光标闪烁：将函数static void fbcon_cursor(struct vc_data *vc, int mode)改为空函数即可。 去掉光标显示：将函数static void fb_flashcursor(struct work_struct *work) 改为空函数即可。 再重新编译、烧写内核。 6.总结 Beautiful Chongqing. 总算搞完了LCD，真累。拖拖拉拉了差不多一个月。对LCD这块，不管是基础知识、驱动还是应用程序，都有了一个新的认识，也除去了LCD这块拦路虎的“心结”，有信心去迎接更复杂的模块。 后续的话，搞定电容屏驱动，就可以考虑学习下摄像头驱动了。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"Exynos4412","slug":"Exynos4412","permalink":"http://yoursite.com/tags/Exynos4412/"},{"name":"LCD","slug":"LCD","permalink":"http://yoursite.com/tags/LCD/"}]},{"title":"Exynos4412——LCD之backligth","date":"2017-11-22T11:27:44.000Z","path":"2017/11/22/Exynos4412——LCD之backligth/","text":"Exynos4412的背光驱动，采用友善之臂的“一线触摸”。 1.背景 关于一线触摸友善之臂官方说明：LCD-S702/zh 在大部分的ARM主控板中，我们发现，直接使用CPU自带的ADC转换器并不能很好的支持大尺寸(7寸以上)的四线电阻触摸屏，市面上一般采用更加专业的USB或串口触摸屏扩展模块来解决。为了节省ARM主控芯片的有限资源以及减少外扩，我们专门开发了只使用一个普通GPIO就可以实现专业触摸效果的替代方案，并把它集成到我们的LCD模块驱动板中，我们称之为“一线触摸(1-Wire)”。它的基本原理是，使用一个低成本的MCU连接一个专业的触控芯片(在此我们使用的是ADS7843或兼容芯片)，采集并处理四线电阻模拟信号，并把滤波(未校准)后的稳定原始数据通过GPIO送给ARM主控，经我们长期反复测试，即使在19寸这样大的电阻触摸屏上，也可以实现非常精准的触摸效果，不会出现漂移抖动的现象。 另外，当今12寸以内的LCD显示屏，大都采用了LED背光，我们顺便也把背光调节部分也交给MCU来处理，并设置了统一的调节数值区间，最后通过“一线触摸”的GPIO传给ARM主控，这样在ARM端就可以非常方便的来设置背光了。 与此同时，我们还为我们设计开发的每一款带“一线触摸”的LCD模块设置了编号存储在MCU中，这样通过一线通讯读取到的编号，就可以知道这个LCD模块的具体类型了，也就可以在bootloader和内核中自动匹配相应的LCD驱动参数，以此来实现无需修改任何配置，即插即用带”一线触摸”的LCD模块。 在电容触摸LCD模块中，我们则去掉了电阻触控芯片，而保留了背光调节和存储LCD类型编号这2个功能，因此电容触摸通讯依然是标准的I2C接口。 需要注意的是，我们实现的“一线触摸”的通讯，和通常所说的单总线接口是不同的。在ARM主控端内部，我们实际采用了一路pwm timer(不是pwm管脚哦)来实现固定的通讯频率(9600Hz)，详细请查看驱动源代码。 也就是说友善之臂为了改善大尺寸四线电阻触摸屏的性能，外加了一个低成本的MCU去控制专业的触控芯片，将滤波后的稳定数据通过GPIO传回到ARM上。这是和触摸屏相关的，本次不深究，而且我的板子LCD是电容屏，以上的改进几乎不关我的事。但，他们把背光调节部分也交给了那个低成本MCU来处理，并通过“一线触摸”来控制，这就坑了。记得以前的都是ARM的一个PWM引脚就完成LCD的背光的控制，现在由于硬件上并不能直接PWM控制，不得不采用“一线触摸”。 2.原理图 Tiny4412SDK-1506-Schematic.pdf： Tiny4412-1412-Schematic.pdf：Exynos4412的GPX1_2与LCD相连，作为“一线触摸”引脚，也就是背光控制引脚。 3.设备树文件123456789101112131415161718192021222324252627282930313233343536373839--- exynos4412-tiny4412.dts 2017-11-22 01:43:28.922397104 -0800+++ linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dts 2017-11-22 01:42:47.459525364 -0800@@ -91,6 +91,18 @@ clock-frequency = &lt;24000000&gt;; &#125;; &#125;;++ backlight@139D0000&#123;+ compatible = &quot;tiny4412,backlight&quot;;+ reg = &lt;0x139D0000 0x14&gt;;+ tiny4412,backlight = &lt;&amp;gpx1 2 GPIO_ACTIVE_HIGH&gt;;+ pinctrl-names = &quot;backlight_out&quot;,&quot;backlight_in&quot;;+ pinctrl-0 = &lt;&amp;backlight_out&gt;;+ pinctrl-1 = &lt;&amp;backlight_in&gt;;+ interrupts = &lt;0 40 0&gt;;+ clocks = &lt;&amp;clock CLK_PWM&gt;;+ clock-names = &quot;timers&quot;;+ &#125;; &#125;; &amp;rtc &#123;@@ -151,4 +163,21 @@ &#125;;+&amp;pinctrl_1 &#123;+ backlight_out: backlight_out&#123;+ samsung,pins = &quot;gpx1-2&quot;;+ samsung,pin-function = &lt;1&gt;;+ samsung,pin-pud = &lt;0&gt;;+ samsung,pin-drv = &lt;0&gt;;+ &#125;;+ backlight_in: backlight_in&#123;+ samsung,pins = &quot;gpx1-2&quot;;+ samsung,pin-function = &lt;0&gt;;+ samsung,pin-pud = &lt;0&gt;;+ samsung,pin-drv = &lt;0&gt;;+ &#125;;+&#125;; 本来想认真分析的，真分析起来，发现没什么看的，0x139D0000是PWMer定时器的基地址，还将gpx1_2设置成了两种模式：backlight_out（输出引脚）和backlight_in（输入引脚）。这里为什么要用到定时器，不是很明白，文末的第二个博客说“开发板和 CPLD 通讯使用了特殊的协议，设置一次背光值，需要读写 IO 多次，因此，需要使用定时器功能”，但看原理图感觉和CPLD(EPM240T100)关系不是很大。以上就是设备树文件的一些设置，后续驱动会用到。 4.驱动简析驱动完整代码如下：[backlight_drv.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/device.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_gpio.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/bitops.h&gt;#include &lt;linux/clk.h&gt;#include &lt;linux/export.h&gt;#include &lt;linux/err.h&gt;#include &lt;linux/io.h&gt;#include &lt;linux/pwm.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/spinlock.h&gt;#include &lt;linux/time.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/delay.h&gt;/* PWM 时钟频率 100M 100M / 250 / 4 = 100000 1/100000 = 10us*/static int major;static struct cdev backlight_cdev;static struct class *cls;static struct pinctrl *pctrl;static struct pinctrl_state *pstate_in;static struct pinctrl_state *pstate_out;static int one_write_pin;struct TIMER_BASE&#123; unsigned int TCFG0; unsigned int TCFG1; unsigned int TCON; unsigned int TCNTB0; unsigned int TCMPB0; unsigned int TCNTO0; unsigned int TCNTB1; unsigned int TCMPB1; unsigned int TCNTO1; unsigned int TCNTB2; unsigned int TCMPB2; unsigned int TCNTO2; unsigned int TCNTB3; unsigned int TCMPB3; unsigned int TCNTO3; unsigned int TCNTB4; unsigned int TCBTO4; unsigned int TINT_CSTAT;&#125;;volatile static struct TIMER_BASE *timer = NULL;static volatile unsigned int io_bit_count;static volatile unsigned int io_data;enum&#123; IDLE, START, REQUEST, WAITING, RESPONSE, STOPING,&#125; one_wire_status = IDLE;static inline void stop_timer_for_1wire(void)&#123; unsigned long tcon; tcon = timer-&gt;TCON; tcon &amp;= ~(1 &lt;&lt; 16); timer-&gt;TCON = tcon;&#125;static irqreturn_t timer_for_1wire_interrupt(int irq, void *dev_id)&#123; unsigned int tint; tint = timer-&gt;TINT_CSTAT; tint |= 0x100; timer-&gt;TINT_CSTAT = tint; //printk(\"timer_for_1wire_interrupt\\n\"); io_bit_count--; switch (one_wire_status) &#123; case START: if (io_bit_count == 0) &#123; io_bit_count = 16; one_wire_status = REQUEST; &#125; break; case REQUEST: gpio_set_value(one_write_pin, io_data &amp; (1U &lt;&lt; 31)); io_data &lt;&lt;= 1; if (io_bit_count == 0) &#123; io_bit_count = 2; one_wire_status = WAITING; &#125; break; case WAITING: if (io_bit_count == 0) &#123; io_bit_count = 32; one_wire_status = RESPONSE; &#125; if (io_bit_count == 1) &#123; pinctrl_select_state(pctrl, pstate_in); gpio_set_value(one_write_pin, 1); &#125; break; case RESPONSE: io_data = (io_data &lt;&lt; 1) | gpio_get_value(one_write_pin); if (io_bit_count == 0) &#123; io_bit_count = 2; one_wire_status = STOPING; gpio_set_value(one_write_pin, 1); pinctrl_select_state(pctrl, pstate_out); //one_wire_session_complete(one_wire_request, io_data); &#125; break; case STOPING: if (io_bit_count == 0) &#123; one_wire_status = IDLE; stop_timer_for_1wire(); &#125; break; default: stop_timer_for_1wire(); &#125; return IRQ_HANDLED;&#125;static const unsigned char crc8_tab[] =&#123; 0x00, 0x07, 0x0E, 0x09, 0x1C, 0x1B, 0x12, 0x15, 0x38, 0x3F, 0x36, 0x31, 0x24, 0x23, 0x2A, 0x2D, 0x70, 0x77, 0x7E, 0x79, 0x6C, 0x6B, 0x62, 0x65, 0x48, 0x4F, 0x46, 0x41, 0x54, 0x53, 0x5A, 0x5D, 0xE0, 0xE7, 0xEE, 0xE9, 0xFC, 0xFB, 0xF2, 0xF5, 0xD8, 0xDF, 0xD6, 0xD1, 0xC4, 0xC3, 0xCA, 0xCD, 0x90, 0x97, 0x9E, 0x99, 0x8C, 0x8B, 0x82, 0x85, 0xA8, 0xAF, 0xA6, 0xA1, 0xB4, 0xB3, 0xBA, 0xBD, 0xC7, 0xC0, 0xC9, 0xCE, 0xDB, 0xDC, 0xD5, 0xD2, 0xFF, 0xF8, 0xF1, 0xF6, 0xE3, 0xE4, 0xED, 0xEA, 0xB7, 0xB0, 0xB9, 0xBE, 0xAB, 0xAC, 0xA5, 0xA2, 0x8F, 0x88, 0x81, 0x86, 0x93, 0x94, 0x9D, 0x9A, 0x27, 0x20, 0x29, 0x2E, 0x3B, 0x3C, 0x35, 0x32, 0x1F, 0x18, 0x11, 0x16, 0x03, 0x04, 0x0D, 0x0A, 0x57, 0x50, 0x59, 0x5E, 0x4B, 0x4C, 0x45, 0x42, 0x6F, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7D, 0x7A, 0x89, 0x8E, 0x87, 0x80, 0x95, 0x92, 0x9B, 0x9C, 0xB1, 0xB6, 0xBF, 0xB8, 0xAD, 0xAA, 0xA3, 0xA4, 0xF9, 0xFE, 0xF7, 0xF0, 0xE5, 0xE2, 0xEB, 0xEC, 0xC1, 0xC6, 0xCF, 0xC8, 0xDD, 0xDA, 0xD3, 0xD4, 0x69, 0x6E, 0x67, 0x60, 0x75, 0x72, 0x7B, 0x7C, 0x51, 0x56, 0x5F, 0x58, 0x4D, 0x4A, 0x43, 0x44, 0x19, 0x1E, 0x17, 0x10, 0x05, 0x02, 0x0B, 0x0C, 0x21, 0x26, 0x2F, 0x28, 0x3D, 0x3A, 0x33, 0x34, 0x4E, 0x49, 0x40, 0x47, 0x52, 0x55, 0x5C, 0x5B, 0x76, 0x71, 0x78, 0x7F, 0x6A, 0x6D, 0x64, 0x63, 0x3E, 0x39, 0x30, 0x37, 0x22, 0x25, 0x2C, 0x2B, 0x06, 0x01, 0x08, 0x0F, 0x1A, 0x1D, 0x14, 0x13, 0xAE, 0xA9, 0xA0, 0xA7, 0xB2, 0xB5, 0xBC, 0xBB, 0x96, 0x91, 0x98, 0x9F, 0x8A, 0x8D, 0x84, 0x83, 0xDE, 0xD9, 0xD0, 0xD7, 0xC2, 0xC5, 0xCC, 0xCB, 0xE6, 0xE1, 0xE8, 0xEF, 0xFA, 0xFD, 0xF4, 0xF3,&#125;;#define crc8_init(crc) ((crc) = 0XACU)#define crc8(crc, v) ( (crc) = crc8_tab[(crc) ^(v)])static void start_one_wire_session(unsigned char req)&#123; unsigned int tcon; printk(\"backlight_write\\n\"); one_wire_status = START; gpio_set_value(one_write_pin, 1); pinctrl_select_state(pctrl, pstate_out); // IDLE to START &#123; unsigned char crc; crc8_init(crc); crc8(crc, req); io_data = (req &lt;&lt; 8) + crc; io_data &lt;&lt;= 16; &#125; io_bit_count = 1; pinctrl_select_state(pctrl, pstate_out); timer-&gt;TCNTB3 = 650; //init tranfer and start timer tcon = timer-&gt;TCON; tcon &amp;= ~(0xF &lt;&lt; 16); tcon |= (1 &lt;&lt; 17); timer-&gt;TCON = tcon; tcon |= (1 &lt;&lt; 16); tcon |= (1 &lt;&lt; 19); tcon &amp;= ~(1 &lt;&lt; 17); timer-&gt;TCON = tcon; timer-&gt;TINT_CSTAT |= 0x08; gpio_set_value(one_write_pin, 0);&#125;static ssize_t backlight_write(struct file *file, const char __user *buf, size_t count, loff_t *off)&#123; unsigned char reg, ret; ret = copy_from_user(&amp;reg, buf, 1); printk(\"kernel: reg = %d\", reg); //printk(\"buf = %d\", *buf); if (ret &lt; 0) &#123; printk(\"%s copy_from_user error\\n\", __func__); &#125; /*if (reg &gt; 127) &#123; reg = 127; &#125; start_one_wire_session(reg + 0x80); */ start_one_wire_session(reg); return 1;&#125;static int backlight_open(struct inode *inode, struct file *file)&#123; printk(\"backlight_open\\n\"); return 0;&#125;static int backlight_release(struct inode *inode, struct file *file)&#123; printk(\"backlight_exit\\n\"); return 0;&#125;static struct file_operations backlight_fops =&#123; .owner = THIS_MODULE, .open = backlight_open, .release = backlight_release, .write = backlight_write,&#125;;static struct device *dev;static struct clk *base_clk;static struct resource *res = NULL, *irq = NULL;static int backlight_probe(struct platform_device *pdev)&#123; int ret; dev_t devid; dev = &amp;pdev-&gt;dev; printk(\"enter %s\\n\", __func__); pctrl = devm_pinctrl_get(dev); if (pctrl == NULL) &#123; printk(\"devm_pinctrl_get error\\n\"); return -EINVAL; &#125; pstate_in = pinctrl_lookup_state(pctrl, \"backlight_in\"); pstate_out = pinctrl_lookup_state(pctrl, \"backlight_out\"); if (pstate_in == NULL || pstate_out == NULL) &#123; printk(\"pinctrl_lookup_state error\\n\"); return -EINVAL; &#125; one_write_pin = of_get_named_gpio(dev-&gt;of_node, \"tiny4412,backlight\", 0); if (!one_write_pin) &#123; printk(\"of_get_named_gpio error\\n\"); return -EINVAL; &#125; devm_gpio_request_one(dev, one_write_pin, GPIOF_OUT_INIT_HIGH, \"one_write\"); //pinctrl_select_state(pctrl, pstate); res = platform_get_resource(pdev, IORESOURCE_MEM, 0); if (res == NULL) &#123; printk(\"platform_get_resource error\\n\"); return -EINVAL; &#125; base_clk = devm_clk_get(&amp;pdev-&gt;dev, \"timers\"); if (IS_ERR(base_clk)) &#123; dev_err(dev, \"failed to get timer base clk\\n\"); return PTR_ERR(base_clk); &#125; ret = clk_prepare_enable(base_clk); if (ret &lt; 0) &#123; dev_err(dev, \"failed to enable base clock\\n\"); return ret; &#125; timer = devm_ioremap_resource(&amp;pdev-&gt;dev, res); if (timer == NULL) &#123; printk(\"devm_ioremap_resource error\\n\"); return -EINVAL; &#125; printk(\"timer: %x\\n\", (unsigned int)timer); timer-&gt;TCFG0 = 0xF00; timer-&gt;TCFG1 = 0x10004; irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0); if (irq == NULL) &#123; printk(\"platform_get_resource irq error\\n\"); return -EINVAL; &#125; ret = devm_request_irq(dev, irq-&gt;start, timer_for_1wire_interrupt , IRQF_TIMER, \"backlight\", NULL); if (ret) &#123; dev_err(dev, \"unable to request irq\\n\"); return -EINVAL; &#125; start_one_wire_session(0x60); if (alloc_chrdev_region(&amp;devid, 0, 1, \"backlight\") &lt; 0) &#123; printk(\"%s ERROR\\n\", __func__); return -EINVAL; &#125; major = MAJOR(devid); cdev_init(&amp;backlight_cdev, &amp;backlight_fops); cdev_add(&amp;backlight_cdev, devid, 1); cls = class_create(THIS_MODULE, \"onewire_backlight\"); device_create(cls, NULL, MKDEV(major, 0), NULL, \"tiny4412_backlight\"); return 0;&#125;static int backlight_remove(struct platform_device *pdev)&#123; printk(\"enter %s\\n\", __func__); device_destroy(cls, MKDEV(major, 0)); class_destroy(cls); cdev_del(&amp;backlight_cdev); unregister_chrdev_region(MKDEV(major, 0), 1); devm_pinctrl_put(pctrl); devm_free_irq(dev, irq-&gt;start, NULL); clk_disable_unprepare(base_clk); devm_gpio_free(dev, one_write_pin); return 0;&#125;static const struct of_device_id backlight_dt_ids[] =&#123; &#123; .compatible = \"tiny4412,backlight\", &#125;, &#123;&#125;,&#125;;MODULE_DEVICE_TABLE(of, backlight_dt_ids);static struct platform_driver backlight_driver =&#123; .driver = &#123; .name = \"tiny4412_backlight\", .of_match_table = of_match_ptr(backlight_dt_ids), &#125;, .probe = backlight_probe, .remove = backlight_remove,&#125;;static int backlight_init(void)&#123; int ret; printk(\"enter %s\\n\", __func__); ret = platform_driver_register(&amp;backlight_driver); if (ret) &#123; printk(KERN_ERR \"Tiny4412 backlight: probe faid backlight: %d\\n\", ret); &#125; return ret;&#125;static void backlight_exit(void)&#123; printk(\"enter %s\\n\", __func__); platform_driver_unregister(&amp;backlight_driver);&#125;module_init(backlight_init);module_exit(backlight_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"Tiny4412 LCD backlight driver.\");MODULE_ALIAS(\"Exynos4412_backlight\");MODULE_VERSION(\"V1.0\"); 首先insmod该驱动，会调用backlight_init(),注册平台设备platform_driver_register(&amp;backlight_driver)。backlight_driver结构体里面的.compatible与设备树文件里的compatible完全匹配上后，即调用最核心的backlight_probe()函数。在backlight_probe()函数里获取设备树的各种信息、地址映射、设置时钟等，最后再申请设备号、注册设备、创建类、创建设备。在backlight_fops操作函数里，主要的是写函数，它获取用户层的数据，然后调用start_one_wire_session()实现背光的修改。这里的start_one_wire_session()就不太好分析了，协议是友善自定的。 5.测试程序[app.c]link123456789101112131415161718192021222324252627282930313233#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#define msleep(x) usleep(x*1000)int main(int argc, char **argv)&#123; int fd; int val; if (argc != 2) &#123; printf(\"%s+val\\n\",argv[0]); return -1; &#125; fd = open(\"/dev/tiny4412_backlight\", O_RDWR); if (fd &lt; 0) &#123; printf(\"can't open /dev/tiny4412_backlight\\n\"); return 0; &#125; val = strtoul(argv[1], NULL, 0); printf(\"app: val = %d\",val); write(fd, &amp;val, 1); return 0; &#125; 6.实测结果 参考博客：学习设备树之（十一）Backlight(20）设备树LCD背光驱动 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"Exynos4412","slug":"Exynos4412","permalink":"http://yoursite.com/tags/Exynos4412/"}]},{"title":"Exynos4412——SD卡启动","date":"2017-11-07T10:36:29.000Z","path":"2017/11/07/Exynos4412——SD卡启动/","text":"实现Tiny4412从SD卡的启动内核与根文件系统。前面启动开发板时，需要从SD卡启动Uboot，然后从DNW下载内核和根文件系统到RAM，或者NFS挂载根文件系统。Uboot应该是支持SD卡的，可以从SD卡读取内核。Uboot把控制权交给内核后，内核必须要支持SD卡，才能访问SD卡的根文件系统，因此需要移植SD卡驱动。 1.关于启动的理解嵌入式Linux开发一般需要至少三个文件：Bootloader(Uboot)、Kernel(uImage)、根文件系统（rootfs）。Kernel-3.x加入设备树后，又多了个DTB设备树文件。因此，本次要准备四个文件：Uboot、Kernel、rootfs、DTB。 一般开发板上有多个存储介质，如：Nand Flash、Nor Flash、mmc、emmc、SD卡、网络也算特殊的一种。 前面的四个文件，理论上可以放在板上的任一存储介质里面，然后给SOC信号（开发板上的启动顺序拨码开关），告诉它从哪个存储介质读取相应文件。但由于一些特殊原因，往往有所限制。比如，Nor Flash比较小，一般只放Uboot，放不下rootfs。好像也没有支持网络NFS启动的Uboot，至少我目前没遇到过。因此，一般常见的方式是把Uboot放在Nor Flash，其它的放在Nand Flash，就像JZ2440；或者全都放在SD卡/TF卡，就像Ti的AM437X；又或者都放在emmc，像Tiny4412；总之就是以上的存储介质组合，根据实际情况而定。需要一提的是，很多SOC现在都在Uboot前封装了一层代码，或者搞了一个其它什么机制，上电后马上初始化了存储介质相关的寄存器，其次才加载用户的第一行代码。 开发板上电后，先内部固化代码先初始化一些必要的东西（有的SOC没有这一机制），然后根据启动引脚的电平，读取相应的存储介质上的Uboot到RAM，启动Uboot后，根据用户传的参数加载内核、设备树、根文件系统到RAM。这一过程的Uboot所处的存储介质受限比较大，要根据SOC所支持的启动方式来选择。后面Uboot启动后，Uboot会初始化更多的硬件存储介质，也就有了更多的选择。 启动过程其实是先将要启动的文件从存储位置拷贝到内存空间，再在内存中运行。因此所谓不同位置启动，也就是从不同位置拷贝而已。 2.移植SD卡驱动SD卡移植的工作内容很少，仅对其设备树文件arch/arm/boot/dts/exynos4412-tiny4412.dts添加了一行代码即可：12345678910-- /work/tools/linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dts 2017-10-21 08:55:07.000000000 -0700+++ /work/linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dts 2017-10-31 03:34:04.609606802 -0700@@ -79,6 +101,7 @@ bus-width = &lt;4&gt;; pinctrl-0 = &lt;&amp;sd2_clk &amp;sd2_cmd &amp;sd2_cd &amp;sd2_bus4&gt;; pinctrl-names = &quot;default&quot;;+ vmmc-supply = &lt;&amp;mmc_reg&gt;; status = &quot;okay&quot;; &#125;; 然后奇迹般就可以了。。懵逼。 3.制作SD卡先将SD卡分为两个区，一个格式为fat32用于放内核和dtb，一个格式为ext3/4用于存放根文件系统。可以使用fdisk命令分区，mkfs命令进行格式化。这里使用如下的mkcard.sh脚本更方便，原脚本里面的sfdisk是2.26版本的，在Ubuntu14.04运行正常，在Ubuntu16.04是无法运行的，Ubuntu16.014sfdisk的版本是2.27.1。顺便修改了下分区大小，看起来更舒服点，修改后的脚本如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#! /bin/sh# mkcard.sh v0.4# (c) Copyright 2009 Graeme Gregory &lt;dp@xora.org.uk&gt;# Licensed under terms of GPLv2## Parts of the procudure base on the work of Denys Dmytriyenko# http://wiki.omap.com/index.php/MMC_Boot_FormatLC_ALL=Cif [ $# -ne 1 ]; then echo \"Usage: $0 &lt;drive&gt;\" exit 1;fiDRIVE=$1dd if=/dev/zero of=$DRIVE bs=1024 count=1024SIZE=`fdisk -l $DRIVE | grep Disk | awk '&#123;print $5&#125;'`echo DISK SIZE - $SIZE bytesCYLINDERS=`echo $SIZE/255/63/512 | bc`echo CYLINDERS - $CYLINDERS# 将SD卡分成2个区sfdisk --no-reread $DRIVE &lt;&lt; EOF1024,1024000,0x0C,*1024100,,,-EOF# 格式化第1分区为fat32格式, 并且命名为bootif [ -b $&#123;DRIVE&#125;1 ]; then mkfs.vfat -F 32 -n \"boot\" $&#123;DRIVE&#125;1else if [ -b $&#123;DRIVE&#125;p1 ]; then mkfs.vfat -F 32 -n \"boot\" $&#123;DRIVE&#125;p1 else echo \"Cant find boot partition in /dev\" fifi# 格式化第2分区为ext3格式, 并且命名为rootfsif [ -b $&#123;DRIVE&#125;2 ]; then mke2fs -j -L \"rootfs\" $&#123;DRIVE&#125;2else if [ -b $&#123;DRIVE&#125;p2 ]; then mke2fs -j -L \"rootfs\" $&#123;DRIVE&#125;p2 else echo \"Cant find rootfs partition in /dev\" fifisyncsudo partprobe $DRIVE sync 参考博客(需梯子) 执行1sudo ./mkcard.sh /dev/mmcblk0 等待一会，使用命令sudo fdisk -l查看分区，如果脚本工作完后，看起来没有分区成功，重启系统再来一次，有点莫名其妙的。 搞定后，此时就会有两个分别名叫boot和rootfs的分区。再使用制作Uboot的sd_fusing.sh脚本。12cd work/uboot_tiny4412_0929/sd_fuse/tiny4412 sudo ./sd_fusing.sh /dev/mmcblk0 简单看了看sd_fusing.sh脚本，脑补了下此时的SD卡分布：此时在boot和rootfs分区看不到相关文件的原因可能就是不在分区内。 最后依次将uImage、DTB、rootfs复制到SD卡即可：1234sudo cp /work/linux-4.13.9/arch/arm/boot/uImage /media/hceng/boot/sudo cp /work/linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dtb /media/hceng/boot/sudo cp -rd /work/nfs_rootfs/* /media/hceng/rootfs/ 4.Uboot参数设置刚开始测试的时候，老是卡在Starting kernel ...，查找了一下午原因，最后发现是Uboot参数设置的时候连写命令所致。Uboot启动参数设置如下： SD卡启动： 1234567setenv bootargs &apos;root=/dev/mmcblk0p2 rw console=ttySAC0,115200 init=/linuxrc&apos;saveenvsetenv bootcmd fatload mmc 0:1 0x40000000 uImage\\;fatload mmc 0:1 0x42000000 exynos4412-tiny4412.dtb\\;bootm 0x40000000 - 0x42000000saveenvboot NFS启动： 1234567setenv bootargs &apos;root=/dev/nfs rw nfsroot=192.168.1.226:/work/fs_mini_mdev_new ethmac=00:40:5c:26:0a:5b ip=192.168.1.225:192.168.1.226:192.168.1.1:255.255.255.0::eth0:off console=ttySAC0,115200 init=/linuxrc&apos;saveenvsetenv bootcmd fatload mmc 0:1 0x40000000 uImage\\;fatload mmc 0:1 0x42000000 exynos4412-tiny4412.dtb\\;bootm 0x40000000 - 0x42000000saveenvboot 5.实际效果 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"SD卡","slug":"SD卡","permalink":"http://yoursite.com/tags/SD卡/"},{"name":"Exynos4412","slug":"Exynos4412","permalink":"http://yoursite.com/tags/Exynos4412/"},{"name":"Uboot","slug":"Uboot","permalink":"http://yoursite.com/tags/Uboot/"}]},{"title":"Exynos4412——网卡移植和NFS启动","date":"2017-10-31T12:27:52.000Z","path":"2017/10/31/Exynos4412——网卡移植和NFS启动/","text":"为Exynos 4412移植好网卡驱动，并采用NFS挂载根文件系统启动。玩Exynos4412的第一个目标是想弄下LCD驱动。在开始流畅的写驱动前，前期的准备工作又多又繁琐。 上次移植好了内核，内核和根文件系统都是在RAM进行进行加载的，后面写驱动的时候，肯定不方便。就以往的经验来看，uboot、kernel都应该在SD卡或者eMMC上，这样断电才不会丢失。根文件系统在调试驱动的时候应该是nfs挂载，调试完成了再烧写到SD卡或者eMMC上。 因此，写驱动前至少还要移植好SD卡驱动、网卡驱动。eMMC可暂时不管。 本次就先移植好网卡驱动，并尝试NFS挂载根文件系统。 1.硬件结构JZ2440中的网卡芯片是DM9000，采用的是内存接口。 Tiny4412的网卡芯片是DM9621，采用的是USB接口。而且该芯片并没有直接接在SOC的USB上，而是接在USB4604这个HUB芯片上。USB4604通过HSIC接口(XuhostSTROBE1和XuhostDATA1)接在SOC上。框架如下： 因此，需要重点关注USB4604和DM9621。查看这两块的原理图： USB4604： DM9621： 发现USB4604的一些功能并没有使用，如外接SPI/I2C设备等。除了数据端口，还能控制的就是复位引脚。 DM9621的驱动在本内核的drivers/net/usb/dm9601.c已经实现，但为了支持识别bootargs中的mac地址的功能，需要稍微修改dm9601.c，添加解析mac地址的功能，并且还需要将解析到的有效的mac地址设置到dm9621中，否则网络不能用。 USB4604的驱动在本内核的drivers/usb/misc/usb4604.c已经实现，但由于没有外接SPI/I2C，需要删除一些，可以参考drivers/usb/misc/usb3503.c或者博客里的代码。我直接用的博客里面的代码。 此外，还需在设备树使能将要用到的外设：hsi、ehci、otg等。 2.移植网卡驱动目前需要修改的文件有：（1）设备树文件：arch/arm/boot/dts/exynos4412-tiny4412.dts；（2）DM9621驱动：drivers/net/usb/dm9601.c；（3）USB4604驱动：drivers/usb/misc/usb4604.c；（4）USB4604驱动头文件：include/linux/platform_data/usb4604.h（新建）；（5）设备树头文件：include/dt-bindings/usb4640/usb4604.h（新建）；（6）DM9621驱动加入内核；（7）USB4604驱动加入内核； 2.1 修改设备树文件主要添加了usb-hub的复位引脚信息和使能了一些外设。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273--- /work/tools/linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dts 2017-10-21 08:55:07.000000000 -0700+++ /work/linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dts 2017-10-30 02:34:10.363297869 -0700@@ -14,6 +14,7 @@ /dts-v1/; #include \"exynos4412.dtsi\" #include &lt;dt-bindings/gpio/gpio.h&gt;+#include &lt;dt-bindings/usb4604/usb4604.h&gt; / &#123; model = \"FriendlyARM TINY4412 board based on Exynos4412\";@@ -21,6 +22,7 @@ chosen &#123; stdout-path = &amp;serial_0;+ bootargs = \"root=/dev/ram0 rw rootfstype=ext4 console=ttySAC0,115200 init=/linuxrc earlyprintk\"; &#125;; memory@40000000 &#123;@@ -28,6 +30,12 @@ reg = &lt;0x40000000 0x40000000&gt;; &#125;; + usb-hub &#123;+ compatible = \"smsc,usb4604\";+ reset-gpios = &lt;&amp;gpm2 4 GPIO_ACTIVE_LOW&gt;;+ initial-mode = &lt;USB4604_MODE_HUB&gt;;+ &#125;;+ leds &#123; compatible = \"gpio-leds\"; @@ -79,7 +87,7 @@ bus-width = &lt;4&gt;; pinctrl-0 = &lt;&amp;sd2_clk &amp;sd2_cmd &amp;sd2_cd &amp;sd2_bus4&gt;; pinctrl-names = \"default\";- status = \"okay\";+ status = \"disabled\"; &#125;; &amp;serial_0 &#123;@@ -97,3 +105,32 @@ &amp;serial_3 &#123; status = \"okay\"; &#125;;+++&amp;exynos_usbphy &#123;+ status = \"okay\";+&#125;;++&amp;ehci &#123;+ status = \"okay\";+ port@0 &#123;+ status = \"okay\";+ &#125;;+ port@1 &#123;+ status = \"okay\";+ &#125;;+ port@2 &#123;+ status = \"okay\";+ &#125;;+&#125;;++&amp;ohci &#123;+ status = \"okay\";+ port@0 &#123;+ status = \"okay\";+ &#125;;+&#125;;++&amp;hsotg &#123;+ status = \"okay\";+&#125;; 2.2 修改DM9621驱动主要是添加解析mac地址的功能，并且还需要将解析到的有效的mac地址设置到dm9621中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384--- /work/tools/linux-4.13.9/drivers/net/usb/dm9601.c 2017-10-21 08:55:07.000000000 -0700+++ /work/linux-4.13.9/drivers/net/usb/dm9601.c 2017-10-30 02:06:54.319597116 -0700@@ -58,6 +58,39 @@ #define DM_RX_OVERHEAD 7 /* 3 byte header + 4 byte crc tail */ #define DM_TIMEOUT 1000 +/* Setup ethernet address */+static u8 param_addr[ETH_ALEN];++static int __init dm9601_set_mac(char *str) &#123;+ u8 addr[ETH_ALEN];+ uint val;+ int idx = 0;+ char *p = str, *end;++ while (*p &amp;&amp; idx &lt; ETH_ALEN) &#123;+ val = simple_strtoul(p, &amp;end, 16);+ if (end &lt;= p) &#123;+ break;+ &#125; else &#123;+ addr[idx++] = val;+ p = end;+ if (*p == ':'|| *p == '-') &#123;+ p++;+ &#125; else &#123;+ break;+ &#125;+ &#125;+ &#125;++ if (idx == ETH_ALEN) &#123;+ printk(\"Setup ethernet address to %pM\\n\", addr);+ memcpy(param_addr, addr, ETH_ALEN);+ &#125;++ return 1;+&#125;+__setup(\"ethmac=\", dm9601_set_mac);+ static int dm_read(struct usbnet *dev, u8 reg, u16 length, void *data) &#123; int err;@@ -190,8 +223,6 @@ return dm_read_shared_word(dev, 0, offset, value); &#125; -- static int dm9601_get_eeprom_len(struct net_device *dev) &#123; return DM_EEPROM_LEN;@@ -281,9 +312,9 @@ .set_msglevel = usbnet_set_msglevel, .get_eeprom_len = dm9601_get_eeprom_len, .get_eeprom = dm9601_get_eeprom,+// .get_settings = usbnet_get_settings,+// .set_settings = usbnet_set_settings, .nway_reset = usbnet_nway_reset,- .get_link_ksettings = usbnet_get_link_ksettings,- .set_link_ksettings = usbnet_set_link_ksettings, &#125;; static void dm9601_set_multicast(struct net_device *net)@@ -343,7 +374,6 @@ .ndo_start_xmit = usbnet_start_xmit, .ndo_tx_timeout = usbnet_tx_timeout, .ndo_change_mtu = usbnet_change_mtu,- .ndo_get_stats64 = usbnet_get_stats64, .ndo_validate_addr = eth_validate_addr, .ndo_do_ioctl = dm9601_ioctl, .ndo_set_rx_mode = dm9601_set_multicast,@@ -390,7 +420,11 @@ /* * Overwrite the auto-generated address only with good ones. */- if (is_valid_ether_addr(mac))+ if (is_valid_ether_addr(param_addr)) &#123;+ /* write MAC to dm9621 */+ memcpy(dev-&gt;net-&gt;dev_addr, param_addr, ETH_ALEN);+ __dm9601_set_mac_address(dev);+ &#125; else if (is_valid_ether_addr(mac)) memcpy(dev-&gt;net-&gt;dev_addr, mac, ETH_ALEN); else &#123; printk(KERN_WARNING 2.3 修改USB4604驱动这个几乎就全改了，应该原来的那个稍微改改也能用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152/* * Driver for SMSC USB4604 USB 2.0 hub controller driver */#include &lt;linux/gpio.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/of_gpio.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/platform_data/usb4604.h&gt;struct usb4604 &#123; enum usb4604_mode mode; struct device *dev; int gpio_reset;&#125;;static int usb4604_reset(struct usb4604 *hub, int state)&#123; if (gpio_is_valid(hub-&gt;gpio_reset)) gpio_set_value_cansleep(hub-&gt;gpio_reset, state); /* Wait 1ms for hub logic to stabilize */ if (state) usleep_range(1, 10); return 0;&#125;static int usb4604_connect(struct usb4604 *hub)&#123; struct device *dev = hub-&gt;dev; usb4604_reset(hub, 1); hub-&gt;mode = USB4604_MODE_HUB; dev_info(dev, \"switched to HUB mode\\n\"); return 0;&#125;static int usb4604_switch_mode(struct usb4604 *hub, enum usb4604_mode mode)&#123; struct device *dev = hub-&gt;dev; int err = 0; switch (mode) &#123; case USB4604_MODE_HUB: err = usb4604_connect(hub); break; case USB4604_MODE_STANDBY: usb4604_reset(hub, 0); dev_info(dev, \"switched to STANDBY mode\\n\"); break; default: dev_err(dev, \"unknown mode is requested\\n\"); err = -EINVAL; break; &#125; return err;&#125;static int usb4604_probe(struct usb4604 *hub)&#123; struct device *dev = hub-&gt;dev; struct usb4604_platform_data *pdata = dev_get_platdata(dev); struct device_node *np = dev-&gt;of_node; int err; u32 mode = USB4604_MODE_HUB; if (pdata) &#123; hub-&gt;gpio_reset = pdata-&gt;gpio_reset; hub-&gt;mode = pdata-&gt;initial_mode; &#125; else if (np) &#123; hub-&gt;gpio_reset = of_get_named_gpio(np, \"reset-gpios\", 0); if (hub-&gt;gpio_reset == -EPROBE_DEFER) return -EPROBE_DEFER; of_property_read_u32(np, \"initial-mode\", &amp;mode); hub-&gt;mode = mode; &#125; if (gpio_is_valid(hub-&gt;gpio_reset)) &#123; err = devm_gpio_request_one(dev, hub-&gt;gpio_reset, GPIOF_OUT_INIT_LOW, \"usb4604 reset\"); if (err) &#123; dev_err(dev, \"unable to request GPIO %d as reset pin (%d)\\n\", hub-&gt;gpio_reset, err); return err; &#125; &#125; usb4604_switch_mode(hub, hub-&gt;mode); dev_info(dev, \"%s: probed in %s mode\\n\", __func__, (hub-&gt;mode == USB4604_MODE_HUB) ? \"hub\" : \"standby\"); return 0;&#125;static int usb4604_platform_probe(struct platform_device *pdev)&#123; struct usb4604 *hub; hub = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(struct usb4604), GFP_KERNEL); if (!hub) return -ENOMEM; hub-&gt;dev = &amp;pdev-&gt;dev; return usb4604_probe(hub);&#125;#ifdef CONFIG_OFstatic const struct of_device_id usb4604_of_match[] = &#123; &#123; .compatible = \"smsc,usb4604\", &#125;, &#123;&#125;,&#125;;MODULE_DEVICE_TABLE(of, usb4604_of_match);#endifstatic struct platform_driver usb4604_platform_driver = &#123; .driver = &#123; .name = USB4604_NAME, .of_match_table = of_match_ptr(usb4604_of_match), &#125;, .probe = usb4604_platform_probe,&#125;;static int __init usb4604_init(void)&#123; int err; err = platform_driver_register(&amp;usb4604_platform_driver); if (err != 0) pr_err(\"usb4604: Failed to register platform driver: %d\\n\", err); return 0;&#125;module_init(usb4604_init);static void __exit usb4604_exit(void)&#123; platform_driver_unregister(&amp;usb4604_platform_driver);&#125;module_exit(usb4604_exit);MODULE_DESCRIPTION(\"USB4604 USB HUB driver\");MODULE_LICENSE(\"GPL\"); 2.4 USB4604驱动头文件枚举usb模式。1234567891011121314151617#ifndef __USB4604_H__#define __USB4604_H__#define USB4604_NAME \"usb4604\"enum usb4604_mode &#123; USB4604_MODE_UNKNOWN = 1, USB4604_MODE_HUB, USB4604_MODE_STANDBY,&#125;;struct usb4604_platform_data &#123; enum usb4604_mode initial_mode; int gpio_reset;&#125;;#endif 2.5 设备树头文件提供usb-hub的工作模式宏。1234567#ifndef _DT_BINDINGS_USB4604#define _DT_BINDINGS_USB4604#define USB4604_MODE_UNKNOWN 1#define USB4604_MODE_HUB 2#define USB4604_MODE_STANDBY 3#endif 2.6 DM9621驱动加入内核进入配置界面：1make menuconfig 将DM9621驱动加入内核 2.7 USB4604驱动加入内核将USB4604驱动加入内核 2.8 重新编译、烧写、测试 编译： 12make uImage LOADADDR=0x40008000 make dtbs 烧写：在开发板uboot界面输入： 1dnw 0x40600000;dnw 0x41000000;dnw 0x42000000 在Ubuntu依次输入：123sudo ./dnw /work/linux-4.13.9/arch/arm/boot/uImagesudo ./dnw /work/ramdisk/ramdisk.imgsudo ./dnw /work/linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dtb 最后再开发板启动：123sudo ./dnw /work/linux-4.13.9/arch/arm/boot/uImagesudo ./dnw /work/ramdisk/ramdisk.imgsudo ./dnw /work/linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dtb 测试：设置网卡ip1ifconfig eth0 192.168.1.225 ping主机：1ping -c4 192.168.1.226 3.NFS启动这里的根文件系统直接使用的是韦老大第三期项目视频的根文件系统，之前在JZ2440上也能运行，就直接拿来用了。此外修改了根文件系统、的etc/init.d/rcS，加入了ifconfig eth0 192.168.1.225设置静态IP。 设置uboot参数：1setenv bootargs &apos;root=/dev/nfs rw nfsroot=192.168.1.226:/work/fs_mini_mdev_new ethmac=00:40:5c:26:0a:5b ip=192.168.1.225:192.168.1.226:192.168.1.1:255.255.255.0::eth0:off console=ttySAC0,115200 init=/linuxrc&apos;; saveenv 开发板下载及启动：1dnw 0x40000000;dnw 0x42000000;bootm 0x40000000 - 0x42000000 Ubuntu下载：12sudo ./dnw /work/linux-4.13.9/arch/arm/boot/uImagesudo ./dnw /work/linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dtb NFS启动效果： 4.心得感谢摩斯电码的博客，很多的参考他的，节约了很多时间。 下一步移植完SD卡的驱动，将uboot和内核都放在SD卡上，根文件系统挂在nfs上，就可以搞LCD了。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"Exynos4412","slug":"Exynos4412","permalink":"http://yoursite.com/tags/Exynos4412/"},{"name":"网卡驱动","slug":"网卡驱动","permalink":"http://yoursite.com/tags/网卡驱动/"},{"name":"NFS","slug":"NFS","permalink":"http://yoursite.com/tags/NFS/"}]},{"title":"Exynos4412——内核移植","date":"2017-10-26T09:48:19.000Z","path":"2017/10/26/Exynos4412——内核移植/","text":"Exynos 4412移植最新的Kernel-4.13.9。话说最近应该不会接触AM437x了，原因有多种，但学习不能停。手头还有买来没开过几次机的Tiny4412，本想买来学Android驱动的。Exynos4412与S3C2240差别相对AM437x小很多，因此过渡应该会更顺滑一点。要学习的还很多，进度有点慢，先在板子上跑起Linux再说吧。 1.设置交叉编译工具链使用的交叉编译工具链是：arm-none-linux-gnueabi-gcc （gcc version 4.8.3 20140320）下载好后，放在Ubuntu中，解压：1tar xjf arm-2014.05-29-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 记下交叉编译工具链的位置：/work/arm-2014.05/bin修改环境变量：1sudo vim /etc/environment 添加交叉编译工具链的路径：1PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/work/arm-2014.05/bin&quot; 更新环境变量：1source /etc/environment 检测：1arm-none-linux-gnueabi-gcc -v 一些关于gcc的扩充资料 2.修改、编译uboot开始的时候使用的是Tiny4412光盘的uboot，但后续的做完了才发现不行。原来是友善的tiny4412标准版有新旧之分，差别就是更换了不同eMMC，所以导致了有些没有更新eMMC控制器配置的uboot无法启动。因此下了新版的uboot_tiny4412_0929.tar.gz即可。参考链接 目前首先需要实现如下功能：用u-boot引导uImage或者zImage，同时将设备信息以设备树的形式传递给Linux内核，而根文件系统以ramdisk的形式传递给内核，因为目前SD卡驱动、eMMC驱动和usb网卡驱动都没有移植。 2.1 关闭MMU1vim include/configs/tiny4412.h 将#define CONFIG_ENABLE_MMU改为#undef CONFIG_ENABLE_MMU; 2.2 修改u-boot的链接地址1vim board/samsung/tiny4412/config.mk 将CONFIG_SYS_TEXT_BASE = 0xc3e00000修改为CONFIG_SYS_TEXT_BASE = 0x43e00000; 2.3 使uboot可以引导uImage1vim common/cmd_bootm.c ①在boot_os_fn *boot_fn;后添加：1int iszImage = 0; ②在images.legacy_hdr_valid = 1;后添加：1iszImage = 1; ③修改12images.os.os = hdr-&gt;ih_os;images.ep = image_get_ep (&amp;images.legacy_hdr_os_copy); 为1234if(iszImage) &#123; images.os.os = hdr-&gt;ih_os; images.ep = image_get_ep (&amp;images.legacy_hdr_os_copy); &#125; 2.4 支持设备树1vim include/configs/tiny4412.h 添加如下两个宏：12#define CONFIG_OF_LIBFDT#define CONFIG_SYS_BOOTMAPSZ (20 &lt;&lt; 20) 2.5 修改uboot的Makefile将原来的：123ifeq ($(HOSTARCH),$(ARCH))CROSS_COMPILE ?=endif 改为123ifeq ($(ARCH),arm)CROSS_COMPILE ?=/work/arm-2014.05/bin/arm-none-linux-gnueabi-endif 2.6 编译uboot123make distcleanmake tiny4412_configmake 3.移植、编译内核3.1 下载最新内核下载的当前最新的内核Kernel-4.13.9。解压12xz -d linux-4.13.9.tar.xztar xf linux-4.13.9.tar 3.2 修改Makefile将12ARCH ?= $(SUBARCH)CROSS_COMPILE ?= $(CONFIG_CROSS_COMPILE:&quot;%&quot;=%) 改为12ARCH ?= armCROSS_COMPILE ?= /work/arm-2014.05/bin/arm-none-linux-gnueabi- 3.3 修改设备树文件1vim arch/arm/boot/dts/exynos4412-tiny4412.dts 在stdout-path = &amp;serial_0;添加启动参数：1bootargs = &quot;root=/dev/ram0 rw rootfstype=ext4 console=ttySAC0,115200 init=/linuxrc earlyprintk&quot;; 将sdhci_2节点下的1status = &quot;okay&quot;; 改为:1status = &quot;disabled&quot;; 3.4 编译内核Kernel-4.13.9对Exynos 4412支持还不错，直接就有配置文件，使用即可。123make distcleanmake ARCH=arm exynos_defconfigmake uImage LOADADDR=0x40008000 这里实测出现错误，显示找不到mkimage。mkimage是/work/uboot_tiny4412_0929/tools里面的，加入环境变量即可。解决参考 1sudo vim /etc/bash.bashrc 加入:1export PATH=/work/uboot_tiny4412_0929/tools:$PATH 更新:1source /etc/bash.bashrc 重新编译：1make uImage LOADADDR=0x40008000 生成uImage在arch/arm/boot。 3.5 编译设备树文件1make dtbs 生成exynos4412-tiny4412.dtb在arch/arm/boot/dts/。 4.下载到开发板4.1 准备SD卡制作SD卡的工具在uboot_tiny4412_0929里面，先编译下。12sd_fusemake 插上SD卡，查看当前SD卡挂载位置。1sudo fdisk -l 我的是/dev/sdb。 4.2 制作SD卡，烧uboot12cd tiny4412./sd_fusing.sh /dev/sdb 制作好了，插上开发板，选择SD卡启动，在串口上即可有打印信息。 4.3 烧写内核、根文件系统、设备树文件这里的根文件系统用的网友做好的ramdisk镜像由于tiny4412的uboot目前还不支持usb网卡，只能使用dnw来下载，并且tiny4412的u-boot中已经自带了dnw命令了，Ubuntu上使用网友的dnw。 ①下载uImage在u-boot里执行下载uImage的命令:1dnw 0x40600000 (这个地址不唯一) 在Ubuntu中执行：1sudo ./dnw /work/linux-4.13.9/arch/arm/boot/uImage ②下载ramdisk在u-boot里执行下载uImage的命令:1dnw 0x41000000 (这个地址不唯一) 在开发机中执行：1sudo ./dnw /work/ramdisk/ramdisk.img ③下载设备树镜像在u-boot里执行下载uImage的命令:1dnw 0x42000000 (这个地址不唯一) 在开发机中执行：1sudo ./dnw /work/linux-4.13.9/arch/arm/boot/dts/exynos4412-tiny4412.dtb 4.4 启动开发板继续输入1bootm 0x40600000 0x41000000 0x42000000 不要重启，现在数据都在RAM里面的，掉电就没了。 5.实际效果 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Exynos4412","slug":"Exynos4412","permalink":"http://yoursite.com/tags/Exynos4412/"},{"name":"内核移植","slug":"内核移植","permalink":"http://yoursite.com/tags/内核移植/"}]},{"title":"QT应用设计——HexoBlogClient","date":"2017-10-12T01:29:04.000Z","path":"2017/10/12/QT应用设计——HexoBlogClient/","text":"本文主要记录采用QT开发的hexo博客管理客户端——HexoBlogClient。 0.初衷做嵌入式这行，如果做界面，几乎只有两个选择：Qt和Android。所以感觉学习下Qt还是很有必要的，顺便回忆点C++。 国庆节前打了鸡血一样疯狂的学了一周Qt，学了后想做个简单的东西练练手。所做的东西一定要是能解决我的某些痛点的，这样才会让我动力去做。 思来想去，每次写博客，需要打开Git Bash，输入创建命令、构建、本地预览、发布、备份……虽说之前GitHub+Hexo搭建及优化——5-5脚本自动化中采用了bat脚本一键完成清理、构建、发布这些操作，但每次要打开Git Bash，进入指定路径，输入脚本运行，还是挺麻烦的。 So，搞个博客客户端一键操作似乎更方便点 = = 1.设计思路写博客，我一般的完整步骤是： 新建博客-&gt;编辑博客-&gt;如果有图片需上传到图床、有代码需上传到GitHub-&gt;清理原来博客的生成的静态页面-&gt;生成新的静态页面-&gt;本地预览-&gt;根据预览效果继续编辑-&gt;满意后再次清理、生成静态页面-&gt;发布博客(GitHub和Coding)-&gt;备份本地的所有源文件到Coding私有库-&gt;访问博客查看。 因此博客客户端首先应该很流畅的实现上面的工作流，其次才是锦上添花的添加其它功能。 a:本地界面 a1:打开这个客户端，首先这个页面应该显示出我的文章列表； a2:实现新建博客文章、编辑博客文章等对文章的常用操作； a3:实现常用的清理、生成、预览、发布、备份等功能； b:图床界面 b1:博客文章采用的Markdwon格式，图片需要先保存到图床，然后引用链接。现在的图床方案是上传到七牛。 b2:在这个界面，需要将图片 通过拖拽/资源管理器 的方式上传到七牛空间，并且按照当前的日期，指定路径格式，如：image/blog/170915/1.jpg； b3:返回链接地址； b4:能够管理已上传的图片(比如跳转到七牛的存储空间)； c:代码界面 c1:显示出本地代码，通过拖拽/资源管理器 的方式增减/编辑代码； c2:上传到GitHub; c3:打开GitHub、Coding； d:设置界面 d1:设置相关的路径，比如博客路径； d2:设置图床的配置文件； e:关于界面 e1:版本、版权信息； e2:主页跳转； e3:获取指定文件； f:其它 f1:修改应用图标 2.程序代码设计创建好Qt工程后，工程项目下会有四类文件：pro工程文件、头文件、源文件、界面文件。直接打开界面文件的mainwindow.ui,在上面拖动控件，实现界面的设计，再在源文件mainwindow.cpp编辑代码，完成功能的设计。 2.1 修改应用程序图标先做个简单的，修改应用程序的图标。图标显示有两个，一个是打开程序后，在程序左上角显示的图标，一个是在资源管理显示代表该程序的图标。 首先要准备个ico图片文件，然后把图片加入到工程项目中。在项目中，点击该工程，右键，添加新文件。选择Qt的Qt Resource File，名字写image，之后就会在工程项目生成一个资源文件：image.qrc。再选中image.qrc右键，添加现有文件，选择准备的hexoblogclient.ico图标，这样就将图标添加进了工程。 a:修改程序左上角图标修改源代码mainwindow.cpp，设置打开程序后左上角的图标和显示的文字： 123456789MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); this-&gt;setWindowIcon(QIcon(\"://image/hexoblogclient.ico\"));//设置图标 this-&gt;setWindowTitle(\"HexoBlogClient\");//设置名字&#125; b:修改应用程序图标在工程目录下创建一个appicon.rc文件，文件内容如下： 1IDI_ICON1 ICON DISCARDABLE &quot;image/hexoblogclient.ico&quot; 再在HexoBlogClient.pro文件添加如下代码：12RC_FILE += \\ appicon.rc 此时重新编译，应用程序图标也变成了ico图案。 2.2 本地界面 界面设计 使用tabWidget控件作为每个界面的容器； 使用treeView控件显示文章列表； 使用pushButton控件作为按键； 使用label控件显示当前文章总数和时间； 效果如下： 功能设计实例化一个QFileSystemModel类，筛选出*.md文件，指定文件路径，隐藏其它Column（也就是只显示文件名，不显示大小、日期等信息），然后以日期为标准，降序排列，最后将信息显示到treeView上。123456789101112131415QFileSystemModel *model1 = new QFileSystemModel();model1-&gt;setRootPath(\"E:/hceng blog/blog/source/_posts\");QStringList nameFilter1;nameFilter1 &lt;&lt; \"*.md\";model1-&gt;setNameFilterDisables(false);model1-&gt;setNameFilters(nameFilter1);//筛选文件类型ui-&gt;treeView1-&gt;setModel(model1);ui-&gt;treeView1-&gt;setRootIndex(model1-&gt;index(\"E:/hceng blog/blog/source/_posts\"));//指定路径ui-&gt;treeView1-&gt;setColumnHidden(1,true);//隐藏显示ui-&gt;treeView1-&gt;setColumnHidden(2,true);ui-&gt;treeView1-&gt;setColumnHidden(3,true);ui-&gt;treeView1-&gt;setSortingEnabled(true);//使能排序ui-&gt;treeView1-&gt;sortByColumn(3, Qt::DescendingOrder);//以时间作为依据排序；升序：Qt::AscendingOrder 降序：Qt::DescendingOrder 接下来是8个功能按键，很多是直接调用的bat脚本实现功能的。 首先是“新建”按钮，获取输入的标题，然后判断是否为空以及是否按下“确定”，这里直接创建了个新的Markdwon文件，然后写入基本的模板格式。12345678910111213141516171819202122232425262728293031323334353637383940void MainWindow::on_pushButton11_clicked()&#123; bool ok; QString text = QInputDialog::getText(this, tr(\"新建博客\"),tr(\"请输入标题:\"), QLineEdit::Normal,NULL, &amp;ok); if ( ok &amp;&amp; !text.isEmpty() ) &#123; /* --- title: \"格式\" date:2017-10-11 15:11:33 tags: - xx toc: true --- summary &lt;!-- more --&gt; */ QDateTime time = QDateTime::currentDateTime(); QString strTime = time.toString(\"yyyy-MM-dd hh:mm:ss \"); QFile namefile(\"E:\\\\hceng blog\\\\blog\\\\source\\\\_posts\\\\\"+text+\".md\"); //qDebug()&lt;&lt;strTime; if (!namefile.open(QIODevice::WriteOnly | QIODevice::Truncate)) return; QTextStream out(&amp;namefile); out&lt;&lt;\"---\"&lt;&lt;'\\n'&lt;&lt;\"title: \\\"\"+text+\"\\\"\"&lt;&lt;'\\n'&lt;&lt;\"date: \"&lt;&lt;strTime&lt;&lt;'\\n'; out&lt;&lt;\"tags: \"&lt;&lt;'\\n'&lt;&lt;\" - xx\"&lt;&lt;'\\n'&lt;&lt;\"toc: true\"&lt;&lt;'\\n'&lt;&lt;\"---\"&lt;&lt;'\\n'; out&lt;&lt;\"summary\"&lt;&lt;'\\n'&lt;&lt;\"&lt;!-- more --&gt;\"&lt;&lt;'\\n'; namefile.close(); &#125; else if(ok &amp;&amp; text.isEmpty() ) &#123; QMessageBox::information(this,\"信息\",\"请输入标题.\"); &#125; else &#123; return; &#125;&#125; 然后是“编辑”按键，先获得当前treeView选择的文件，再通过桌面服务使用默认程序打开该文件。12345678910void MainWindow::on_pushButton12_clicked()&#123; QString currentFilePath = model1-&gt;filePath(ui-&gt;treeView1-&gt;currentIndex()); if (!currentFilePath.isEmpty()) &#123; qDebug()&lt;&lt;\"file://\"+currentFilePath; QDesktopServices::openUrl(QUrl(\"file:///\"+currentFilePath)); //QDesktopServices::openUrl(QUrl(\"file:///E:/hceng blog/blog/source/_posts/测试文章.md\")); &#125;&#125; “清理&amp;重构”按键调用的脚本执行，等同执行的hexo c &amp; hexo g，最后使用QMessageBox显示截取的部分数据；调用cmd.exe的时候，在纠结使用startDetached还是start，前者是完全独立的启动，后者类似调用。执行脚本需要一定时间，通常都是数秒以上，使用start会出现未响应的情况，但如果使用startDetached可能会多次按该按键，导致启动多次，不知道什么时候完成。最后还是选的start。 123456789101112131415161718192021222324void MainWindow::on_pushButton13_clicked()&#123; ui-&gt;pushButton13-&gt;setText(\"请等待……\"); QTime dieTime = QTime::currentTime().addMSecs(100);//延时0.1s while( QTime::currentTime() &lt; dieTime ) QCoreApplication::processEvents(QEventLoop::AllEvents, 100); QProcess *process=new QProcess(this); //process-&gt;startDetached(\"cmd.exe\", QStringList() &lt;&lt; \"/c\" &lt;&lt; \"D:\\\\git\\\\qt\\\\HexoBlogClient\\\\bat\\\\clean_creat.bat\"); process-&gt;start(\"cmd.exe\", QStringList() &lt;&lt; \"/c\" &lt;&lt; \"D:\\\\git\\\\qt\\\\HexoBlogClient\\\\bat\\\\clean_creat.bat\"); process-&gt;waitForFinished(); ui-&gt;pushButton13-&gt;setText(\"清理&amp;&amp;重构\"); QString strTemp=QString::fromLocal8Bit(process-&gt;readAllStandardOutput()); //strTemp = strTemp.section('O',-1,-1); strTemp = strTemp.section('l',-2,-1); qDebug()&lt;&lt;strTemp; QMessageBox testMassage; testMassage.setText(strTemp); testMassage.exec();&#125; “预览/停止”按键也是调用的脚本的命令：hexo s，关闭的时候通过读取进程列表，关闭指定端口的进程。实测中，有一定概率误关掉整个浏览器。1234567891011121314151617181920212223242526void MainWindow::on_pushButton14_clicked()&#123; if(pushButton14Flag == 0) &#123; QProcess *process=new QProcess(this); process-&gt;start(\"cmd.exe\", QStringList() &lt;&lt; \"/c\" &lt;&lt; \"D:\\\\git\\\\qt\\\\HexoBlogClient\\\\bat\\\\view.bat\"); process-&gt;waitForFinished(); /* QTime dieTime = QTime::currentTime().addMSecs(1000);//延时1s while( QTime::currentTime() &lt; dieTime ) QCoreApplication::processEvents(QEventLoop::AllEvents, 100); */ QDesktopServices::openUrl(QUrl(\"http://localhost:4000/\")); ui-&gt;pushButton14-&gt;setText(\"停止\"); pushButton14Flag = 1; &#125; else &#123; QProcess *process=new QProcess(this); process-&gt;start(\"cmd.exe\", QStringList() &lt;&lt; \"/c\" &lt;&lt; \"D:\\\\git\\\\qt\\\\HexoBlogClient\\\\bat\\\\stop_view.bat\"); process-&gt;waitForFinished(); ui-&gt;pushButton14-&gt;setText(\"预览\"); pushButton14Flag = 0; &#125;&#125; “发布”也比较花时间，也是调用脚本的命令：hexo d1234567891011121314void MainWindow::on_pushButton15_clicked()&#123; ui-&gt;pushButton15-&gt;setText(\"请等待……\"); QTime dieTime = QTime::currentTime().addMSecs(100);//延时0.1s while( QTime::currentTime() &lt; dieTime ) QCoreApplication::processEvents(QEventLoop::AllEvents, 100); QProcess *process=new QProcess(this); process-&gt;start(\"cmd.exe\", QStringList() &lt;&lt; \"/c\" &lt;&lt; \"D:\\\\git\\\\qt\\\\HexoBlogClient\\\\bat\\\\deploy.bat\"); process-&gt;waitForFinished(); ui-&gt;pushButton15-&gt;setText(\"发布\");&#125; “备份”是将整个工程上传到Coding的私有库，原理还是git。1234567891011121314void MainWindow::on_pushButton16_clicked()&#123; ui-&gt;pushButton16-&gt;setText(\"请等待……\"); QTime dieTime = QTime::currentTime().addMSecs(100);//延时0.1s while( QTime::currentTime() &lt; dieTime ) QCoreApplication::processEvents(QEventLoop::AllEvents, 100); QProcess *process=new QProcess(this); process-&gt;start(\"cmd.exe\", QStringList() &lt;&lt; \"/c\" &lt;&lt; \"D:\\\\git\\\\qt\\\\HexoBlogClient\\\\bat\\\\bak.bat\"); process-&gt;waitForFinished(); ui-&gt;pushButton16-&gt;setText(\"备份\");&#125; “发布&amp;备份”是前面两个的结合。1234567891011121314void MainWindow::on_pushButton17_clicked()&#123; ui-&gt;pushButton17-&gt;setText(\"请等待……\"); QTime dieTime = QTime::currentTime().addMSecs(100);//延时0.1s while( QTime::currentTime() &lt; dieTime ) QCoreApplication::processEvents(QEventLoop::AllEvents, 100); QProcess *process=new QProcess(this); process-&gt;start(\"cmd.exe\", QStringList() &lt;&lt; \"/c\" &lt;&lt; \"D:\\\\git\\\\qt\\\\HexoBlogClient\\\\bat\\\\deploy_bak.bat\"); process-&gt;waitForFinished(); ui-&gt;pushButton17-&gt;setText(\"发布&amp;&amp;备份\");&#125; “访问”就仅仅是打开博客链接，不用再在浏览器里翻了。1234void MainWindow::on_pushButton18_clicked()&#123; QDesktopServices::openUrl(QUrl(\"https://hceng.cn/\"));&#125; 最下面的统计文件数量和显示当前时间，是个定时任务，每秒都刷新这两个label。文件数量是获取博客文章路径的fileInfoList,然后获得文件数量，再转换成字符类型追加到label中。1234//timeshowQTimer *timer = new QTimer(this);connect(timer,SIGNAL(timeout()),this,SLOT(timerUpdate()));timer-&gt;start(1000); 123456789101112131415161718void MainWindow::timerUpdate(void)&#123; QDateTime time = QDateTime::currentDateTime(); QString strTime = time.toString(\"yyyy-MM-dd dddd hh:mm:ss \"); ui-&gt;label1-&gt;setText(strTime); QDir *dir=new QDir(\"E:/hceng blog/blog/source/_posts\"); QStringList filter; filter&lt;&lt;\"*.md\"; dir-&gt;setNameFilters(filter); //QList&lt;QFileInfo&gt; *fileInfo=new QList&lt;QFileInfo&gt;(dir-&gt;entryInfoList(filter)); QFileInfoList fileInfoList=dir-&gt;entryInfoList(filter);//在qt中有typedef QList&lt;QFileInfo&gt; QFileInfoList;所以两者等价 QString fileCount = QString::number(fileInfoList.count(), 10); QString strCount = \"文章总数：\"; strCount.append(fileCount); ui-&gt;label2-&gt;setText(strCount);&#125; 2.3 图床界面2.4 代码界面2.5 设置界面2.6 关于界面3.计划最近有点忙/懒，图床部分，看了下，要研究下七牛的API，暂时没那个精力。试着用了下客户端，还是比较满意的，不用打开资源管理器和git-bash了，上传图片和代码，还是和原来一样，觉得不流畅，后面有时间，有精力了再研究。后面最想做的有两个： 实现配置文件的读取/写入； 获取服务器指定图片； 加上国庆，话说有半个月没摸驱动了，Qt暂停下，先玩玩驱动。目前只完成了第一个主界面，后面的几乎没做，如果有志同道合的朋友可以交流下，一起完成。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"QT","slug":"QT","permalink":"http://yoursite.com/tags/QT/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Photoshop基础2——工具","date":"2017-09-23T09:29:23.000Z","path":"2017/09/23/Photoshop基础2——工具/","text":"本文主要记录Photoshop相关理论基础第二部分：工具。 1.修饰工具可用于局部修复。 1.1 污点修复工具 污点修复画笔(去斑) 修复画笔(取代图章工具,色彩完好) 修补(无缝复制另外一块区域,亮度色彩融合最佳) 红眼(非常方便,大小图象都可适用) 1.2 图章工具 仿制图章：用得较少，一般用 修复画笔 代替； 图案图章：1.定义图章：选择区域→编辑→定义图案；2.生成图章：滤镜→图案生成器→选择区域→生成（不满意点击再次生成）;3.使用图章：填充图案，选择区域，CTRL+G或者使用油漆桶填充图案; 1.3 橡皮擦工具 背景橡皮擦：智能擦除背景颜色,效果类似抠图； 魔术橡皮擦：魔术棒+橡皮擦工具的使用； 1.4 模糊工具 模糊工具：选中区域变模糊； 锐化工具：非常谨慎的使用，非常容易出现杂色； 涂抹工具：效果不好，一般选择滤镜→液化实现效果； 1.5 减淡工具 减淡工具：提升亮度，减少颜色（改变肤色），类似滤色效果； 加深工具：降低亮度，加重颜色（显瘦）； 海棉工具：有加色和减色模式，色相不变，增加饱和度，减色相反； 2.绘画工具可用于局部修饰。 2.1 画笔工具画笔工具的核心概念:模式选择 模式可以分为6组： A组:正常 溶解 背后 清除 B组:变暗 正片叠低 颜色加深 线性加深 深色 C组:变亮 滤色 颜色减淡 线性减淡 浅色 注:b组和c组是数值对立的 D组:叠加 柔光 强光 亮光 线性光 点光 实色混合 注:都是光,变化不大,很微妙,有共同点 E组:差值 排除 减去 划分 注:两者是反值;负片效果 F组:色相 饱和度 颜色 明度 注:基于人眼的视觉效果HSB模式,多了一个颜色模式 模式解释 A组: 溶解：根据画笔硬度画出 扩散溶解效果，硬度越高溶解越少，硬度越低溶解越大（越虚）； 背后：后画的笔画是画在上一笔的背后,即下一层；表示被当住了画后面的；两次绘画不同颜色的画笔即可看出效果； 清除：类似橡皮擦工具； 背后的使用特点：1.使用背后的前提条件是 必须同一个图层之中存在透明区域（用魔术棒选中删了），否则无法显示，因为是在像素之后绘画；2.使用背后，可以很容易的在后面做出光晕等好看的效果，不会损害前面的象素； B组 vs C组: 变暗：以前景色为基础，前景色与画面中笔触的颜色作为背景色做对比，画面中比前景色亮的颜色都变成前景色,比前景色暗的颜色不发生变化;即以一种颜色作为整个画面最亮的色，降低了整个画面亮度； 变亮：与变暗相反，所有比前景色亮的都不变,与前景色暗的地方都变成前景色； 正片叠底：颜色加深，对色调进行修改。是RGB模式和CMYK模式中加色与减色的应用，这里对应CMYK的减色模式，即用RGB叠加，越加越暗，直到黑色； 滤色：颜色提亮，和正片叠底相反，对应加色模式，即用RGB颜色叠加，越加越亮，直到白色；混和技巧:加亮时用滤色，变暗时用正片叠底；滤色用黑色前景时无效果，正片叠底时用白色无效果（即不允许存在）;照片去黑色背景或白色背景时直接使用（在图层中）滤色或正片叠底；参考前面的：Photoshop基础1——色彩 颜色加深：查看每个通道中的颜色信息，增加对比度使基色变暗以反映混合色，如果与白色混合的话将不会产生变化，”颜色加深”模式创建的效果和“正片叠底”模式创建的效果比较类似; 颜色减淡：查看每个通道中的颜色信息，通过减小对比度使基色变亮以反映混合色，与黑色混合则不发生变化。除了指定在这个模式的层上边缘区域更尖锐，以及在这个模式下着色的笔划之外，“颜色减淡”模式类似于“滤色”模式创建的效果； 线性加深：查看每个通道中的颜色信息通过减小亮度使“基色”变暗以反映混合色，如果“混合色”与“基色”上的白色混合后将不会产生变化； 线性减淡：查看每个通道中的颜色信息通过增加亮度使“基色”变亮以反映混合色，如果“混合色”与“基色”上的黑色混合后将不会产生变化； 深色：比较混合色和基色的所有通道值的总和并显示值较小的颜色，即较深色的颜色。“深色”不会生成第三种颜色（可以通过“变暗”混合获得），因为它将从基色和混合色中选择最小的通道值来创建结果颜色； 浅色：和深色相反，显示较浅的颜色； D组: 叠加：亮度不变,颜色重叠； 柔光：屏蔽中性灰度,颜色取中间值； 线性光：光线不随距离减弱； 点光：光线随着距离逐渐减弱； E组: 差值：负片效果，使用画笔时直接转换为负片（所画为互补色=色环上对面的颜色）； 排除：也是负片效果,只是淡一些； F组: 色相：锁定前景色HSB模式中颜色的值，即H值，只涂抹颜色;与S、B无关； 饱和度：同上只锁定饱和度S； 亮度：同上只锁定亮度B； 颜色：给黑白片着色使用，亮度不变只改变颜色和饱和度，如果用 正常 的话会把亮度饱和也改变了（黑白图无色相，无饱和度）； 2.2 替换颜色工具比抽出更改更方便，选择相应的模式：色相、饱和度、明度、颜色，可以方便的替换颜色,不用担心边缘被更改； 2.3 历史记录画笔配合历史记录调板使用，做了特效后部分恢复，局部修饰；裁剪时部分无法使用历史绘画笔时，重新定义记录状态（把画笔位置放在裁切位置就可以用了）; 2.4 历史记录艺术画笔在恢复时增加笔触效果，菜单下面可以选择样式与模式，可以做出很有特色的艺术效果； 2.5 渐变工具有5种类型：线性渐变、径向渐变、锥性渐变、对称渐变、菱形渐变； 上面表示透明度，下面表示颜色。可以任意添加油漆桶，两个油漆桶之间的菱形表示过渡位置； 渐变编辑器里调节渐变类型时可以选择杂色渐变，同时可以选择限制色彩范围；填充时并且可以选择混合模式，如在背后模式中选择锥形渐变可以画出强烈的光照效果；油漆桶可以选择图案填充模式； 参考资料：Photoshop 用户指南——工具库 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"设计","slug":"设计","permalink":"http://yoursite.com/tags/设计/"},{"name":"Photoshop","slug":"Photoshop","permalink":"http://yoursite.com/tags/Photoshop/"}]},{"title":"Photoshop基础1——色彩","date":"2017-09-15T09:29:23.000Z","path":"2017/09/15/Photoshop基础1——色彩/","text":"本文主要记录Photoshop相关理论基础第一部分：色彩。 又开始折腾了，在驱动的世界稍微能喘上口气，就又闲不住了。最近兼职了当了下美工，又燃起了对设计的热情，抽空余时间，学下设计基础。 1.色彩模式色彩模式常用的有四种： ①HSB:基于人眼视觉的颜色模式；②RGB:基于光色的颜色模式，是加色模式，两者组合变亮；③CMYK:基于印刷颜料的颜色模式，是减色模式，两者组合变暗；④Lab:基于人对颜色的感觉，与设备无关，色域宽阔； （1） HSB： (色相H(Hue)：在0~360°的标准色环上，按照角度值标识。比如红是0°、橙色是30°等，黑白无色相; 饱和度S(Saturation)：是指颜色的强度或纯度。饱和度表示色相中彩色成分所占的比例，用从0%(灰色)~100%(完全饱和)的百分比来度量; 亮度B(Brightness)：是颜色的明暗程度，通常是从0(暗)~100%(亮)的百分比来度量的; （2）RGB： R(Red)：0~255阶,一共256阶色; G(Green)：0~255阶,一共256阶色; B(Blue)：0~255阶,一共256阶色;其中：白色：R G B:255 255 255；黑色：R G B:0 0 0； （3）CMYK： C(Cyan青色)：0~100%; M(Magenta品红色)：0~100%; Y(Yellow黄色)：0~100%; K(Key Plate黑墨印刷版)：0~100%;CMKK放在一起可以综合出其他的色彩，前3种都是0%的时候印刷成无色,即白色；都为100%的时候印不出纯黑色，工艺达不到，有杂质,所以加入K黑色用来印刷纯黑色; （4）Lab： L(Luminosity亮度)：0~100%; a：表示从洋红色至绿色的范围，+127~-128; b：表示从黄色至蓝色的范围，+127~-128;当a=0、b=0时显示灰色,同时L=100时为白色,L=0时为黑色; 在表达色彩范围上，最全的是Lab模式，其次是RGB模式，最窄的是CMYK模式。也就是说Lab模式所定义的色彩最多，且与光线及设备无关，并且处理速度与RGB模式同样快，比CMYK模式快数倍。因此，可放心大胆的在图像编辑中使用Lab模式，而且，Lab模式保证在转换成CMYK模式时色彩最少丢失或被替代。因此，从理论上讲最佳避免色彩损失的方法是：应用Lab模式编辑图像，再转换CMYK模式打印。 2.加色/减色模式在RGB模式中，如果RGB的值为（0,0,0），那么就是黑色，如果是（255,255,255）就是白色。这很容易理解，试想一下一个黑屋子里什么灯都不打开，就是漆黑一片；相反如果红灯、绿灯、蓝灯都开到最亮，那么屋子里就是一片明亮。 而在CMYK模式中，如果在印刷的时候，把CMYK的值设为（0,0,0,0），那么就等于什么颜料都没上，纸还是白色的；如果把油墨设为（100%,100%,100%,100%），所有颜料都浓浓地刷上一遍，印出来的就是黑色。由于颜色来自于光线，那么黑色自然就是什么颜色都没有，而白色则包含了很多种颜色。 因此，RGB模式被称之为加色模式，CMYK被被称之为减色模式。 之所以会有这两种模式，还是因为它们对应的颜色表现媒介的不同。在加色模式中，颜色是由光线直接照射产生的，所以只要有光线叠加，颜色就会越来越亮，最终成为白色。而减色模式中，颜色是通过颜料吸收光线来产生的，要表现一种颜色，就要想办法把光线中其他的颜色过滤掉，也就是减掉，如果什么颜料都不上，光线就被全部反射，看到的依然是白光。 那么加色模式和减色模式到底有什么用？ 简单来讲，加色模式就是使颜色变亮，减色模式使颜色变暗。 在PS中，经常用到的加色和减色工具分别是滤色和正片叠底。例如，想要去掉一张图片的黑色背景效果，就可以将图层混合模式设为滤色，相反，如果要去掉白色背景，则选择正片叠底。另外，也可以将画笔工具设为加色和减色属性，对图片进行局部的修饰。这样做的好处是，避免了做选区的大量工作，而且修饰起来比做选区要更加精准和美观。 3.分辨率PS中，分辨的单位有 像素/英寸 和 像素/厘米 ，一般默认使用前者。 一般显示器采用72DPI,印刷品采用300DPI。 分辨率越高画面放大越清晰，但是图像文件大小也越大；可以通过 重新采样 改变原始分辨率，当这种方式是通过算法来扩展像素，就目前来看，大多数情况都不太好。 重新采样的算法主要有：邻近、两次线性、两次立方。这三个算法参考周围的像素依次增多，因此理论上两次立方的效果是最好的。但当图片比较简单时，选择邻进，会让线条更加清晰，不发虚，相对效果更好。 参考资料：Photoshop 用户指南——颜色模式 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"设计","slug":"设计","permalink":"http://yoursite.com/tags/设计/"},{"name":"Photoshop","slug":"Photoshop","permalink":"http://yoursite.com/tags/Photoshop/"}]},{"title":"AM437x——I2C驱动","date":"2017-09-11T06:30:36.000Z","path":"2017/09/11/AM437x——I2C驱动/","text":"记录AM437x的I2C适配器驱动和I2C设备驱动，以及去除am437x EEPROM验证ID功能。 1.I2C驱动在Linux中，I2C驱动有I2C适配器驱动（就是SOC的I2C控制器驱动）和I2C设备驱动（就是I2C设备，比如AT24C256）。 本次写驱动的过程，先是利用内核自带的I2C适配器驱动写了I2C设备驱动，待I2C设备驱动验证好了，再写的I2C适配器驱动。因此记录的顺序也是先是I2C设备驱动，再是I2C适配器驱动。 2.去除am437x EEPROM验证ID功能前面裸机的对EEPROM随意的测试读写，改变了里面的一些数据。Ti发布的SDK需要在不更改代码的情况下运行在Ti不同的EVM上，所以Ti在代码中会添加对EVM板上EEPROM内部ID的判断。这就尴尬了，没人给我说过不能改啊 = = 。验证ID的数据被我改了，现在Uboot没法引导内核了。= = 没办法，要么改回EEPROM的数据，要么去除Uboot的验证，权衡后，选择了后者。通过查阅和测试，相关代码在：~/ti-processor-sdk-linux-am437x-evm-01.00.00.03/board-support/u-boot-2014.07+gitAUTOINC+fb6ab76dad-gfb6ab76/board/ti/am43xx/路径下的board.c和board.h。 修改原理是，屏蔽掉去读eeprom的数据，手动指定板子和版本信息。在read_eeprom()函数中,注释掉原来的验证，在后面的strncpy()函数中指定板子信息。修改后该部分代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * Read header information from EEPROM into global structure. */static int read_eeprom(struct am43xx_board_id *header)&#123;#if 0 /* Check if baseboard eeprom is available */ if (i2c_probe(CONFIG_SYS_I2C_EEPROM_ADDR)) &#123; printf(\"Could not probe the EEPROM at 0x%x\\n\", CONFIG_SYS_I2C_EEPROM_ADDR); return -ENODEV; &#125; /* read the eeprom using i2c */ if (i2c_read(CONFIG_SYS_I2C_EEPROM_ADDR, 0, 2, (uchar *)header, sizeof(struct am43xx_board_id))) &#123; printf(\"Could not read the EEPROM\\n\"); return -EIO; &#125; if (header-&gt;magic != 0xEE3355AA) &#123; /* * read the eeprom using i2c again, * but use only a 1 byte address */ if (i2c_read(CONFIG_SYS_I2C_EEPROM_ADDR, 0, 1, (uchar *)header, sizeof(struct am43xx_board_id))) &#123; printf(\"Could not read the EEPROM at 0x%x\\n\", CONFIG_SYS_I2C_EEPROM_ADDR); return -EIO; &#125; if (header-&gt;magic != 0xEE3355AA) &#123; printf(\"Incorrect magic number (0x%x) in EEPROM\\n\", header-&gt;magic); return -EINVAL; &#125; &#125;#endif //strncpy(am43xx_board_name, (char *)header-&gt;name, sizeof(header-&gt;name)); strncpy(am43xx_board_name, \"AM43__SK\", sizeof(header-&gt;name)); am43xx_board_name[sizeof(header-&gt;name)] = 0; //strncpy(am43xx_board_rev, (char *)header-&gt;version, sizeof(header-&gt;version)); strncpy(am43xx_board_rev, \"1.2\",sizeof(header-&gt;version)); am43xx_board_rev[sizeof(header-&gt;version)] = 0; return 0;&#125; 修改后，重新编译Uboot，重新下载，又能愉快启动了。 3.I2C设备驱动3.1 编写I2C设备驱动的四种方法在内核linux-3.14.43+gitAUTOINC+875c69b2c3-g875c69b\\Documentation\\i2c\\instantiating-devices里面介绍了How to instantiate I2C devices。 说明了I2C设备驱动有以下四种编写方式： Method 1: Method 1a: Declare the I2C devices by bus number Method 1b: Declare the I2C devices via devicetree Method 1c: Declare the I2C devices via ACPIMethod 2: Instantiate the devices explicitlyMethod 3: Probe an I2C bus for certain devicesMethod 4: Instantiate from user-space Method 1a中，先定义一个板载信息结构体i2c_board_info，然后通过i2c_register_board_info()注册板载信息。然后i2c_board_info就被放在了i2c_board_list链表中。 但调用i2c_ragister_adapter()时，会使用i2c_scan_static_board_info对i2c_board_list进行扫描，调用i2c_new_device()创建client。 该方式的i2c_scan_static_board_info在i2c_ragister_adapter()之前，不适合动态加载(insmod方式)。 Method 1b中，就是把资源信息，以设备树的方式提供，换汤不换药。 Method 1c中，ACPI不懂，跳过。 Method 2中，翻译的意思是 明确实例化设备。还是先定义一个板载信息结构体i2c_board_info，然后通过i2c_new_device()或i2c_new_probed_device()去创建client。这两个函数前者认为设备一定存在，根据i2c_board_info的地址创建设备。而i2c_new_probed_device()则会先检查i2c_board_info描述的地址设备是否真的存在，只有存在才会创建client。本次I2C设备驱动就是用的这种方式。 Method 3中，不需要事先确定适配器，内核不太推荐该方法，跳过。 Method 4，这个就NB了，直接从用户层创建I2C设备。但需要下个i2c-tools使用里面的头文件i2c-dev.h,才好在应用程序中，调用i2c_smbus_read_word_data进行访问。感觉统一了驱动，减少了驱动的工作量，但稍微加大了应用程序设计的工作量。这里我没使用，以后遇到了再说。从用户空间创建设备的方法： 1234//创建echo eeprom 0x50 &gt; /sys/bus/i2c/devices/i2c-03/new_device//删除# echo 0x50 &gt; /sys/bus/i2c/devices/i2c-0/new_device 3.2 采用Method 2编写驱动采用设备平台驱动模型编写。 首先分析at24cxx_dev.c，按照前面介绍的步骤:1.先定义一个板载信息结构体i2c_board_info：123static struct i2c_board_info at24cxx_info = &#123; I2C_BOARD_INFO(&quot;at24c256&quot;, 0x50),&#125;; 2.通过i2c_new_device()创建client：123456789101112static int at24cxx_dev_init(void)&#123; struct i2c_adapter *i2c_adap; printk(KERN_INFO&quot;%s OK.\\n&quot;,__func__); i2c_adap = i2c_get_adapter(0); at24cxx_client = i2c_new_device(i2c_adap, &amp;at24cxx_info); i2c_put_adapter(i2c_adap); return 0;&#125; 这里还通过i2c_get_adapter()获取了适配器0(AM437X的I2C控制器0)，然后调用i2c_put_adapter再将其挂起。现在I2C设备就有了。 再分析at24cxx_drv.c:1.分配/设置一个i2c_driver: 123456789static struct i2c_driver at24cxx_driver = &#123; .driver = &#123; .name = &quot;ti_i2c0&quot;, .owner = THIS_MODULE, &#125;, .probe = at24cxx_probe, .remove = at24cxx_remove, .id_table = at24cxx_id_table,&#125;; name无所谓，这里还有probe()和remove()函数，分别在模块加载和卸载时调用。这里的probe()加载，必须要id_table里面的设备名字与i2c_board_info相同才能加载。 2.注册i2c_driver:1i2c_add_driver(&amp;at24cxx_driver); 3.注册字符设备：待id_table里面的设备名字与i2c_board_info相同，调用probe()函数。probe()函数进行字符设备注册那一套操作。 3.1申请设备号：123456if(alloc_chrdev_region(&amp;devid, 0, TI_EEPROM_CNT, &quot;at24cxx&quot;) &lt; 0)&#123; printk(KERN_INFO&quot;%s ERROR.\\n&quot;,__func__); goto error;&#125;major = MAJOR(devid); 3.2绑定操作函数、创建类、创建设备：1234cdev_init(&amp;at24cxx_cdev, &amp;at24cxx_fops); cdev_add(&amp;at24cxx_cdev, devid, TI_EEPROM_CNT); at24cxx_cls = class_create(THIS_MODULE, &quot;ti_at24cxx&quot;);device_create(at24cxx_cls, NULL, MKDEV(major, 0), NULL, &quot;at24cxx&quot;); 4.释放资源：在卸载模块时，释放probe()申请的资源：1234567for(i=0;i&lt;TI_EEPROM_CNT;i++)&#123; device_destroy(at24cxx_cls, MKDEV(major, i)); &#125;class_destroy(at24cxx_cls);unregister_chrdev(major, &quot;at24cxx&quot;); 5.完善操作函数：这里只实现了EEPROM的随机读写。先说写EEPROM，前面裸机的时候，写EEPROM是先发送一个8位的设备地址和写命令(这个控制器自动的，不管)，然后是发送两个8位的数据地址，最后是一个8位要写的数据。因此，用户层传进来的的参数是地址和数据，需要分解成两个8位地址和数据再发送，一共三个数据。1234567891011if (copy_from_user(&amp;ker_buf, user_buf, count)) return -EFAULT;send[0] = ker_buf[0]&gt;&gt;8;send[1] = ker_buf[0];send[2] = ker_buf[1];if(i2c_master_send(at24cxx_client, send, 3)) return 2;else return -EIO; 再分析下写，裸机的时候对EEPROM写，需要先发送一个8位的设备地址和写命令(这个控制器自动的，不管)，再发送两个数据8位地址，再发送一个8位的设备地址和读命令(这个控制器自动的，也不管)，再读取8位数据。 因此，用户层传进来的是一个地址数据，需要分解成两个8位地址，发送出去，再接收一个8位数据。 1234567891011if (copy_from_user(&amp;addr, user_buf, count)) return -EFAULT;send[0] = addr&gt;&gt;8;send[1] = addr;i2c_master_send(at24cxx_client, send, 2);i2c_master_recv(at24cxx_client, &amp;data, 1);ret = copy_to_user(user_buf, &amp;data, 1); 最后看看应用程序app_at24cxx.c:读取EEPROM格式是./app_at24cxx r addr，写EEPROM格式是./app_at24cxx w addr val。1.先判断传入的参数：12345if ((argc != 3) &amp;&amp; (argc != 4))&#123; print_usage(argv[0]); return -1;&#125; 2.打开EEPROM设备：1fd = open(&quot;/dev/at24cxx&quot;, O_RDWR); 3.判断如果是读操作：123456if (strcmp(argv[1], &quot;r&quot;) == 0)&#123; buf[0] = strtoul(argv[2], NULL, 0); read(fd, buf, 1); printf(&quot;data: %c, %d, 0x%2x\\n&quot;, buf[0], buf[0], buf[0]);&#125; strcmp()比较字符串，strtoul()将字符串转换成整型。 4.判断如果是写操作：12345678910else if ((strcmp(argv[1], &quot;w&quot;) == 0) &amp;&amp; (argc == 4))&#123; buf[0] = strtoul(argv[2], NULL, 0); buf[1] = strtoul(argv[3], NULL, 0); if (write(fd, buf, 2) == 2) printf(&quot;write ok, addr = 0x%02x, data = 0x%02x\\n&quot;, buf[0], buf[1]); else printf(&quot;write err, addr = 0x%02x, data = 0x%02x\\n&quot;, buf[0], buf[1]);&#125; write()的写成功返回的是实际写入的字节数，这个靠驱动的写函数的返回值。 3.3 完整代码[at24cxx_dev.c]link123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/i2c.h&gt;#include &lt;linux/err.h&gt;#include &lt;linux/regmap.h&gt;#include &lt;linux/slab.h&gt;static struct i2c_board_info at24cxx_info = &#123; I2C_BOARD_INFO(\"at24c256\", 0x50),&#125;;static struct i2c_client *at24cxx_client;static int at24cxx_dev_init(void)&#123; struct i2c_adapter *i2c_adap; printk(KERN_INFO\"%s OK.\\n\",__func__); i2c_adap = i2c_get_adapter(0); at24cxx_client = i2c_new_device(i2c_adap, &amp;at24cxx_info); i2c_put_adapter(i2c_adap); return 0;&#125;static void at24cxx_dev_exit(void)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); i2c_unregister_device(at24cxx_client);&#125;module_init(at24cxx_dev_init);module_exit(at24cxx_dev_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am437x board i2c device to at24c256\");MODULE_ALIAS(\"platform:device tree:ti_i2c\");MODULE_VERSION(\"V1.0\"); [at24cxx_drv.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/i2c.h&gt;#include &lt;linux/err.h&gt;#include &lt;linux/regmap.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/fs.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/cdev.h&gt;#define TI_EEPROM_CNT 1static int major;static struct cdev at24cxx_cdev;static struct class *at24cxx_cls;static struct i2c_client *at24cxx_client;/* * 传入: buf[0] : addr * 输出: buf[0] : data */static ssize_t at24cxx_read(struct file * file, char __user *user_buf, size_t count, loff_t *off)&#123; unsigned char addr, data; char send[2]; int ret; if(count != 1)&#123; printk(KERN_INFO\"at24cxx_read count != 1.\\n\"); return 1; &#125; if (copy_from_user(&amp;addr, user_buf, count)) return -EFAULT; send[0] = addr&gt;&gt;8; send[1] = addr; i2c_master_send(at24cxx_client, send, 2); i2c_master_recv(at24cxx_client, &amp;data, 1); ret = copy_to_user(user_buf, &amp;data, 1); return 1;&#125;/* buf[0] : addr * buf[1] : data */static ssize_t at24cxx_write(struct file *file, const char __user *user_buf, size_t count, loff_t *off)&#123; unsigned char ker_buf[2]; char send[3]; printk(KERN_INFO\"%s OK.\\n\",__func__); if(count != 2)&#123; printk(KERN_INFO\"at24cxx_write count != 2.\\n\"); return 1; &#125; if (copy_from_user(&amp;ker_buf, user_buf, count)) return -EFAULT; //printk(\"ker_buf[0]= 0x%02x, ker_buf[1]= x%02x\\n\", ker_buf[0], ker_buf[1]); send[0] = ker_buf[0]&gt;&gt;8; send[1] = ker_buf[0]; send[2] = ker_buf[1]; if(i2c_master_send(at24cxx_client, send, 3)) return 2; else return -EIO;&#125;static struct file_operations at24cxx_fops = &#123; .owner = THIS_MODULE, .read = at24cxx_read, .write = at24cxx_write,&#125;;static int at24cxx_probe(struct i2c_client *client, const struct i2c_device_id *id)&#123; dev_t devid; at24cxx_client = client; printk(KERN_INFO\"%s OK.\\n\",__func__); //1.申请设备号 if(alloc_chrdev_region(&amp;devid, 0, TI_EEPROM_CNT, \"at24cxx\") &lt; 0) &#123; printk(KERN_INFO\"%s ERROR.\\n\",__func__); goto error; &#125; major = MAJOR(devid); //2.注册到系统中 cdev_init(&amp;at24cxx_cdev, &amp;at24cxx_fops); cdev_add(&amp;at24cxx_cdev, devid, TI_EEPROM_CNT); at24cxx_cls = class_create(THIS_MODULE, \"ti_at24cxx\"); device_create(at24cxx_cls, NULL, MKDEV(major, 0), NULL, \"at24cxx\"); error: unregister_chrdev_region(MKDEV(major, 0), TI_EEPROM_CNT); return 0;&#125;static int at24cxx_remove(struct i2c_client *client)&#123; unsigned int i; printk(KERN_INFO\"%s OK.\\n\",__func__); for(i=0;i&lt;TI_EEPROM_CNT;i++) &#123; device_destroy(at24cxx_cls, MKDEV(major, i)); &#125; class_destroy(at24cxx_cls); unregister_chrdev(major, \"at24cxx\"); return 0;&#125;static const struct i2c_device_id at24cxx_id_table[] = &#123; &#123; \"at24c256\", 0 &#125;, &#123;&#125;&#125;;/* 1. 分配/设置i2c_driver */static struct i2c_driver at24cxx_driver = &#123; .driver = &#123; .name = \"ti_i2c0\", .owner = THIS_MODULE, &#125;, .probe = at24cxx_probe, .remove = at24cxx_remove, .id_table = at24cxx_id_table,&#125;;static int at24cxx_drv_init(void)&#123; /* 2. 注册i2c_driver */ printk(KERN_INFO\"%s OK.\\n\",__func__); i2c_add_driver(&amp;at24cxx_driver); return 0;&#125;static void at24cxx_drv_exit(void)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); i2c_del_driver(&amp;at24cxx_driver);&#125;module_init(at24cxx_drv_init);module_exit(at24cxx_drv_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am437x board i2c drvice to at24c256\");MODULE_ALIAS(\"platform:device tree:ti_i2c\");MODULE_VERSION(\"V1.0\"); [app_at24cxx.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;/* * ./app_at24cxx r addr * ./app_at24cxx w addr val */void print_usage(char *file)&#123; printf(\"%s r addr\\n\", file); printf(\"%s w addr val\\n\", file);&#125;int main(int argc, char **argv)&#123; int fd; unsigned char buf[2]; int x; if ((argc != 3) &amp;&amp; (argc != 4)) &#123; print_usage(argv[0]); return -1; &#125; fd = open(\"/dev/at24cxx\", O_RDWR); if (fd &lt; 0) &#123; printf(\"can't open /dev/at24cxx\\n\"); return -1; &#125; if (strcmp(argv[1], \"r\") == 0) &#123; buf[0] = strtoul(argv[2], NULL, 0); read(fd, buf, 1); printf(\"data: %c, %d, 0x%2x\\n\", buf[0], buf[0], buf[0]); &#125; else if ((strcmp(argv[1], \"w\") == 0) &amp;&amp; (argc == 4)) &#123; buf[0] = strtoul(argv[2], NULL, 0); buf[1] = strtoul(argv[3], NULL, 0); if (write(fd, buf, 2) == 2) printf(\"write ok, addr = 0x%02x, data = 0x%02x\\n\", buf[0], buf[1]); else printf(\"write err, addr = 0x%02x, data = 0x%02x\\n\", buf[0], buf[1]); &#125; else &#123; print_usage(argv[0]); return -1; &#125; close(fd); return 0;&#125; 4.I2C适配器驱动下面开始比较好玩的I2C适配器驱动。去除内核的I2C适配器模块，删除设备树文件里相关的I2C资源信息。 4.1 编写I2C适配器驱动I2C适配器驱动采用最原始的方法编写。1.入口函数入口函数做了四件事情：硬件相关设置、注册中断、初始化等待队列、注册I2C适配器。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667static const struct i2c_algorithm am437x_i2c_algo = &#123; // .smbus_xfer = , .master_xfer = am437x_i2c_xfer, .functionality = am437x_i2c_func,&#125;;static struct i2c_adapter am437x_i2c_adapter = &#123; .name = &quot;i2c_adapter&quot;, .algo = &amp;am437x_i2c_algo,//i2c总线通信方法 .owner = THIS_MODULE,&#125;;static void i2c_init(void)&#123; printk(KERN_INFO&quot;%s OK.\\n&quot;,__func__); /*clk*/ PRCM_CM_WKUP_I2C0_CLKCTRL = ioremap(0x44DF2800+0x340, 0x04*1); *PRCM_CM_WKUP_I2C0_CLKCTRL |= (0x02&lt;&lt;0); PRCM_CM_WKUP_CLKSTCTRL = ioremap(0x44DF2800+0x300, 0x04*1); *PRCM_CM_WKUP_CLKSTCTRL |= (0x01&lt;&lt;14); PRCM_CM_PER_L4LS_CLKSTCTRL = ioremap(0x44DF8800+0x400, 0x04*1); *PRCM_CM_PER_L4LS_CLKSTCTRL |= (0x01&lt;&lt;27); /*GPIO:gpio3_5-&gt;I2C0_SDA;gpio3_6-&gt;I2C0_SCL*/ CTRL_CONF_I2C0_SDA = ioremap(0x44E10000+0x0988, 0x04*1); CTRL_CONF_I2C0_SCL = ioremap(0x44E10000+0x098C, 0x04*1); *CTRL_CONF_I2C0_SDA &amp;= ~(0x07&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;19); *CTRL_CONF_I2C0_SCL &amp;= ~(0x07&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;19); /*I2C0 set*/ I2C0 = ioremap(0x44E0B000, sizeof(struct am437x_i2c_regs)); I2C0-&gt;CON &amp;= ~(0x01&lt;&lt;15);//reset I2C0-&gt;SYSC &amp;= ~(0x01&lt;&lt;0);//Auto Idle disabled. I2C0-&gt;PSC = 3;//the module divided by (PSC + 1) -&gt; 48M/(3+1)=12M I2C0-&gt;SCLL = 63;//tLOW = (SCLL + 7) * ICLK time period I2C0-&gt;SCLH = 65;//tHIGH = (SCLH + 5) * ICLK time period //I2C0-&gt;SA = 0x50;//Slave address.x 1010 000 I2C0-&gt;CON |= (0x01&lt;&lt;15);//Module enabled &#125;static int i2c_bus_drv_init(void)&#123; printk(KERN_INFO&quot;%s OK.\\n&quot;,__func__); //硬件相关的设置 i2c_init(); if (request_irq(102, i2c_xfer_irq, 0, &quot;am437x-i2c&quot;, NULL)) return -EAGAIN; init_waitqueue_head(&amp;i2c_data.wait); i2c_add_adapter(&amp;am437x_i2c_adapter);//会在/sys/class/i2c-adapter下生成i2c-x return 0;&#125; 硬件设置部分，初始化了相关时钟，设置GPIO复用，设置了I2C0控制器的一些设置。这里设置直接用ioremap()映射寄存器进程操作，是很不对的，内核是个整体，相关之间有关联，理论上时钟部分内核已经封装好了，我现在只需要调用相关就行。但秉着先调通，再优化改进的思想，映射是最快，最方便的= =。同理GPIO的设置和中断号也是不规范的。 i2c_add_adapter()会调用i2c_register_adapter()注册适配器，自动完成字符设备注册那一套。绑定了结构体i2c_adapter，i2c_adapter里面有I2C总线通信方法i2c_algorithm。i2c_algorithm里面两个函数：.master_xfer = am437x_i2c_xfer,:传输函数；.functionality = am437x_i2c_func,:支持的协议； I2C适配器驱动的关键就是实现这两个函数。 2.出口函数与入口函数相反操作：1234567891011121314151617static void i2c_bus_drv_exit(void)&#123; printk(KERN_INFO&quot;%s OK.\\n&quot;,__func__); iounmap(CTRL_CONF_I2C0_SDA); iounmap(CTRL_CONF_I2C0_SCL); iounmap(PRCM_CM_WKUP_I2C0_CLKCTRL); iounmap(PRCM_CM_WKUP_CLKSTCTRL); iounmap(PRCM_CM_PER_L4LS_CLKSTCTRL); iounmap(I2C0); free_irq(102, NULL); i2c_del_adapter(&amp;am437x_i2c_adapter);&#125; 3.实现关键函数一：am437x_i2c_func()虽说是关键函数，但这个是送分题，返回支持协议即可。123456static u32 am437x_i2c_func(struct i2c_adapter *adap)&#123; printk(KERN_INFO&quot;%s OK.\\n&quot;,__func__); //用于返回总线支持的协议 return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_PROTOCOL_MANGLING;&#125; 4.实现关键函数二：am437x_i2c_xfer()先定义个传输数据的结构体：123456789struct am437x_i2c_xfer_data &#123; struct i2c_msg *msgs; uint32_t cur_rec; uint32_t cur_send; uint32_t reg_cnt; uint32_t err; wait_queue_head_t wait;&#125;;static struct am437x_i2c_xfer_data i2c_data; 里面包含了i2c_msg结构体、当前接收位置cur_rec、当前发送位置cur_send、CNT寄存器计数reg_cnt、状态标志err、唤醒队列wait； i2c_msg结构体比较重要，包含了从机地址，发送/接收标志、数据长度和数据指针。12345678struct i2c_msg &#123; __u16 addr; // 从机地址 __u16 flags; // 标志 #define I2C_M_TEN 0x0010 // 十位地址标志 #define I2C_M_RD 0x0001 // 接收数据标志 __u16 len; // 数据长度 __u8 *buf; // 数据指针 &#125;; 前面at24cxx_drv.c中调用发送i2c_master_send()和接收i2c_master_recv()时，就会调用这里的传输函数am437x_i2c_xfer()。先初始化相关变量：123456789i2c_data.msgs = msgs;i2c_data.cur_rec = 0;i2c_data.cur_send = 0;i2c_data.err = -ENODEV;I2C0-&gt;CNT = i2c_data.msgs-&gt;len;i2c_data.reg_cnt = I2C0-&gt;CNT;I2C0-&gt;SA = i2c_data.msgs-&gt;addr; 保存传入的i2c_msg，设置当前接收位置cur_rec和当前发送位置cur_send为0，赋值给I2C0-&gt;CNT寄存器传输长度，因为I2C0-&gt;CNT在后面不好把握什么时候会清零，再将I2C0-&gt;CNT赋值给reg_cnt,作为要传输数据的总长度。再将设备地址传给寄存器。 接着开始传输：123456789101112131415161718192021222324static void am437x_i2c_start(void)&#123; printk(KERN_INFO&quot;%s OK.\\n&quot;,__func__); I2C0-&gt;IRQSTS |= 0x7FFF; I2C0-&gt;IRQEN_CLR |= 0x7FFF; if(i2c_data.msgs-&gt;flags &amp; I2C_M_RD) //read &#123; I2C0-&gt;CON |= (0x01&lt;&lt;10 | (0x01&lt;&lt;15)); //MST=1 TRX=0 I2C0-&gt;CON &amp;= ~(0x01&lt;&lt;9); I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;3); &#125; else//write &#123; I2C0-&gt;CON |= (0x01&lt;&lt;9 | 0x01&lt;&lt;10 | 0x01&lt;&lt;15); //MST=1 TRX=1 I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;4); &#125; I2C0-&gt;CON |= (0x01&lt;&lt;0);&#125; 先清除所有中断，利用i2c_data.msgs-&gt;flags判断时读还是写，设置对应模式和对应中断，最后启动传输。 随后进入休眠，中断就会根据情况发送/接收数据，待满足 当前传输长度等于总传输长度时，唤醒该函数，完成本次传输。 5.中断函数前面am437x_i2c_start()中设置I2C0-&gt;CON |= (0x01&lt;&lt;0);后，AM437X的I2C控制器就会自动传输数据，等完成后，生成对应的标志位。但发生中断后，进入中断函数，先清除除 接收标志和发送标志 以外的中断（更好的方式保留ACK响应标志和bus空闲标志，这里简化，暂不管）。判断是接收完成还是发送完成，如果是接收完成：清除接收中断，保存I2C0-&gt;DATA数据，同时，当前接收标志i2c_data.cur_rec加1，直到 当前接收等于总传输，即可关闭中断，发送停止信号。如果是发送完成：清除发送中断，赋值I2C0-&gt;DATA数据，同时，当前接收标志i2c_data.cur_send加1，直到 当前发送等于总传输，即可关闭中断，发送停止信号。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static irqreturn_t i2c_xfer_irq(int irq, void *dev_id)&#123; unsigned int status = 0; printk(KERN_INFO&quot;%s OK.\\n&quot;,__func__); status = I2C0-&gt;IRQSTS; //I2C0-&gt;IRQSTS = (status &amp; (0x01&lt;&lt;1 |0x01&lt;&lt;3 | 0x01&lt;&lt;4)); I2C0-&gt;IRQSTS = (status &amp; (0x01&lt;&lt;3 | 0x01&lt;&lt;4)); if(status &amp; (0x01&lt;&lt;3))//receive &#123; //printk(KERN_INFO&quot;i2c receive.\\n&quot;); I2C0-&gt;IRQSTS |= (0x01&lt;&lt;3); i2c_data.msgs-&gt;buf[i2c_data.cur_rec] = I2C0-&gt;DATA; i2c_data.cur_rec++; if(i2c_data.cur_rec == i2c_data.reg_cnt) &#123; I2C0-&gt;IRQEN_CLR |= (0x01&lt;&lt;3); am437x_i2c_stop(1); &#125; &#125; if (status &amp; (0x01&lt;&lt;4))//send &#123; //printk(KERN_INFO&quot;i2c send.\\n&quot;); I2C0-&gt;IRQSTS |= (0x01&lt;&lt;4); I2C0-&gt;DATA = i2c_data.msgs-&gt;buf[i2c_data.cur_send]; i2c_data.cur_send++; if(i2c_data.cur_send == i2c_data.reg_cnt) &#123; I2C0-&gt;IRQEN_CLR |= (0x01&lt;&lt;4); am437x_i2c_stop(1); &#125; &#125; //判断是否有ack和bus空闲 I2C0-&gt;IRQSTS |= 0x7FFF; return IRQ_HANDLED;&#125; 在am437x_i2c_stop()里，除了要发送停止信号，还要唤醒队列。123456789101112static void am437x_i2c_stop(int err)&#123; printk(KERN_INFO&quot;%s OK.\\n&quot;,__func__); i2c_data.err = err; I2C0-&gt;CON |= (0x01&lt;&lt;1); //stop ndelay(50); /*唤醒*/ wake_up(&amp;i2c_data.wait);&#125; 这就完了，还是比较清晰的。 4.2 完整代码[i2c_bus_am437x.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/i2c.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/time.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/err.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/pm_runtime.h&gt;#include &lt;linux/clk.h&gt;#include &lt;linux/cpufreq.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/io.h&gt;#include &lt;asm/irq.h&gt;struct am437x_i2c_xfer_data &#123; struct i2c_msg *msgs; uint32_t cur_rec; uint32_t cur_send; uint32_t reg_cnt; uint32_t err; wait_queue_head_t wait;&#125;;static struct am437x_i2c_xfer_data i2c_data;static volatile unsigned long *CTRL_CONF_I2C0_SDA;static volatile unsigned long *CTRL_CONF_I2C0_SCL;static volatile unsigned long *PRCM_CM_WKUP_I2C0_CLKCTRL;static volatile unsigned long *PRCM_CM_WKUP_CLKSTCTRL;static volatile unsigned long *PRCM_CM_PER_L4LS_CLKSTCTRL;struct am437x_i2c_regs &#123; uint32_t REVNB_LO; //00h uint32_t REVNB_HI; //04h uint32_t RESERVED0[2]; //08h uint32_t SYSC; //10h uint32_t RESERVED1[4]; //14h uint32_t IRQSTS_RAW; //24h uint32_t IRQSTS; //28h uint32_t IRQEN_SET; //2ch uint32_t IRQEN_CLR; //30h uint32_t WE; //34h uint32_t DMARXEN_SET; //38h uint32_t DMATXEN_SET; //3ch uint32_t DMARXEN_CLR; //40h uint32_t DMATXEN_CLR; //44h uint32_t DMARXWAKE_EN; //48h uint32_t DMATXWAKE_EN; //4ch uint32_t RESERVED2[16]; //50h uint32_t SYSS; //90h uint32_t BUF; //94h uint32_t CNT; //98h uint32_t DATA; //9ch uint32_t RESERVED3; //a0h uint32_t CON; //a4h uint32_t OA; //a8h uint32_t SA; //ach uint32_t PSC; //b0h uint32_t SCLL; //b4h uint32_t SCLH; //b8h uint32_t SYSTEST; //bch uint32_t BUFSTAT; //c0h uint32_t OA1; //c4h uint32_t OA2; //c8h uint32_t OA3; //cch uint32_t ACTOA; //d0h&#125;;static volatile struct am437x_i2c_regs *I2C0;static void am437x_i2c_start(void)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); I2C0-&gt;IRQSTS |= 0x7FFF; I2C0-&gt;IRQEN_CLR |= 0x7FFF; if(i2c_data.msgs-&gt;flags &amp; I2C_M_RD) //read &#123; I2C0-&gt;CON |= (0x01&lt;&lt;10 | (0x01&lt;&lt;15)); //MST=1 TRX=0 I2C0-&gt;CON &amp;= ~(0x01&lt;&lt;9); I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;3); &#125; else//write &#123; I2C0-&gt;CON |= (0x01&lt;&lt;9 | 0x01&lt;&lt;10 | 0x01&lt;&lt;15); //MST=1 TRX=1 I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;4); &#125; I2C0-&gt;CON |= (0x01&lt;&lt;0);&#125;static void am437x_i2c_stop(int err)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); i2c_data.err = err; mdelay(2);//为了防止读EEPROM的时候，写操作后，马上就读操作，导致错误; I2C0-&gt;CON |= (0x01&lt;&lt;1); //stop ndelay(50);//等待停止信号发完 /*唤醒*/ wake_up(&amp;i2c_data.wait);&#125;static irqreturn_t i2c_xfer_irq(int irq, void *dev_id)&#123; unsigned int status = 0; printk(KERN_INFO\"%s OK.\\n\",__func__); status = I2C0-&gt;IRQSTS; //I2C0-&gt;IRQSTS = (status &amp; (0x01&lt;&lt;1 |0x01&lt;&lt;3 | 0x01&lt;&lt;4)); I2C0-&gt;IRQSTS = (status &amp; (0x01&lt;&lt;3 | 0x01&lt;&lt;4)); if(status &amp; (0x01&lt;&lt;3))//receive &#123; //printk(KERN_INFO\"i2c receive.\\n\"); I2C0-&gt;IRQSTS |= (0x01&lt;&lt;3); i2c_data.msgs-&gt;buf[i2c_data.cur_rec] = I2C0-&gt;DATA; i2c_data.cur_rec++; if(i2c_data.cur_rec == i2c_data.reg_cnt) &#123; I2C0-&gt;IRQEN_CLR |= (0x01&lt;&lt;3); am437x_i2c_stop(1); &#125; &#125; if (status &amp; (0x01&lt;&lt;4))//send &#123; //printk(KERN_INFO\"i2c send.\\n\"); I2C0-&gt;IRQSTS |= (0x01&lt;&lt;4); I2C0-&gt;DATA = i2c_data.msgs-&gt;buf[i2c_data.cur_send]; i2c_data.cur_send++; if(i2c_data.cur_send == i2c_data.reg_cnt) &#123; I2C0-&gt;IRQEN_CLR |= (0x01&lt;&lt;4); am437x_i2c_stop(1); &#125; &#125; //判断是否有ack和bus空闲 I2C0-&gt;IRQSTS |= 0x7FFF; return IRQ_HANDLED;&#125;static int am437x_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)&#123; //用于实现I2C协议，将i2c_msg消息传给i2c设备 unsigned long timeout; printk(KERN_INFO\"%s OK.\\n\",__func__); //把num个i2c_msg的I2C数据发送出去/读进来 i2c_data.msgs = msgs; i2c_data.cur_rec = 0; i2c_data.cur_send = 0; i2c_data.err = -ENODEV; I2C0-&gt;CNT = i2c_data.msgs-&gt;len; i2c_data.reg_cnt = I2C0-&gt;CNT; I2C0-&gt;SA = i2c_data.msgs-&gt;addr; am437x_i2c_start(); /*休眠*/ if(i2c_data.msgs-&gt;flags &amp; I2C_M_RD) //读 &#123; timeout = wait_event_timeout(i2c_data.wait,(i2c_data.cur_rec == i2c_data.reg_cnt), HZ * 5);//5S &#125; else &#123; timeout = wait_event_timeout(i2c_data.wait, (i2c_data.cur_send == i2c_data.reg_cnt), HZ * 5);//5S &#125; if(0 == timeout) &#123; printk(\"am437x i2c timeout.\\n\"); return -ETIMEDOUT; &#125; else &#123; return i2c_data.err; &#125;&#125;static u32 am437x_i2c_func(struct i2c_adapter *adap)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); //用于返回总线支持的协议 return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_PROTOCOL_MANGLING;&#125;static const struct i2c_algorithm am437x_i2c_algo = &#123; // .smbus_xfer = , .master_xfer = am437x_i2c_xfer, .functionality = am437x_i2c_func,&#125;;static struct i2c_adapter am437x_i2c_adapter = &#123; .name = \"i2c_adapter\", .algo = &amp;am437x_i2c_algo,//i2c总线通信方法 .owner = THIS_MODULE,&#125;; static void i2c_init(void)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); /*clk*/ PRCM_CM_WKUP_I2C0_CLKCTRL = ioremap(0x44DF2800+0x340, 0x04*1); *PRCM_CM_WKUP_I2C0_CLKCTRL |= (0x02&lt;&lt;0); PRCM_CM_WKUP_CLKSTCTRL = ioremap(0x44DF2800+0x300, 0x04*1); *PRCM_CM_WKUP_CLKSTCTRL |= (0x01&lt;&lt;14); PRCM_CM_PER_L4LS_CLKSTCTRL = ioremap(0x44DF8800+0x400, 0x04*1); *PRCM_CM_PER_L4LS_CLKSTCTRL |= (0x01&lt;&lt;27); /*GPIO:gpio3_5-&gt;I2C0_SDA;gpio3_6-&gt;I2C0_SCL*/ CTRL_CONF_I2C0_SDA = ioremap(0x44E10000+0x0988, 0x04*1); CTRL_CONF_I2C0_SCL = ioremap(0x44E10000+0x098C, 0x04*1); *CTRL_CONF_I2C0_SDA &amp;= ~(0x07&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;19); *CTRL_CONF_I2C0_SCL &amp;= ~(0x07&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;19); /*I2C0 set*/ I2C0 = ioremap(0x44E0B000, sizeof(struct am437x_i2c_regs)); I2C0-&gt;CON &amp;= ~(0x01&lt;&lt;15);//reset I2C0-&gt;SYSC &amp;= ~(0x01&lt;&lt;0);//Auto Idle disabled. I2C0-&gt;PSC = 3;//the module divided by (PSC + 1) -&gt; 48M/(3+1)=12M I2C0-&gt;SCLL = 63;//tLOW = (SCLL + 7) * ICLK time period I2C0-&gt;SCLH = 65;//tHIGH = (SCLH + 5) * ICLK time period //I2C0-&gt;SA = 0x50;//Slave address.x 1010 000 I2C0-&gt;CON |= (0x01&lt;&lt;15);//Module enabled &#125;static int i2c_bus_drv_init(void)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); //硬件相关的设置 i2c_init(); if (request_irq(102, i2c_xfer_irq, 0, \"am437x-i2c\", NULL)) return -EAGAIN; init_waitqueue_head(&amp;i2c_data.wait); i2c_add_adapter(&amp;am437x_i2c_adapter);//会在/sys/class/i2c-adapter下生成i2c-x return 0;&#125;static void i2c_bus_drv_exit(void)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); iounmap(CTRL_CONF_I2C0_SDA); iounmap(CTRL_CONF_I2C0_SCL); iounmap(PRCM_CM_WKUP_I2C0_CLKCTRL); iounmap(PRCM_CM_WKUP_CLKSTCTRL); iounmap(PRCM_CM_PER_L4LS_CLKSTCTRL); iounmap(I2C0); free_irq(102, NULL); i2c_del_adapter(&amp;am437x_i2c_adapter);&#125;module_init(i2c_bus_drv_init);module_exit(i2c_bus_drv_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am437x board i2c bus drvice.\");MODULE_ALIAS(\"ti_i2c\");MODULE_VERSION(\"V2.0\"); 5.测试结果加载i2c0总线驱动，再加载at24cxx设备驱动，最后运行应用程序。写1地址1，2地址2，3地址3，4地址4； 再读取1地址数据，2地址数据，3地址数据，4地址数据。 再看下逻辑分析仪效果：向地址0x02写入数据2：向地址0x02读出数据2：（PS:图片经过处理，让其在一张图上显示，因此时间标识有误。） 6.心得本次I2C适配器驱动，算是第一次写一个较复杂的驱动，目的是先写通，其次才是优化，因此存在以下一些问题：1.没有使用系统提供的时钟、GPIO配置等函数，全是自己映射；2.中断没有对总线空闲、没有ack进行判断；3.有些函数返回值没有处理； 收获：1.先调通再优化，现在调通了，优化等下次有机会在优化；2.调不动的时候，拿逻辑分析仪抓，再对照标准波形，一找一个准； 在写博客的时候，发现个BUG：printk()打印调试的时候，一切正常。在关闭printk()打印后，先对EEPROM写操作，再去读操作，发现怎么都是255。这种情况，多半是哪里延时时序问题。用逻辑分析仪抓波形，一个个printk()的关，最终发现问题在am437x_i2c_stop()。波形如下：可以看到地址发错了，加上一个2ms的延时后，即正常。 I2C驱动完了，下一个计划，LCD驱动。😀 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"AM437X","slug":"AM437X","permalink":"http://yoursite.com/tags/AM437X/"},{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"}]},{"title":"AM437x——I2C裸机","date":"2017-08-28T06:12:26.000Z","path":"2017/08/28/AM437x——I2C裸机/","text":"记录AM437x的I2C裸机调试，包含GPIO模拟和寄存器控制。 0.I2C协议关键点0.1 I2C协议想象有两个设备，他们之间要传输数据。发数据的叫主设备，接收数据的叫从设备。两个设备之间，只有两根线。一根线得作为时钟信号线，这样两个设备才能统一一个信号标准，另外一个自然只有作为信号线传输数据。 主设备要发送数据前，得发出一个特殊的信号，告诉从设备，这个信号就是开始信号。同理，发送完后，有个特殊的结束信号。以及从机在接收到数据后，给个响应信号表示自己收到了。 开始信号s：SCL为高，SDA由高变低，开始传输数据结束信号p：SCL为高，SDA由低变高，结束传输数据响应信号a：接收器在收到8位数据后，在第9个时钟周期，拉低SDA电平。SDA的信号，只能在SCL为低的时候发生变化。 如图， SDA和SCL开始都为高。然后SDA拉低，表示开始信号。 在接下来的8个时间周期里，主机控制SDA的高低，发出一个 包含从机地址 和 是读操作还是写操作 的数据。第9个时钟周期，主设备拉高后释放掉SDA，再去读取它。从设备应该拉低SDA，给出响应信号。 再接下来的8个时间周期里，主机控制SDA的高低，传达数据。从机就读取电平高低，得到数据。第9个时钟周期，从设备给主设备一个响应信号。 最后，主机给个停止信号，表示传输结束。 0.2 EEPROM以CAT24C256这个EEPROM作为从设备为例。 先看看CAT24C256的引脚有哪些：SCL和SDA，时钟和数据。A0,A1和A2，用来表示从设备的地址，在硬件电路上，设置这3个引脚的值。WP，写保护引脚。高电平的时候写保护，因此在写EEPROM的时候得将该引脚置低。 再看看，前面说的 “一个 包含从机地址 和 是读操作还是写操作 的数据”：可以看到前4位固定为”1010”，然后是3位地址，最后位表示是读操作还是写操作。 写操作的时序先来个开始信号，然后是从机地址(写)，然后是要写地址的高8位，再是低8位，再是要写的8位数据，最后是停止信号。每次传输的后面都得有个响应信号。 读操作的时序先来个开始信号，然后是从机地址(写)，然后是要写地址的高8位，再是低8位。再来个开始信号，然后是从机地址(读)，获取8位数据，最后是停止信号。每次传输的后面都得有个响应信号，但如果是最后一次接收数据可不要。 1.GPIO模拟版本1.1硬件结构TI EVM开发板的EEPROM部分电路图： 米尔科技开发板的EEPROM部分电路图： 两个板子都是用的I2C0，器件地址都是000，唯一不同的是米尔的板子用了EMU0引脚控制EEPROM的写保护。后面以米尔板子为例。这三个引脚分别是： I2C0_SDA-&gt;gpio3_5;I2C0_SCL-&gt;gpio3_6; WP-&gt;gpio3_7; 1.2相关函数 GPIO相关 1.启用GPIO3时钟，引脚控制默认为GPIO，再设置为输出，拉高引脚，做好准备；123456789101112void i2c_init(void)&#123; PRCM_CM_PER_GPIO3_CLKCTRL |= (0x02&lt;&lt;0); //gpio3_5-&gt;I2C0_SDA;gpio3_6-&gt;I2C0_SCL;gpio3_7-&gt;WP //CTRL_CONF_I2C0_SDA ;//GPIO模式I2C，默认配置即可 //CTRL_CONF_I2C0_SCL ;//GPIO模式I2C，默认配置即可 GPIO3-&gt;OE &amp;= ~(0x01&lt;&lt;7 | 0x01&lt;&lt;6 | 0x01&lt;&lt;5);//输出 GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;7 | 0x01&lt;&lt;6 | 0x01&lt;&lt;5);//拉高&#125; 2.封装好SDA和SCL的输出高低电平函数，以及获取SDA引脚数据函数，最后还有使能写保护引脚函数；1234567891011121314151617181920212223242526272829303132333435363738static void SDA(char x)&#123; GPIO3-&gt;OE &amp;= ~(0x01&lt;&lt;5); if(x) &#123; GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;5); &#125; else &#123; GPIO3-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;5); &#125; &#125;static void SCL(char x)&#123; GPIO3-&gt;OE &amp;= ~(0x01&lt;&lt;6); if(x) &#123; GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;6); &#125; else &#123; GPIO3-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;6); &#125; &#125;static char GET_SDA(void)&#123; GPIO3-&gt;OE |= (0x01&lt;&lt;5); return (GPIO3-&gt;DATAIN &amp; (0x01&lt;&lt;5)?1:0);&#125;void eeprom_write_protect(char x)&#123; if(x) GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;7); else GPIO3-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;7);&#125; I2C协议相关1.三个信号函数：开始信号、停止信号、响应信号(判断是否收到从设备的响应信号)。理论上可以通过调节延时的长短，改变传输速度。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static void i2c_delay(volatile int time)&#123; time = time*1; for (; time &gt; 0; time--);&#125;static void i2c_start(void)&#123; SCL(1); i2c_delay(1); SDA(1); i2c_delay(1); SDA(0); i2c_delay(1); SCL(0); i2c_delay(1);&#125;static void i2c_stop(void)&#123; SDA(0); i2c_delay(1); SCL(1); i2c_delay(1); SDA(1); i2c_delay(1);&#125;static int i2c_ack(void)&#123; int pin_val; SCL(0); i2c_delay(1); SDA(1); i2c_delay(1); //实测中，am437x引脚由输出设置为输入的时候，会有一个高电平 //因此，趁现在SCL为低，先设置为输入 GET_SDA(); SCL(1); i2c_delay(1); pin_val = GET_SDA(); i2c_delay(1); SCL(0); i2c_delay(1); return pin_val;&#125; 2.I2C的读写函数写就是在8个时钟周期里，SCL低的时候，改变SDA，SCL高的时候，稳定SDA，从而发出8位数据。写就是在8个时钟周期里，SCL低的时候，不读引脚，SCL高的时候，读引脚，从而得到8位数据。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void eeprom_write(unsigned char addr, unsigned char data)&#123; eeprom_write_protect(0); i2c_start(); i2c_write(0xA0); while(i2c_ack()); i2c_write(addr&gt;&gt;8); while(i2c_ack()); i2c_write(addr); while(i2c_ack()); i2c_write(data); while(i2c_ack()); i2c_stop(); eeprom_write_protect(1);&#125;unsigned char eeprom_read(unsigned char addr)&#123; unsigned char data = 0; eeprom_write_protect(0); i2c_start(); i2c_write(0xA0); while(i2c_ack()); i2c_write(addr&gt;&gt;8); while(i2c_ack()); i2c_write(addr); while(i2c_ack()); i2c_stop(); i2c_delay(10); i2c_start(); i2c_write(0xA1); while(i2c_ack()); data = i2c_read(); i2c_stop(); eeprom_write_protect(1); return data;&#125; EEPROM相关写操作：先关闭写保护，发出开始信号，发出从机地址(写)，发出高地址、低地址，发出数据，发出停止信号和打开写保护。读操作：先关闭写保护，发出开始信号，发出从机地址(写)，发出高地址、低地址。再发出开始信号，发出从机地址(写读)，读取数据，发出停止信号和打开写保护。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void eeprom_write(unsigned char addr, unsigned char data)&#123; eeprom_write_protect(0); i2c_start(); i2c_write(0xA0); while(i2c_ack()); i2c_write(addr&gt;&gt;8); while(i2c_ack()); i2c_write(addr); while(i2c_ack()); i2c_write(data); while(i2c_ack()); i2c_stop(); eeprom_write_protect(1);&#125;unsigned char eeprom_read(unsigned char addr)&#123; unsigned char data = 0; eeprom_write_protect(0); i2c_start(); i2c_write(0xA0); while(i2c_ack()); i2c_write(addr&gt;&gt;8); while(i2c_ack()); i2c_write(addr); while(i2c_ack()); i2c_stop(); i2c_delay(10); i2c_start(); i2c_write(0xA1); while(i2c_ack()); data = i2c_read(); i2c_stop(); eeprom_write_protect(1); return data;&#125; 1.3测试效果 串口打印： 向0x01地址写数据2： 读0x01地址数据为2： 2.I2C寄存器版本2.1硬件结构同上。 2.2相关函数 初始化相关1.初始化相关的时钟和配置复用功能； 12345678910111213141516static void i2c_gpio_init(void)&#123; PRCM_CM_WKUP_I2C0_CLKCTRL |= (0x02&lt;&lt;0); PRCM_CM_WKUP_CLKSTCTRL |= (0x01&lt;&lt;14); PRCM_CM_PER_L4LS_CLKSTCTRL|= (0x01&lt;&lt;27); PRCM_CM_PER_GPIO3_CLKCTRL |= (0x02&lt;&lt;0); //gpio3_5-&gt;I2C0_SDA;gpio3_6-&gt;I2C0_SCL;gpio3_7-&gt;WP CTRL_CONF_I2C0_SDA &amp;= ~(0x07&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;19); CTRL_CONF_I2C0_SCL &amp;= ~(0x07&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;19); //CTRL_CONF_EMU0 GPIO3-&gt;OE &amp;= ~(0x01&lt;&lt;7); GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;7);&#125; 2.初始化I2C0，注册中断；注意这里的从机地址不含最后的读写操作位。 123456789101112131415161718192021void i2c_init(void)&#123; i2c_gpio_init(); register_irq(IRQ_I2C0, i2c0_irq); interrupt_init(IRQ_I2C0); I2C0-&gt;CON &amp;= ~(0x01&lt;&lt;15);//reset I2C0-&gt;SYSC &amp;= ~(0x01&lt;&lt;0);//Auto Idle disabled. I2C0-&gt;PSC = 3;//the module divided by (PSC + 1) -&gt; 48M/(3+1)=12M I2C0-&gt;SCLL = 63;//tLOW = (SCLL + 7) * ICLK time period I2C0-&gt;SCLH = 65;//tHIGH = (SCLH + 5) * ICLK time period I2C0-&gt;SA = 0x50;//Slave address.1010 000 I2C0-&gt;CON |= (0x01&lt;&lt;15);//Module enabled &#125; 中断处理函数中断处理函数是硬件I2C的核心，根据中断状态标志位去进行相应的读或写操作。 12345678910111213141516171819202122232425262728293031323334void i2c0_irq(void)&#123; unsigned int status = 0; status = I2C0-&gt;IRQSTS; I2C0-&gt;IRQSTS = (status &amp; (0x01&lt;&lt;3 | 0x01&lt;&lt;4)); if(status &amp; (0x01&lt;&lt;3))//receive &#123; I2C0-&gt;IRQSTS |= (0x01&lt;&lt;3); if(r_count == num) &#123; I2C0-&gt;IRQEN_CLR |= (0x01&lt;&lt;3); I2C0-&gt;CON |= (0x01&lt;&lt;1);//stop &#125; else &#123; data_from_slave[r_count++] = (unsigned char)I2C0-&gt;DATA; &#125; &#125; if (status &amp; (0x01&lt;&lt;4))//send &#123; I2C0-&gt;DATA = data_to_slave[t_count++]; I2C0-&gt;IRQSTS |= (0x01&lt;&lt;4); if(t_count == num) &#123; I2C0-&gt;IRQEN_CLR |= (0x01&lt;&lt;4); &#125; &#125;&#125; EEPROM相关写操作：去写保护，分解地址高低位，设置传输数据的位数(地址是两位+数据一位)，清除中断，设置为主机发送模式，使能发送中断，开始传输，直到地址数据传完，开启写保护。读操作：去写保护，分解地址高低位，设置传输数据的位数(地址是两位)，清除中断，设置为主机发送模式，使能发送中断，开始传输，直到地址数据传完。再设置传输位（接收数据一位），清除中断，设置位主机接收模式，开始传输，直至传输完成，开启写保护。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687void eeprom_write(unsigned char addr, unsigned char data)&#123; eeprom_write_protect(0); data_to_slave[0] = addr&gt;&gt;8; data_to_slave[1] = (addr &amp; 0xFF); data_to_slave[2] = data; t_count = 0; I2C0-&gt;CNT = 0x03; num = I2C0-&gt;CNT; I2C0-&gt;IRQSTS |= 0x7FFF; I2C0-&gt;IRQEN_CLR |= 0x7FFF; I2C0-&gt;CON |= (0x01&lt;&lt;9 | 0x01&lt;&lt;10 | 0x01&lt;&lt;15); //MST=1 TRX=1 I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;4); I2C0-&gt;CON |= (0x01&lt;&lt;0); while(i2c_master_bus_busy() == 0); while(t_count != num); I2C0-&gt;CON |= (0x01&lt;&lt;1); //stop eeprom_write_protect(1);&#125;unsigned char eeprom_read(unsigned char addr)&#123; unsigned char data = 0; eeprom_write_protect(0); data_to_slave[0] = addr&gt;&gt;8; data_to_slave[1] = (addr &amp; 0xFF); t_count = 0; r_count = 0; I2C0-&gt;CNT = 0x02; num = I2C0-&gt;CNT; I2C0-&gt;IRQSTS |= 0x7FFF; I2C0-&gt;IRQEN_CLR |= 0x6FFF; I2C0-&gt;CON |= (0x01&lt;&lt;9 | 0x01&lt;&lt;10 | 0x01&lt;&lt;15); //MST=1 TRX=1 I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;4); I2C0-&gt;CON |= (0x01&lt;&lt;0); while(i2c_master_bus_busy() == 0); while(t_count != num); while(!(I2C0-&gt;IRQSTS_RAW &amp; (0x01&lt;&lt;2)));//----------------------------------------------------------------// I2C0-&gt;CNT = 0x01; num = I2C0-&gt;CNT; I2C0-&gt;IRQSTS |= 0x7FFF; I2C0-&gt;IRQEN_CLR |= 0x6FFF; I2C0-&gt;CON |= (0x01&lt;&lt;10 | (0x01&lt;&lt;15)); I2C0-&gt;CON &amp;= ~(0x01&lt;&lt;9); I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;3 | 0x01&lt;&lt;8); I2C0-&gt;CON |= (0x01&lt;&lt;0); while(i2c_master_bus_busy() == 0); while(r_count != num); data = data_from_slave[0]; eeprom_write_protect(1); return data;&#125; 2.3测试效果 向0x01地址写数据2： 读0x01地址数据为2： 3.完整代码[main.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/************************************************************************* &gt; File Name: main.c &gt; Author: hceng &gt; Description: AM437X裸机i2c &gt; Created Time: 20170815*************************************************************************/#include \"AM437X/AM437X_SOC.h\"#include \"led.h\"#include \"delay.h\"#include \"uart.h\"#include \"printf.h\"#include \"key.h\"#include \"clkout.h\"#include \"int.h\"#include \"timer.h\"#include \"i2c.h\"int main()&#123; unsigned int i; uart_init(); gic_init(); timer2_init(); i2c_init(); printf(\"init ok.\\n\\r\"); //write eeprom. for(i=0; i&lt;5; i++) &#123; eeprom_write(i,2*i); delay_ms(4);//Must be delayed more than 4ms. &#125; delay_ms(10); //read eeprom. for(i=0; i&lt;5; i++) &#123; printf(\"read_data%d = %d\\n\\r\",i, eeprom_read(i)); delay_ms(4); &#125; while(1) &#123; &#125; return 0;&#125; [i2c.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461#include \"AM437X/AM437X_SOC.h\"#include \"i2c.h\"#include \"uart.h\"#include \"printf.h\"#include \"int.h\" #include \"delay.h\" #ifdef GPIO_I2Cstatic void i2c_delay(volatile int time)&#123; time = time*1; for (; time &gt; 0; time--);&#125;static void SDA(char x)&#123; GPIO3-&gt;OE &amp;= ~(0x01&lt;&lt;5); if(x) &#123; GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;5); &#125; else &#123; GPIO3-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;5); &#125; &#125;static void SCL(char x)&#123; GPIO3-&gt;OE &amp;= ~(0x01&lt;&lt;6); if(x) &#123; GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;6); &#125; else &#123; GPIO3-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;6); &#125; &#125;static char GET_SDA(void)&#123; GPIO3-&gt;OE |= (0x01&lt;&lt;5); return (GPIO3-&gt;DATAIN &amp; (0x01&lt;&lt;5)?1:0);&#125;void i2c_init(void)&#123; PRCM_CM_PER_GPIO3_CLKCTRL |= (0x02&lt;&lt;0); //gpio3_5-&gt;I2C0_SDA;gpio3_6-&gt;I2C0_SCL;gpio3_7-&gt;WP //CTRL_CONF_I2C0_SDA ;//GPIO模式I2C，默认配置即可 //CTRL_CONF_I2C0_SCL ;//GPIO模式I2C，默认配置即可 GPIO3-&gt;OE &amp;= ~(0x01&lt;&lt;7 | 0x01&lt;&lt;6 | 0x01&lt;&lt;5);//输出 GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;7 | 0x01&lt;&lt;6 | 0x01&lt;&lt;5);//拉高&#125;static void i2c_start(void)&#123; SCL(1); i2c_delay(1); SDA(1); i2c_delay(1); SDA(0); i2c_delay(1); SCL(0); i2c_delay(1);&#125;static void i2c_stop(void)&#123; SDA(0); i2c_delay(1); SCL(1); i2c_delay(1); SDA(1); i2c_delay(1);&#125;static int i2c_ack(void)&#123; int pin_val; SCL(0); i2c_delay(1); SDA(1); i2c_delay(1); //实测中，am437x引脚由输出设置为输入的时候，会有一个高电平 //因此，趁现在SCL为低，先设置为输入 GET_SDA(); SCL(1); i2c_delay(1); pin_val = GET_SDA(); i2c_delay(1); SCL(0); i2c_delay(1); return pin_val;&#125;static void i2c_write(unsigned char data)&#123; int i = 0; for(i=0; i&lt;8; i++) &#123; SCL(0); i2c_delay(1); if(data &amp; 0x80) SDA(1); else SDA(0); data = data&lt;&lt;1; i2c_delay(1); SCL(1); i2c_delay(1); &#125; SCL(0); i2c_delay(1);&#125;static unsigned char i2c_read(void)&#123; int i = 0; unsigned char data = 0; SCL(0); i2c_delay(1); SDA(1); GET_SDA();//同理 i2c_delay(1); for(i=0; i&lt;8; i++) &#123; SCL(1); i2c_delay(1); data = data&lt;&lt;1; if(GET_SDA()) data |= 0x01; SCL(0); i2c_delay(1); &#125; SCL(1);//再给eeprom的ack提供一个时钟周期 i2c_delay(1); SCL(0); i2c_delay(1); return data;&#125;static void eeprom_write_protect(char x)&#123; if(x) GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;7); else GPIO3-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;7);&#125;void eeprom_write(unsigned char addr, unsigned char data)&#123; eeprom_write_protect(0); i2c_start(); i2c_write(0xA0); while(i2c_ack()); i2c_write(addr&gt;&gt;8); while(i2c_ack()); i2c_write(addr); while(i2c_ack()); i2c_write(data); while(i2c_ack()); i2c_stop(); eeprom_write_protect(1);&#125;unsigned char eeprom_read(unsigned char addr)&#123; unsigned char data = 0; eeprom_write_protect(0); i2c_start(); i2c_write(0xA0); while(i2c_ack()); i2c_write(addr&gt;&gt;8); while(i2c_ack()); i2c_write(addr); while(i2c_ack()); i2c_stop(); i2c_delay(10); i2c_start(); i2c_write(0xA1); while(i2c_ack()); data = i2c_read(); i2c_stop(); eeprom_write_protect(1); return data;&#125;#endif#ifdef REG_I2Cvoid i2c0_irq(void)&#123; unsigned int status = 0; status = I2C0-&gt;IRQSTS; I2C0-&gt;IRQSTS = (status &amp; (0x01&lt;&lt;3 | 0x01&lt;&lt;4)); if(status &amp; (0x01&lt;&lt;3))//receive &#123; I2C0-&gt;IRQSTS |= (0x01&lt;&lt;3); if(r_count == num) &#123; I2C0-&gt;IRQEN_CLR |= (0x01&lt;&lt;3); I2C0-&gt;CON |= (0x01&lt;&lt;1);//stop &#125; else &#123; data_from_slave[r_count++] = (unsigned char)I2C0-&gt;DATA; &#125; &#125; if (status &amp; (0x01&lt;&lt;4))//send &#123; I2C0-&gt;DATA = data_to_slave[t_count++]; I2C0-&gt;IRQSTS |= (0x01&lt;&lt;4); if(t_count == num) &#123; I2C0-&gt;IRQEN_CLR |= (0x01&lt;&lt;4); &#125; &#125;&#125;void eeprom_write_protect(char x)&#123; if(x) GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;7); else GPIO3-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;7);&#125;static unsigned int i2c_master_bus_busy(void)&#123; if(I2C0-&gt;IRQSTS_RAW &amp; (0x01&lt;&lt;12)) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;unsigned char eeprom_read(unsigned char addr)&#123; unsigned char data = 0; eeprom_write_protect(0); data_to_slave[0] = addr&gt;&gt;8; data_to_slave[1] = (addr &amp; 0xFF); t_count = 0; r_count = 0; I2C0-&gt;CNT = 0x02; num = I2C0-&gt;CNT; I2C0-&gt;IRQSTS |= 0x7FFF; I2C0-&gt;IRQEN_CLR |= 0x6FFF; I2C0-&gt;CON |= (0x01&lt;&lt;9 | 0x01&lt;&lt;10 | 0x01&lt;&lt;15); //MST=1 TRX=1 I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;4); I2C0-&gt;CON |= (0x01&lt;&lt;0); while(i2c_master_bus_busy() == 0); while(t_count != num); while(!(I2C0-&gt;IRQSTS_RAW &amp; (0x01&lt;&lt;2)));//----------------------------------------------------------------// I2C0-&gt;CNT = 0x01; num = I2C0-&gt;CNT; I2C0-&gt;IRQSTS |= 0x7FFF; I2C0-&gt;IRQEN_CLR |= 0x6FFF; I2C0-&gt;CON |= (0x01&lt;&lt;10 | (0x01&lt;&lt;15)); I2C0-&gt;CON &amp;= ~(0x01&lt;&lt;9); I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;3 | 0x01&lt;&lt;8); I2C0-&gt;CON |= (0x01&lt;&lt;0); while(i2c_master_bus_busy() == 0); while(r_count != num); data = data_from_slave[0]; eeprom_write_protect(1); return data;&#125;void eeprom_write(unsigned char addr, unsigned char data)&#123; eeprom_write_protect(0); data_to_slave[0] = addr&gt;&gt;8; data_to_slave[1] = (addr &amp; 0xFF); data_to_slave[2] = data; t_count = 0; I2C0-&gt;CNT = 0x03; num = I2C0-&gt;CNT; I2C0-&gt;IRQSTS |= 0x7FFF; I2C0-&gt;IRQEN_CLR |= 0x7FFF; I2C0-&gt;CON |= (0x01&lt;&lt;9 | 0x01&lt;&lt;10 | 0x01&lt;&lt;15); //MST=1 TRX=1 I2C0-&gt;IRQEN_SET |= (0x01&lt;&lt;4); I2C0-&gt;CON |= (0x01&lt;&lt;0); while(i2c_master_bus_busy() == 0); while(t_count != num); I2C0-&gt;CON |= (0x01&lt;&lt;1); //stop eeprom_write_protect(1);&#125;static void i2c_gpio_init(void)&#123; PRCM_CM_WKUP_I2C0_CLKCTRL |= (0x02&lt;&lt;0); PRCM_CM_WKUP_CLKSTCTRL |= (0x01&lt;&lt;14); PRCM_CM_PER_L4LS_CLKSTCTRL|= (0x01&lt;&lt;27); PRCM_CM_PER_GPIO3_CLKCTRL |= (0x02&lt;&lt;0); //gpio3_5-&gt;I2C0_SDA;gpio3_6-&gt;I2C0_SCL;gpio3_7-&gt;WP CTRL_CONF_I2C0_SDA &amp;= ~(0x07&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;19); CTRL_CONF_I2C0_SCL &amp;= ~(0x07&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;19); //CTRL_CONF_EMU0 GPIO3-&gt;OE &amp;= ~(0x01&lt;&lt;7); GPIO3-&gt;DATAOUT |= (0x01&lt;&lt;7);&#125;void i2c_init(void)&#123; i2c_gpio_init(); register_irq(IRQ_I2C0, i2c0_irq); interrupt_init(IRQ_I2C0); I2C0-&gt;CON &amp;= ~(0x01&lt;&lt;15);//reset I2C0-&gt;SYSC &amp;= ~(0x01&lt;&lt;0);//Auto Idle disabled. I2C0-&gt;PSC = 3;//the module divided by (PSC + 1) -&gt; 48M/(3+1)=12M I2C0-&gt;SCLL = 63;//tLOW = (SCLL + 7) * ICLK time period I2C0-&gt;SCLH = 65;//tHIGH = (SCLH + 5) * ICLK time period I2C0-&gt;SA = 0x50;//Slave address.1010 000 I2C0-&gt;CON |= (0x01&lt;&lt;15);//Module enabled &#125;void debug_i2c(char *str)&#123; printf(\"-------------------------%s---------------------------\\r\\n\",str); printf(\"I2C0-&gt;REVNB_HI = 0x%x\\r\\n\",I2C0-&gt;REVNB_HI ); printf(\"I2C0-&gt;REVNB_LO = 0x%x\\r\\n\",I2C0-&gt;REVNB_LO ); printf(\"I2C0-&gt;REVNB_HI = 0x%x\\r\\n\",I2C0-&gt;REVNB_HI ); printf(\"I2C0-&gt;SYSC = 0x%x\\r\\n\",I2C0-&gt;SYSC ); printf(\"I2C0-&gt;IRQSTS_RAW = 0x%x\\r\\n\",I2C0-&gt;IRQSTS_RAW ); printf(\"I2C0-&gt;IRQSTS = 0x%x\\r\\n\",I2C0-&gt;IRQSTS ); printf(\"I2C0-&gt;IRQEN_SET = 0x%x\\r\\n\",I2C0-&gt;IRQEN_SET ); printf(\"I2C0-&gt;IRQEN_CLR = 0x%x\\r\\n\",I2C0-&gt;IRQEN_CLR ); printf(\"I2C0-&gt;WE = 0x%x\\r\\n\",I2C0-&gt;WE ); printf(\"I2C0-&gt;DMARXEN_SET = 0x%x\\r\\n\",I2C0-&gt;DMARXEN_SET ); printf(\"I2C0-&gt;DMATXEN_SET = 0x%x\\r\\n\",I2C0-&gt;DMATXEN_SET ); printf(\"I2C0-&gt;DMARXEN_CLR = 0x%x\\r\\n\",I2C0-&gt;DMARXEN_CLR ); printf(\"I2C0-&gt;DMATXEN_CLR = 0x%x\\r\\n\",I2C0-&gt;DMATXEN_CLR ); printf(\"I2C0-&gt;DMARXWAKE_EN= 0x%x\\r\\n\",I2C0-&gt;DMARXWAKE_EN); printf(\"I2C0-&gt;DMATXWAKE_EN= 0x%x\\r\\n\",I2C0-&gt;DMATXWAKE_EN); printf(\"I2C0-&gt;SYSS = 0x%x\\r\\n\",I2C0-&gt;SYSS ); printf(\"I2C0-&gt;BUF = 0x%x\\r\\n\",I2C0-&gt;BUF ); printf(\"I2C0-&gt;CNT = 0x%x\\r\\n\",I2C0-&gt;CNT ); printf(\"I2C0-&gt;DATA = 0x%x\\r\\n\",I2C0-&gt;DATA ); printf(\"I2C0-&gt;CON = 0x%x\\r\\n\",I2C0-&gt;CON ); printf(\"I2C0-&gt;OA = 0x%x\\r\\n\",I2C0-&gt;OA ); printf(\"I2C0-&gt;SA = 0x%x\\r\\n\",I2C0-&gt;SA ); printf(\"I2C0-&gt;PSC = 0x%x\\r\\n\",I2C0-&gt;PSC ); printf(\"I2C0-&gt;SCLL = 0x%x\\r\\n\",I2C0-&gt;SCLL ); printf(\"I2C0-&gt;SCLH = 0x%x\\r\\n\",I2C0-&gt;SCLH ); printf(\"I2C0-&gt;SYSTEST = 0x%x\\r\\n\",I2C0-&gt;SYSTEST ); printf(\"I2C0-&gt;BUFSTAT = 0x%x\\r\\n\",I2C0-&gt;BUFSTAT ); printf(\"I2C0-&gt;OA1 = 0x%x\\r\\n\",I2C0-&gt;OA1 ); printf(\"I2C0-&gt;OA2 = 0x%x\\r\\n\",I2C0-&gt;OA2 ); printf(\"I2C0-&gt;OA3 = 0x%x\\r\\n\",I2C0-&gt;OA3 ); printf(\"I2C0-&gt;ACTOA = 0x%x\\r\\n\",I2C0-&gt;ACTOA ); printf(\"I2C0-&gt;SBLOCK = 0x%x\\r\\n\",I2C0-&gt;SBLOCK ); printf(\"******************************************************\\r\\n\");&#125;#endif [i2c.h]link12345678910111213141516171819202122232425262728293031323334#ifndef __I2C_H__#define __I2C_H__#define GPIO_I2C//#define REG_I2C#ifdef GPIO_I2Cextern void i2c_init(void);extern void eeprom_write(unsigned char addr, unsigned char data);extern unsigned char eeprom_read(unsigned char addr);#endif#ifdef REG_I2Cvolatile unsigned int t_count;volatile unsigned int r_count;volatile unsigned int num;volatile unsigned char data_to_slave[5];volatile unsigned char data_from_slave[5];extern void i2c_init(void);extern unsigned char eeprom_read(unsigned char addr);extern void eeprom_write(unsigned char addr, unsigned char data);extern void debug_i2c(char *str);#endif#endif 4.心得GPIO模拟I2C优势是通用性高，移植方便。利用SOC自带的I2C控制的优势是稳定，高效。 GPIO模拟I2C需要对时序的每个细节都比较清楚才行，非常适合去理解I2C的原理。硬件I2C几乎不需要考虑时序，按逻辑设置和读取相关寄存器即可。还有一个重要的点是去看从机I2C设备的时序，不同的设备，可能会不一样的。下一步，终于要开始I2C的驱动了~~~ 整个过程，最大的功臣就是逻辑分析仪，太好用了😀 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"AM437X","slug":"AM437X","permalink":"http://yoursite.com/tags/AM437X/"},{"name":"裸机","slug":"裸机","permalink":"http://yoursite.com/tags/裸机/"}]},{"title":"AM437x——RTC驱动","date":"2017-08-27T08:47:02.000Z","path":"2017/08/27/AM437x——RTC驱动/","text":"本文主要记录AM437X驱动的RTC。包含一个不标准的RTC驱动、一个还算有点标准的RTC驱动，以及正常的测试方式。 0.本次关于驱动的新收获写RTC驱动的时候，我先尝试的按标准的RTC框架来，写着写着，我想试试之前的一个猜想。理论上任何字符驱动，我都可以通过填充file_operations里面的函数，实现对硬件的操作控制。也就是说，写完裸机程序，按之前LED那套标准的字符驱动框架去写驱动，在应用层通过open()等函数去操作/dev/下的设备，是万能的。实际上RTC驱动也是这样做的，但因为RTC的特殊性，内核提供的是rtc_class_ops这个结构体，而不是file_operations。正常所需做的就是去填充rtc_class_ops的函数，然后注册等。想想这两个的区别，前面万能那个，应用层就没那么好受了，不通用，比如使用hwclock是不能调用到驱动函数的，因此需要自己去实现去RTC的访问，就像访问LED驱动一样。后面标准RTC那个，其最后的实质、原理是一样的，只是提供了统一的框架，增强了通用性。 1.不标准的RTC驱动1.1入口函数和出口函数先是入口函数，在insmod驱动的时候调用，分配了主设备号，注册了字符设备驱动，创建了个类，使用cdev机制，自动在/dev/目录下创建设备，应用层就是通过对这个设备操作，调用驱动实现对硬件的操作。再申请了内存，映射了寄存器地址，后面对这些映射出来的寄存器操作，就实现对硬件层的寄存器操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static int rtc_drv_init(void)&#123; dev_t devid; printk(KERN_INFO\"%s OK.\\n\",__func__); if(alloc_chrdev_region(&amp;devid, 0, TI_RTC_CNT, \"ti_rtc\") &lt; 0) &#123; printk(KERN_INFO\"%s ERROR.\\n\",__func__); goto error; &#125; major = MAJOR(devid); cdev_init(&amp;rtc_cdev, &amp;rtc_fops); cdev_add(&amp;rtc_cdev, devid, TI_RTC_CNT); rtc_cls = class_create(THIS_MODULE, \"ti_rtc\"); device_create(rtc_cls, NULL, MKDEV(major, 0), NULL, \"ti_rts0\"); PRCM_CM_RTC_CLKSTCTRL = ioremap(0x44DF8500+0x00, 0x04*1); PRCM_CM_RTC_CLKCTRL = ioremap(0x44DF8500+0x20, 0x04*1); RTCSS_BASE = ioremap(0x44E3E000, 0xA0); RTCSS_SECONDS = RTCSS_BASE + 0; RTCSS_MINUTES = RTCSS_BASE + 1; RTCSS_HOURS = RTCSS_BASE + 2; RTCSS_DAYS = RTCSS_BASE + 3; RTCSS_WEEKS = RTCSS_BASE + 4; RTCSS_MONTHS = RTCSS_BASE + 5; RTCSS_YEARS = RTCSS_BASE + 6; RTCSS_ALARM_SECONDS = RTCSS_BASE + 8; RTCSS_ALARM_MINUTES = RTCSS_BASE + 9; RTCSS_ALARM_HOURS = RTCSS_BASE + 10; RTCSS_ALARM_DAYS = RTCSS_BASE + 11; RTCSS_ALARM_MONTHS = RTCSS_BASE + 12; RTCSS_ALARM_YEARS = RTCSS_BASE + 13; RTCSS_CTRL = RTCSS_BASE + 15; RTCSS_OSC = RTCSS_BASE + 20; RTCSS_KICK0R = RTCSS_BASE + 25; RTCSS_KICK1R = RTCSS_BASE + 26; error: unregister_chrdev_region(MKDEV(major, 0), TI_RTC_CNT); return 0;&#125; 然后是出口函数，注册做什么，这里就反过来做什么。清除设备，清除类，注销字符设备，释放映射的内存。1234567891011121314151617static void rtc_drv_exit(void)&#123; unsigned i; printk(KERN_INFO\"%s OK.\\n\",__func__); for(i=0;i&lt;TI_RTC_CNT;i++) &#123; device_destroy(rtc_cls, MKDEV(major, i)); &#125; class_destroy(rtc_cls); cdev_del(&amp;rtc_cdev); unregister_chrdev(major, \"ti_rtc\"); iounmap(PRCM_CM_RTC_CLKSTCTRL); iounmap(PRCM_CM_RTC_CLKCTRL); iounmap(RTCSS_BASE); &#125; 修饰下入口函数和出口函数，让这两个普通函数，能够通过insmod加载的时候被调用。以及对该添加版权信息，驱动信息等。12345678module_init(rtc_drv_init);module_exit(rtc_drv_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am437x board rtc drvice\");MODULE_ALIAS(\"character device:ti_rtc\");MODULE_VERSION(\"V1.0\"); 1.2填充构造函数这里添加构造函数，需要什么，加什么，加了之后，再去实现，应用层就是调用到这些函数的功能。这里只打开设备、读取和设置时间操作。123456static struct file_operations rtc_fops = &#123; .owner = THIS_MODULE, .open = rtc_drv_open, .read = rtc_drv_read_time, .write = rtc_drv_set_time, &#125;; 1.3实现构造函数现在去实现构造函数。这部分和裸机的操作是一摸一样的，在open()函数里进行初始化，在read()函数里对寄存器(映射后的)进行读取，传输给应用层。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct rtc_struct &#123; int year; int month; //int week; int day; int hour; int minute; int second;&#125;;static int rtc_drv_open(struct inode *inode, struct file *file)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); *PRCM_CM_RTC_CLKCTRL &amp;= ~(0x03&lt;&lt;0); *PRCM_CM_RTC_CLKCTRL |= (0x01&lt;&lt;1); *PRCM_CM_RTC_CLKSTCTRL &amp;= ~(0x03&lt;&lt;0); *RTCSS_CTRL &amp;= ~(0x01&lt;&lt;6); *RTCSS_KICK0R = (0x83E70B13); *RTCSS_KICK1R = (0x95A4F1E0); *RTCSS_OSC &amp;= ~(0x01&lt;&lt;3); *RTCSS_OSC |= (0x01&lt;&lt;6); *RTCSS_CTRL |= (0x01&lt;&lt;0); return 0; &#125;static ssize_t rtc_drv_read_time(struct file *file, char __user *user_buf, size_t size, loff_t *ppos)&#123; struct rtc_struct rtc_time; printk(KERN_INFO\"%s OK.\\n\",__func__); rtc_time.year = (((*RTCSS_YEARS &amp; (0x03&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_YEARS &amp; (0x0F&lt;&lt;0))); rtc_time.month = (((*RTCSS_MONTHS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_MONTHS &amp; (0x0F&lt;&lt;0))); rtc_time.day = (((*RTCSS_DAYS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_DAYS &amp; (0x0F&lt;&lt;0))); rtc_time.hour = (((*RTCSS_HOURS &amp; (0x03&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_HOURS &amp; (0x0F&lt;&lt;0))); rtc_time.minute = (((*RTCSS_MINUTES &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_MINUTES &amp; (0x0F&lt;&lt;0))); rtc_time.second = (((*RTCSS_SECONDS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_SECONDS &amp; (0x0F&lt;&lt;0))); copy_to_user(user_buf, &amp;rtc_time, sizeof(rtc_time)); return 0; &#125; 接收应用层的数据，写入寄存器(映射后的)，完成对RTC的设置。和裸机的操作，是一摸一样的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static ssize_t rtc_drv_set_time(struct file *file, const char __user *user_buf, size_t count, loff_t * ppos)&#123; struct rtc_struct rtc_time; printk(KERN_INFO\"%s OK.\\n\",__func__); if(count != sizeof(rtc_time))&#123; printk(KERN_INFO\"write count != %d.\\n\",sizeof(rtc_time)); return 1; &#125; if (copy_from_user(&amp;rtc_time, user_buf, count)) return -EFAULT; *RTCSS_CTRL &amp;= ~(0x01&lt;&lt;0);//stop if((rtc_time.year-2000) &gt; 99 || (rtc_time.year-2000) &lt; 0) goto err; if(rtc_time.month &gt; 12 || rtc_time.month &lt; 0) goto err; *RTCSS_MONTHS = ((rtc_time.month/10) &lt;&lt; 4) | ((rtc_time.month%10) &lt;&lt; 0); if(rtc_time.day &gt; 32 || rtc_time.day &lt; 0) goto err; *RTCSS_DAYS = ((rtc_time.day/10) &lt;&lt; 4) | ((rtc_time.day%10) &lt;&lt; 0); if(rtc_time.hour &gt; 23 || rtc_time.hour &lt; 0) goto err; *RTCSS_HOURS = ((rtc_time.hour/10) &lt;&lt; 4) | ((rtc_time.hour%10) &lt;&lt; 0); if(rtc_time.minute &gt; 59 || rtc_time.minute &lt; 0) goto err; *RTCSS_MINUTES = ((rtc_time.minute/10) &lt;&lt; 4) | ((rtc_time.minute%10) &lt;&lt; 0); if(rtc_time.second &gt; 59 || rtc_time.second &lt; 0) goto err; *RTCSS_SECONDS = ((rtc_time.second/10) &lt;&lt; 4) | ((rtc_time.second%10) &lt;&lt; 0); *RTCSS_CTRL |= (0x01&lt;&lt;0);//start return 0; err: printk(KERN_INFO\"rtc_drv_set_time err.\\n\"); return 1; &#125; 1.4完整驱动代码[rtc_drv.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;asm/io.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/cdev.h&gt;#define TI_RTC_CNT 1int major;static struct cdev rtc_cdev;static struct class *rtc_cls;static volatile unsigned long *PRCM_CM_RTC_CLKCTRL = NULL; static volatile unsigned long *PRCM_CM_RTC_CLKSTCTRL = NULL; static volatile unsigned long *RTCSS_BASE = NULL;static volatile unsigned long *RTCSS_CTRL = NULL;static volatile unsigned long *RTCSS_KICK0R = NULL;static volatile unsigned long *RTCSS_KICK1R = NULL; static volatile unsigned long *RTCSS_OSC = NULL;static volatile unsigned long *RTCSS_YEARS = NULL; static volatile unsigned long *RTCSS_MONTHS = NULL;static volatile unsigned long *RTCSS_WEEKS = NULL; static volatile unsigned long *RTCSS_DAYS = NULL;static volatile unsigned long *RTCSS_HOURS = NULL; static volatile unsigned long *RTCSS_MINUTES = NULL;static volatile unsigned long *RTCSS_SECONDS = NULL; static volatile unsigned long *RTCSS_ALARM_YEARS = NULL; static volatile unsigned long *RTCSS_ALARM_MONTHS = NULL; static volatile unsigned long *RTCSS_ALARM_DAYS = NULL;static volatile unsigned long *RTCSS_ALARM_HOURS = NULL; static volatile unsigned long *RTCSS_ALARM_MINUTES = NULL;static volatile unsigned long *RTCSS_ALARM_SECONDS = NULL; struct rtc_struct &#123; int year; int month; //int week; int day; int hour; int minute; int second;&#125;;static int rtc_drv_open(struct inode *inode, struct file *file)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); *PRCM_CM_RTC_CLKCTRL &amp;= ~(0x03&lt;&lt;0); *PRCM_CM_RTC_CLKCTRL |= (0x01&lt;&lt;1); *PRCM_CM_RTC_CLKSTCTRL &amp;= ~(0x03&lt;&lt;0); *RTCSS_CTRL &amp;= ~(0x01&lt;&lt;6); *RTCSS_KICK0R = (0x83E70B13); *RTCSS_KICK1R = (0x95A4F1E0); *RTCSS_OSC &amp;= ~(0x01&lt;&lt;3); *RTCSS_OSC |= (0x01&lt;&lt;6); *RTCSS_CTRL |= (0x01&lt;&lt;0); return 0; &#125;static ssize_t rtc_drv_read_time(struct file *file, char __user *user_buf, size_t size, loff_t *ppos)&#123; struct rtc_struct rtc_time; printk(KERN_INFO\"%s OK.\\n\",__func__); rtc_time.year = (((*RTCSS_YEARS &amp; (0x03&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_YEARS &amp; (0x0F&lt;&lt;0))); rtc_time.month = (((*RTCSS_MONTHS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_MONTHS &amp; (0x0F&lt;&lt;0))); rtc_time.day = (((*RTCSS_DAYS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_DAYS &amp; (0x0F&lt;&lt;0))); rtc_time.hour = (((*RTCSS_HOURS &amp; (0x03&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_HOURS &amp; (0x0F&lt;&lt;0))); rtc_time.minute = (((*RTCSS_MINUTES &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_MINUTES &amp; (0x0F&lt;&lt;0))); rtc_time.second = (((*RTCSS_SECONDS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (*RTCSS_SECONDS &amp; (0x0F&lt;&lt;0))); copy_to_user(user_buf, &amp;rtc_time, sizeof(rtc_time)); return 0; &#125;static ssize_t rtc_drv_set_time(struct file *file, const char __user *user_buf, size_t count, loff_t * ppos)&#123; struct rtc_struct rtc_time; printk(KERN_INFO\"%s OK.\\n\",__func__); if(count != sizeof(rtc_time))&#123; printk(KERN_INFO\"write count != %d.\\n\",sizeof(rtc_time)); return 1; &#125; if (copy_from_user(&amp;rtc_time, user_buf, count)) return -EFAULT; *RTCSS_CTRL &amp;= ~(0x01&lt;&lt;0);//stop if((rtc_time.year-2000) &gt; 99 || (rtc_time.year-2000) &lt; 0) goto err; if(rtc_time.month &gt; 12 || rtc_time.month &lt; 0) goto err; *RTCSS_MONTHS = ((rtc_time.month/10) &lt;&lt; 4) | ((rtc_time.month%10) &lt;&lt; 0); if(rtc_time.day &gt; 32 || rtc_time.day &lt; 0) goto err; *RTCSS_DAYS = ((rtc_time.day/10) &lt;&lt; 4) | ((rtc_time.day%10) &lt;&lt; 0); if(rtc_time.hour &gt; 23 || rtc_time.hour &lt; 0) goto err; *RTCSS_HOURS = ((rtc_time.hour/10) &lt;&lt; 4) | ((rtc_time.hour%10) &lt;&lt; 0); if(rtc_time.minute &gt; 59 || rtc_time.minute &lt; 0) goto err; *RTCSS_MINUTES = ((rtc_time.minute/10) &lt;&lt; 4) | ((rtc_time.minute%10) &lt;&lt; 0); if(rtc_time.second &gt; 59 || rtc_time.second &lt; 0) goto err; *RTCSS_SECONDS = ((rtc_time.second/10) &lt;&lt; 4) | ((rtc_time.second%10) &lt;&lt; 0); *RTCSS_CTRL |= (0x01&lt;&lt;0);//start return 0; err: printk(KERN_INFO\"rtc_drv_set_time err.\\n\"); return 1; &#125;static struct file_operations rtc_fops = &#123; .owner = THIS_MODULE, .open = rtc_drv_open, .read = rtc_drv_read_time, .write = rtc_drv_set_time, &#125;;static int rtc_drv_init(void)&#123; dev_t devid; printk(KERN_INFO\"%s OK.\\n\",__func__); if(alloc_chrdev_region(&amp;devid, 0, TI_RTC_CNT, \"ti_rtc\") &lt; 0) &#123; printk(KERN_INFO\"%s ERROR.\\n\",__func__); goto error; &#125; major = MAJOR(devid); cdev_init(&amp;rtc_cdev, &amp;rtc_fops); cdev_add(&amp;rtc_cdev, devid, TI_RTC_CNT); rtc_cls = class_create(THIS_MODULE, \"ti_rtc\"); device_create(rtc_cls, NULL, MKDEV(major, 0), NULL, \"ti_rts0\"); PRCM_CM_RTC_CLKSTCTRL = ioremap(0x44DF8500+0x00, 0x04*1); PRCM_CM_RTC_CLKCTRL = ioremap(0x44DF8500+0x20, 0x04*1); RTCSS_BASE = ioremap(0x44E3E000, 0xA0); RTCSS_SECONDS = RTCSS_BASE + 0; RTCSS_MINUTES = RTCSS_BASE + 1; RTCSS_HOURS = RTCSS_BASE + 2; RTCSS_DAYS = RTCSS_BASE + 3; RTCSS_WEEKS = RTCSS_BASE + 4; RTCSS_MONTHS = RTCSS_BASE + 5; RTCSS_YEARS = RTCSS_BASE + 6; RTCSS_ALARM_SECONDS = RTCSS_BASE + 8; RTCSS_ALARM_MINUTES = RTCSS_BASE + 9; RTCSS_ALARM_HOURS = RTCSS_BASE + 10; RTCSS_ALARM_DAYS = RTCSS_BASE + 11; RTCSS_ALARM_MONTHS = RTCSS_BASE + 12; RTCSS_ALARM_YEARS = RTCSS_BASE + 13; RTCSS_CTRL = RTCSS_BASE + 15; RTCSS_OSC = RTCSS_BASE + 20; RTCSS_KICK0R = RTCSS_BASE + 25; RTCSS_KICK1R = RTCSS_BASE + 26; error: unregister_chrdev_region(MKDEV(major, 0), TI_RTC_CNT); return 0;&#125;static void rtc_drv_exit(void)&#123; unsigned i; printk(KERN_INFO\"%s OK.\\n\",__func__); for(i=0;i&lt;TI_RTC_CNT;i++) &#123; device_destroy(rtc_cls, MKDEV(major, i)); &#125; class_destroy(rtc_cls); cdev_del(&amp;rtc_cdev); unregister_chrdev(major, \"ti_rtc\"); iounmap(PRCM_CM_RTC_CLKSTCTRL); iounmap(PRCM_CM_RTC_CLKCTRL); iounmap(RTCSS_BASE); &#125;module_init(rtc_drv_init);module_exit(rtc_drv_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am437x board rtc drvice\");MODULE_ALIAS(\"character device:ti_rtc\");MODULE_VERSION(\"V1.0\"); 1.5测试程序及效果[rtc_app.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#define msleep(x) usleep(x*1000)/* * ./rtc_app w 2017 08 25 18 36 20 * ./rtc_app r [times]*/struct rtc_struct &#123; int year; int month; //int week; int day; int hour; int minute; int second;&#125;;struct rtc_struct set_time, rtc_time;int main(int argc, char **argv)&#123; int fd; int i; fd = open(\"/dev/ti_rts0\", O_RDWR); if (fd &lt; 0) &#123; printf(\"can't open /dev/ti_rts0.\\n\"); return 0; &#125; if(strcmp(argv[1], \"w\") == 0 &amp;&amp; argc == 8) &#123; set_time.year = atoi(argv[2]); set_time.month = atoi(argv[3]); set_time.day = atoi(argv[4]); set_time.hour = atoi(argv[5]); set_time.minute = atoi(argv[6]); set_time.second = atoi(argv[7]); write(fd, &amp;set_time, sizeof(set_time)); printf(\"write ok\\n\"); &#125; else if(strcmp(argv[1], \"r\") == 0) &#123; if(argv[2] == NULL) i = 999; else i = atoi(argv[2]); do&#123; read(fd, &amp;rtc_time, sizeof(rtc_time)); printf(\"\\n\\rcurrent_time is:\\n\\r\\%d-%d-%d %d:%d:%d\\n\\r\",\\ rtc_time.year+2000,rtc_time.month,rtc_time.day,rtc_time.hour,rtc_time.minute,rtc_time.second); printf(\"read ok\\n\"); msleep(1000); i--; &#125; while(i); &#125; close(fd); return 0;&#125; 这里除了年，其它都还OK，估计是和系统的一些设置冲突了。 2.还算有点标准的RTC驱动本来计划完整的写好RTC驱动的，实际过程中发现ti官方内核的RTC不能关，关了无法正常启动。经验不足，又无法解决这个问题，只能在保持他远样的基础上，能写成什么算什么。大部分框架也算写了，剩下的感觉应该也不难了。这次用的设备驱动模型来写的。由rtc_dev.c和rtc_drv.c组成。 2.1rtc_dev.c首先是在rtc_dev.c中注册平台设备，并设置硬件资源。RTC所需的硬件资源教少，主要是RTC寄存器和中断。12345678910111213141516171819202122static struct resource am437x_rtc_resource[] = &#123; [0] = &#123; .name = \"RTCSS\", .start = 0x44E3E000, .end = 0x44E3EFFF, .flags = IORESOURCE_MEM, &#125;, [1] = &#123; .name = \"RTCINT\", .start = 107, .end = 107, .flags = IORESOURCE_IRQ,//107 &#125;, [2] = &#123; .name = \"RTCALARMINT\", .start = 108, .end = 108, .flags = IORESOURCE_IRQ,//108 &#125;,&#125;; 2.2rtc_drv.crtc_drv.c开始要做的也差不多，注册平台设备。然后两个名字相同，匹配成功后调用probe()函数。这里的probe()先获取rtc_dev.c里面的中断和RTC物理基地址的资源。随即映射RTC基地址。同时初始化RTC。然后注册RTC设备devm_rtc_device_register().这里绑定的是rtc_class_ops，而不是之前的file_operations。这里的rtc_class_ops是为RTC“量身定做”的操作函数，更设备RTC设备。devm_rtc_device_register()里面的操作也是注册字符设备那一套，本质还是一样的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119static struct rtc_class_ops am437x_rtc_ops = &#123; .open = rtc_drv_open, .release = rtc_drv_release, .read_time = rtc_drv_read_time, .set_time = rtc_drv_set_time, .read_alarm = rtc_drv_read_alarm, .set_alarm = rtc_drv_set_alarm, .proc = rtc_drv_proc, .alarm_irq_enable = rtc_drv_alarm_irq_enable, &#125;; static void am437x_rtc_enable(struct platform_device *pdev, int en)&#123; void __iomem *rtc_base = am437x_rtc_base; unsigned int tmp; if (am437x_rtc_base == NULL) return; if (en) &#123; /* Enable the clock/module so that we can access the registers */ pm_runtime_get_sync(&amp;pdev-&gt;dev); //rtc init. tmp = readb(rtc_base + 0x40);//CTRL.Enable the RTC module writew(tmp &amp; ~(0x01&lt;&lt;6), rtc_base + 0x40); writel(0x83E70B13, rtc_base + 0x6C);//KICK0R.Write Project Disable writel(0x95A4F1E0, rtc_base + 0x70);//KICK1R tmp = readb(rtc_base + 0x54);//OSC.mode1:Internal clock writew(tmp &amp; ~(0x01&lt;&lt;3), rtc_base + 0x54); tmp = readb(rtc_base + 0x54); writew(tmp | (0x01&lt;&lt;6), rtc_base + 0x54); tmp = readb(rtc_base + 0x40);//run. writew(tmp | (0x01&lt;&lt;0), rtc_base + 0x40); &#125; else &#123; tmp = readb(rtc_base + 0x40);//stop. writew(tmp &amp; ~(0x01&lt;&lt;0), rtc_base + 0x40); tmp = readb(rtc_base + 0x40);//CTRL.Disable the RTC module writew(tmp | (0x01&lt;&lt;6), rtc_base + 0x40); /* Disable the clock/module */ pm_runtime_put_sync(&amp;pdev-&gt;dev); &#125;&#125;struct resource *am437x_rtc_mem;static int am437x_rtc_probe(struct platform_device *pdev) &#123; struct resource *res; int ret; printk(KERN_INFO\"%s OK.\\n\",__func__); /* find the IRQs */ am437x_rtc_timer_irq = platform_get_irq(pdev, 0); if (am437x_rtc_timer_irq &lt; 0) &#123; dev_err(&amp;pdev-&gt;dev, \"no irq for rtc tick\\n\"); return am437x_rtc_timer_irq; &#125; am437x_rtc_alarm_irq = platform_get_irq(pdev, 1); if (am437x_rtc_alarm_irq &lt; 0) &#123; dev_err(&amp;pdev-&gt;dev, \"no irq for alarm\\n\"); return am437x_rtc_alarm_irq; &#125; dev_dbg(&amp;pdev-&gt;dev, \"am437x_rtc: tick irq %d, alarm irq %d\\n\", am437x_rtc_timer_irq, am437x_rtc_alarm_irq); /*RTC*/ res = platform_get_resource(pdev, IORESOURCE_MEM, 0); if(res == NULL)&#123; dev_err(&amp;pdev-&gt;dev, \"RTC:failed to get memory regin resource.\\n\"); return -ENOENT; &#125; am437x_rtc_mem = request_mem_region(res-&gt;start, res-&gt;end - res-&gt;start+1, pdev-&gt;name); if (am437x_rtc_mem == NULL)&#123; dev_err(&amp;pdev-&gt;dev, \"RTC:failed to reserve memory region.\\n\"); return -ENOENT; goto err_nores; &#125; am437x_rtc_base = ioremap(res-&gt;start, res-&gt;end - res-&gt;start+1); if (am437x_rtc_mem == NULL)&#123; dev_err(&amp;pdev-&gt;dev, \"RTC:failed ioremap.\\n\"); return -EINVAL; goto err_nomap; &#125; am437x_rtc_enable(pdev, 1); rtc = devm_rtc_device_register(&amp;pdev-&gt;dev, pdev-&gt;name,&amp;am437x_rtc_ops, THIS_MODULE); if (IS_ERR(rtc)) &#123; pr_debug(\"%s: can't register RTC device, err %ld\\n\",pdev-&gt;name, PTR_ERR(rtc)); goto err_nortc; &#125; return 0; err_nortc: am437x_rtc_enable(pdev, 0); iounmap(am437x_rtc_base); err_nomap: release_resource(am437x_rtc_mem); err_nores: return ret;&#125; 然后是填充rtc_class_ops里面的操作函数，open()本来计划用来申请中断的，但申请的时候说被占用了，还是之前没有去掉内核RTC的原因。这里就先屏蔽了。read_time()和set_time()里面还是读取/设置寄存器。alarm的也差不多，没有中断，就先搁置了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143static int rtc_drv_open(struct device *dev)&#123; struct platform_device *pdev = to_platform_device(dev); struct rtc_device *rtc_dev = platform_get_drvdata(pdev); int ret; printk(KERN_INFO\"%s OK.\\n\",__func__);/* if (devm_request_irq(&amp;pdev-&gt;dev, am437x_rtc_timer_irq, rtc_irq, 0, dev_name(&amp;rtc-&gt;dev), rtc)) &#123; pr_debug(\"%s: RTC timer interrupt IRQ%d already claimed\\n\",pdev-&gt;name, am437x_rtc_timer_irq); goto fail0; &#125; if ((am437x_rtc_timer_irq != am437x_rtc_alarm_irq) &amp;&amp; (devm_request_irq(&amp;pdev-&gt;dev, am437x_rtc_alarm_irq, rtc_irq, 0, dev_name(&amp;rtc-&gt;dev), rtc))) &#123; pr_debug(\"%s: RTC alarm interrupt IRQ%d already claimed\\n\",pdev-&gt;name, am437x_rtc_alarm_irq); goto fail0; &#125;*/ return 0;fail0: return -EIO;&#125;static int rtc_drv_release(struct device *dev)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); return 0;&#125;static int tm2bcd(struct rtc_time *tm)&#123; if (rtc_valid_tm(tm) != 0) return -EINVAL; tm-&gt;tm_sec = bin2bcd(tm-&gt;tm_sec); tm-&gt;tm_min = bin2bcd(tm-&gt;tm_min); tm-&gt;tm_hour = bin2bcd(tm-&gt;tm_hour); tm-&gt;tm_mday = bin2bcd(tm-&gt;tm_mday); tm-&gt;tm_mon = bin2bcd(tm-&gt;tm_mon + 1); /* epoch == 1900 */ if (tm-&gt;tm_year &lt; 100 || tm-&gt;tm_year &gt; 199) return -EINVAL; tm-&gt;tm_year = bin2bcd(tm-&gt;tm_year - 100); return 0;&#125;static void bcd2tm(struct rtc_time *tm)&#123; tm-&gt;tm_sec = bcd2bin(tm-&gt;tm_sec); tm-&gt;tm_min = bcd2bin(tm-&gt;tm_min); tm-&gt;tm_hour = bcd2bin(tm-&gt;tm_hour); tm-&gt;tm_mday = bcd2bin(tm-&gt;tm_mday); tm-&gt;tm_mon = bcd2bin(tm-&gt;tm_mon) - 1; /* epoch == 1900 */ tm-&gt;tm_year = bcd2bin(tm-&gt;tm_year) + 2000;&#125;static void rtc_wait_not_busy(void)&#123; int count = 0; u8 status; /* BUSY may stay active for 1/32768 second (~30 usec) */ for (count = 0; count &lt; 50; count++) &#123; status = readb(am437x_rtc_base + 0x44);//STS if ((status &amp; (0x01&lt;&lt;0)) == 0) break; udelay(1); &#125; /* now we have ~15 usec to read/write various registers */&#125;static int rtc_drv_read_time(struct device *dev, struct rtc_time *rtc_t)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); //local_irq_disable(); rtc_wait_not_busy(); rtc_t-&gt;tm_sec = readb(am437x_rtc_base + 0x00); rtc_t-&gt;tm_min = readb(am437x_rtc_base + 0x04); rtc_t-&gt;tm_hour = readb(am437x_rtc_base + 0x08); rtc_t-&gt;tm_mday = readb(am437x_rtc_base + 0x0C); rtc_t-&gt;tm_mon = readb(am437x_rtc_base + 0x10); rtc_t-&gt;tm_year = readb(am437x_rtc_base + 0x14); //local_irq_enable(); bcd2tm(rtc_t); printk(\"\\n\\rcurrent_time is:\\n\\r\\%d-%d-%d %d:%d:%d\\n\\r\",\\ rtc_t-&gt;tm_year,rtc_t-&gt;tm_mon,rtc_t-&gt;tm_mday,rtc_t-&gt;tm_hour,rtc_t-&gt;tm_min,rtc_t-&gt;tm_sec); return 0;&#125;static int rtc_drv_set_time(struct device *dev, struct rtc_time *rtc_t)&#123; if (tm2bcd(rtc_t) &lt; 0) return -EINVAL; //local_irq_disable(); rtc_wait_not_busy(); writeb(rtc_t-&gt;tm_sec, am437x_rtc_base + 0x00); writeb(rtc_t-&gt;tm_min, am437x_rtc_base + 0x04); writeb(rtc_t-&gt;tm_hour, am437x_rtc_base + 0x08); writeb(rtc_t-&gt;tm_mday, am437x_rtc_base + 0x0C); writeb(rtc_t-&gt;tm_mon, am437x_rtc_base + 0x10); writeb(rtc_t-&gt;tm_year, am437x_rtc_base + 0x14); //local_irq_enable(); return 0;&#125;static int rtc_drv_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); return 0;&#125;static int rtc_drv_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); return 0;&#125;static int rtc_drv_proc(struct device *dev, struct seq_file *seq)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); return 0;&#125;static int rtc_drv_alarm_irq_enable(struct device *dev, unsigned int enabled)&#123; printk(KERN_INFO\"%s OK.\\n\",__func__); return 0;&#125; 2.3相关代码及测试效果rtc_dev.crtc_drv.c在系统输入hwclock -f /dev/rtc1 3.正常的测试驱动额，虽然没有正常调试出RTC，但还是记下正常调试的方法，万一以后用到了呢。 Linux中有两个时间，一个是系统时间，通过命令date获取；一个是硬件时间，通过命令hwclock获取； RTC驱动的一般测试如下：1.获取系统时间1date 如果时间正常，则进行第2步，如果不正常，修改系统时间为正常时间：1date 082316432017.00//2017-08-23 16:43:00 2.获取硬件时间1hwclock 由于此处是RTC驱动第一次加载，还没设置正确的时间，所以此时显示的时间，多数是不正确的1970年。 3.同步硬件时间1hwclock -w 第一步设置好了正常的系统时间，现在将系统时间与硬件时间进行同步。 4.自动同步硬件时间现在的系统时间和硬件时间是同步的，如果关机重启，系统时间将不会实时同步，而硬件时间是一直实时同步的，因此需要将硬件时间同步到系统时间。修改启动脚本：etc/init.d/rcS，在最后一行加上：1/sbin/hwclock -s 4.验证重启，检查系统时间和硬件时间是不是实时的。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"AM437X","slug":"AM437X","permalink":"http://yoursite.com/tags/AM437X/"},{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"}]},{"title":"AM437x——RTC裸机","date":"2017-08-23T08:46:58.000Z","path":"2017/08/23/AM437x——RTC裸机/","text":"AM437x的RTC模块裸机程序。 0.为什么要RTC在实际开发中，往往需要知道当前的时间，比如现在的2017年8月23日17点02分。由于设备不使用的时候或者遇到故障时，会出现关机操作，而关机的这段时间长短，设备是不知道的，当再次开机时，时间要么被归零，要么显示为关机时的那个时间。 为了同步到现在的实时时间，我能想到两个解决方案。 1.利用网络，从网络中获取当前时间。2.利用一个设备关机仍在计时工作的模块，开机后加上关机的这段时间。 第一个方案，需要网络，对于大多数单片机设备是不现实的，附加的成本太高。第二个方案，就是现在大量使用的RTC，有的集成到SOC里面了，有些仍以外部芯片的形式出现。 在设备关机后，RTC在备用电池（一般是纽扣电池）的支持下，以超低功耗的方式继续默默的工作，直到开机，将时间同步。 这就是RTC存在的主要意义。 1.AM437x的RTCAM437x的RTC介绍在参考手册19章Timers的第4部分：Real-Time Clock (RTC)大致的特性有： 总计数时间为100年； 提供秒、分、小时、星期、日期、月份、年等； 数据以Binary-coded-decimal (BCD)表示； 时钟源可选择内部或外部； 有两个闹钟； 有两种中断：时间中断和闹钟中断； 很良心的有个Use Cases： The following list includes high-level steps to start using the RTC: Enable the module clock domains (for details on which clock domain, see Section 19.4.2, Integration). Enable the RTC module using CTRL_REG.RTC_disable. Enable the 32K clock from PER PLL, if using the internal RTC oscillator. Write to the kick registers (KICK0R, KICK1R) in the RTC. Configure the timer in RTCSS for desired application (set time and date, alarm wakeup, and so on). Start the RTC (in CTRL_REG.STOP_RTC). 基本把配置步骤写得很清楚了。 关于时钟和中断：时钟来自于外部CLKIN32的CLK_32K_RTC或者内部PRCM的CLK_32KHz；可以产生两种中断：timer_intr_pend和alarm_intr_pend。 关于写保护如图中的三个状态，向KICK0和KICK1写入指定的值，即可去写保护。 2.RTC编程本次裸机的目的，是想实现以下两个功能： 设置和读取RTC的时间； 设置和读取RTC闹钟的时间，利用中断打印闹钟； 模块初始化：包含时钟使能、模块使能、时钟源选择、中断注册、使能中断。1234567891011121314151617181920212223242526272829303132333435363738void rtc_init(void)&#123; //1.set performing the System Clock configuration for RTC. PRCM_CM_RTC_CLKCTRL &amp;= ~(0x3&lt;&lt;0); PRCM_CM_RTC_CLKCTRL |= (0x01&lt;&lt;1); PRCM_CM_RTC_CLKSTCTRL &amp;= ~(0x3&lt;&lt;0); //Wait write is completed. while(!(PRCM_CM_RTC_CLKSTCTRL &amp; (0x01&lt;&lt;9 | 0x01&lt;&lt;8))); while(PRCM_CM_RTC_CLKCTRL &amp; (0x03&lt;&lt;16)); //2.Enable the RTC module; RTCSS-&gt;CTRL &amp;= ~(0x01&lt;&lt;6); //3.Write Project Disable; RTCSS-&gt;KICK0R = (0x83E70B13); RTCSS-&gt;KICK1R = (0x95A4F1E0); //4.Set clock Source; //mode1:Internal clock RTCSS-&gt;OSC &amp;= ~(0x01&lt;&lt;3); RTCSS-&gt;OSC |= (0x01&lt;&lt;6); //mode2:External clock //RTCSS-&gt;OSC &amp;= ~(0x01&lt;&lt;3); //RTCSS-&gt;OSC |= (0x01&lt;&lt;6 | 0x01&lt;&lt;3); register_irq(RTCALARMINT, alarm_irq); interrupt_init(RTCALARMINT); //5.Enable interrupt; rtc_int_enalbe(); //6.Run. //rtc_start();&#125; 这里将中断的使能/去能、RTC的启动/停止，分别封装成了函数。12345678910111213141516171819void rtc_start(void)&#123; RTCSS-&gt;CTRL |= (0x01&lt;&lt;0);&#125;void rtc_stop(void)&#123; RTCSS-&gt;CTRL &amp;= ~(0x01&lt;&lt;0);&#125;static void rtc_int_enalbe(void)&#123; RTCSS-&gt;INTRS |= (0x01&lt;&lt;3);//RTC_ALARM1&#125;static void rtc_int_clear(void)&#123; RTCSS-&gt;STS |= (0x01&lt;&lt;6);;//RTC_ALARM1&#125; 设置时间和获取时间：将所有时间参数封装成一个结构体：1234567891011struct rtc_struct &#123; int year; int month; int week; int day; int hour; int minute; int second;&#125;;extern struct rtc_struct rtc_time, rtc_alarm; 设置时间主要是将值分解成BCD的格式：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int set_time(struct rtc_struct rtc_time)&#123; rtc_stop(); if((rtc_time.year-2000) &gt; 99 || (rtc_time.year-2000) &lt; 0) goto err; RTCSS-&gt;YEARS = (((rtc_time.year-2000)/10) &lt;&lt; 4) | (((rtc_time.year-2000)%10) &lt;&lt; 0); if(rtc_time.month &gt; 12 || rtc_time.month &lt; 0) goto err; RTCSS-&gt;MONTHS = ((rtc_time.month/10) &lt;&lt; 4) | ((rtc_time.month%10) &lt;&lt; 0); if(rtc_time.week &gt; 7 || rtc_time.week &lt; 0) //goto err; rtc_time.week = 1; RTCSS-&gt;WEEKS = rtc_time.week; if(rtc_time.day &gt; 32 || rtc_time.day &lt; 0) goto err; RTCSS-&gt;DAYS = ((rtc_time.day/10) &lt;&lt; 4) | ((rtc_time.day%10) &lt;&lt; 0); if(rtc_time.hour &gt; 23 || rtc_time.hour &lt; 0) goto err; RTCSS-&gt;HOURS = ((rtc_time.hour/10) &lt;&lt; 4) | ((rtc_time.hour%10) &lt;&lt; 0); if(rtc_time.minute &gt; 59 || rtc_time.minute &lt; 0) goto err; RTCSS-&gt;MINUTES = ((rtc_time.minute/10) &lt;&lt; 4) | ((rtc_time.minute%10) &lt;&lt; 0); if(rtc_time.second &gt; 59 || rtc_time.second &lt; 0) goto err; RTCSS-&gt;SECONDS = ((rtc_time.second/10) &lt;&lt; 4) | ((rtc_time.second%10) &lt;&lt; 0); rtc_start(); return 0; err: printf(\"set_time err.\\n\\r\"); return 1;&#125;struct rtc_struct get_time(void)&#123; struct rtc_struct current_time; current_time.year = (((RTCSS-&gt;YEARS &amp; (0x03&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;YEARS &amp; (0x0F&lt;&lt;0))); current_time.month = (((RTCSS-&gt;MONTHS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;MONTHS &amp; (0x0F&lt;&lt;0))); current_time.week = ( RTCSS-&gt;WEEKS &amp; (0x0F&lt;&lt;0)); current_time.day = (((RTCSS-&gt;DAYS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;DAYS &amp; (0x0F&lt;&lt;0))); current_time.hour = (((RTCSS-&gt;HOURS &amp; (0x03&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;HOURS &amp; (0x0F&lt;&lt;0))); current_time.minute = (((RTCSS-&gt;MINUTES &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;MINUTES &amp; (0x0F&lt;&lt;0))); current_time.second = (((RTCSS-&gt;SECONDS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;SECONDS &amp; (0x0F&lt;&lt;0))); printf(\"\\n\\rcurrent_time is:\\n\\r\\%d-%d-%d %d:%d:%d\\n\\r\",\\current_time.year+2000,current_time.month,current_time.day,current_time.hour,current_time.minute,current_time.second); return current_time;&#125; 设置闹钟和获取闹钟：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int set_alarm(struct rtc_struct alarm_time)&#123; if((alarm_time.year-2000) &gt; 99 || (alarm_time.year-2000) &lt; 0) goto err; RTCSS-&gt;ALARM_YEARS = (((alarm_time.year-2000)/10) &lt;&lt; 4) | (((alarm_time.year-2000)%10) &lt;&lt; 0); if(alarm_time.month &gt; 12 || alarm_time.month &lt; 0) goto err; RTCSS-&gt;ALARM_MONTHS = ((alarm_time.month/10) &lt;&lt; 4) | ((alarm_time.month%10) &lt;&lt; 0); if(alarm_time.day &gt; 32 || alarm_time.day &lt; 0) goto err; RTCSS-&gt;ALARM_DAYS = ((alarm_time.day/10) &lt;&lt; 4) | ((alarm_time.day%10) &lt;&lt; 0); if(alarm_time.hour &gt; 23 || alarm_time.hour &lt; 0) goto err; RTCSS-&gt;ALARM_HOURS = ((alarm_time.hour/10) &lt;&lt; 4) | ((alarm_time.hour%10) &lt;&lt; 0); if(alarm_time.minute &gt; 59 || alarm_time.minute &lt; 0) goto err; RTCSS-&gt;ALARM_MINUTES = ((alarm_time.minute/10) &lt;&lt; 4) | ((alarm_time.minute%10) &lt;&lt; 0); if(alarm_time.second &gt; 59 || alarm_time.second &lt; 0) goto err; RTCSS-&gt;ALARM_SECONDS = ((alarm_time.second/10) &lt;&lt; 4) | ((alarm_time.second%10) &lt;&lt; 0); return 0; err: printf(\"set_alarm err.\\n\\r\"); return 1;&#125;struct rtc_struct get_alarm(void)&#123; struct rtc_struct alarm_time; alarm_time.year = (((RTCSS-&gt;ALARM_YEARS &amp; (0x03&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;ALARM_YEARS &amp; (0x0F&lt;&lt;0))); alarm_time.month = (((RTCSS-&gt;ALARM_MONTHS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;ALARM_MONTHS &amp; (0x0F&lt;&lt;0))); alarm_time.day = (((RTCSS-&gt;ALARM_DAYS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;ALARM_DAYS &amp; (0x0F&lt;&lt;0))); alarm_time.hour = (((RTCSS-&gt;ALARM_HOURS &amp; (0x03&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;ALARM_HOURS &amp; (0x0F&lt;&lt;0))); alarm_time.minute = (((RTCSS-&gt;ALARM_MINUTES &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;ALARM_MINUTES &amp; (0x0F&lt;&lt;0))); alarm_time.second = (((RTCSS-&gt;ALARM_SECONDS &amp; (0x07&lt;&lt;4))&gt;&gt;4)*10 + (RTCSS-&gt;ALARM_SECONDS &amp; (0x0F&lt;&lt;0))); printf(\"\\n\\ralarm_time is:\\n\\r\\%d-%d-%d %d:%d:%d\\n\\r\",\\ alarm_time.year+2000,alarm_time.month,alarm_time.day,alarm_time.hour,alarm_time.minute,alarm_time.second); return alarm_time;&#125; 中断服务函数12345void alarm_irq(void)&#123; rtc_int_clear(); printf(\"\\n\\r----------------alarm_irq-----------------\\n\\r\");&#125; 主函数123456789101112131415161718192021222324252627282930313233343536373839404142int main()&#123; rtc_time.year = 2017; rtc_time.month = 8; //rtc_time.week = 1; rtc_time.day = 24; rtc_time.hour = 10; rtc_time.minute = 42; rtc_time.second = 15; rtc_alarm.year = 2017; rtc_alarm.month = 8; rtc_alarm.day = 24; rtc_alarm.hour = 10; rtc_alarm.minute = 42; rtc_alarm.second = 20; uart_init(); printf(\"init ok.\\n\\r\"); gic_init(); timer2_init(); rtc_init(); set_time(rtc_time); set_alarm(rtc_alarm); printf(\"=====set time and alarm is:=====\\n\\r\"); get_time(); get_alarm(); printf(\"================================\\n\\r\"); while(1) &#123; delay_ms(1000); get_time(); &#125; return 0;&#125; 3.实测与源码BUG:上电后，set_alarm()是没问题的，set_time()显示没有设置成功，这时按键复位重启一下，发现这时就设置成功了。 = = ? 源码——&gt;GitHub 4.心得RTC感觉还是比较重要，能够实现得到实时的时间。整个过程，稍微需要注意点的就是BCD的转换，容易弄错。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"AM437X","slug":"AM437X","permalink":"http://yoursite.com/tags/AM437X/"},{"name":"裸机","slug":"裸机","permalink":"http://yoursite.com/tags/裸机/"}]},{"title":"AM437x——LED驱动","date":"2017-08-12T08:06:46.000Z","path":"2017/08/12/AM437x——LED驱动/","text":"本文主要记录AM437X驱动的LED。含简单的字符设备驱动、设备驱动模型、设备树以及LED子系统。 目前就Linux驱动的理解是： Linux驱动 = 裸机 + 框架 关于框架，目前的理解是： 以LED驱动为例，之前印象中就是韦老大的思路，现在init里注册、硬件初始化，然后应用层open()、read()就调用了file_operations里面的drv_open()、drv_write()等，算是最简单的驱动框架。然后韦老大又提及了总线设备驱动模型，将设备和驱动分离，感受到了新的框架。不久前，简单接触了下设备树，感觉就是总线设备驱动模型的修改（升级），将原来的设备部分，不再单独放在代码里，而是放在dts里面，开机加载，然后驱动匹配获取硬件资源。因此，感觉驱动的框架在一步一步的发展，优化，最原始的注册、open等框架，还是不变。同时，了解到了除输入子系统的其它子系统，加深了对这一模式的理解。感觉就是，将某个硬件资源无缝的融入现有的环境中，而无须改变应用层的程序。 这就是目前的一点小小理解吧，算是打开了个入口，希望以后了解得更加全面、细致。 1.搭建开发环境1.1安装TI_SDK先在TI官网下载ti-processor-sdk-linux-am437x-evm-01.00.00.03-Linux-x86-Install.bin在Ubuntu（only Ubuntu 12.04 LTS and Ubuntu 14.04 LTS are supported）下，对该文件加入可执行权限，然后直接运行。安装目录选择默认即可。完成之后，便在当前用户的home目录生成了所有所需文件。 1.2编译内核在当前生成ti-processor-sdk-linux-am437x-evm-01.00.00.03目录下，有个Makefile，打开后可以看到相关的编译选项，如： 编译全部文件：make all 编译内核：make linux 编译u-boot:make u-boot-spl 以及make的依赖：-include Rules.make。在本层目录里，打开Rules.make，可以知道内核的默认配置文件：12#defconfigDEFCONFIG=tisdk_am437x-evm_defconfig 通过查找，tisdk_am437x-evm_defconfig在~/ti-processor-sdk-linux-am437x-evm-01.00.00.03/board-support/linux-3.14.43+gitAUTOINC+875c69b2c3-g875c69b/arch/arm/configs里。这里通过修改该配置文件，然后重新编译内核，即可关闭系统LED相关的驱动，在后面自己写LED驱动时，防止互相干扰。因此将tisdk_am437x-evm_defconfig配置文件里的所有有关LED的配置都关闭掉。 最后在顶层目录执行make linux,编译完成后，生成~/ti-processor-sdk-linux-am437x-evm-01.00.00.03/board-support/linux-3.14.43+gitAUTOINC+875c69b2c3-g875c69b/arch/arm/boot/zImage文件。 1.3烧写SD卡回到~/ti-processor-sdk-linux-am437x-evm-01.00.00.03/bin下，TI制作了很多脚本，其中的create-sdcard.sh就是制作SD卡的。Ubuntu插上SD卡，然后切换成root用户，执行该脚本，根据提示一路选择下去即可。 这里烧写完了，测试发现并没有使用之前编译的内核，分析脚本后发现，该脚本直接使用的~/ti-processor-sdk-linux-am437x-evm-01.00.00.03/filesystem下的tisdk-rootfs-image-am437x-evm.tar.gz。脚本将该文件作为根文件系统放入SD卡，因此并没有使用之前编译的内核。解决方法要么在执行脚本的过程中根据提示输入相关的路径，要么在制作好SD卡后，将编译好的内核覆盖掉SD卡的内核即可。我选择的后者：cp ~/ti-processor-sdk-linux-am437x-evm-01.00.00.03/board-support/linux-3.14.43+gitAUTOINC+875c69b2c3-g875c69b/arch/arm/boot/zImage /media/hceng/rootfs/boot/。 最后将制作好的SD卡插上开发板启动即可。 2.简单的字符驱动先记录下几个重要类型或结构体： 表示设备号(32位机中：高12位表示主设备号，低20位表示次设备号) 1typedef __kernel_dev_t dev_t; 描述字符设备 12345678struct cdev &#123; struct kobject kobj; //内嵌kobject结构体，用于设备驱动模型管理 struct module *owner; //包含指向该结构的模块的指针，用于引用计数 const struct file_operations *ops; //指向字符设备操作函数集的指针 struct list_head list; //该结构将使用该驱动的字符设备连接成一个链表 dev_t dev; //该字符设备的其实设备号，一个设备可能有多个设备号 unsigned int count; //使用该字符设备驱动的设备数量&#125;; 描述类 12345678910111213struct class&#123; const char *name; //类名称 struct module *owner; //对应模块 struct subsystem subsys; //对应的subsystem; struct list_head children; //class_device链表 struct list_head interfaces; //class_interface链表 struct semaphore sem; /用于同步的信号锁 struct class_attribute *class_attrs; //类属性 int (*uevent)(struct class_device *dev,char **envp,int num_envp, char *buffer,int buffer_size); //事件 void (*release)(struct class_device *dev); //释放类设备 void (*class_release)(struct class *class); //释放类&#125; 总结下，目前理解的字符设备编写流程: 1)驱动加载函数：xx_drv_init() 1.1)申请设备号：alloc_chrdev_region() 1.2)cde初始化(绑定fops)：cdev_init() 1.3)注册到内核：cdev_add() 1.4)创建类：class_create() 1.5)向类中添加设备(mdev自动创建设备节点)：device_create() 1.6)硬件相关(内存映射)：ioremap()2)驱动卸载函数：xx_drv_exit() 2.1)移除设备：device_destroy() 2.2)移除类：class_destroy() 2.3)注销cdev：cdev_del() 2.4)释放设备号：unregister_chrdev() 2.5)释放内存：iounmap()3)必要修饰:module_init(xx_drv_init);module_exit(xx_drv_exit);MODULE_LICENSE(&quot;GPL&quot;);4)构造file_operations:struct file_operations xx_drv_fops;5)实现file_operations里每个函数:xx_open()、xx_write()…… 2.1驱动代码[leds_drv.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;asm/io.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/cdev.h&gt;#define TI_LEDS_CNT 4int major;static struct cdev leds_cdev;static struct class *leds_cls;static volatile unsigned long *PRCM_CM_PER_GPIO5_CLKCTRL = NULL; static volatile unsigned long *CTRL_CONF_UART3_RXD = NULL; static volatile unsigned long *CTRL_CONF_UART3_TXD = NULL; static volatile unsigned long *CTRL_CONF_UART3_CTSN = NULL;static volatile unsigned long *CTRL_CONF_UART3_RTSN = NULL;static volatile unsigned long *GPIO_OE = NULL;static volatile unsigned long *GPIO_SETDATAOUT = NULL;static volatile unsigned long *GPIO_DATAOUT = NULL; static int leds_drv_open(struct inode *inode, struct file *file) &#123; int minor = iminor(file-&gt;f_inode); printk(KERN_INFO\"%s OK.\\n\",__func__); *PRCM_CM_PER_GPIO5_CLKCTRL = (0x01&lt;&lt;1); *CTRL_CONF_UART3_RXD &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18); *CTRL_CONF_UART3_RXD |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17); *GPIO_OE &amp;= ~(0x01&lt;&lt;minor); *GPIO_SETDATAOUT |= (0x01&lt;&lt;minor); return 0; &#125; static ssize_t leds_drv_write(struct file *file, const char __user *user_buf, size_t count, loff_t * ppos) &#123; int minor = iminor(file-&gt;f_inode); char buf; printk(KERN_INFO\"%s OK.\\n\",__func__); if(count != 1)&#123; printk(KERN_INFO\"write count != 1.\\n\"); return 1; &#125; if (copy_from_user(&amp;buf, user_buf, count)) return -EFAULT; if (0x01 == buf) *GPIO_DATAOUT |= (0x01&lt;&lt;minor); else if(0x00 == buf) *GPIO_DATAOUT &amp;= ~(0x01&lt;&lt;minor); return 0; &#125; static struct file_operations leds_fops = &#123; .owner = THIS_MODULE, .open = leds_drv_open, .write = leds_drv_write, &#125;;static int leds_drv_init(void)&#123; //1.申请设备号 dev_t devid; printk(KERN_INFO\"%s OK.\\n\",__func__); if(alloc_chrdev_region(&amp;devid, 0, TI_LEDS_CNT, \"ti_leds\") &lt; 0) &#123; printk(KERN_INFO\"%s ERROR.\\n\",__func__); goto error; &#125; major = MAJOR(devid); //2.注册到系统中 cdev_init(&amp;leds_cdev, &amp;leds_fops); cdev_add(&amp;leds_cdev, devid, TI_LEDS_CNT); leds_cls = class_create(THIS_MODULE, \"ti_leds\"); device_create(leds_cls, NULL, MKDEV(major, 0), NULL, \"ti_led0\"); device_create(leds_cls, NULL, MKDEV(major, 1), NULL, \"ti_led1\"); device_create(leds_cls, NULL, MKDEV(major, 2), NULL, \"ti_led2\"); device_create(leds_cls, NULL, MKDEV(major, 3), NULL, \"ti_led3\"); //3.硬件相关 PRCM_CM_PER_GPIO5_CLKCTRL = ioremap(0x44DF8800+0x498, 0x04*1); CTRL_CONF_UART3_RXD = ioremap(0x44E10000+0xA28, 0x04*4); CTRL_CONF_UART3_TXD = CTRL_CONF_UART3_RXD + 1; CTRL_CONF_UART3_CTSN = CTRL_CONF_UART3_RXD + 2; CTRL_CONF_UART3_RTSN = CTRL_CONF_UART3_RXD + 3; GPIO_OE = ioremap(0x48322000+0x134, 0x04); GPIO_DATAOUT = ioremap(0x48322000+0x13C, 0x04); GPIO_SETDATAOUT = ioremap(0x48322000+0x194, 0x04);error: unregister_chrdev_region(MKDEV(major, 0), TI_LEDS_CNT); return 0;&#125;static void leds_drv_exit(void)&#123; unsigned i; printk(KERN_INFO\"%s OK.\\n\",__func__); for(i=0;i&lt;TI_LEDS_CNT;i++) &#123; device_destroy(leds_cls, MKDEV(major, i)); &#125; class_destroy(leds_cls); cdev_del(&amp;leds_cdev); unregister_chrdev(major, \"ti_leds\"); iounmap(PRCM_CM_PER_GPIO5_CLKCTRL); iounmap(CTRL_CONF_UART3_RXD); iounmap(GPIO_OE); iounmap(GPIO_DATAOUT); iounmap(GPIO_SETDATAOUT);&#125;module_init(leds_drv_init);module_exit(leds_drv_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am437x board leds drvice\");MODULE_ALIAS(\"character device:ti_leds\");MODULE_VERSION(\"V1.0\"); 2.2测试代码(跑马灯)[leds_app.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#define msleep(x) usleep(x*1000)int main(int argc, char **argv)&#123; int fd[4]; int val = 0; int i = 0; //const char *dev[] = &#123;\"/dev/ti_led0\", \"/dev/ti_led1\", \"/dev/ti_led2\", \"/dev/ti_led3\"&#125;; const char *dev[] = &#123;\"/dev/ti_led2\", \"/dev/ti_led0\", \"/dev/ti_led3\", \"/dev/ti_led1\"&#125;; for(i=0; i&lt;4; i++) &#123; fd[i] = open(dev[i], O_RDWR); if (fd[i] &lt; 0) &#123; printf(\"can't open %s\\n\", *dev[i]); return 0; &#125; &#125; //leds off all. for(i=0; i&lt;4; i++) &#123; write(fd[i], &amp;val, 1); &#125; //flicker leds. while(1) &#123; val = !val; for(i=0; i&lt;4; i++) &#123; write(fd[i], &amp;val, 1); msleep(300); &#125; &#125;&#125; 2.3关于printk调试内核的printk定义了如下的打印等级：12345678#define KERN_EMERG &quot;&lt;0&gt;&quot; /* system is unusable */#define KERN_ALERT &quot;&lt;1&gt;&quot; /* action must be taken immediately */#define KERN_CRIT &quot;&lt;2&gt;&quot; /* critical conditions */#define KERN_ERR &quot;&lt;3&gt;&quot; /* error conditions */#define KERN_WARNING &quot;&lt;4&gt;&quot; /* warning conditions */#define KERN_NOTICE &quot;&lt;5&gt;&quot; /* normal but significant condition */#define KERN_INFO &quot;&lt;6&gt;&quot; /* informational */#define KERN_DEBUG &quot;&lt;7&gt;&quot; /* debug-level messages */ 如果使用串口登陆，可通过修改/proc/sys/kernel/printk里的参数进行设置：1echo &quot;8 4 1 7&quot; &gt;/proc/sys/kernel/printk 上面的四个数字分别代表：控制台日志级别：优先级[s1] 高于该值的消息将被打印至控制台，[s1]数值越小，优先级越高；默认的消息日志级别：将用该优先级来打印没有优先级的消息；最低的控制台日志级别：控制台日志级别可被设置的最小值(最高优先级)；默认的控制台日志级别：控制台日志级别的缺省值； 如果使用SSH登陆，是无法显示printk的打印信息的，但打印的数据会被放在/var/log/messages和/proc/kmsg中，利用这一特性，可以后台运行tail命令进行侦测：1tail -f /var/log/messages &amp; 缺点是不能设置打印等级，同时内核的其它信息也会被打印出来。 3.设备驱动模型驱动关于设备驱动模型前面以及有点了解，在写驱动的时候，主要体现在将原本的硬件资源信息抽取了出来，单独放在了一个文件里，当两个文件的分别加载的时候，根据名字匹配，匹配成功则调用probe()函数，进行类似前面的init()进行初始化。其它的内容基本一样，该干嘛就干嘛。 3.1驱动代码[leds_dev.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/delay.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;asm/irq.h&gt;#include &lt;asm/io.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/platform_device.h&gt;/************************************************** TI_BOARD --------------------------------------------------- Ball Color Mode Pin --------------------------------------------------- H24 D7_Blue 0x07 uart3_txd(GPIO5_3) H25 D8_Blue 0x07 uart3_rxd(GPIO5_2) K24 D9_Green 0x07 uart3_rtsn(GPIO5_1) H22 D10_Red 0x07 uart3_ctsn(GPIO5_0) **************************************************/static struct resource leds_resource[] = &#123; //PRCM_CM_PER_GPIO5_CLKCTRL(498h) [0] = &#123; .start = 0x44DF8800, .end = 0x44DFFFFF, .name = \"CM_PER\", .flags = IORESOURCE_MEM, &#125;, //CTRL_CONF_UART3_RXD(A28h)、CTRL_CONF_UART3_TXD(A2Ch)、CTRL_CONF_UART3_CTSN(A30h)、CTRL_CONF_UART3_RTSN((A34h)) [1] = &#123; .start = 0x44E10000, .end = 0x44E1FFFF, .name = \"CONTROL_MODULE\", .flags = IORESOURCE_MEM, &#125;, //GPIO_OE(134h)、GPIO_SETDATAOUT(194h)、GPIO_DATAOUT(13Ch) [2] = &#123; .start = 0x48322000, .end = 0x48322FFF, .name = \"GOIP5\", .flags = IORESOURCE_MEM, &#125;, [3] = &#123; .start = 0, .end = 3, .name = \"GOIP5_PIN\", .flags = IORESOURCE_IO, &#125;&#125;; static void leds_release(struct device * dev) &#123; printk(KERN_INFO\"%s OK.\\n\",__func__);&#125;static struct platform_device leds_dev = &#123; .name = \"ti_am437x_leds_platform\", .id = -1, .num_resources = ARRAY_SIZE(leds_resource), .resource = leds_resource, .dev = &#123; .release = leds_release, &#125;, &#125;;static int leds_dev_init(void) &#123; printk(KERN_INFO\"%s OK.\\n\",__func__); return platform_device_register(&amp;leds_dev);; &#125; static void leds_dev_exit(void) &#123; printk(KERN_INFO\"%s OK.\\n\",__func__); platform_device_unregister(&amp;leds_dev); &#125; module_init(leds_dev_init);module_exit(leds_dev_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am437x board leds drvice\");MODULE_ALIAS(\"platform:ti_leds\");MODULE_VERSION(\"V2.0\"); [leds_drv.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &lt;linux/module.h&gt; #include &lt;linux/version.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/interrupt.h&gt; #include &lt;linux/irq.h&gt; #include &lt;linux/sched.h&gt; #include &lt;linux/pm.h&gt; #include &lt;linux/sysctl.h&gt; #include &lt;linux/proc_fs.h&gt; #include &lt;linux/delay.h&gt; #include &lt;linux/platform_device.h&gt; #include &lt;linux/input.h&gt; #include &lt;linux/irq.h&gt; #include &lt;asm/uaccess.h&gt; #include &lt;asm/io.h&gt; #include &lt;linux/cdev.h&gt;#include &lt;asm/uaccess.h&gt;#define TI_LEDS_CNT 4int major;static struct cdev leds_cdev;static struct class *leds_cls;static volatile unsigned long *PRCM_CM_PER_GPIO5_CLKCTRL = NULL; static volatile unsigned long *CTRL_CONF_UART3_RXD = NULL; static volatile unsigned long *CTRL_CONF_UART3_TXD = NULL; static volatile unsigned long *CTRL_CONF_UART3_CTSN = NULL;static volatile unsigned long *CTRL_CONF_UART3_RTSN = NULL;static volatile unsigned long *GPIO_OE = NULL;static volatile unsigned long *GPIO_SETDATAOUT = NULL;static volatile unsigned long *GPIO_DATAOUT = NULL; static int leds_drv_open(struct inode *inode, struct file *file) &#123; int minor = iminor(file-&gt;f_inode); printk(KERN_INFO\"%s OK.\\n\",__func__); *PRCM_CM_PER_GPIO5_CLKCTRL = (0x01&lt;&lt;1); *CTRL_CONF_UART3_RXD &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18); *CTRL_CONF_UART3_RXD |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17); *GPIO_OE &amp;= ~(0x01&lt;&lt;minor); *GPIO_SETDATAOUT |= (0x01&lt;&lt;minor); return 0; &#125; static ssize_t leds_drv_write(struct file *file, const char __user *user_buf, size_t count, loff_t * ppos) &#123; int minor = iminor(file-&gt;f_inode); char buf; printk(KERN_INFO\"%s OK.\\n\",__func__); if(count != 1)&#123; printk(KERN_INFO\"write count != 1.\\n\"); return 1; &#125; if (copy_from_user(&amp;buf, user_buf, count)) return -EFAULT; if (0x01 == buf) *GPIO_DATAOUT |= (0x01&lt;&lt;minor); else if(0x00 == buf) *GPIO_DATAOUT &amp;= ~(0x01&lt;&lt;minor); return 0; &#125; static struct file_operations leds_fops = &#123; .owner = THIS_MODULE, .open = leds_drv_open, .write = leds_drv_write, &#125;; static int leds_probe(struct platform_device *pdev) &#123; struct resource *res; dev_t devid; printk(KERN_INFO\"%s OK.\\n\",__func__); //1.申请设备号 if(alloc_chrdev_region(&amp;devid, 0, TI_LEDS_CNT, \"ti_leds\") &lt; 0) &#123; printk(\"%s ERROR\\n\",__func__); goto error; &#125; major = MAJOR(devid); //2.注册到系统中 cdev_init(&amp;leds_cdev, &amp;leds_fops); cdev_add(&amp;leds_cdev, devid, TI_LEDS_CNT); leds_cls = class_create(THIS_MODULE, \"ti_leds\"); device_create(leds_cls, NULL, MKDEV(major, 0), NULL, \"ti_led0\"); device_create(leds_cls, NULL, MKDEV(major, 1), NULL, \"ti_led1\"); device_create(leds_cls, NULL, MKDEV(major, 2), NULL, \"ti_led2\"); device_create(leds_cls, NULL, MKDEV(major, 3), NULL, \"ti_led3\"); //3.硬件相关 res = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"CM_PER\"); if (!res) return -EINVAL; PRCM_CM_PER_GPIO5_CLKCTRL = ioremap(res-&gt;start+0x498, 0x04*1); res = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"CONTROL_MODULE\"); if (!res) return -EINVAL; CTRL_CONF_UART3_RXD = ioremap(res-&gt;start+0xA28, 0x04*4); CTRL_CONF_UART3_TXD = CTRL_CONF_UART3_RXD + 1; CTRL_CONF_UART3_CTSN = CTRL_CONF_UART3_RXD + 2; CTRL_CONF_UART3_RTSN = CTRL_CONF_UART3_RXD + 3; res = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"GOIP5\"); if (!res) return -EINVAL; GPIO_OE = ioremap(res-&gt;start+0x134, 0x04); GPIO_DATAOUT = ioremap(res-&gt;start+0x13C, 0x04); GPIO_SETDATAOUT = ioremap(res-&gt;start+0x194, 0x04); *PRCM_CM_PER_GPIO5_CLKCTRL = (0x01&lt;&lt;1);//使能GPIO外设时钟error: unregister_chrdev_region(MKDEV(major, 0), TI_LEDS_CNT); return 0; &#125; static int leds_remove(struct platform_device *pdev) &#123; unsigned i; printk(KERN_INFO\"%s OK.\\n\",__func__); for(i=0;i&lt;TI_LEDS_CNT;i++) &#123; device_destroy(leds_cls, MKDEV(major, i)); &#125; class_destroy(leds_cls); cdev_del(&amp;leds_cdev); unregister_chrdev(major, \"ti_leds\"); iounmap(PRCM_CM_PER_GPIO5_CLKCTRL); iounmap(CTRL_CONF_UART3_RXD); iounmap(GPIO_OE); iounmap(GPIO_DATAOUT); iounmap(GPIO_SETDATAOUT); return 0; &#125;struct platform_driver leds_drv = &#123; .probe = leds_probe, .remove = leds_remove, .driver = &#123; .name = \"ti_am437x_leds_platform\", &#125; &#125;; static int leds_drv_init(void) &#123; printk(KERN_INFO\"%s OK.\\n\",__func__); return platform_driver_register(&amp;leds_drv); &#125; static void leds_drv_exit(void) &#123; printk(KERN_INFO\"%s OK.\\n\",__func__); platform_driver_unregister(&amp;leds_drv); &#125; module_init(leds_drv_init);module_exit(leds_drv_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am437x board leds drvice\");MODULE_ALIAS(\"platform:ti_leds\");MODULE_VERSION(\"V2.0\"); 测试程序同前面的一样。 4.设备树驱动4.1初识设备树 1）前面的总线设备驱动模型中，硬件资源来自于leds_dev.c里面的信息，这样会导致不同的板子，会添加不同的硬件资源信息，造成内核的臃肿。2）使用设备树后，内核不再包含硬件的描述，硬件描述放在单独的DTS里面，然后编译成二进制的DTB，在U-Boot启动的时候加载进去，然后内核进行解析。3）DTS、DTC和DTB之间的关系：DTS经过DTC编译得到DTB，DTB通过DTC反编译得到DTS. 4）ARM中，所有的DTS文件放在arch/arm/boot/dts目录中，为了简化，将Soc公用部分提取了出来作为dtsi，类似头文件。5）DTC编译工具的源代码在scripts/dtc目录中，编译内核时，编译内核时，需要使能才能将源码编译成工具，对应于scripts/dtc/Makefile中&quot;hostprogs-y:=dtc&quot;。Ubuntu也可直接安装DTC工具：1sudo apt-get install device-tree-compiler 6)内核的arch/arm/boot/dts/Makefile中，描述了当某种Soc被选中后，哪些.dtb会编译出来。执行make dtbs，会根据arch/arm/Makefile编译指定目标。7）单独编译与反编译：12./scripts/dtc/dtc -I dts -O dtb -o xxx.dtb arch/arm/boot/dts/xxx.dts //dts-&gt;dtb./scripts/dtc/dtc -I dtb -O dts -o xxx.dts arch/arm/boot/dts/xxx.dtb //dtb-&gt;dts 8）后面认识深刻了，再总结总结。 4.2修改AM437x设备树AM437x的设备树文件在~/ti-processor-sdk-linux-am437x-evm-01.00.00.03/board-support/linux-3.14.43+gitAUTOINC+875c69b2c3-g875c69b/arch/arm/boot/dts/中，主要是am4372.dtsi和am437x-sk-evm.dts。我的目的是希望写个设备树框架的LED程序，因此想让am437x-sk-evm.dts干净点，只包含LED硬件描述，因此我需要删除am437x-sk-evm.dts里面的其它硬件描述。经过测试，am437x-sk-evm.dts里面包含部分MMC的描述，一旦删除将不能成功启动内核。而且，后面调试的时候，希望开发板通过NFS挂载的方式，直接加载编译的驱动模块，因此需要保留网卡描述部分。最后，将MMC和网卡必须的部分，提取了出来，放在了am4372.dtsi中。精简后的am437x-sk-evm.dts内容如下：[am437x-sk-evm.dts]link1234567891011121314151617181920212223242526272829303132333435363738/* AM437x SK EVM *//dts-v1/;#include \"am4372.dtsi\"#include &lt;dt-bindings/pinctrl/am43xx.h&gt;#include &lt;dt-bindings/gpio/gpio.h&gt;/ &#123; model = \"TI AM437x SK EVM\"; compatible = \"ti,am437x-sk-evm\",\"ti,am4372\",\"ti,am43\"; led_pin &#123; compatible = \"ti_leds\"; pinctrl-names = \"default\"; pinctrl-0 = &lt;&amp;leds_pins&gt;; am437x,led_gpio0 = &lt;&amp;gpio5 0 GPIO_ACTIVE_HIGH&gt;; am437x,led_gpio1 = &lt;&amp;gpio5 1 GPIO_ACTIVE_HIGH&gt;; am437x,led_gpio2 = &lt;&amp;gpio5 2 GPIO_ACTIVE_HIGH&gt;; am437x,led_gpio3 = &lt;&amp;gpio5 3 GPIO_ACTIVE_HIGH&gt;; &#125;;&#125;;&amp;am43xx_pinmux &#123; leds_pins: leds_pins &#123; pinctrl-single,pins = &lt; 0x228 (PIN_OUTPUT | MUX_MODE7) /* uart3_rxd.gpio5_2 */ 0x22c (PIN_OUTPUT | MUX_MODE7) /* uart3_txd.gpio5_3 */ 0x230 (PIN_OUTPUT | MUX_MODE7) /* uart3_ctsn.gpio5_0 */ 0x234 (PIN_OUTPUT | MUX_MODE7) /* uart3_rtsn.gpio5_1 */ &gt;; &#125;;&#125;;&amp;gpio5 &#123; status = \"okay\";&#125;;额，在调试的过程中，需要不断编译新的DTB和复制到SD卡的rootfs分区中，仿照前面写了个脚本进行自动编译和复制，同时检查文件的生成时间间隔，实际中，确实减少了焦躁的重复操作。 4.3驱动代码[leds_drv.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include &lt;linux/module.h&gt; #include &lt;linux/version.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/interrupt.h&gt; #include &lt;linux/irq.h&gt; #include &lt;linux/sched.h&gt; #include &lt;linux/pm.h&gt; #include &lt;linux/sysctl.h&gt; #include &lt;linux/proc_fs.h&gt; #include &lt;linux/delay.h&gt; #include &lt;linux/platform_device.h&gt; #include &lt;linux/input.h&gt; #include &lt;linux/irq.h&gt; #include &lt;asm/uaccess.h&gt; #include &lt;asm/io.h&gt; #include &lt;linux/cdev.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;linux/of_gpio.h&gt;#define TI_LEDS_CNT 4int major;static struct cdev leds_cdev;static struct class *leds_cls;static int led0,led1,led2,led3; static int leds_drv_open(struct inode *inode, struct file *file) &#123; printk(KERN_INFO\"%s OK.\\n\",__func__); return 0; &#125; static ssize_t leds_drv_write(struct file *file, const char __user *user_buf, size_t count, loff_t * ppos) &#123; int minor = iminor(file-&gt;f_inode); char buf; printk(KERN_INFO\"%s OK.\\n\",__func__); if(count != 1)&#123; printk(KERN_INFO\"write count != 1.\\n\"); return 1; &#125; if (copy_from_user(&amp;buf, user_buf, count)) return -EFAULT; if(0x01 == buf) &#123; switch(minor)&#123; case 0: gpio_set_value(led0, 0); break; case 1: gpio_set_value(led1, 0); break; case 2: gpio_set_value(led2, 0); break; case 3: gpio_set_value(led3, 0); break; default: printk(KERN_INFO\"%s receive minor error.\\n\",__func__); &#125; &#125; else if(0x00 == buf) &#123; switch(minor)&#123; case 0: gpio_set_value(led0, 1); break; case 1: gpio_set_value(led1, 1); break; case 2: gpio_set_value(led2, 1); break; case 3: gpio_set_value(led3, 1); break; default: printk(KERN_INFO\"%s receive minor error\\n\",__func__); &#125; &#125; return 0; &#125; static struct file_operations leds_fops = &#123; .owner = THIS_MODULE, .open = leds_drv_open, .write = leds_drv_write, &#125;; static int leds_probe(struct platform_device *pdev) &#123; struct device *dev = &amp;pdev-&gt;dev; dev_t devid; printk(KERN_INFO\"%s OK.\\n\",__func__); //1.申请设备号 if(alloc_chrdev_region(&amp;devid, 0, TI_LEDS_CNT, \"ti_leds\") &lt; 0) &#123; printk(KERN_INFO\"%s ERROR.\\n\",__func__); goto error; &#125; major = MAJOR(devid); //2.注册到系统中 cdev_init(&amp;leds_cdev, &amp;leds_fops); cdev_add(&amp;leds_cdev, devid, TI_LEDS_CNT); leds_cls = class_create(THIS_MODULE, \"ti_leds\"); device_create(leds_cls, NULL, MKDEV(major, 0), NULL, \"ti_led0\"); device_create(leds_cls, NULL, MKDEV(major, 1), NULL, \"ti_led1\"); device_create(leds_cls, NULL, MKDEV(major, 2), NULL, \"ti_led2\"); device_create(leds_cls, NULL, MKDEV(major, 3), NULL, \"ti_led3\"); //3.硬件相关 led0 = of_get_named_gpio(dev-&gt;of_node, \"am437x,led_gpio0\", 0);; led1 = of_get_named_gpio(dev-&gt;of_node, \"am437x,led_gpio1\", 0);; led2 = of_get_named_gpio(dev-&gt;of_node, \"am437x,led_gpio2\", 0);; led3 = of_get_named_gpio(dev-&gt;of_node, \"am437x,led_gpio3\", 0); //printk(KERN_INFO\"led0 = %d\\n\",led0); //printk(KERN_INFO\"led1 = %d\\n\",led1); //printk(KERN_INFO\"led2 = %d\\n\",led2); //printk(KERN_INFO\"led3 = %d\\n\",led3); devm_gpio_request_one(dev, led0, GPIOF_OUT_INIT_HIGH, \"LED0\"); devm_gpio_request_one(dev, led1, GPIOF_OUT_INIT_HIGH, \"LED1\"); devm_gpio_request_one(dev, led2, GPIOF_OUT_INIT_HIGH, \"LED2\"); devm_gpio_request_one(dev, led3, GPIOF_OUT_INIT_HIGH, \"LED3\");error: unregister_chrdev_region(MKDEV(major, 0), TI_LEDS_CNT); return 0; &#125; static int leds_remove(struct platform_device *pdev) &#123; unsigned i; printk(KERN_INFO\"%s OK.\\n\",__func__); for(i=0;i&lt;TI_LEDS_CNT;i++) &#123; device_destroy(leds_cls, MKDEV(major, i)); &#125; class_destroy(leds_cls); cdev_del(&amp;leds_cdev); unregister_chrdev(major, \"ti_leds\"); return 0; &#125;static const struct of_device_id of_gpio_leds_match[] = &#123; &#123; .compatible = \"ti_leds\", &#125;, &#123;&#125;,&#125;;static struct platform_driver leds_drv = &#123; .probe = leds_probe, .remove = leds_remove, .driver = &#123; .name = \"ti_am437x_leds_platform\", .owner = THIS_MODULE, .of_match_table = of_match_ptr(of_gpio_leds_match), &#125;,&#125;;static int leds_drv_init(void) &#123; printk(KERN_INFO\"%s OK.\\n\",__func__); return platform_driver_register(&amp;leds_drv); &#125; static void leds_drv_exit(void) &#123; printk(KERN_INFO\"%s OK.\\n\",__func__); platform_driver_unregister(&amp;leds_drv); &#125; module_init(leds_drv_init);module_exit(leds_drv_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"hceng &lt;huangcheng.job@foxmail.com&gt;\");MODULE_DESCRIPTION(\"TI am437x board leds drvice\");MODULE_ALIAS(\"platform:device tree:ti_leds\");MODULE_VERSION(\"V3.0\"); 测试程序同前面的一样。 5.LED子系统驱动留个挂念，以后再添加。 6.心得在我理解到驱动=裸机+软件框架的时候，我对之前的裸机也就没那么排斥了。而且这个软件框架，就现在来看，核心的那几步像：申请设备号、注册设备、创建类和创建节点这些都不变，早晚会做。所以，我算入门了吗？😀下一步，开始另一个阶段~ 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"AM437X","slug":"AM437X","permalink":"http://yoursite.com/tags/AM437X/"},{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"}]},{"title":"Linux开发环境配置及shell script","date":"2017-08-05T03:37:41.000Z","path":"2017/08/05/Linux开发环境配置及shell-script/","text":"本文主要是以快速搭建环境为目标学习shell script。 之前写过一个Linux嵌入式开发环境搭建的博客，后面每次搭环境都翻来复制上面的代码。感觉就像记事本一样，还是有点用，这也是写博客的一点动力吧。用了Linux也有段时间了，它的魅力也逐渐展现出来了。以前还在熟悉Linux命令的过程中，shell script就是个老虎，觉得没接触过，害怕，每次都绕开它。直到这周遇到了ti的SDK，尝试一边百度，一边测它的脚本，感觉有点小入门了，于是想练习下。想到每次搭建环境重复操作的痛点，就拿它开刀吧。 0.环境搭建的几个方面根据过去的经验，用虚拟机装好Ubuntu后，一般会做这样几个步骤： 1.安装vmware tools,以便复制粘贴和文件共享；2.更新软件源，以便更快的下载软件；3.安装及配置常用软件，比如： 3-1.安装git,方面后续的一些安装； 3-2.安装vim和简单配置； 3-3.安装ftp和简单配置； 3-4.安装nfs和简单配置； 3-5.安装samba和简单配置； 3-6.安装tmux、htop等；4.安装开发所需的 g++等工具、库； 除了第一步，其它都计划用脚本实现。 在开发中，厌烦了每次编辑了驱动，都要拖进Linux主机进行编译，然后还要复制到开发板。重新打造了工作流，只需要在电脑上操作三步：编辑-&gt;make编译-&gt;insmod加载 1.检测当前环境在运行脚本前，需要检测一些东西： 1.1检测网络状态如果不能联网，后续的没必要做了。之前想过自动检测修复网络的，但想了想，网络的情况比较多，暂时搁置。而且刚装好虚拟机肯定是联网的，如果不能联网肯定是虚拟机设置的问题，也不是脚本能解决的。为了方便打印醒目和更改用户名，这里先设置几个变量：12345678910#define echo print color.RED_COLOR='\\E[1;31m' PINK_COLOR='\\E[1;35m' YELOW_COLOR='\\E[1;33m' BLUE_COLOR='\\E[1;34m' GREEN_COLOR='\\E[1;32m' END_COLOR='\\E[0m' #set linux host user name.user_name=hceng 检测网络函数：123456789check_network() &#123; ping -c 1 www.baidu.com &gt; /dev/null 2&gt;&amp;1 if [ $? -eq 0 ];then echo -e \"$&#123;GREEN_COLOR&#125;Network ok.$&#123;END_COLOR&#125;\" else echo -e \"$&#123;RED_COLOR&#125;Network failure!$&#123;END_COLOR&#125;\" exit 1 fi&#125;先ping一次百度，能够ping通就表示网络没问题。 1.2检测是否是root用户很多操作都需要root权限，因此必须使用root用户权限运行脚本，这里先检测是否是root用户：1234567# Check user must root.check_root() &#123; if [ $(id -u) != \"0\" ]; then echo -e \"$&#123;RED_COLOR&#125;Error: You must be root to run this script, please use root.$&#123;END_COLOR&#125;\" exit 1 fi&#125; 1.3检测设置的用户是否存在现在用的用户名是hceng，后面为了方便其它用户使用，所以在前面定义了个变量，改变变量就可以修改用户。但为了防止设置的用户在系统中不存在，这里需要进行检测。12345678910# Check set linux host user name.check_user_name() &#123; cat /etc/passwd|grep $user_name if [ $? -eq 0 ];then echo -e \"$&#123;GREEN_COLOR&#125;Check the set user name OK.$&#123;END_COLOR&#125;\" else echo -e \"$&#123;RED_COLOR&#125;Check the set user name failure!$&#123;END_COLOR&#125;\" exit 1 fi&#125; 1.4检测运行结果为检测某些命令，是否运行正常。1234567check_status() &#123; ret=$? if [ \"$ret\" -ne \"0\" ]; then echo -e \"$&#123;RED_COLOR&#125;Failed setup, aborting..$&#123;END_COLOR&#125;\" exit 1 fi&#125; 1.5获取系统版本信息后面更新源和装某些软件需要当前Ubuntu的版本代号。123456# Get the code name of the Linux host release to the caller.get_host_type() &#123; local __host_type=$1 local the_host=`lsb_release -a 2&gt;/dev/null | grep Codename: | awk &#123;'print $2'&#125;` eval $__host_type=\"'$the_host'\"&#125; 2.更新软件源这里使用了阿里、网易和官方的三个源，应该没问题了。修改配置文件的原则就是先备份再修改。同时为了防止脚本再次运行覆盖掉备份，还需要检测是否已经存在了备份。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#This function will update the source of the software.update_software_source() &#123; local back_file=/etc/apt/sources.list.backup if [ ! -e \"$back_file\" ];then cp /etc/apt/sources.list $back_file fi check_status get_host_type host_release check_status echo \\ \"#Ali source. deb-src http://archive.ubuntu.com/ubuntu $host_release main restricted deb http://mirrors.aliyun.com/ubuntu/ $host_release main restricted deb-src http://mirrors.aliyun.com/ubuntu/ $host_release main restricted multiverse universe deb http://mirrors.aliyun.com/ubuntu/ $host_release-updates main restricted deb-src http://mirrors.aliyun.com/ubuntu/ $host_release-updates main restricted multiverse universe deb http://mirrors.aliyun.com/ubuntu/ $host_release universe deb http://mirrors.aliyun.com/ubuntu/ $host_release-updates universe deb http://mirrors.aliyun.com/ubuntu/ $host_release multiverse deb http://mirrors.aliyun.com/ubuntu/ $host_release-updates multiverse deb http://mirrors.aliyun.com/ubuntu/ $host_release-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ $host_release-backports main restricted universe multiverse deb http://archive.canonical.com/ubuntu $host_release partner deb-src http://archive.canonical.com/ubuntu $host_release partner deb http://mirrors.aliyun.com/ubuntu/ $host_release-security main restricted deb-src http://mirrors.aliyun.com/ubuntu/ $host_release-security main restricted multiverse universe deb http://mirrors.aliyun.com/ubuntu/ $host_release-security universe deb http://mirrors.aliyun.com/ubuntu/ $host_release-security multiverse #Netease source. deb http://mirrors.163.com/ubuntu/ $host_release main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ $host_release-security main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ $host_release-updates main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ $host_release-proposed main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ $host_release-backports main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release-security main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release-updates main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release-proposed main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release-backports main restricted universe multiverse #Official source deb http://archive.ubuntu.com/ubuntu/ $host_release main restricted universe multiverse deb http://archive.ubuntu.com/ubuntu/ $host_release-security main restricted universe multiverse deb http://archive.ubuntu.com/ubuntu/ $host_release-updates main restricted universe multiverse deb http://archive.ubuntu.com/ubuntu/ $host_release-proposed main restricted universe multiverse deb http://archive.ubuntu.com/ubuntu/ $host_release-backports main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release-security main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release-updates main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release-proposed main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release-backports main restricted universe multiverse\" \\ &gt; /etc/apt/sources.list check_status #apt-get update 1&gt;/dev/null apt-get update check_status echo -e \"$&#123;GREEN_COLOR&#125;Update source completed.$&#123;END_COLOR&#125;\" &#125; 3.安装软件及配置软件主要包括自己一般常用的软件，像vim、tmux、samba等。还有就是开发所需的g++、各种库。其中git要在vim前面，因为vim的配置文件需要git下载。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# Execute an action.FA_DoExec() &#123; echo -e \"$&#123;BLUE_COLOR&#125;==&gt; Executing: '$&#123;@&#125;'.$&#123;END_COLOR&#125;\" eval $@ || exit $?&#125;# Install list software.install_software() &#123; local install_software_list=(\"git\" \"vim\" \"tmux\" \"htop\" \"vsftpd\" \"openssh-server\" \"nfs-kernel-server\" \"portmap\" \"samba\") echo -e \"$&#123;PINK_COLOR&#125;install_software_list:$&#123;install_software_list[*]&#125;.$&#123;END_COLOR&#125;\" #install git if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"git\");then apt-get -y install git &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;git install completed.$&#123;END_COLOR&#125;\" fi #install and configure vim if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"vim\");then apt-get -y install vim &amp;&amp; vim_configure &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;vim install completed.$&#123;END_COLOR&#125;\" fi #install tmux if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"tmux\");then apt-get -y install tmux &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;tmux install completed.$&#123;END_COLOR&#125;\" fi #install htop if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"htop\");then apt-get -y install htop &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;htop install completed.$&#123;END_COLOR&#125;\" fi #install and configure vsftpd if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"vsftpd\");then apt-get -y install vsftpd &amp;&amp; ftp_configure &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;vsftpd install completed.$&#123;END_COLOR&#125;\" fi #install openssh-server if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"openssh-server\");then apt-get -y install openssh-server &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;openssh-server install completed.$&#123;END_COLOR&#125;\" fi #install and configure nfs-kernel-server if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"nfs-kernel-server\");then apt-get -y install nfs-kernel-server &amp;&amp; nfs_configure &amp;&amp; \\ /etc/init.d/nfs-kernel-server restart &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;nfs-kernel-server install completed.$&#123;END_COLOR&#125;\" fi #install portmap if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"portmap\");then apt-get -y install portmap &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;portmap install completed.$&#123;END_COLOR&#125;\" fi #install and configure samba if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"samba\");then apt-get -y install samba &amp;&amp; samba_configure &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;samba install completed.$&#123;END_COLOR&#125;\" fi #others get_host_type host_release FA_DoExec apt-get -y install \\ gnupg flex bison gperf build-essential \\ zip curl libc6-dev libncurses5-dev libncurses5-dev:i386 x11proto-core-dev \\ libx11-dev:i386 libreadline6-dev:i386 \\ libgl1-mesa-glx-lts-$host_release:i386 libgl1-mesa-dev-lts-$host_release \\ g++-multilib mingw32 tofrodos libncurses5-dev:i386 \\ python-markdown libxml2-utils xsltproc zlib1g-dev:i386 if [ ! -h /usr/lib/i386-linux-gnu/libGL.so ]; then FA_DoExec ln -s /usr/lib/i386-linux-gnu/mesa/libGL.so.1 \\ /usr/lib/i386-linux-gnu/libGL.so fi # Development support FA_DoExec apt-get -y install \\ dos2unix minicom gawk echo -e \"$&#123;GREEN_COLOR&#125;software install completed.$&#123;END_COLOR&#125;\"&#125; 3.1配置vimvim的配置文件来自GitHub的Amir,我就不重复造轮子了。这里只是先clone下来，然后执行安装脚本。这里值得一提的是执行脚本要指定用户运行，不然会以root用户的路径设置，导致脚本运行错误。1234567891011# Configure vim form github.vim_configure() &#123; git clone --depth=1 https://github.com/amix/vimrc.git /home/$user_name/.vim_runtime touch /home/$user_name/.vim_runtime/my_configs.vim echo \":set number\" &gt; /home/$user_name/.vim_runtime/my_configs.vim chown -R $user_name /home/$user_name/.vim_runtime chmod u+x /home/$user_name/.vim_runtime/install_awesome_vimrc.sh su - $user_name -s /home/$user_name/.vim_runtime/install_awesome_vimrc.sh&#125; 3.2配置ftpFTP主要是修改为可写。在使用MobaXterm SSH登陆后，可以直接通过左边的Sftp进行文件的传输，貌似这个可以不用配置了。12345# Configure ftp.ftp_configure() &#123; sed -i 's/#loacl_enable=YES/loacl_enable=YES/g' /etc/vsftpd.conf sed -i 's/#write_enable=YES/write_enable=YES/g' /etc/vsftpd.conf&#125; 3.3配置nfs在前面的工作流中，开发板直接运行Linux主机中交叉编译好的模块，是通过nfs实现的。因此需要开发板开机后就挂载nfs.习惯在Linux主机中单独开辟一个路径作为工作目录，因此这里是设置的整个工作目录。12345678910111213# Configure nfs.nfs_configure() &#123; local work_file=/work if [ ! -d \"$work_file\" ];then mkdir /work fi check_status grep \"/work\" /etc/exports 1&gt;/dev/null if [ $? -ne 0 ];then sed -i '$a\\/work *(rw,sync,no_root_squash,no_subtree_check)' /etc/exports fi&#125; 3.4配置sambasamba也是实现前面工作流不可确少的一环。这样就不用每次修改代码后，通过ftp上传到Linux主机。samba在Windows上的使用是：先Windows+r，打开命令窗口，然后输入：\\\\192.168.1.xx，最后建议右键，映射网络驱动，方面后续打开。测试中需要重启生效。1234567891011121314151617181920212223# Configure samba.samba_configure() &#123; local back_file=/etc/samba/smb.conf.bakup if [ ! -e \"$back_file\" ];then cp /etc/samba/smb.conf $back_file fi check_status grep \"/work\" /etc/samba/smb.conf 1&gt;/dev/null if [ $? -ne 0 ];then sed -i \\ '$a[share_work]\\n\\ path = \\/work\\n\\ available = yes\\n\\ public = yes\\n\\ guest ok = yes\\n\\ read only = no\\n\\ writeable = yes\\n' /etc/samba/smb.conf fi /etc/init.d/samba restart chmod -R 777 /work&#125; 4.完整代码及心得[setup_ubuntu_host_env.sh]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#!/bin/bash# -------------------------------------------------------------------------------# Filename: setup_ubuntu_host_env.sh# Revision: 1.0# Date: 2017/08/05# Author: hceng# Email: huangcheng.job@foxmail.com# Website: www.hceng.cn# Function: setup ubuntu host env.# Notes: learn# -------------------------------------------------------------------------------## Description: #1.check env.#1.1 check network #1.2 check use root #1.3 check set name #1.4 configure samba #2.update software sourcev. #3.install vim tmux htop ftp ssh nfs samba.#3.1 configure vim #3.2 configure ftp #3.3 configure nfs #3.4 configure samba #4.install system tool eg:g++ ...## -------------------------------------------------------------------------------#define echo print color.RED_COLOR='\\E[1;31m' PINK_COLOR='\\E[1;35m' YELOW_COLOR='\\E[1;33m' BLUE_COLOR='\\E[1;34m' GREEN_COLOR='\\E[1;32m' END_COLOR='\\E[0m' #Set linux host user name.user_name=hceng# Check network.check_network() &#123; ping -c 1 www.baidu.com &gt; /dev/null 2&gt;&amp;1 if [ $? -eq 0 ];then echo -e \"$&#123;GREEN_COLOR&#125;Network OK.$&#123;END_COLOR&#125;\" else echo -e \"$&#123;RED_COLOR&#125;Network failure!$&#123;END_COLOR&#125;\" exit 1 fi&#125;# Check user must root.check_root() &#123; if [ $(id -u) != \"0\" ]; then echo -e \"$&#123;RED_COLOR&#125;Error: You must be root to run this script, please use root.$&#123;END_COLOR&#125;\" exit 1 fi&#125;# Check set linux host user name.check_user_name() &#123; cat /etc/passwd|grep $user_name if [ $? -eq 0 ];then echo -e \"$&#123;GREEN_COLOR&#125;Check the set user name OK.$&#123;END_COLOR&#125;\" else echo -e \"$&#123;RED_COLOR&#125;Check the set user name failure!$&#123;END_COLOR&#125;\" exit 1 fi&#125;# Check the results of the operation.check_status() &#123; ret=$? if [ \"$ret\" -ne \"0\" ]; then echo -e \"$&#123;RED_COLOR&#125;Failed setup, aborting..$&#123;END_COLOR&#125;\" exit 1 fi&#125;# Get the code name of the Linux host release to the caller.get_host_type() &#123; local __host_type=$1 local the_host=`lsb_release -a 2&gt;/dev/null | grep Codename: | awk &#123;'print $2'&#125;` eval $__host_type=\"'$the_host'\"&#125;#This function will update the source of the software.update_software_source() &#123; local back_file=/etc/apt/sources.list.backup if [ ! -e \"$back_file\" ];then cp /etc/apt/sources.list $back_file fi check_status get_host_type host_release check_status echo \\ \"#Ali source. deb-src http://archive.ubuntu.com/ubuntu $host_release main restricted deb http://mirrors.aliyun.com/ubuntu/ $host_release main restricted deb-src http://mirrors.aliyun.com/ubuntu/ $host_release main restricted multiverse universe deb http://mirrors.aliyun.com/ubuntu/ $host_release-updates main restricted deb-src http://mirrors.aliyun.com/ubuntu/ $host_release-updates main restricted multiverse universe deb http://mirrors.aliyun.com/ubuntu/ $host_release universe deb http://mirrors.aliyun.com/ubuntu/ $host_release-updates universe deb http://mirrors.aliyun.com/ubuntu/ $host_release multiverse deb http://mirrors.aliyun.com/ubuntu/ $host_release-updates multiverse deb http://mirrors.aliyun.com/ubuntu/ $host_release-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ $host_release-backports main restricted universe multiverse deb http://archive.canonical.com/ubuntu $host_release partner deb-src http://archive.canonical.com/ubuntu $host_release partner deb http://mirrors.aliyun.com/ubuntu/ $host_release-security main restricted deb-src http://mirrors.aliyun.com/ubuntu/ $host_release-security main restricted multiverse universe deb http://mirrors.aliyun.com/ubuntu/ $host_release-security universe deb http://mirrors.aliyun.com/ubuntu/ $host_release-security multiverse #Netease source. deb http://mirrors.163.com/ubuntu/ $host_release main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ $host_release-security main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ $host_release-updates main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ $host_release-proposed main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ $host_release-backports main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release-security main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release-updates main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release-proposed main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ $host_release-backports main restricted universe multiverse #Official source deb http://archive.ubuntu.com/ubuntu/ $host_release main restricted universe multiverse deb http://archive.ubuntu.com/ubuntu/ $host_release-security main restricted universe multiverse deb http://archive.ubuntu.com/ubuntu/ $host_release-updates main restricted universe multiverse deb http://archive.ubuntu.com/ubuntu/ $host_release-proposed main restricted universe multiverse deb http://archive.ubuntu.com/ubuntu/ $host_release-backports main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release-security main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release-updates main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release-proposed main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu/ $host_release-backports main restricted universe multiverse\" \\ &gt; /etc/apt/sources.list check_status #apt-get update 1&gt;/dev/null apt-get update check_status echo -e \"$&#123;GREEN_COLOR&#125;Update source completed.$&#123;END_COLOR&#125;\" &#125;# Configure vim form github.vim_configure() &#123; git clone --depth=1 https://github.com/amix/vimrc.git /home/$user_name/.vim_runtime touch /home/$user_name/.vim_runtime/my_configs.vim echo \":set number\" &gt; /home/$user_name/.vim_runtime/my_configs.vim chown -R $user_name /home/$user_name/.vim_runtime chmod u+x /home/$user_name/.vim_runtime/install_awesome_vimrc.sh su - $user_name -s /home/$user_name/.vim_runtime/install_awesome_vimrc.sh&#125;# Configure ftp.ftp_configure() &#123; sed -i 's/#loacl_enable=YES/loacl_enable=YES/g' /etc/vsftpd.conf sed -i 's/#write_enable=YES/write_enable=YES/g' /etc/vsftpd.conf&#125;# Configure nfs.nfs_configure() &#123; local work_file=/work if [ ! -d \"$work_file\" ];then mkdir /work fi grep \"/work\" /etc/exports 1&gt;/dev/null if [ $? -ne 0 ];then sed -i '$a\\/work *(rw,sync,no_root_squash,no_subtree_check)' /etc/exports fi&#125;# Configure samba.samba_configure() &#123; local back_file=/etc/samba/smb.conf.bakup if [ ! -e \"$back_file\" ];then cp /etc/samba/smb.conf $back_file fi check_status grep \"/work\" /etc/samba/smb.conf 1&gt;/dev/null if [ $? -ne 0 ];then sed -i \\ '$a[share_work]\\n\\ path = \\/work\\n\\ available = yes\\n\\ public = yes\\n\\ guest ok = yes\\n\\ read only = no\\n\\ writeable = yes\\n' /etc/samba/smb.conf fi /etc/init.d/samba restart chmod -R 777 /work&#125;# Execute an action.FA_DoExec() &#123; echo -e \"$&#123;BLUE_COLOR&#125;==&gt; Executing: '$&#123;@&#125;'.$&#123;END_COLOR&#125;\" eval $@ || exit $?&#125;# Install list software.install_software() &#123; local install_software_list=\\ (\"git\" \"vim\" \"tmux\" \"htop\" \"vsftpd\" \"openssh-server\" \"nfs-kernel-server\" \"portmap\" \"samba\") echo -e \"$&#123;PINK_COLOR&#125;install_software_list:$&#123;install_software_list[*]&#125;.$&#123;END_COLOR&#125;\" #install git if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"git\");then apt-get -y install git &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;git install completed.$&#123;END_COLOR&#125;\" fi #install and configure vim if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"vim\");then apt-get -y install vim &amp;&amp; vim_configure &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;vim install completed.$&#123;END_COLOR&#125;\" fi #install tmux if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"tmux\");then apt-get -y install tmux &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;tmux install completed.$&#123;END_COLOR&#125;\" fi #install htop if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"htop\");then apt-get -y install htop &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;htop install completed.$&#123;END_COLOR&#125;\" fi #install and configure vsftpd if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"vsftpd\");then apt-get -y install vsftpd &amp;&amp; ftp_configure &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;vsftpd install completed.$&#123;END_COLOR&#125;\" fi #install openssh-server if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"openssh-server\");then apt-get -y install openssh-server &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;openssh-server install completed.$&#123;END_COLOR&#125;\" fi #install and configure nfs-kernel-server if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"nfs-kernel-server\");then apt-get -y install nfs-kernel-server &amp;&amp; nfs_configure &amp;&amp; \\ /etc/init.d/nfs-kernel-server restart &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;nfs-kernel-server install completed.$&#123;END_COLOR&#125;\" fi #install portmap if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"portmap\");then apt-get -y install portmap &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;portmap install completed.$&#123;END_COLOR&#125;\" fi #install and configure samba if (echo \"$&#123;install_software_list[@]&#125;\" | grep -wq \"samba\");then apt-get -y install samba &amp;&amp; samba_configure &amp;&amp; echo -e \"$&#123;BLUE_COLOR&#125;samba install completed.$&#123;END_COLOR&#125;\" fi #others get_host_type host_release FA_DoExec apt-get -y install \\ gnupg flex bison gperf build-essential \\ zip curl libc6-dev libncurses5-dev libncurses5-dev:i386 x11proto-core-dev \\ libx11-dev:i386 libreadline6-dev:i386 \\ libgl1-mesa-glx-lts-$host_release:i386 libgl1-mesa-dev-lts-$host_release \\ g++-multilib mingw32 tofrodos libncurses5-dev:i386 \\ python-markdown libxml2-utils xsltproc zlib1g-dev:i386 if [ ! -h /usr/lib/i386-linux-gnu/libGL.so ]; then FA_DoExec ln -s /usr/lib/i386-linux-gnu/mesa/libGL.so.1 \\ /usr/lib/i386-linux-gnu/libGL.so fi # Development support FA_DoExec apt-get -y install \\ dos2unix minicom gawk echo -e \"$&#123;GREEN_COLOR&#125;software install completed.$&#123;END_COLOR&#125;\"&#125;check_networkcheck_rootcheck_user_nameupdate_software_sourceinstall_softwareecho -e \"$&#123;GREEN_COLOR&#125;===================================================$&#123;END_COLOR&#125;\" echo -e \"$&#123;GREEN_COLOR&#125;============setup ubuntu host env ok!==============$&#123;END_COLOR&#125;\" echo -e \"$&#123;GREEN_COLOR&#125;===================================================$&#123;END_COLOR&#125;\"su $user_name exit 0 就目前来看，shell脚本还不算太难。主要就是提取某个文本内容，然后做出判断，对应执行。技巧性还是蛮多的，很有乐趣。遇到要实现某个功能，百度一下也基本有。调试的时候，能够打印出变量，或者提出局部代码进行运行测试，还是很方便的。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/环境搭建/"},{"name":"shell script","slug":"shell-script","permalink":"http://yoursite.com/tags/shell-script/"}]},{"title":"AM437x——LED裸机","date":"2017-07-28T15:09:15.000Z","path":"2017/07/28/AM437x——LED裸机/","text":"最近在玩AM437X，记录下一些学习过程。分为裸机和驱动。 0.准备文件 AM437x EVM Schematic（后称原理图YP） am4378（后称芯片手册SP） spruhl7g（后称参考手册CP） 1.分析原理图四个LED灯，单片机通过控制三极管的通断，从而控制灯的亮灭。单片机高电平，三极管打通，灯亮，反之低电平，LED灭。D7_Blue 对应uart3_txd(GPIO5_3)；D8_Blue 对应uart3_rxd(GPIO5_2)；D9_Green 对应uart3_rtsn(GPIO5_1)；D10_Red 对应uart3_ctsn(GPIO5_0)； 2.编写程序1.使能GPIO外设时钟；1PRCM_CM_PER_GPIO5_CLKCTRL = (0x01&lt;&lt;1); 2.设置GPIO模式（默认使能了上拉，且为GPIO模式）；12345678CTRL_CONF_UART3_RXD &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18);//使能上/下拉、关闭输入CTRL_CONF_UART3_RXD |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17);//IO模式，设置上拉CTRL_CONF_UART3_TXD &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18);//使能上/下拉、关闭输入CTRL_CONF_UART3_TXD |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17);//IO模式，设置上拉CTRL_CONF_UART3_RTSN &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18);//使能上/下拉、关闭输入CTRL_CONF_UART3_RTSN |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17);//IO模式，设置上拉CTRL_CONF_UART3_CTSN &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18);//使能上/下拉、关闭输入CTRL_CONF_UART3_CTSN |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17);//IO模式，设置上拉 3.设置为输出；1GPIO5-&gt;OE &amp;= ~(0x01&lt;&lt;0 | 0x01&lt;&lt;1 | 0x01&lt;&lt;2 | 0x01&lt;&lt;3); 4.设置允许输出位;1GPIO5-&gt;SETDATAOUT |= (0x01&lt;&lt;0 | 0x01&lt;&lt;1 | 0x01&lt;&lt;2 | 0x01&lt;&lt;3); 5.设置输出值;12GPIO5-&gt;DATAOUT |= (0x01&lt;&lt;0 | 0x01&lt;&lt;1 | 0x01&lt;&lt;2 | 0x01&lt;&lt;3);//高GPIO5-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;0 | 0x01&lt;&lt;1 | 0x01&lt;&lt;2 | 0x01&lt;&lt;3);//低 6.封装成函数;将前面的1-4步，封装为void led_init(void);1234567891011121314151617void led_init(void)&#123; PRCM_CM_PER_GPIO5_CLKCTRL = (0x01&lt;&lt;1); CTRL_CONF_UART3_RXD &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18); CTRL_CONF_UART3_RXD |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17); CTRL_CONF_UART3_TXD &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18); CTRL_CONF_UART3_TXD |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17); CTRL_CONF_UART3_RTSN &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18); CTRL_CONF_UART3_RTSN |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17); CTRL_CONF_UART3_CTSN &amp;= ~(0x7&lt;&lt;0 | 0x01&lt;&lt;16 | 0x01&lt;&lt;17 | 0x01&lt;&lt;18); CTRL_CONF_UART3_CTSN |= (0x7&lt;&lt;0 | 0x01&lt;&lt;17); GPIO5-&gt;OE &amp;= ~(0x01&lt;&lt;0 | 0x01&lt;&lt;1 | 0x01&lt;&lt;2 | 0x01&lt;&lt;3); GPIO5-&gt;SETDATAOUT |= (0x01&lt;&lt;0 | 0x01&lt;&lt;1 | 0x01&lt;&lt;2 | 0x01&lt;&lt;3);&#125;将前面的第5步根据需求，封装成分别操作每个灯；总开关（1开0关）：1234567void led_switch(unsigned char on_off)&#123; if(on_off) GPIO5-&gt;DATAOUT |= (0x01&lt;&lt;0 | 0x01&lt;&lt;1 | 0x01&lt;&lt;2 | 0x01&lt;&lt;3); else GPIO5-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;0 | 0x01&lt;&lt;1 | 0x01&lt;&lt;2 | 0x01&lt;&lt;3);&#125; 每个灯的独立开关（1开0关）：12345678910111213141516171819202122232425262728293031void led0_switch(unsigned char on_off)&#123; if(on_off) GPIO5-&gt;DATAOUT |= (0x01&lt;&lt;0); else GPIO5-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;0);&#125;void led1_switch(unsigned char on_off)&#123; if(on_off) GPIO5-&gt;DATAOUT |= (0x01&lt;&lt;1); else GPIO5-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;1);&#125;void led2_switch(unsigned char on_off)&#123; if(on_off) GPIO5-&gt;DATAOUT |= (0x01&lt;&lt;2); else GPIO5-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;2);&#125;void led3_switch(unsigned char on_off)&#123; if(on_off) GPIO5-&gt;DATAOUT |= (0x01&lt;&lt;3); else GPIO5-&gt;DATAOUT &amp;= ~(0x01&lt;&lt;3);&#125; 3.下载设置AM437X支持多种方式启动，比如：flash memory, memory cards and UART, USB, or Ethernet.以后估计使用U盘和SD卡的情况居多。U盘和SD卡启动对image有一定的格式要求，需要加个头信息。该部分在参考手册5.2.9 Image Format有介绍，后面有时间再分析。 这里直接用现成的tiimage.c进行加头操作。tiimage.c和程序的交叉编译，都是在Linux进行的，需要做如下步骤：1.清理，交叉编译；2.编译，加头；3.重命名；4.复制到SD卡（U盘）； 为了方便，写了脚本完成以上操作，只需要插上U盘（Windows下），然后ssh登陆执行脚本即可。关于工作流的想法，后面找个时间写写。 [hceng_am437x_create_MLO.sh]link123456789101112131415161718192021222324252627282930313233#!/bin/bashmyPath=\"/mnt/hgfs/windows/\" #利用虚拟机\"文件共享\"WindowsU盘的路径RED_COLOR='\\E[1;31m' #红GREEN_COLOR='\\E[1;32m' #绿YELOW_COLOR='\\E[1;33m' #黄BLUE_COLOR='\\E[1;34m' #蓝PINK='\\E[1;35m' #粉红RES='\\E[0m' #END#生成MLOfunction creat_MLO()&#123; rm -f /mnt/hgfs/windows/MLO make clean make gcc ./image_tool/tiimage.c -o tiimage.out ./tiimage.out 0x40300000 MMCSD am437x_hardware.bin /mnt/hgfs/windows/MLO rm -f *.dis *.bin *.o *_elf tiimage.out ls /mnt/hgfs/windows/MLO -l &amp;&amp; echo -e \"$&#123;GREEN_COLOR&#125;======MLO OK!======$&#123;RES&#125;\"\\ || echo -e \"$&#123;RED_COLOR&#125;======MLO ERROR!======$&#123;RES&#125;\" sync&#125;#判断U盘路径是否存在；#存在则生成MLO、拷贝，不存在则提示报错if [ ! -d \"$myPath\" ];then echo -e \"$&#123;RED_COLOR&#125;======Check USB Disk!======$&#123;RES&#125;\" else creat_MLO fi syncexit 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"AM437X","slug":"AM437X","permalink":"http://yoursite.com/tags/AM437X/"},{"name":"裸机","slug":"裸机","permalink":"http://yoursite.com/tags/裸机/"}]},{"title":"2017年中","date":"2017-07-23T14:51:19.000Z","path":"2017/07/23/2017年中/","text":"2017年中，毕业、工作之际。0x00:距离上次博客，过去两个月了。返校答辩后，不知为何，情绪低落了小半个月。0x01:过去的两个月里，搬出了公司，换了一个我还算比较喜欢的房子。接来女朋友，过上了两个人的小日子。趁着618免息，换了个快一万的笔记本。收到了毕业证和学位证，拿到了转正后的第一份工资。搭了梯子，翻了墙，看了看外面的世界……0x02:之前一直准备更新博客，但突然发现一些图片挂掉了，重新规划了一下图床的方案，却又突然好了。但不管怎样，博客还得继续做下去。0x03:工作内容挺杂的，唯一感到满足的终于开始独立的写Linux驱动了和看英文手册写裸机，虽然才是开始，路还很长，但至少开了头。0x04:确实还在迷茫，工作让我巩固基础，但也让我觉得没有跨越。其实很简单，想清楚自己目的是什么，需要什么，要做什么，先做什么，后做什么。给自己点压力，让自己跑起来。2017年中，新的开始。0x05: 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"移植MiniGUI到JZ2440","date":"2017-05-26T01:46:37.000Z","path":"2017/05/26/移植MiniGUI到JZ2440/","text":"尝试将MiniGUI到JZ2440上。移植所需文件： 文件包名 作用 libminigui-1.6.10.tar.gz MiniGUI开发库 minigui-res-1.6.10.tar.gz MiniGUI资源文件 mg-samples-1.6.10.tar.gz MiniGUI示例程序 tslib-1.4.tar.gz 触摸屏功能 1.移植MiniGUI1.1 解压、编译MiniGUI开发库123456tar xzf libminigui-1.6.10.tar.gzcd libminigui-1.6.10/mkdir tmp./configure CC=arm-linux-gcc --prefix=$&#123;PWD&#125;/tmp --build=i386-linux --host=arm-linux --target=arm-linuxmakemake install 完成上面操作，即可在tmp目录下生成以下文件： 将生成的/lib下所有文件(和共享库相关)拷贝到开发板/lib目录下，将生成的/etc下的MiniGUI.cfg也拷贝到开发板/etc目录下:12cp –rfd ./lib/* /work/hceng/nfs_rootfs/libcp ./etc/* /work/hceng/nfs_rootfs/etc 1.2 解压MiniGUI资源文件12tar xzf minigui-res-1.6.10.tar.gzcd minigui-res-1.6.10/ 修改config.linux，指定生成文件路径： 编译生成：1make install 此时会在指定的/tmp目录下生成以下文件： 这些文件包含了MiniGUI会使用到的资源，包括基本字体、图标、位图和鼠标光标等，将这些文件全部复制到开发板的/usr/local/lib/minigui/res/路径下，这个路径是前面MiniGUI.cfg指定的。 1.3 编译MiniGUI示例程序 解压、配置、编译：12345tar xzf mg-samples-1.6.10.tar.gzcd mg-samples-1.6.10.tar.gz/./configure CC=arm-linux-gcc --build=i386-linux --host=arm-linux -target=arm-linux CFLAGS=-I/work/minigui/libminigui-1.6.10/tmp/include LDFLAGS=-L/work/minigui/libminigui-1.6.10/tmp/libmakemake install 此时会在/src目录下生成示例程序： 复制示例程序到开发板里面去，注意有些程序需要本目录下的图片文件，需要一同拷贝过去。这里以helloworld为例：1cp helloworld /work/hceng/nfs_rootfs/ 1.4 其他修改 修改前面复制到开发板/etc目录下的MiniGUI.cfg以适应JZ2440。 在开发板的/etc目录下建立ld.so.conf文件，并添加如下内容：123/usr/local/lib/usr/lib/lib 在/etc/init.d/rcS脚本文件里添加如下内容(非必需)：1/bin/ln –s /dev/vc/0 /dev/tty0 移植MiniGUI完成，运行应用程序： 2.移植tslib2.1 安装一些工具123sudo apt-get install autoconfsudo apt-get install automakesudo apt-get install libtool 2.2 解压、编译123456789tar xzf tslib-1.4.tar.gzcd tslib./autogen.sh mkdir tmpecho &quot;ac_cv_func_malloc_0_nonnull=yes&quot; &gt;arm-linux.cache./configure --host=arm-linux --cache-file=arm-linux.cache --prefix=$(pwd)/tmpmakemake install 2.3 安装12cd tmpcp * -rfd /work/hceng/nfs_rootfs 2.4 修改/etc/ts.conf第1行(去掉#号和第一个空格)1# module_raw input 改为：1module_raw input 2.5 在开发板设置环境变量123456export TSLIB_TSDEVICE=/dev/event0export TSLIB_CALIBFILE=/etc/pointercalexport TSLIB_CONFFILE=/etc/ts.confexport TSLIB_PLUGINDIR=/lib/tsexport TSLIB_CONSOLEDEVICE=noneexport TSLIB_FBDEVICE=/dev/fb0 2.6 运行校准示例程序1ts_calibrate 如果在运行程序的时候，出现提示：1selected device is not a touchscreen I understand 有显示，但无法触屏，可能是编译器版本和内核版本不一致，解决方法如下： 修改编译器的input.h：12cd /usr/local/arm/4.3.2/arm-none-linux-gnueabi/libc/usr/include/linuxsudo vim input.h 将1#define EV_VERSION 0x010000 改为：1#define EV_VERSION 0x010001 重新进行前面的编译即可，编译后，记得改回编译器的版本。 3.MiniGUI和tslib链接 此时虽然分别移植好了MiniGUI和tslib，但触屏并不能正常的控制GUI，需要进行将MiniGUI和tslib进行链接。 使用MiniGUI 的 IAL 引擎，修改/libminigui-1.6.10/src/ial/下的dummy.c成如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include \"common.h\"#include \"tslib.h\"#ifdef _DUMMY_IAL#include &lt;sys/ioctl.h&gt;#include &lt;sys/poll.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;linux/kd.h&gt;#include \"ial.h\"#include \"dummy.h\"#ifndef _DEBUG#define _DEBUG // for debugging#endif/* for storing data reading from /dev/touchScreen/0raw */typedef struct &#123; unsigned short pressure; unsigned short x; unsigned short y; unsigned short pad;&#125; TS_EVENT;static unsigned char state [NR_KEYS];static int mousex = 0;static int mousey = 0;static TS_EVENT ts_event;static struct tsdev *ts;/************************ Low Level Input Operations **********************//** Mouse operations -- Event*/static int mouse_update(void)&#123; return 1;&#125;static void mouse_getxy(int *x, int* y)&#123; if (mousex &lt; 0) mousex = 0; if (mousey &lt; 0) mousey = 0; if (mousex &gt; 639) mousex = 639; if (mousey &gt; 479) mousey = 479;#ifdef _DEBUG // printf (\"mousex = %d, mousey = %d/n\", mousex, mousey);#endif *x = mousex; *y = mousey;&#125;static int mouse_getbutton(void)&#123; return ts_event.pressure;&#125;#ifdef _LITE_VERSIONstatic int wait_event (int which, int maxfd, fd_set *in, fd_set *out, fd_set *except, struct timeval *timeout)#elsestatic int wait_event (int which, fd_set *in, fd_set *out, fd_set *except, struct timeval *timeout)#endif&#123; struct ts_sample sample; int ret = 0; int fd; fd_set rfds; int e; if (!in) &#123; in = &amp;rfds; FD_ZERO (in); &#125;fd = ts_fd(ts); if ((which &amp; IAL_MOUSEEVENT) &amp;&amp; fd &gt;= 0) &#123; FD_SET (fd, in);#ifdef _LITE_VERSION if (fd &gt; maxfd) maxfd = fd;#endif &#125;#ifdef _LITE_VERSION e = select (maxfd + 1, in, out, except, timeout) ;#else e = select (FD_SETSIZE, in, out, except, timeout) ;#endif if (e &gt; 0) &#123; // input events is coming if (fd &gt; 0 &amp;&amp; FD_ISSET (fd, in)) &#123; FD_CLR (fd, in); ts_event.x=0; ts_event.y=0; ret = ts_read(ts, &amp;sample, 1); if (ret &lt; 0) &#123; perror(\"ts_read()\"); exit(-1); &#125; ts_event.x = sample.x; ts_event.y = sample.y; ts_event.pressure = (sample.pressure &gt; 0 ? 4:0); // if (ts_event.pressure &gt; 0 &amp;&amp; if((ts_event.x &gt;= 0 &amp;&amp; ts_event.x &lt;= 639) &amp;&amp; (ts_event.y &gt;= 0 &amp;&amp; ts_event.y &lt;= 479)) &#123; mousex = ts_event.x; mousey = ts_event.y; // printf(\"ts_event.x is %d, ts_event.y is %d-------------------------------------&gt;/n\",ts_event.x ,ts_event.y); &#125;//#ifdef _DEBUG // if (ts_event.pressure &gt; 0) &#123; // printf (\"mouse down: ts_event.x = %d, ts_event.y = %d,ts_event.pressure = %d/n\",ts_event.x,ts_event.y,ts_event.pressure); // &#125;//#endif ret |= IAL_MOUSEEVENT; return (ret); &#125; &#125; else if (e &lt; 0) &#123; return -1; &#125; return (ret);&#125;BOOL InitDummyInput(INPUT* input, const char* mdev, const char* mtype)&#123; char *ts_device = NULL; if ((ts_device = getenv(\"TSLIB_TSDEVICE\")) != NULL) &#123; // open touch screen event device in blocking mode ts = ts_open(ts_device, 0); &#125; else &#123;#ifdef USE_INPUT_API ts = ts_open(\"/dev/input/0raw\", 0);#else ts = ts_open(\"/dev/touchscreen/ucb1x00\", 0);#endif &#125;#ifdef _DEBUG printf (\"TSLIB_TSDEVICE is open!!!!!!!!!!!/n\");#endif if (!ts) &#123; perror(\"ts_open()\"); exit(-1); &#125; if (ts_config(ts)) &#123; perror(\"ts_config()\"); exit(-1); &#125; input-&gt;update_mouse = mouse_update; input-&gt;get_mouse_xy = mouse_getxy; input-&gt;set_mouse_xy = NULL; input-&gt;get_mouse_button = mouse_getbutton; input-&gt;set_mouse_range = NULL; input-&gt;wait_event = wait_event; mousex = 0; mousey = 0; ts_event.x = ts_event.y = ts_event.pressure = 0; return TRUE;&#125;void TermDummyInput(void)&#123; if (ts) ts_close(ts);&#125;#endif /* _DUMMY_IAL */ 指定tslib 相关的头文件和共享库文件重新编译libminigui: 12cd /work/minigui/libminigui-1.6.10/./configure CC=arm-linux-gcc --prefix=$&#123;PWD&#125;/tmp --build=i386-linux --host=arm-linux --target=arm-linux CFLAGS=&quot;-I/work/minigui/tslib/tmp/include -L/work/minigui/tslib/tmp/lib -lts&quot; 将新生成的/tmp/lib下的文件覆盖掉开发板原来的文件： 1cp –rfd ./lib/* /work/hceng/nfs_rootfs/lib 因为共享文件变了，这里重新编译示例程序libminigui: 1./configure CC=arm-linux-gcc --build=i386-linux --host=arm-linux -target=arm-linux CFLAGS=-I/work/minigui/libminigui-1.6.10/tmp/include LDFLAGS=-L/work/minigui/libminigui-1.6.10/tmp/lib 再将生成的应用程序复制到开发板重新运行： 1cp painter /work/hceng/nfs_rootfs/ 在开发板运行： 1./ painter 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/环境搭建/"}]},{"title":"PCB_Ruler","date":"2017-05-18T13:48:04.000Z","path":"2017/05/18/PCB-Ruler/","text":"这是一个毕业的故事。0x00 初衷： 即将大学毕业，大家在一起了四年，所以想在毕业之际准备个小东西作为纪念品。在考虑专业特色、有意义（有一定实用性）且价格不贵这些因素后，我想到做这个PCB_Ruler也许可以。 0x01 过程： 整个过程 两个人利用空闲时间制作，进行了一个多月，进行了三次大修改和PCB打样，投入1000多元。最后做了150块，分别送给了两个班87名同学、若干本专业的任课老师和行政老师等。 0x02 功能： 主要功能是测量，有cm和mil两种，其中cm是日常常用的，mil是pcb制作中一种比较通用的单位。 正面：直尺功能、有常见的电阻电容、元器件的封装参考；过孔的孔径大小参考； 背面：走线线宽参考；元器件的脚间距参考；纪念信息； 0x03 效果： 0x04 致谢： 感谢和我一起制作的同学@小冲冲，抽出空余时间，一同完成本设计。 0x05 权限：东西开源啦，开源地址：https://github.com/hceng/learn/tree/master/PCB_Ruler 0x06 毕业照： 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"PCB","slug":"PCB","permalink":"http://yoursite.com/tags/PCB/"},{"name":"设计","slug":"设计","permalink":"http://yoursite.com/tags/设计/"}]},{"title":"Linux环境编程学习","date":"2017-04-30T15:55:30.000Z","path":"2017/04/30/Linux环境编程/","text":"记录Linux环境下的编程，0基础开始，不断更新。最近在学习Linux环境编程，仿佛打开了新世界的大门。初学，认知有局限，不断修正。 文件相关1.fopen[1-fopen.c]link1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; FILE * fp; unsigned int i = 0; fp = fopen(argv[1], \"w\"); if(fp == NULL) &#123; printf(\"Unable to fopen \\n\"); return -1; &#125;/* printf(\"argc = %d\\n\",argc); for(i; i&lt;argc; i++) &#123; printf(\"argv[%d]=%s\\n\",i,argv[i]); &#125;*/ printf(\"read success \\n\"); fclose(fp); return 0;&#125; 测试结果：分析： fopen的第一个参数：argv[1]，是运行fopen时传入的参数 hceng.txt.fopen对其写操作，但没有这个文件，就自动创建了该文件。 2.fopen_max[2-fopen_max.c]link1234567891011121314#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; FILE * fp; int count = 0; fclose(stdin); while((fp = fopen(argv[1], \"r\")) != NULL) count++; printf(\"count = %d \\n\", count); return 0;&#125; 测试结果：分析： 意味着一个文件最多被打开1022次。 3. fgetc[3-fgetc.c]link123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; FILE * fp; fp = fopen(argv[1], \"r\"); if(fp == NULL) &#123; printf(\"Unable to fopen\\n\"); return -1; &#125; char ch = fgetc(fp); ch = fgetc(fp); ch = fgetc(fp); //printf(\"ch = %c \\n\", ch); fputc(ch, stdout); putchar(10); fclose(fp); return 0;&#125; 测试结果：分析： fgetc每次得到一个字符（且自动跳到下一个字符），fputc这里指定ch写到标准输出流。putchar是输出一个字符的意思，这里参数10换成ascii码是换行。 4. cat[4-cat.c]link1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; FILE *fp_r; char ch; fp_r = fopen(argv[1], \"r\"); if(fp_r == NULL) &#123; // printf(\"Unable to fopen \\n\"); fprintf(stdout, \"Unable to fopen \\n\"); return -1; &#125; while((ch = fgetc(fp_r)) != EOF) &#123; //printf(\"%c\",ch); fputc(ch, stdout); &#125; fclose(fp_r); return 0;&#125; 测试结果：分析： 实现类似cat的命令，fgetc一直获取字符到结尾，然后fputc依次打印出来。 5. cp[5-cp.c]link123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; FILE *fp_r, *fp_w; char ch; fp_r = fopen(argv[1], \"r\"); if(fp_r == NULL) &#123; fprintf(stdout,\"Unable to fopen fp_r\\n\"); return -1; &#125; fp_w = fopen(argv[2], \"w\"); if(fp_w == NULL) &#123; fprintf(stdout, \"Unable to fopen fp_w \\n\"); &#125; while((ch = fgetc(fp_r)) != EOF) &#123; fputc(ch, fp_w); &#125; fclose(fp_r); fclose(fp_w); return 0;&#125; 测试结果：分析： 实现类似cp的命令，fgetc一直获取argv[1]字符到结尾，然后fputc写到argv[2]。 6. line[6-line.c]link1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; FILE *fp_r; char ch; int line = 0; fp_r = fopen(argv[1], \"r\"); if(fp_r == NULL) &#123; fprintf(stdout, \"Unable to fopen \\n\"); return -1; &#125; while((ch = fgetc(fp_r)) != EOF) &#123; if(ch == '\\n') line++; &#125; printf(\"line = %d \\n\",line); fclose(fp_r); return 0;&#125; 测试结果：分析： 获取文件行数，fgetc一直读到结尾，遇到\\n则表示换行，即行数+1。 7. fgets[7-fgets.c]link1234567891011121314151617181920212223#include &lt;stdio.h&gt;#define N 32int main(int argc, const char *argv[])&#123; FILE *fp_r; char buf[N] = &#123;0&#125;; fp_r = fopen(argv[1], \"r\"); if(fp_r == NULL) &#123; fprintf(stdout, \"Unable to fopen fp_r \\n\"); return -1; &#125; fgets(buf, 32, fp_r); fputs(buf, stdout); fclose(fp_r); return 0;&#125; 测试结果：分析： 获取文件字符串，这里要设置读取的字符串的长度，感觉有点局限。应该是识别以\\n结尾，这里一次只读取了一行。 8. fgets_cp[8-fgets_cp.c]link123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#define N 32int main(int argc, const char *argv[])&#123; FILE *fp_r, *fp_w; char buf[N] = &#123;0&#125;; fp_r = fopen(argv[1], \"r\"); if(fp_r == NULL) &#123; fprintf(stdout, \"Unable to fopen fp_r \\n\"); return -1; &#125; fp_w = fopen(argv[2], \"w\"); if(fp_w == NULL) &#123; fprintf(stdout, \"Unable to fopen fp_w \\n\"); return -1; &#125; while(fgets(buf, 16, fp_r) != NULL) fputs(buf, fp_w); fclose(fp_r); fclose(fp_w); return 0;&#125; 测试结果：分析： 以fgets的方式获取一行，写入另一个文件，以实现cp的功能。判断的依据是fgets获取的是非空 9. fread_fwrite[9-fread_fwrite.c]link12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#define N 32int main(int argc, const char *argv[])&#123; FILE *fp_r, *fp_w; char buf[N] = &#123;0&#125;; fp_r = fopen(argv[1], \"r\"); if(fp_r == NULL) &#123; fprintf(stdout, \"Unable to fopen fp_r\\n\"); return -1; &#125; fp_w = fopen(argv[2], \"w\"); if(fp_w == NULL) &#123; fprintf(stdout, \"Unable to fopen fp_w\\n\"); return -1; &#125; size_t bytes = fread(buf, 5, 3, fp_r); fwrite(buf, 5, 2, fp_w); //printf(\"bytes = %d \\n\",bytes); return 0;&#125; 测试结果：分析： fread/ fwrite第一个参数是指向读取/写入的缓冲数据，第二个参数是定义每个数据类型的大小，第三个是定义的数据类型个数，最后是指向操作的文件指针。 10.实例 时间编程题目要求：编程读写一个文件test.txt，每隔1秒向文件中写入一行数据，类似这样：1, 2007-7-30 15:16:422, 2007-7-30 15:16:43该程序应该无限循环，直到按Ctrl-C中断程序。再次启动程序写文件时可以追加到原文件之后，并且序号能够接续上次的序号，比如：1, 2007-7-30 15:16:422, 2007-7-30 15:16:433, 2007-7-30 15:19:024, 2007-7-30 15:19:035, 2007-7-30 15:19:04 提示：要追加写入文件，同时要读取该文件的内容以决定下一个序号是几，应该用什么模式打开文件？首先判断一下打开的文件是否为新文件，如果是新文件，就从序号1开始写入；如果不是新文件，则统计原来有多少行，比如有n行，然后从序号n+1开始写入。以后每写一行就把行号加1。获取当前的系统时间需要调用函数time()，得到的结果是一个time_t类型，其实就是一个大整数，其值表示从UTC时间1970年1月1日00:00:00（称为UNIX的Epoch时间）到当前时刻的秒钟数。然后调用localtime()将time_t所表示的UTC时间转换为本地时间（我们是+8区，比UTC多8个小时）并转成struct tm类型，该类型的各数据成员分别表示年月日时分秒，请自己写出转换格式的代码，不要使用ctime()或asctime()函数。具体用法请查阅man page。time和localtime函数需要头文件time.h。调用sleep(n)可使程序睡眠n秒，该函数需要头文件unistd.h [hceng_time.c]link1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/************************************************************************* &gt; File Name: hceng_time.c &gt; Author:hceng &gt; Mail: huangcheng.job@foxmail.com &gt; Created Time: Wed 26 Apr 2017 06:48:22 AM UTC ************************************************************************/#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;int main(int argc, const char *argv[])&#123; FILE *fd; char ch; unsigned int line = 0; time_t *get_time; struct tm *local_time; //add data to file fd = fopen(argv[1], \"a+\"); if(fd == NULL) &#123; fprintf(stderr,\"can't open file!\"); return -1; &#125; //get line while((ch = fgetc(fd)) != EOF) &#123; if(ch == '\\n') ++line; &#125; //show while(1) &#123; time(get_time); local_time = localtime(get_time); fprintf(fd,\"%d. %d-%d-%d %d:%d:%d\\n\",++line,local_time-&gt;tm_year+1900,local_time-&gt;tm_mon,local_time-&gt;tm_mday,local_time-&gt;tm_hour,local_time-&gt;tm_min,local_time-&gt;tm_sec); printf(\"%d. %d-%d-%d %d:%d:%d\\n\",line,local_time-&gt;tm_year+1900,local_time-&gt;tm_mon,local_time-&gt;tm_mday,local_time-&gt;tm_hour,local_time-&gt;tm_min,local_time-&gt;tm_sec); fflush(fd); sleep(1); &#125; fclose(fd); return 0;&#125; 测试结果：分析： 先以追加的方式打开文件（没有则创建），然后获取文件行数，再获取时间且转换成本地时间，然后按格式要求打印信息。 进程相关1.fork1[fork.c]link12345678910111213141516171819202122232425262728293031#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; pid_t pid; printf(\"hello world\\n\"); pid = fork(); printf(\"pid = %d\\n\",pid); if(pid &lt; 0) &#123; perror(\"Unable to fork\"); return -1; &#125; if(pid == 0) &#123; //子进程 printf(\"child process parent %d ,child = %d\\n\",getppid(), getpid()); &#125; else &#123; //父进程: printf(\"parent process = %d, child = %d\\n\", getpid(), pid); &#125; while(1); return 0;&#125; 测试结果：分析： 首先父进程fork了自己，返回了子进程的PID，并打印出来。然后继续执行，打印出自己的PID和子进程PID。子进程产生了和父进程一模一样的代码，然后从fork处开始执行，子进程fork返回的的固定为0，然后getppi打印出父进程PID，getpid打印出自己的PID。 从PS可以看到父进程PID为：11370，子进程为：11371. 注：一般fork后是父进程继续运行，但如果父进程时间片用完了，则子进程会先进行，所以这里的打印顺序是不确定的，如果要确定，需要同步。 2.fork2[fork_1.c]link12345678910111213141516171819202122232425262728#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; pid_t pid; pid = fork(); if(pid &lt; 0) &#123; perror(\"Unable to fork\"); return -1; &#125; if(pid == 0) &#123; //子进程 printf(\"child process parent %d ,child = %d\\n\",getppid(), getpid()); &#125; else &#123; //父进程: printf(\"parent process = %d, child = %d\\n\", getpid(), pid); while(1); &#125; return 0;&#125; 测试结果：分析： 这里父进程有个whileh会一直执行，二子程序没有。在PS中可以看到子进程（12173）被标记为defunct(僵尸进程)。 在Linux系统中，一个进程结束了，但是他的父进程没有等待(调用wait / waitpid)他，那么他将变成一个僵尸进程。当用ps命令观察进程的执行状态时，看到这些进程的状态栏为defunct。僵尸进程是一个早已死亡的进程，但在进程表（processs table）中仍占了一个位置（slot）。 但是如果该进程的父进程已经先结束了，那么该进程就不会变成僵尸进程。因为每个进程结束的时候,系统都会扫描当前系统中所运行的所有进程，看看有没有哪个进程是刚刚结束的这个进程的子进程，如果是的话，就由Init进程来接管他，成为他的父进程，从而保证每个进程都会有一个父进程。而Init进程会自动wait其子进程,因此被Init接管的所有进程都不会变成僵尸进程。 3.fork3[fork_2.c]link123456789101112131415161718192021222324252627282930313233343536#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;wait.h&gt;int main(int argc, const char *argv[])&#123; pid_t pid; pid = fork(); if(pid &lt; 0) &#123; perror(\"Unable to fork\"); return -1; &#125; if(pid == 0) &#123; //子进程 printf(\"child process parent %d ,child = %d\\n\",getppid(), getpid()); exit(0); &#125; else &#123; //父进程: int status; sleep(4); wait(&amp;status); printf(\"child exit\\n\"); sleep(4); printf(\"parent status = %d\\n\", status); &#125; return 0;&#125; 测试结果：分析： 这里多了个wait来监控子进程。当父进程执行wait时，立即被阻塞，直到子进程退出，才继续执行后续的。第一个sleep(4)时，PS看到父进程为15167,子进程15168为僵尸状态，执行wait时，自动回收僵尸进程。等回收完了，父进程结束阻塞，继续执行到结束。 4.exit和_exit12345678910111213#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;//#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; printf(\"hello world\"); _exit(5); //exit(5); printf(\"hello Shenzhen\\n\"); return 0;&#125; 123456789101112#include &lt;stdio.h&gt;//#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; printf(\"hello world\"); //_exit(5); exit(5); printf(\"hello Shenzhen\\n\"); return 0;&#125; 123456789101112#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;//#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; printf(\"hello world\\n\"); _exit(5); //exit(5); printf(\"hello Shenzhen\\n\"); return 0;&#125; 分析： _exit()执行后立即返回给内核，而exit()要先执行一些清除操作，然后将控制权交给内核。调用_exit函数时，其会关闭进程所有的文件描述符，清理内存以及其他一些内核清理函数，但不会刷新流(stdin, stdout, stderr …)。exit函数是在_exit函数之上的一个封装，其会调用_exit，并在调用之前先刷新流。因此才会看到遇到_exit并不会打印，因为数据在“IO缓存”，而exit会刷新流，导致打印输出。 带三个例子加个\\n，使用_exit也打印出来了， printf函数就是使用缓冲I/O的方式，该函数在遇到“\\n”换行符时自动的从缓冲区中将记录读出。 参考文章 5.daemon1、何为守护进程？（1）daemon:守护进程、 后台程序简称是d，（一般带有d的都是守护进程）（2）长期运行： 从系统启动时开始运行，到系统关闭时结束(运行周期)（3）与控制台脱离（终端）：守护进程启动后，脱离控制台，不受终端控制，背后的问题是会话（4）服务器：是一个应用程序，使用时直接调用定义： 是一个在后台运行，并且不受终端控制的服务程序！2、编写守护进程（1）创建父子进程，父进程退出 （孤儿进程）（2）在子进程中设置新的会话 （setsid）（3）改变当前目录为根目录（4）重设文件权限掩码 （增加对文件操作灵活性）（5）关闭所有文件描述符创建完守护进程之后，要加入服务程序，并且要在while循环之中实现。参考文章1；参考文章2； [dameon.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; pid_t pid; pid = fork(); if(pid &lt; 0) &#123; perror(\"Unable to fork\"); exit(1); &#125; if(pid == 0) &#123; //创建新的会话，让子进程成为会话组的领导者，不受终端控制 setsid(); //改变当前目录为根目录 chdir(\"/\"); //重设文件权限掩码 umask(0); //关闭打开的文件描述符 int i, fd_w; char buf[] = &#123;\"hello world\\n\"&#125;; //getdtablesize()返回这个进程的文件描述表的项数 for(i = 0; i &lt; getdtablesize(); i++) close(i); fd_w = open(\"/test123.txt\", O_CREAT | O_WRONLY | O_APPEND, 0666); if(fd_w &lt; 0) &#123; perror(\"Unalbe to open\"); exit(1); &#125; while(1) &#123; write(fd_w, buf, 20); sleep(1); &#125; close(fd_w); &#125; else &#123; exit(0); &#125; return 0;&#125; 测试结果：ps -ajx分析： 守护进程用于一直后台运行，且不受终端控制。编写守护程序有5步，参考前面的介绍。 6.exec[exec.c]link12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; printf(\"hello start \\n\");#if 1 if(execl(\"/bin/ls\", \"ls\", \"-l\", \"-a\", NULL) &lt; 0) &#123; perror(\"Unable to execl\"); exit(1); &#125;#endif#if 0 if(execlp(\"ls\", \"ls\", \"-l\", \"-a\", NULL) &lt; 0) &#123; perror(\"Unable to execl\"); exit(1); &#125;#endif#if 0 char *arg[] = &#123;\"ls\", \"-la\", NULL&#125;; if(execv(\"/bin/ls\", arg) &lt; 0) &#123; perror(\"Unable to execl\"); exit(1); &#125;#endif printf(\"hello end \\n\"); return 0;&#125; 测试结果：分析： 这里的三个exec系列函数的效果都是一样的。调用某个新程序后，就把自己覆盖了，所以最后的hello end才没打印。 区别如下： 带“p”的表示PATH有关； 带“l”的表示list,与数组有关； 带“v”的表示vector； 带“e”的表示environment，将使用调用者的environ； 线程相关 线程是什么？线程是一个轻量级的进程，内核也会调度线程，线程在进程当中创建。 进程和线程的区别？线程没有自己独享的资源，因此没有自己的地址空间，他要依附在进程的地址空间中借助进程的资源运行。线程优点：数据共享很简单，创建线程的要快于创建进程；线程缺点：安全性、相互之间容易影响、有限的虚拟地址空间； 线程间如何实现通信？ 全局变量、数组 线程标识符：用来唯一的表示一个线程，通过调用线程库来实现对线程的访问操作。 线程相关函数：1、创建 –》 pthread_create2、回收线程 –》 pthread_join3、结束线程 –》 pthread_exit4、线程销毁 –》 pthread_destroy 1.pthread1234567891011int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);功能：创建线程参数：thread 线程对象attr 线程属性默认为NULL，栈的空间大小是8Mstart_routine 函数指针，用来指向函数名arg 参数，作为函数指针的参数返回值：成功： 0失败： 错误码 123void pthread_exit(void *arg)功能： 线程结束函数参数： 传递线程退出时的状态值 12345pthread_join（pthread_t pthread， void**retval）功能：线程回收函数（阻塞等待，直到等到线程退出了，会立即释放）参数： pthread 线程对象retval 线程退出时的状态值 [pthread.c]link12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void *pthread_fun(void * arg)&#123; int i = 20; printf(\"*arg = %d \\n\", *(int *)arg); while(i--) &#123; printf(\"pthread i = %d \\n\", i); sleep(1); if(i == 10) pthread_exit(\"pthread exit\"); &#125;&#125;int main(int argc, const char *argv[])&#123; pthread_t tid; int num = 18; if(pthread_create(&amp;tid, NULL, pthread_fun, &amp;num) != 0) &#123; perror(\"Unable to pthread_create\"); exit(1); &#125; printf(\"pthread start \\n\"); void * ret; pthread_join(tid, &amp;ret); printf(\"pthread end %s \\n\", (char *)ret); return 0;&#125; 测试结果：分析： pthread_create创建线程pthread_fun，并传入参数&amp;num，然后主进程调用pthread_join等待线程。线程每隔1s打印输出，直到i = 10时，调用pthread_exit结束线程，同时传递状态值pthread exit到pthread_join。主进程再打印出状态值后退出。 注意：编译的时候加上-pthread 2.mutex不加互斥锁：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;pthread_mutex_t lock;int value_1, value_2;void *pthread_fun(void * arg)&#123; while(1) &#123; //pthread_mutex_lock(&amp;lock); if(value_1 == value_2) &#123; printf(\"value_1 = %d, value_2 = %d\\n\", value_1, value_2); &#125; //pthread_mutex_unlock(&amp;lock); &#125;&#125;int main(int argc, const char *argv[])&#123; int count = 0; pthread_t pthread; if(pthread_mutex_init(&amp;lock, NULL) &lt; 0) &#123; perror(\"fail to pthread_mutex_init \"); exit(1); &#125; if(pthread_create(&amp;pthread, NULL, pthread_fun, NULL) &lt; 0) &#123; perror(\"fail to pthread_create \"); exit(1); &#125; while(1) &#123; count++; //pthread_mutex_lock(&amp;lock); value_1 = count; value_2 = count; //pthread_mutex_unlock(&amp;lock); &#125; pthread_join(pthread, NULL); return 0;&#125;测试结果： 加上互斥锁：[pthread_mutex.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;pthread_mutex_t lock;int value_1, value_2;void *pthread_fun(void * arg)&#123; while(1) &#123; pthread_mutex_lock(&amp;lock); if(value_1 == value_2) &#123; printf(\"value_1 = %d, value_2 = %d\\n\", value_1, value_2); &#125; pthread_mutex_unlock(&amp;lock); &#125;&#125;int main(int argc, const char *argv[])&#123; int count = 0; pthread_t pthread; if(pthread_mutex_init(&amp;lock, NULL) &lt; 0) &#123; perror(\"fail to pthread_mutex_init \"); exit(1); &#125; if(pthread_create(&amp;pthread, NULL, pthread_fun, NULL) &lt; 0) &#123; perror(\"fail to pthread_create \"); exit(1); &#125; while(1) &#123; count++; pthread_mutex_lock(&amp;lock); value_1 = count; value_2 = count; pthread_mutex_unlock(&amp;lock); &#125; pthread_join(pthread, NULL); return 0;&#125;测试结果：分析： 假如不加互斥锁，可能出现这种情况：主进程里将count赋值给value_1和value_2，此时value_1=value_2，线程里面的if(value_1 == value_2)通过了，这时线程的时间片用完，主进程执行count++和value_1 = count，此时主进程的时间片用完，线程继续执行，打印出value_1和value_2，就会发现value_1不等于value_2。 现在加上互斥锁，主进程count++,然后上锁，此时不能系统中断后续的count赋值给value_1和value_2，然后主线程再解锁。线程在if(value_1 == value_2)也上锁，保证后面的不被中断，打印出value_1和value_2，再解锁，整个过程，value_1一直value_2。 3.syns[pthread_syns.c]link1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;semaphore.h&gt;#define N 32char buf[N] = &#123;0&#125;;sem_t mysem;void *pthread_fun(void * arg)&#123; while(1) &#123; sem_wait(&amp;mysem); printf(\"--&gt; %s\\n\",buf); &#125;&#125;int main(int argc, const char *argv[])&#123; pthread_t tid; sem_init(&amp;mysem, 0, 0); if(pthread_create(&amp;tid, NULL, pthread_fun, NULL) != 0) &#123; perror(\"Unable to pthread_create\"); exit(1); &#125; while(1) &#123; fgets(buf, 32, stdin); sem_post(&amp;mysem); &#125; return 0;&#125; 测试结果：分析： 这里利用了信号同步。主线程调用fgets等待输入，输入完成后使用sem_post发送mysem信号，线程一直调用sem_wait等待信号，一旦信号到来，就打印出buf. 进程通信 条件变量： 定义：一个线程临界资源状态的变化，会通知另外一个线程去做相应的功能处理；条件变量跟互斥锁配合使用； 特点:具有阻塞功能、唤醒；为什么需要进程间通信？ 1、数据交互 2、共享资源 3、信号通知 4、同步或者互斥进程间通信方式介绍： 1、传统的进程间通信 无名管道、有名管道、信号通知 2、sytem V – IPC 共享内存、消息队列、信号量 前面六种只能用于单台的计算机中使用 3、套接字 1.kill[kill.c]link12345678910111213#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; if(kill(atoi(argv[1]), atoi(argv[2])) &lt; 0) &#123; perror(\"Unable to kill\"); exit(1); &#125; return 0;&#125; 测试结果：分析： kill()有两个参数，第一个是操作进程的PID，第二个是信号种类的编号。其中2是SIGINT结束进程，所以发送这个信号后，signal就打印hello world。结束进程。 2.raise[raise.c]link123456789101112131415#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; printf(\"hello wrold.\\n\"); if(raise(atoi(argv[1])) &lt; 0) &#123; perror(\"Unable to raise\"); exit(1); &#125;while(1); return 0;&#125; 测试结果：分析： raise()只能给自己发送信号，而且还不能发送SIGQUIT。这里raise自己发送SIGINT结束了自己。 3.signal12345678signal（int signum， sighandler_t handler）功能：信号响应函数参数：1. signum：信号种类中的一种，跟handler关联起来，执行相应的处理方式2. 忽略 SIG_IGN、 默认 SIG_DFL、 捕捉 --&gt;自己定义一个信号处理函数，类型跟sighandler_t的形式一致 把linux中已经定义好的62种信号中的一种信号跟linux传递给进程的信号signo做判断，看是那种信号，再做相应的处理 常用信号编号 种类 默认操作：结束进程2 SIGINT ctrl+c 结束进程3 SIGQUIT ctrl+\\ 结束进程9 SIGKILL 结束进程10 SIGUSR1 结束进程12 SIGUSR2 结束进程14 SIGALRM 结束进程19 SIGSTOP 暂停进程20 SIGTSTP ctrl+z 暂停进程注：SIGKILL 和SIGSTOP不能被忽略或者捕捉[signal.c]link12345678910111213141516171819202122#include &lt;signal.h&gt;#include &lt;stdio.h&gt;//signo代表内核相当前进程发送的信号时什么,而我们又不清楚时那个信号//需要用if语句做判断void fun(int signo)&#123; if(signo == SIGINT) &#123; printf(\"hello world \\n\"); &#125;&#125;int main(int argc, const char *argv[])&#123; //信号处理函数，本身不具有阻塞作用 //第一个参数： 要出里的信号是什么？62中的一种 //第二个参数： 三种相应方式： //忽略（SIG_IGN）、默认(SIG_DFL)、捕捉(用户自定义函数) signal(SIGINT, fun); pause(); return 0;&#125;测试结果：分析： 主函数调用signal安装信号，第一个参数指定了信号类型为按下CTRL+C产生，第二个为捕捉到信号后相应操作。然后信号的处理函数判断出信号类型后执行对应的操作。 pause()功能：引起调用进程进程阻塞，知道收到信号才会立即结束 4.alarm[alarm.c]link1234567891011121314151617#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; int ret = -1; ret = alarm(9); printf(\"ret = %d \\n\", ret); sleep(3); ret = alarm(10); printf(\"ret = %d \\n\", ret); pause(); printf(\"hello world \\n\"); //while(1); return 0;&#125; 测试结果：分析： 先给ret赋值个-1，然后调用alarm设置为9，因为之前没有设置过alarm，所以返回0.然后休眠3秒后，有赋值为10，此时返回的为6，即上次设置后剩下的时间9-3=6.然后程序调用pause挂起程序，直到10秒后，闹钟到了，发送SIGALRM信号结束进程。 5.pipe[pipe.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, const char *argv[])&#123; int fd[2]; pid_t pid; char buf[1024] = &#123;0&#125;; int count = 0; if(pipe(fd) &lt; 0) &#123; perror(\"Unable to pipe\"); exit(1); &#125;#if 1 pid = fork(); if(pid &lt; 0) &#123; perror(\"Unable to fork\"); exit(1); &#125; if(pid == 0) &#123;// printf(\"fd[0] = %d , fd[1] = %d \\n\", fd[0], fd[1]); while(1) &#123; read(fd[0], buf, 32);//如果管道中没有数据，读操作会阻塞 if(strncmp(buf, \"quit\", 4) == 0) break; printf(\"--&gt; %s \\n\", buf); &#125; &#125; else &#123;// printf(\"fd[0] = %d , fd[1] = %d \\n\", fd[0], fd[1]); while(1) &#123; fgets(buf, 32, stdin); write(fd[1], buf, strlen(buf) + 1); if(strncmp(buf, \"quit\", 4) == 0) break; &#125; wait(NULL); &#125;#endif#if 0 while(1) &#123;//如果缓冲区慢，则会阻塞在write函数 write(fd[1], buf, 1024); count++; if(count == 64) &#123; read(fd[0], buf, 1024); read(fd[0], buf, 1024); read(fd[0], buf, 1024); read(fd[0], buf, 1024); &#125; printf(\"count = %d \\n\", count); &#125;#endif close(fd[0]); write(fd[1], buf, 1024); return 0;&#125; 测试结果：分析： 这里创建一个管道完成进程间的通信，父进程负责写数据，子进程负责读数据。 首先是pipe()创建了一个管道，其中fd[0]是标准输入，fd[1]是标准输出。然后在fork()创建了个子进程。 父进程的工作：不断从键盘获得数据，存入buf。然后将buf数据写入fd[1]。如果收到“quit”字符即退出，调用wait()等待子进程结束。 子进程的工作：不断从fd[0]读取数据到buf，打印buf，如果遇到“quit”字符即退出。 管道的意义就是，连通了fb[0]和fb[1]，实现了进程间数据/信号的单向传输。 6.fifo[mkfifo_w.c]link123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#define N 32int main(int argc, const char *argv[])&#123; int fd_r, fd_w; size_t bytes = 0; char buf[N] = &#123;0&#125;; if(mkfifo(\"myfifo\", 0666) &lt; 0) &#123; perror(\"Unable to mkfifo\"); // exit(1); &#125; fd_w = open(\"myfifo\", O_WRONLY); if(fd_w &lt; 0) &#123; perror(\"Unable to open fd_w.\"); exit(1); &#125; printf(\"fifo write\\n\"); while(1) &#123; fgets(buf, 32, stdin); write(fd_w, buf, strlen(buf) + 1); if(strncmp(buf, \"quit\", 4) == 0) break; &#125; return 0;&#125; [mkfifo_r.c]link12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#define N 32int main(int argc, const char *argv[])&#123; int fd_r; size_t bytes = 0; char buf[N] = &#123;0&#125;; fd_r = open(\"myfifo\", O_RDONLY); if(fd_r &lt; 0) &#123; perror(\"Unable to open fd_r\"); exit(1); &#125; while(1) &#123; read(fd_r, buf, 32); if(strncmp(buf, \"quit\", 4) == 0) break; printf(\"--&gt; %s \\n\", buf); &#125; return 0;&#125; 测试结果：分析： FIFO的功能与管道差不多，但FIFO在文件系统中拥有一个名称，其打开方式和打开普通文件是一样的，这样就可以实现非相关的进程通信。 写入端/发送端：首先创建一个名叫“myfifo“，权限为666的FIFO。然后打开这个FIFO，不断从键盘获得数据写入FIFO里面，直到遇到”quit“退出。 读出端/接收端：打开同名FIFO，不断从中读取数据打印出来，直到遇到”quit“退出。 7.ftok[ftok.c]link1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char *argv[])&#123; key_t key; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"Unable to ftok\"); exit(1); &#125; printf(\"key = %#x \\n\", key); return 0;&#125; 测试结果： 分析： 这里ftok应该是产生一个唯一的标识，因为路径是唯一的，对应的key有是唯一的。后面的IPC对象：共享内存、消息队列、信号灯，通过key找到内核对象。通过shell命令ipcs来查看对象信息。 编程框架：1、通过ftok函数得到key值，让不同的进程找到内核对象2、创建或者打开内核对象（共享内存、消息队列、信号灯集）3、操作内核对象 共享内存 ：通过shmat映射内核中的共享内存到用户空间， 解除映射shmdt，不能再操作共享内存。 消息队列：通过msgsnd发送消息，msgrcv接收消息4、删除内核对象 删除共享内存shmctl 删除消息队列msgctl 8.msg【1】消息队列机制1234特点： 1、先进先出 2、按照类型发送、读取消息 使用ipcs -q查看系统中的消息 【2】如何创建消息队列1234567msggetint msgget(key_t key, int msgflg);功能：创建或者打开消息队列key:让不同的进程找到同一个消息队列msgflg： IPC_CREAT | IPC_EXCL | 0666 创建 防止重复创建 权限 【3】发送消息/接收消息123456789101112131415161718192021结构体： struct msgbuf &#123; long mtype; /* message type, must be &gt; 0 */消息类型 char mtext[1]; /* message data */消息正文 &#125;;msgsnd/msgrcv:int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); 功能： msgid： 消息队列标示符 （用于操作消息队列发送或者接收消息） msgp：首先定义一个消息队列的结构体，类型如上所示结构体1 msgsz：消息队列正文（text）的大小 msgflg：设置为阻塞的方式0 非阻塞的方式 IPC_NOWAITssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); msgid： 消息队列标示符 （用于操作消息队列发送或者接收消息） msgp：首先定义一个消息队列的结构体，类型如上所示结构体1 msgsz：消息队列正文（text）的大小 msgtyp：消息的类型（必须是大于0的整数） msgflg：设置为阻塞的方式0 非阻塞的方式 IPC_NOWAIT 【4】控制(删除)消息队列msgctl1234 int msgctl(int msqid, int cmd, struct msqid_ds *buf); msgid： 消息队列标示符 （用于操作消息队列发送或者接收消息） cmd：操作消息队列的命令 IPC_STAT 获取消息队列属性信息的命令，需要定义一个struct msqid_ds结构体 [msg_w.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/msg.h&gt;struct msgbuf&#123; long type; char text[32];&#125;;#define MSG_SIZE (sizeof(struct msgbuf) - sizeof(long))int main(int argc, const char *argv[])&#123; key_t key; int msgid; struct msgbuf mymsg; char buf[32] = &#123;0&#125;; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"Unable to ftok\"); exit(1); &#125; msgid = msgget(key, IPC_CREAT | IPC_EXCL | 0666); if(msgid &lt; 0) &#123; if(errno == EEXIST) &#123; msgid = msgget(key, 0666); &#125; else &#123; perror(\"Unable to msgget\"); exit(1); &#125; &#125; system(\"ipcs -q\"); mymsg.type = 100; //strcpy(mymsg.text,\"hello world\"); while(1) &#123; fgets(buf, 32, stdin); strcpy(mymsg.text, buf); if(msgsnd(msgid, &amp;mymsg, MSG_SIZE, 0) &lt; 0) &#123; perror(\"Unable to msgsnd\"); exit(1); &#125; &#125; system(\"ipcs -q\"); return 0;&#125; [msg_r.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/msg.h&gt;#include &lt;string.h&gt;struct msgbuf&#123; long type; char text[32];&#125;;#define MSG_SIZE (sizeof(struct msgbuf) - sizeof(long))int main(int argc, const char *argv[])&#123; key_t key; int msgid; struct msgbuf mymsg; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"Unable to ftok\"); exit(1); &#125; msgid = msgget(key, IPC_CREAT | IPC_EXCL | 0666); if(msgid &lt; 0) &#123; if(errno == EEXIST) &#123; msgid = msgget(key, 0666); &#125; else &#123; perror(\"Unable to msgget\"); exit(1); &#125; &#125; while(1) &#123; if(msgrcv(msgid, &amp;mymsg, MSG_SIZE, 100, 0) &lt; 0) &#123; perror(\"Unable to msgsnd\"); exit(1); &#125; system(\"ipcs -q\"); printf(\"--&gt;%ld %s \\n\", mymsg.type, mymsg.text); &#125; if(msgctl(msgid, IPC_RMID, NULL) &lt; 0) &#123; perror(\"Unable to msgctl\"); exit(1); &#125; system(\"ipcs -q\"); return 0;&#125; 测试结果：分析： 消息队列是让进程以消息的形式交换数据。 写入端/发送端：定义一个消息msgbuf的结构体，其中一个是类型，一个是数据。调用ftok()创建唯一的key。调用msgget()创建或打开消息队列，调用shell显示当前的ipc中的消息队列信息。设置类型为100，不断从键盘获取数据复制到mymsg.text，并调用msgsnd()发送出去。 读出端/接收端：使用调用ftok()传入相同的参数，得到相同的key，调用msgget()打开同一个消息队列。调用msgcrv()接收消息，接收到则打印书类型和数据。后面的消息队列控制函数并没有调用到，第二个参数IPC_RMID表示立即删除队列消息。这里使用shell命令：ipcrm -q [msgid]手动删除。 9.sem[1]信号灯机制123信号量的集合（一个或者多个信号量，信号量是一类资源，资源的值代表了资源的数量） 实现同步：按照约定的先后顺序执行 互斥： 可以用两个信号量实现互斥操作 [2]打开或者创建信号灯semget123456789101112int semget(key_t key, int nsems, int semflg);功能：打开或者创建信号量参数 nsems： 信号量的数量是多少个？系统从0开始分配 举例：当nsems = 1则信号量是0 当nsems = 2则信号量分别是 0 和 1 当nsems = 3则信号量分别是 0 和 1 和 2 semflg：设置semget函数的功能： IPC_CREAT | IPC_EXCL | 0666 创建 防止重复创建 有效权限位返回值： 成功返回信号量操作表示符 失败 -1 [3]信号灯初始化semctl12345678910111213141516171819 int semctl(int semid, int semnum, int cmd, ...); 功能：信号量控制函数 参数： semnum 操作第几个信号量 举例 semnum 是 0，表示操作第0个信号量 举例 semnum 是 1，表示操作第1个信号量 cmd： 对信号量使用的命令 IPC_STAT 获取信号量的属性信息 SETVAL 初始化信号量的值，需要定义一个联合体 类型如下所示：union semun &#123; int val; /* Value for SETVAL */ struct semid_ds *buf;/* Buffer for IPC_STAT, IPC_SET */ unsigned short *array;/* Array for GETALL, SETALL */struct seminfo *__buf;/* Buffer for IPC_INFO(Linux-specific) */&#125;; …：表示参数不确定如果使用IPC_STAT、SETVAL命令，必须使用第四个参数定义一个联合体变量来接收如果定义IPC_RMID则不用使用第四个参数 [4]信号量操作方式123456789int semop(int semid, struct sembuf *sops, unsigned nsops); 功能：信号量的pv操作 sops：对信号量的操作方式 unsigned short sem_num; /* 第几个信号量*/ short sem_op; /* 信号量的PV操作,正数表示释放操作、负数表示申请操作 */ short sem_flg; /*0表示阻塞方式,IPC_NOWAIT表示非阻塞方式*/ nsops：表示操作几个信号量，从0开始 P申请操作 V释放操作 [sem_w.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/shm.h&gt;union semun&#123; int val;&#125;;int main(int argc, const char *argv[])&#123; key_t key; int semid; union semun mysem; struct sembuf mybuf; char buf1[32] = &#123;0&#125;; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"fail to ftok\"); exit(1); &#125; semid = semget(key, 2, IPC_CREAT | IPC_EXCL | 0666); if(semid &lt; 0) &#123; if(errno == EEXIST) semid = semget(key, 2, 0666); else &#123; perror(\"fail to semget\"); exit(1); &#125; &#125; else &#123; mysem.val = 0; semctl(semid, 0, SETVAL, mysem); mysem.val = 1; semctl(semid, 1, SETVAL, mysem); &#125; int shmid = shmget(key, 128, IPC_CREAT | 0666); if(shmid &lt; 0) &#123; if(errno == EEXIST) &#123; shmid = shmget(key, 128, 0666); &#125; else&#123; perror(\"fail to shmget\"); exit(1); &#125; &#125; char *buf = (char *)shmat(shmid, NULL, 0); if(buf == (char *)-1) &#123; perror(\"fail to shmat\"); exit(1); &#125; while(1) &#123; fgets(buf1, 32, stdin); mybuf.sem_num = 1; mybuf.sem_op = -1; mybuf.sem_flg = 0; semop(semid, &amp;mybuf, 1); strcpy(buf,buf1); mybuf.sem_num = 0; mybuf.sem_op = 1; mybuf.sem_flg = IPC_NOWAIT; semop(semid, &amp;mybuf, 1); &#125; system(\"ipcs -s\"); return 0;&#125; [sem_rw.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt;union semun&#123; int val;&#125;;int main(int argc, const char *argv[])&#123; key_t key; int semid; union semun mysem; struct sembuf mybuf; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"fail to ftok\"); exit(1); &#125; semid = semget(key, 2, IPC_CREAT | IPC_EXCL | 0666); if(semid &lt; 0) &#123; if(errno == EEXIST) semid = semget(key, 2, 0666); else &#123; perror(\"fail to semget\"); exit(1); &#125; &#125; else &#123; mysem.val = 0; semctl(semid, 0, SETVAL, mysem); mysem.val = 1; semctl(semid, 1, SETVAL, mysem); &#125; int shmid = shmget(key, 128, IPC_CREAT | 0666); if(shmid &lt; 0) &#123; if(errno == EEXIST) &#123; shmid = shmget(key, 128, 0666); &#125; else&#123; perror(\"fail to shmget\"); exit(1); &#125; &#125; char *buf = (char *)shmat(shmid, NULL, 0); if(buf == (char *)-1) &#123; perror(\"fail to shmat\"); exit(1); &#125; while(1) &#123; mybuf.sem_num = 0; mybuf.sem_op = -1; mybuf.sem_flg = 0; semop(semid, &amp;mybuf, 1); printf(\"--&gt; %s \\n\", buf); mybuf.sem_num = 1; mybuf.sem_op = 1; mybuf.sem_flg = IPC_NOWAIT; semop(semid, &amp;mybuf, 1); &#125; system(\"ipcs -s\"); return 0;&#125; 测试结果：分析： 信号量不是用来在进程间传输数据的，而是用来同步数据的。这里里共享内存为例，完成两个进程的同步。 写入端/发送端：首先调用ftok()创建唯一的key。调用semget ()创建或打开信号量集，其中第二个参数表示创建两个信号量。然后调用控制函数semctl()分别设置两个的值为0和1。然后创建一个共享内存，映射到用户空间，不断从键盘获得输入。mybuf.sem_num表示设置第1个信号量，mybuf.sem_op为负表示期望减，mybuf.sem_flg为0为阻塞，IPC_NOWAIT为非阻塞。然后在调用semop()进行设置刚才初始化的sembuf。即读去到数据则欲将第一个信号量减1。复制好后，再将第0个信号量欲加1. 读出端/接收端：前面部分都是对应的，在循环部分，先欲把第0个信号量减1，等打印完后，再欲把第1个信号量设置为1。 即整个流程，先信号量0和1分别为0和1。sem.w收到数据，则欲将第1个信号量减1，成功，继续执行执行strcpy()，然后将信号量0设置为1。这时sem.r中，之前欲将第0个参数减1，但为0，减不动，阻塞着，现在发现第0个信号量被设置为1，于是继续执行，打印了出来。然后设置第1个参数为1。这时，sem.w中刚走完一个循环，且收到了键盘数据，但现在第1个信号量是0，无法拷贝，现在发现第1个参数被设置为了1，于是又继续执行后续的拷贝和设置信号量。如此往复。 10.shm 共享内存：内核空间中的一块区域，由用户创建，系统维护里面的数据结构，通过获取到的描述符shmget的返回值，对共享内存进行操作； 特点： 1、高效，因为用户可以直接对内和对象进行操作，并不需要把数据在写到自己的用户空间里，在所有的进程间通信对象中是最快的。 注意： 1、映射，共享内存的映射，就是把共享内存段的地址传递给用户空间相应数据类型的指针变量。 2、同步和互斥：对共享内存进行循环操作的时候，容易出现一个进程在写操作的时候，另一个已经打读了好多次，为了能够完成写一次读一次操作，需要进行同步或者互斥。 步骤：【1】共享内存创建 1234567shmgetint shmget(key_t key, size_t size, int shmflg);功能： 创建或者打开共享内存key： 通过ftok函数返回，用于让不同的进程找到内核区域中的内核对象（共享内存）size：指定共享内存的大小，以字节为单位shmflg：指定创建的共享内存具有什么权限 IPC_CREAT | IPC_EXCL | ０６６６ 【2】映射共享内存1234567shmatvoid *shmat(int shmid, const void *shmaddr, int shmflg);功能：把内核空间的共享内存映射到用户空间，（因为用户空间根内核空间不能直接访问，所以通过映射的方式，简介得到这块共享内存地址）shmid:【操作】共享内存的表示符shmaddr： NULL有系统来分配一块共享内存shmflg： 0 【3】解除映射1shmdt 【4】删除共享内存12345678shmctlint shmctl(int shmid, int cmd, struct shmid_ds *buf);功能：共享内存对象控制函数通过命令，也就是第二个参数设置：IPC_STAT用来获取共享内存的一些属性信息IPC_RMID用来删除共享内存对象buf：用来存储共享内存的属性信息的，需要定义一个struct shmid_ds 的结构体 [shm_w.c]link1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/shm.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;int main(int argc, const char *argv[])&#123; key_t key; int shmid; char * ptr; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"Unable to ftok\"); exit(1); &#125; printf(\"key = %#x \\n\", key); shmid = shmget(key, 128, IPC_CREAT | IPC_EXCL | 0666); if(shmid &lt; 0) &#123; if(errno == EEXIST) &#123; shmid = shmget(key, 128, 0666); &#125; else &#123; perror(\"Unable to shmget\"); exit(1); &#125; &#125; if((ptr = shmat(shmid, NULL, 0)) == (char *)-1) &#123; perror(\"Unable to shmat\"); exit(1); &#125; strcpy(ptr, \"hello world\"); if(shmdt(ptr) &lt; 0) &#123; perror(\"Unable to shmdt\"); exit(1); &#125;#if 0 if(shmctl(shmid, IPC_RMID, NULL) &lt; 0) &#123; perror(\"Unable to shmctl\"); exit(1); &#125;#endif return 0;&#125; [shm_r.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/shm.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;int main(int argc, const char *argv[])&#123; key_t key; int shmid; char * ptr; key = ftok(\".\", 'a'); if(key &lt; 0) &#123; perror(\"Unable to ftok\"); exit(1); &#125; shmid = shmget(key, 128, IPC_CREAT | IPC_EXCL | 0666); if(shmid &lt; 0) &#123; if(errno == EEXIST) &#123; shmid = shmget(key, 128, 0666); &#125; else &#123; perror(\"Unable to shmget\"); exit(1); &#125; &#125; if((ptr = shmat(shmid, NULL, 0)) == (char *)-1) &#123; perror(\"Unable to shmat\"); exit(1); &#125; printf(\"--&gt; %s \\n\",ptr); if(shmdt(ptr) &lt; 0) &#123; perror(\"Unable to shmdt\"); exit(1); &#125; if(shmctl(shmid, IPC_RMID, NULL) &lt; 0) &#123; perror(\"Unable to shmctl\"); exit(1); &#125; return 0;&#125; 测试结果：分析： 写入端写入数据到共享内存，读取端读出并释放。 写入端/发送端：首先调用ftok()创建一个key，调用shmget()分配一个所需共享内存，得到shmid。然后调用shmat()再将内核中的共享内存映射到用户空间，最后调用strcpy()将“hello world“写入到这个空间，并释放用户空间。 读出端/接收端：使用调用ftok()传入相同的参数，得到相同的key，调用shmget也得到同样的shmid，再调用shmat()映射，打印出之前的数据。最后 调用shmdt()和shmctl()释放用户空间和内核空间。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux环境编程","slug":"Linux环境编程","permalink":"http://yoursite.com/tags/Linux环境编程/"}]},{"title":"Linux自动挂载/卸载U盘","date":"2017-04-22T03:10:55.000Z","path":"2017/04/22/Linux自动挂载卸载U盘/","text":"记录在mdev机制下不能自动卸载U盘的解决方法。 加载USB驱动有两种方式： 一是将模块编译到内核，再把新内核下载到开发板。 二是将驱动作为模块，内核启动后再加载驱动模块。 在主机中编译模块，在Linux中的/work/hceng/linux-3.4.2目录下执行：1$ make moudles 复制主机生成的drivers/usb/storage/usb-storage.ko到开发板中:1cp drivers/usb/storage/usb-storage.ko /work/hceng/nfs_rootfs 在开发板中，加载USB驱动模块：1$ insmod usb-storage.ko 然后在开发板插上U盘后，再手动挂载U盘即可访问数据:1$ mount /dev/sda1 /mnt 这里存在两个问题，一是需要手动加载usb-storage.ko，二是需要手动挂载U盘。 第一个问题通过将模块加载命令放在启动脚本里实现开机自动加载，/etc/init.d/rcS,加入如下命令：1insmod usb-storage.ko 第二个问题利用mdev机制进行自动挂载U盘，首先修改/etc/medv.conf，将下面代码加入行底：12sd[a-z][0-9] 0:0 666 @/etc/mdev/udisk_insert sd[a-z] 0:0 666 $/etc/mdev/udisk_remove 在/bin/hotplug.sh中把 “case $MDEV in”修改成如下：123456789case $MDEV insd[a-z][0-9]) DEVNAME=udisk MOUNTPOINT=/udisk ;;sda1) DEVNAME=udisk MOUNTPOINT=/udisk ;; 完成上面的设置后，U盘确实能够自动挂载，但拔U盘却不能自动卸载，这样会导致下次插入U盘相应的节点会自动增加，且访问原来的节点报错。 查阅相关资料并无解决方案，多次实验后，发现插上U盘后会自动在/sys/bus/usb/devices/1-1:1.0下生成U盘的信息文件，利用这一点进行检测U盘，在无奈的情况下写了个程序解决这个问题，代码如下：[usb.c]link1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*检查是否有U盘插上，没有则卸载一次/media/sda1，保证下次自动挂载U盘正常*//*定时器相关*/static int count = 0; static struct itimerval oldtv; static unsigned char usb_umount_ok = 0;void set_timer() &#123; struct itimerval itv; itv.it_interval.tv_sec = 1; itv.it_interval.tv_usec = 0; itv.it_value.tv_sec = 1; itv.it_value.tv_usec = 0; setitimer(ITIMER_REAL, &amp;itv, &amp;oldtv); &#125; /*查看/sys/bus/usb/devices/目录下是否有1-1，有则表示有U盘*/static unsigned int judge_usb(void) &#123; FILE *fd; fd = fopen(\"/sys/bus/usb/devices/1-1/version\",\"r\"); if(fd == NULL) return 0; else fclose(fd); usb_umount_ok = 0; return 1;&#125;/*检查usb是否拔出，从而确定是否卸载*/static void colse_usb(void)&#123; if(!judge_usb() &amp;&amp; usb_umount_ok==0) &#123; system(\"cd /;umount /media/sda1;rm -r /media/sd*;echo umount usb ok!\"); usb_umount_ok = 1; &#125; &#125;void signal_handler(int m) &#123; colse_usb(); &#125; int main(void)&#123; signal(SIGALRM, signal_handler); set_timer(); while(1); return 0;&#125; 编译后，运行测试，最后再放在上述启动脚本里：12arm-linux-gcc -o usb usb.c./app/usb&amp; 搞定。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"USB","slug":"USB","permalink":"http://yoursite.com/tags/USB/"}]},{"title":"自己写bootloader","date":"2017-04-13T00:35:55.000Z","path":"2017/04/13/自己写bootloader/","text":"参考写了个bootloader。 0.编写bootloader步骤 初始化硬件：关看门狗、设置时钟、设置SDRAM、初始化NAND FLASH; 因为bootloader比较大（大于4K），需要重定位到SDRAM; 把内核从NAND FLASH读到SDRAM; 设置“要传给内核的参数”; 跳转启动内核; 1.初始化硬件1.1 关看门狗[start.S]1234567.text.global _start_start:/* 1. 关看门狗 ：向寄存器WTCON(0x53000000)写0即可；P462；*/ ldr r0, =0x53000000 //将0x53000000放入r0； mov r1, #0 //将0放入r1中； str r1, [r0] //将r1中的0放入r0所指的存储器中； 1.2 设置时钟[start.S]1234567891011121314151617/* 2. 设置时钟：配置寄存器CLKDIVN(0x4C000014)设置分频；P260； */ ldr r0, =0x4c000014 mov r1, #0x05; //FCLK:HCLK:PCLK=1:4:8 str r1, [r0]/* 如果HDIVN非0，CPU的总线模式应设置为“asynchronous bus mode”;P244 */ mrc p15, 0, r1, c1, c0, 0 //读出控制寄存器； orr r1, r1, #0xc0000000 //设置为“asynchronous bus mode”； mcr p15, 0, r1, c1, c0, 0 //写入控制寄存器； /* 设置MPLLCON = S3C2440_MPLL_400MHZ; P256 */ ldr r0, =0x4c000004 ldr r1, =(0x5c&lt;&lt;12)|(0x01&lt;&lt;4)|(0x01) str r1, [r0] /*优化速度： 启动ICACHE */ mrc p15, 0, r0, c1, c0, 0 @ read control reg orr r0, r0, #(1&lt;&lt;12) mcr p15, 0, r0, c1, c0, 0 @ write it back 1.3 初始化SDRAM[start.S]12345678910111213141516171819202122232425 /*初始化SDRAM：依次向SDRAM寄存器 写入sdram_config中的值*/ ldr r0, = 0x48000000 //将SDRAM寄存器基地址写入r0； adr r1, sdram_config //将sdram_config的当前地址写入r1; add r3, r0, #(13*4) //r3=r0+13*4,即为SDRAM寄存器结尾地址；1: ldr r2, [r1], #4 //将r1寄存器的值放入r2，并将r1的地址+4; str r2, [r0], #4 //将r2的值写入r0，并将r0的地址+4; cmp r0, r3 //比较r0和r3，判断是否设置到了最后一个寄存器；bne 1b //不相等即没有设置完，跳到前面(b)的1处； … … … …sdram_config: //把要设置的值，存在这里；P56; .long 0x22011110 //BWSCON .long 0x00000700 //BANKCON0 .long 0x00000700 //BANKCON1 .long 0x00000700 //BANKCON2 .long 0x00000700 //BANKCON3 .long 0x00000700 //BANKCON4 .long 0x00000700 //BANKCON5 .long 0x00018005 //BANKCON6 .long 0x00018005 //BANKCON7 .long 0x008C04F4 //REFRESH .long 0x000000B1 //BANKSIZE .long 0x00000030 //MRSRB6 .long 0x00000030 //MRSRB7 2.重定位[start.S]123456789101112/*把bootloader本身的代码从flash复制到它的链接地址去*/ ldr sp, =0x34000000 //在调用C语言前，需要先设置栈，即SP指向一个地址；[1] bl nand_init //初始化nand flash；[2] mov r0, #0 //设置copy_code_to_sdram传入参数；参数1：r0=0； ldr r1, =_start //参数2：r1=_start； ldr r2, =__bss_start //r2=__bss_start sub r2, r2, r1 //参数3：r2=r2-r1 即除去_bss段的部分； bl copy_code_to_sdram //执行复制代码到SDRAM的函数；[3] bl clear_bss //执行清理_bss段函数；[4] [1]:为什么是0x34000000？ 栈是由上向下增加的，只要SP指向SDRAM最高处就行。 [2]:为何在这里初始化Nand Flash？ 不管后面的copy_code_to_sdram是Nand启动还是Nor启动，最后都会拷贝Nand上面的内核到SDRAM，所以早晚都得初始化。 [init.c]12345678void nand_init(void)&#123; #define TACLS 0 #define TWRPH0 1 #define TWRPH1 0 NFCONF = (TACLS&lt;&lt;12)|(TWRPH0&lt;&lt;8)|(TWRPH1&lt;&lt;4); //设置时序；P225; NFCONT = (1&lt;&lt;4)|(1&lt;&lt;1)|(1&lt;&lt;0); //使能NAND Flash控制器, 初始化ECC, 禁止片选；P226;&#125; [3]: copy_code_to_sdram具体实现？ start.S中的所有的C函数都在init.c中(除了最后的main)，copy_code_to_sdram()先判断是Nor启动还是Nand启动。 如果是Nor启动：由于Nor Flash特性（可以像内存一样读，但不能像内存一样写），直接复制上面的代码到SDRAM中的链接地址即可； 如果是Nand启动：2440上电后，硬件上将Nand上前4k拷贝到内部RAM中运行，这4k代码再将后续的整个代码拷贝到SDRAM中的链接地址。 [init.c]123456789101112131415161718//传入参数：*src源地址；*dest目的地地址；len数据长度；void copy_code_to_sdram(unsigned char *src, unsigned char *dest, unsigned int len)&#123; int i = 0; if (isBootFromNorFlash()) //如果是NOR启动； &#123; while (i &lt; len) //将len长度的数据，从源地址复制到目标地址上去； &#123; dest[i] = src[i]; i++; &#125; &#125; else &#123; nand_read((unsigned int)src, dest, len); //nand_read较麻烦，再后面介绍； &#125;&#125; 判断是Nand还是Nor：（利用Nor Flash可以像内存一样读，但不能像内存一样写的特性）[init.c]1234567891011121314151617int isBootFromNorFlash(void)&#123; volatile int *p = (volatile int *)0; int val; val = *p; //备份原来0地址的值； *p = 0x12345678; //向0地址写值； if (*p == 0x12345678) //判断是否写入成功； &#123; *p = val; //写成功, 是nand启动，恢复原来的值； return 0; &#125; else &#123; return 1; //NOR不能像内存一样写； &#125;&#125;Nand Flash结构：Nand Flash读操作：[init.c]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576void nand_read(unsigned int addr, unsigned char *buf, unsigned int len)&#123; int col = addr % 2048; int i = 0; /* 1. 选中 */ nand_select(); while (i &lt; len) &#123; /* 2. 发出读命令00h */ nand_cmd(0x00); /* 3. 发出地址(分5步发出) */ nand_addr(addr); /* 4. 发出读命令30h */ nand_cmd(0x30); /* 5. 判断状态 */ nand_wait_ready(); /* 6. 读数据 */ for (; (col &lt; 2048) &amp;&amp; (i &lt; len); col++) //处理没有从最左边开始的情况； &#123; buf[i] = nand_data(); i++; addr++; &#125; col = 0; &#125; /* 7. 取消选中 */ nand_deselect();&#125;/* nand_read 涉及的子函数*//* 1.选中Nand；P226*/ void nand_select(void)&#123; NFCONT &amp;= ~(1&lt;&lt;1); &#125;/* 2.取消选中Nand */ void nand_deselect(void)&#123; NFCONT |= (1&lt;&lt;1); &#125;/* 3.nand命令 */ void nand_cmd(unsigned char cmd)&#123; volatile int i; NFCMMD = cmd; for (i = 0; i &lt; 10; i++);&#125;/* 4.nand地址 */ void nand_addr(unsigned int addr)&#123; unsigned int col = addr % 2048; //对2k取余，得到列； unsigned int page = addr / 2048; //对2k取整，得到行； volatile int i; NFADDR = col &amp; 0xff; //列的7-0位； for (i = 0; i &lt; 10; i++); NFADDR = (col &gt;&gt; 8) &amp; 0xff; //列的15-8位； for (i = 0; i &lt; 10; i++); NFADDR = page &amp; 0xff; //行的7-0位； for (i = 0; i &lt; 10; i++); NFADDR = (page &gt;&gt; 8) &amp; 0xff; //行的15-8位； for (i = 0; i &lt; 10; i++); NFADDR = (page &gt;&gt; 16) &amp; 0xff; //行的23-16位； for (i = 0; i &lt; 10; i++); &#125;/* 5.等待读结束 */ void nand_wait_ready(void)&#123; while (!(NFSTAT &amp; 1));&#125;/* 6.nand数据 */ unsigned char nand_data(void)&#123; return NFDATA;&#125; 清理_bss段： 在start.S跳转到main前，还需要清理_bss段。_bss段存放的是未初始化的全局变量或者初始化为0的全局变量，用于处理可能过多0占用过多空间的情况。现在清0，后续要使用时，再赋0使用。[init.c]12345678void clear_bss(void)&#123; extern int __bss_start, __bss_end; //声明链接脚本的链接地址; int *p = &amp;__bss_start; for (; p &lt; &amp;__bss_end; p++) //以_bss_start开始，清理到_bss_end; *p = 0;&#125; 链接脚本：[boot.lds]123456789101112131415SECTIONS &#123; . = 0x33f80000; .text : &#123; *(.text) &#125; //代码段在0x33f80000，即链接地址，重定位后程序运行的地址； . = ALIGN(4); //四字节对齐（32位）； .rodata : &#123;*(.rodata*)&#125; //只读数据段 . = ALIGN(4); .data : &#123; *(.data) &#125; //数据段 . = ALIGN(4); __bss_start = .; //_bss开始 .bss : &#123; *(.bss) *(COMMON) &#125; __bss_end = .; //_bss结束&#125; 3.把内核读到SDRAM 前面start.S中调用init.c中的nand_init初始化了Nand Flahsh和写好了nand_read()函数。start.S最后跳到main函数中，而mian函数boot.c中。[boot.c]12/* 0. 帮内核设置串口: 内核启动的开始部分会从串口打印一些信息,但是内核一开始没有初始化串口 */ uart0_init(); //略，看相应章节设置；把内核读到SDRAM:[boot.c]12/* 1. 从NAND FLASH里把内核读入内存 */ nand_read(0x60000+64, (unsigned char *)0x30008000, 0x400000); 第一个参数：源地址：0x60000+64 Nand Flash一般分区情况如图，kernel设计的位置在0x60000，这里加64是因为内核格式为uImage，uImage结构是64字节头+zImage。 第二个参数：目的地址：0x3000 8000 即为Nand Flash的起始地址。 第三个参数：长度：0x200000 内核大小，后面内核大于2M，这里为0x4000 0000。 4.设置要传给内核的参数[boot.c]12345 /* 2. 设置参数 */ setup_start_tag(); setup_memory_tags(); setup_commandline_tag(\"noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0,115200 rootfstype=yaffs2\");setup_end_tag(); 主要分四部分：开始、内存信息、命令信息、结束。 5.跳转启动内核[boot.c]123/* 3. 跳转执行 */ theKernel = (void (*)(int, int, unsigned int))0x30008000; theKernel(0, 362, 0x30000100); 函数指针指向0x3000 8000,即指向内核位置，跳转到内核。theKernel()参数： 第一个参数：固定的0； 第二个参数：机器ID； 第三个参数：要传入给内核的参数位置； 6.其它相关源码参考：韦东山老师毕业班视频； 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"bootloader","slug":"bootloader","permalink":"http://yoursite.com/tags/bootloader/"}]},{"title":"软件癖","date":"2017-04-06T03:06:19.000Z","path":"2017/04/06/软件癖/","text":"软件“洁癖”。 折腾Windows久了，渐渐的对软件有了“洁癖”。带广告的要想办法去掉广告，有绿色版的要绿色版本优先，能精简的必须精简，收费的也无耻的去百度云找找，有功能限制一定要想办法去掉限制，有最新版的稳定情况下一定使用最新的。 经过时间的过滤，有些软件忍受住了我的“洁癖”，幸存了下来，他们有的堪称“神器”，有的良心无比让人敬佩。谨以此文感谢这些提高工作效率和创造安静的环境的软件，对作者深感敬佩。 Chrome:Windows端的主力浏览器，干净简洁的界面、强大的插件，一直在心中都是无可替代的存在。 SoureInsight:Windows端代码神器，最开始使用的时候是拒绝的，xp时代的审美风格，非常抵触，除去外观，实用性上无话可说，几乎成为每天必开的软件。最近升级到4.0，界面没什么大变化，功能上也少有眼前一亮的更新，站在顶端，难有进步。 OneNote:笔记软件神器，配合数位板手写笔记，神器中的神器。最近看Datasheet，手写笔迹注释，看英语都没那么排斥了，唯一不足是插入任何格式的文档，都是以图片的形式打印输出，查单词没戏了。 PowerPoint:估计是大学玩得最多的软件，几乎可以背到任何一个按钮的位置。上可配合Pr做视频，下可当Ps修图/做图。现在基本没做PPT，但作为做图神器，现在所有的平面图都是在这上面做，胜任了Ps和Visio的功能。 Adobe Photoshop:Adobe，设计领域的老大。Photoshop博大精深，会点小操作，就基本满足日常所有的需求了。PS对我还是很有吸引力的，我在考虑要不要在博客上也加个PS相关的板块 = = Adobe Acrobat DC:在尝试使用其他PDF查看软件后，最终还是觉得Adobe Acrobat DC是最好用的，所有对PDF的“遐想”，几乎都可以完成，比如：分割/合并PDF、添加页眉/页码、设置是导出PDF的表格到Excel，总是一种深藏不露的感觉，只要是我能想到的，用心去找，总能找到解决方法。 WePE:这个真的是情怀，在那个以装系统为家常便饭的时光里，老毛桃带来的除了便利还有捆绑软件和绑定首页，尽管关掉了捆绑软件，绑定首页也是不能忍的。一直希望找到一个干净的PE，现在终于找到了，感谢UEPON。 Everything:积累的文件资料越来越多，时间久了，记不到放在哪了。Windows自带的搜索基本是废的，就没见到过进度条走完过。直到使用Everything才成功解决这一问题，现在使用，仍有那种不可思议的感觉。 huorong:一直都没怎么用过第三方的杀毒软件，Windows Defender基本够用了。出于对垃圾清理和流量状态显示的需求，在经历多种替代方案后，最终决定使用huorong，干净、简洁。我需要的功能都有，附加点可能需要的，我不想的绝对不要出现，挺符合要求的。 Bandzip:用了很久的好压，之前也没怎么觉得有问题，后来有次发现Edeg首页被劫持了，最后发现是它搞的“鬼”。一直对2345这种门户网站没什么好感，这次算彻底失望了。Bandzip还是很不错的，除了干净，可以预览压缩包的图片，这个还是挺实用的。还有就是图标挺新鲜的。 Snipaste:平时基本使用Ctrl+Alt+Q的QQ截图，挺方便的，但有些小功能QQ没有，这个算互补，软件也很良心。 MobaXterm:之前一直想找个串口、SSH、FTP三合一的软件，找了很久，直到用到这个，几乎完美。几乎支持所有的传输协议，还有文件夹同步、录制命令、自定义主题色彩等。免费版几乎就完全就够了，也算良心~ 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Linux并发控制机制","date":"2017-04-05T15:55:00.000Z","path":"2017/04/05/Linux并发控制/","text":"本文主要是简单记录下驱动中的并发控制。 1.并发控制 2.原子变量操作测试代码：[atomic_drv.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;linux/module.h&gt; #include &lt;linux/init.h&gt; #include &lt;asm/atomic.h&gt;//原子变量操作的头文件#include &lt;asm/bitops.h&gt;//原子位操作的头文件atomic_t a1 = ATOMIC_INIT(1);//定义和设置原子量；unsigned long int a2;//操作函数传入参数的数据类型是unsigned long int；static int test_drv_init(void)&#123; //测试原子变量操作： printk(\"test a1\\nKERN_INFO:atomic_read(): a1 = %d\\n\", a1); atomic_add(4, &amp;a1); printk(\"KERN_INFO:atomic_add(): a1 = %d\\n\", a1); atomic_dec(&amp;a1); printk(\"KERN_INFO:atomic_dec(): a1 = %d\\n\", a1); printk(\"KERN_INFO:atomic_dec_and_test(): judge_a1 = %d, new_a1 = %d\\n\",\\ atomic_dec_and_test(&amp;a1),atomic_read(&amp;a1)); //测试原子位操作： set_bit(0,&amp;a2);//设置a的0位为1; printk(\"test a2\\nKERN_INFO:set_bit(): a2 = %ld\\n\", a2); printk(\"KERN_INFO:test_and_clear_bit(): return_a2 = %d, new_a2 = %ld\\n\",\\ test_and_clear_bit(0, &amp;a2), a2); printk(\"KERN_INFO:test_and_set_bit(): return_a2 = %d, new_a2 = %ld\\n\",\\ test_and_set_bit(0, &amp;a2), a2); return 0;&#125;static void test_drv_exit(void)&#123; &#125;module_init(test_drv_init);module_exit(test_drv_exit);MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"hceng\"); MODULE_DESCRIPTION(\"Learn for atomic\"); 3.自旋锁测试代码：[lock_drv.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*设备驱动中，有些设备只允许打开一次，这里用count计数，lock对count进行保护*/#include &lt;linux/module.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_device.h&gt;#include &lt;linux/spinlock.h&gt;//自旋锁头文件static struct class *testdrv_class;static struct class_device *testdrv_class_dev;int count = 0 ;spinlock_t lock;static int test_drv_open(struct inode *inode, struct file *file)&#123; spin_lock(&amp;lock); if(count) &#123; spin_unlock(&amp;lock); printk(\"kernel: open fail! count = %d\\n\",count); return -EBUSY; &#125; count++; spin_unlock(&amp;lock); printk(\"kernel: open ok! count = %d\\n\",count); return 0;&#125;static int test_drv_release(struct inode *inode, struct file *file)&#123; spin_lock(&amp;lock); count--; spin_unlock(&amp;lock); printk(\"kernel: release ok! count = %d\\n\",count); return 0;&#125;static struct file_operations test_drv_fops = &#123; .owner = THIS_MODULE, .open = test_drv_open, .release = test_drv_release, &#125;;int major;static int test_drv_init(void)&#123; major = register_chrdev(0, \"test_drv\", &amp;test_drv_fops); testdrv_class = class_create(THIS_MODULE, \"testdrv\"); testdrv_class_dev = device_create(testdrv_class, NULL, MKDEV(major, 0), NULL, \"locktest\"); spin_lock_init(&amp;lock); printk(\"kernel: init ok!\\n\"); return 0;&#125;static void test_drv_exit(void)&#123; unregister_chrdev(major, \"test_drv\"); device_destroy(testdrv_class, MKDEV(major, 0)); class_destroy(testdrv_class); printk(\"kernel: exit ok!\\n\");&#125;module_init(test_drv_init);module_exit(test_drv_exit);MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"hceng\"); MODULE_DESCRIPTION(\"Learn for lock\");[lock_test.c]link123456789101112131415161718192021#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; int fd; fd = open(\"/dev/locktest\", O_RDWR); if (fd &lt; 0) &#123; printf(\"app: can't open!\\n\"); &#125; else printf(\"app: open ok!\\n\"); while(1); return 0;&#125; 4.信号量[semaphore_drv.c]link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/*设备驱动中，有些资源只能被单一进程访问，这里用sem确保单一访问*/#include &lt;linux/module.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_device.h&gt;#include &lt;linux/semaphore.h&gt;//信号量头文件static struct class *testdrv_class;static struct class_device *testdrv_class_dev;struct semaphore sem;static int test_drv_open(struct inode *inode, struct file *file)&#123; printk(\"kernel:down before sem.count = %d \\n\", sem.count); down(&amp;sem); /*临界资源*/ printk(\"kernel:down after sem.count = %d \\n\", sem.count); return 0;&#125;static int test_drv_release(struct inode *inode, struct file *file)&#123; printk(\"kernel:up before sem.count = %d \\n\", sem.count); up(&amp;sem); printk(\"kernel:up after sem.count = %d \\n\", sem.count); return 0;&#125;static struct file_operations test_drv_fops = &#123; .owner = THIS_MODULE, .open = test_drv_open, .release = test_drv_release, &#125;;int major;static int test_drv_init(void)&#123; major = register_chrdev(0, \"test_drv\", &amp;test_drv_fops); testdrv_class = class_create(THIS_MODULE, \"testdrv\"); testdrv_class_dev = device_create(testdrv_class, NULL, MKDEV(major, 0), NULL, \"semaphoretest\"); sema_init(&amp;sem, 2);//允许同时2个进程访问临界资源 printk(\"kernel: init ok!\\n\"); return 0;&#125;static void test_drv_exit(void)&#123; unregister_chrdev(major, \"test_drv\"); device_destroy(testdrv_class, MKDEV(major, 0)); class_destroy(testdrv_class); printk(\"kernel: exit ok!\\n\");&#125;module_init(test_drv_init);module_exit(test_drv_exit);MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"hceng\"); MODULE_DESCRIPTION(\"Learn for semaphore\"); [semaphore_test.c]link123456789101112131415161718192021#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; int fd; fd = open(\"/dev/semaphoretest\", O_RDWR); if (fd &lt; 0) &#123; printf(\"app: can't open!\\n\"); &#125; else printf(\"app: open ok!\\n\"); while(1); return 0;&#125; 5.完成量 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"}]},{"title":"终端复用软件-Tmux","date":"2017-03-31T11:50:00.000Z","path":"2017/03/31/终端复用软件——Tmux/","text":"本文主要记录终端复用软件——Tmux的简单使用。 Tmux是一个可以把终端分屏的软件，最开始知道这货是在酷安下了Termux，酷安大佬们真会完，刷Termu下面的评论中看到了Tmux，觉得还挺好玩的。最近Linux终端用得比较多，尝试安装玩玩，记录下。 1.安装tmux在ubuntu终端中，使用以下命令安装：1$ sudo apt-get install tmux 2.基本使用Tmux为了不和其它软件的快捷键影响，所以它的命令全要加前缀Ctrl+b后再操作，例如新建个窗口的操作步骤： 按下组合键 Ctrl+b; 放开组合键 Ctrl+b; 按下 c 键; Tmux的操作很多，这里我只记录几个我常用的，后续自己有需求再增加： 功能 前缀操作 组合键 创建新窗口 Ctrl+b-&gt;松开 c 水平划分窗口 Ctrl+b-&gt;松开 “ 垂直划分窗口 Ctrl+b-&gt;松开 % 调整窗口大小 Ctrl+b-&gt;不松住 方向键 切换窗口 Ctrl+b-&gt;松开 方向键 显示窗口标号 Ctrl+b-&gt;松开 q 关闭窗口 Ctrl+b-&gt;松开 x-&gt;y 关闭Tmux Ctrl+b-&gt;松开 &amp;-&gt;y 3.其它优化美化的话参考后面给的博客链接，这里我只美化了底边状态栏：进入home目录，新建.tmux.conf12$ cd ~$ vi ~/.tmux.conf加入以下代码： 12345678910111213141516171819# 状态栏# 颜色set -g status-bg blackset -g status-fg white # 对齐方式set-option -g status-justify centre # 左下角set-option -g status-left &apos;#[bg=black,fg=green][#[fg=cyan]#S#[fg=green]]&apos;set-option -g status-left-length 20 # 窗口列表setw -g automatic-rename onset-window-option -g window-status-format &apos;#[dim]#I:#[default]#W#[fg=grey,dim]&apos;set-window-option -g window-status-current-format &apos;#[fg=cyan,bold]#I#[fg=blue]:#[fg=cyan]#W#[fg=dim]&apos; # 右下角set -g status-right &apos;#[fg=green][#[fg=cyan]%Y-%m-%d#[fg=green]]&apos; 参考博客：Tmux 速成教程：技巧和调整Tmux简单教程 最后修改时间：2017/3/31 19:51:36 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux基础/"}]},{"title":"U-Boot分析、移植及使用","date":"2017-03-26T10:39:00.000Z","path":"2017/03/26/U-Boot分析、移植及使用/","text":"该系列主要是为驱动学习提供基石，从0到Qt。本文是该系列的第二篇:对U-Boot进行分析及移植. 1.U-Boot结构分析Bootloader一般可以分成两个阶段： 第一个阶段通常使用汇编进行必要的硬件初始化，例如：关看门狗、关中断、设置时钟频率、RAM初始化等。除此之外，还要将第二阶段的代码复制到RAM中，设置好栈，然后跳到第二阶段，该阶段主要是与SOC平台相关。 第二阶段一般是用c语言编写，该阶段主要和开发板板载资源相关。该阶段主要初始化后续的硬件，处理内存映射、以及将内核和根文件系统从Flash“搬运”到RAM中运行，然后传入启动参数，最后启动引导内核，完成使命。 Linux中系统一般的分区结构，如下图： 分区主要分为四个分区：Bootloader、Boot parameters、Kernel、Root filesystem。其中Boot parameters是待传入内核的参数，Kernel即内核、Root filesystem是根文件系统。Bootloader在第一个分区(假设该储存介质为Nand Flash)，则在Nand Flash的地址为0x0000 0000，S3C2440上电后，硬件自动把Nand Flash上前4k代码复杂到自己内部RAM中运行。该4k代码先要初始化一些必要的硬件，如看门狗，中断等，然后准备好SRAM，并将后续的代码复制到SDRAM中，再跳到SDRAM中运行，完成Bootloader第一阶段。此时在SDRAM中的第二阶段代码开始工作，首先还是初始化硬件，处理内存映射，把Nand Flash上内核和根文件系统“搬运”到SDRAM准备运行，然后根据用户通过串口传入的启动参数放在Boot parameters，然后内核启动，完成使命。内核启动后，开始去Boot parameters寻找启动参数，根据启动参数做出相应的操作，如：控制台输出、串口波特率、根文件系统位置。 2.U-Boot源码分析 这里根据u-boot-1.1.6的源码进行分析，，主要工作有： 第一阶段的硬件初始化(CPU模式、看门狗、中断) 准备SDRAM 设置堆栈 搬运FLASH中的代码到SDRAM 清除.bss段并跳转至第二阶段 第二阶段的硬件初始化（时钟、串口） 内存映射 根据传入参数启动内核 2.1第一阶段 该阶段的源码在/arch/cpu/arm920t/start.S中：首先进行硬件初始化，包括设置CPU模式，关闭看门狗、关闭中断。这里把时钟配置放在了第二阶段。 设置CPU模式 把CPU设置为SVC模式，将当前程序状态计数器CPSR的值保存到r0中，利用bic指令清除r0的0x1f并存入r0中，再利用orr指令或运算上0xd3并存入r0，最后r0写回CPSR,这一过程就把CPSR设置为SVC模式：[start.S]123456reset:/* set the cpu to SVC32 mode*/ mrs r0,cpsr bic r0,r0,#0x1f orr r0,r0,#0xd3 msr cpsr,r0 设置看门狗和关闭中断 根据S3C2440的datasheet，将0x00写入pWTCON对应寄存器的地址，完成看门狗的关闭。中断部分也类似，将INTMSK寄存器设置为0xffff ffff即可：[start.S]12345678910111213/* turn off the watchdog */# define pWTCON 0x53000000# define INTMOD 0X4A000004# define INTMSK 0x4A000008 /* Interupt-Controller base addresses */# define INTSUBMSK 0x4A00001C# define CLKDIVN 0x4C000014 /* clock divisor register */ ldr r0, =pWTCON mov r1, #0x0 str r1, [r0]/* turn off the int */ ldr r1, =0x3ff ldr r0, =INTSUBMSK str r1, [r0] 准备SDRAMstart.S中没有初始化SDRAM，而是先跳转到函数cpu_init_crit中，再跳转至lowlevel_init.S中进行初始化SDRAM。adr是一个位置无关指令，将_start的地址读取到r0中，上电后，Flash中的前4k就被拷到S3C2440内部RAM，则这里r0=0。然后再用ldr指令将_TEXT_BASE这个地址（来自链接脚本，代表运行地址）的值放在r1中。然后比较r0和r1的值，如果是相等的，那么证明这个时候代码已经位于了其应该位于的地方，这个时候就不再需要初始化SDRAM去重定位了。如果r1和r0的值不相等，那么将直接跳转cpu_init_crit中。[start.S]1234adr r0, _start /* r0 &lt;- current position of code */ldr r1, _TEXT_BASE /* test if we run from flash or RAM */cmp r0, r1 /* don&apos;t reloc during debug */blne cpu_init_crit [start.S]12345678910111213141516171819202122cpu_init_crit: /*flush v4 I/D caches*/ mov r0, #0 mcr p15, 0, r0, c7, c7, 0 /* flush v3/v4 cache */ mcr p15, 0, r0, c8, c7, 0 /* flush v4 TLB */ /*disable MMU stuff and caches*/ mrc p15, 0, r0, c1, c0, 0 bic r0, r0, #0x00002300 @ clear bits 13, 9:8 (--V- --RS) bic r0, r0, #0x00000087 @ clear bits 7, 2:0 (B--- -CAM) orr r0, r0, #0x00000002 @ set bit 2 (A) Align orr r0, r0, #0x00001000 @ set bit 12 (I) I-Cache mcr p15, 0, r0, c1, c0, 0 /* * before relocating, we have to setup RAM timing * because memory timing is board-dependend, you will * find a lowlevel_init.S in your board directory. */ mov ip, lr bl lowlevel_init mov lr, ip 设置栈 通常为了保存调用C语言时传递参数和保存CPU运行时的现场，需要设置栈，根据定义_TEXT_BASED为代码段的开始地址，然后在代码段的下面留出一段内存实现malloc和全局参数，再留出一点给中断模式的栈和abort异常的栈，剩下的就是栈了：[start.S]12345678910/* Set up the stack */stack_setup: ldr r0, _TEXT_BASE /* upper 128 KiB: relocated uboot */ sub r0, r0, #CFG_MALLOC_LEN /* malloc area */ sub r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo */#ifdef CONFIG_USE_IRQ sub r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)#endif sub sp, r0, #12 /* leave 3 words for abort-stack */ 搬运FLASH中的代码到SDRAM 现在将Bootloader的全部代码复制到RAM中运行： [lowlevel_init.S]1234567891011121314151617relocate: /* relocate U-Boot to RAM */ adr r0, _start /* r0 &lt;- current position of code */ ldr r1, _TEXT_BASE /* test if we run from flash or RAM */ cmp r0, r1 /* don&apos;t reloc during debug */ beq clear_bss ldr r2, _armboot_start ldr r3, _bss_start sub r2, r3, r2 /* r2 &lt;- size of armboot */ bl CopyCode2Ram /* r0: source, r1: dest, r2: size */copy_loop: ldmia r0!, &#123;r3-r10&#125; /* copy from source address [r0] */ stmia r1!, &#123;r3-r10&#125; /* copy to target address [r1] */ cmp r0, r2 /* until source end addreee [r2] */ ble copy_loop 清除.bss段并跳转至第二阶段 bss段部分保存有静态变量、没有初始化或初始化值为0的全局变量，为了减小体积和防止程序在读取它们时，读取的时上次的值，所以需要先清0： [start.S]12345678910clear_bss: ldr r0, _bss_start /* find start of bss segment */ ldr r1, _bss_end /* stop here */ mov r2, #0x00000000 /* clear */clbss_l:str r2, [r0] /* clear loop... */ add r0, r0, #4 cmp r0, r1 ble clbss_lldr pc, _start_armboot 2.2第二阶段 第二阶段的代码在lib_arm/board.c中的start_armboot()函数开始，在内部调用各自函数进行设置： 设置时钟[smdk2410.c]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int board_init (void)&#123; S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER(); S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO(); /* to reduce PLL lock time, adjust the LOCKTIME register */ clk_power-&gt;LOCKTIME = 0xFFFFFF; /* configure MPLL */ clk_power-&gt;MPLLCON = ((M_MDIV &lt;&lt; 12) + (M_PDIV &lt;&lt; 4) + M_SDIV); /* some delay between MPLL and UPLL */ delay (4000); /* configure UPLL */ clk_power-&gt;UPLLCON = ((U_M_MDIV &lt;&lt; 12) + (U_M_PDIV &lt;&lt; 4) + U_M_SDIV); /* some delay between MPLL and UPLL */ delay (8000); /* set up the I/O ports */ gpio-&gt;GPACON = 0x007FFFFF; gpio-&gt;GPBCON = 0x00044555; gpio-&gt;GPBUP = 0x000007FF; gpio-&gt;GPCCON = 0xAAAAAAAA; gpio-&gt;GPCUP = 0x0000FFFF; gpio-&gt;GPDCON = 0xAAAAAAAA; gpio-&gt;GPDUP = 0x0000FFFF; gpio-&gt;GPECON = 0xAAAAAAAA; gpio-&gt;GPEUP = 0x0000FFFF; gpio-&gt;GPFCON = 0x000055AA; gpio-&gt;GPFUP = 0x000000FF; gpio-&gt;GPGCON = 0xFF95FFBA; gpio-&gt;GPGUP = 0x0000FFFF; gpio-&gt;GPHCON = 0x002AFAAA; gpio-&gt;GPHUP = 0x000007FF; /* arch number of SMDK2410-Board */ gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE_SMDK2410; /* adress of boot parameters */ gd-&gt;bd-&gt;bi_boot_params = 0x30000100; icache_enable(); dcache_enable(); return 0;&#125; 初始化串口[serial.c]1234567891011121314151617181920int serial_init (void)&#123; serial_setbrg (); return (0);&#125;/* * Read a single byte from the serial port. Returns 1 on success, 0 * otherwise. When the function is succesfull, the character read is * written into its argument c. */int serial_getc (void)&#123; S3C24X0_UART * const uart = S3C24X0_GetBase_UART(UART_NR); /* wait for character to arrive */ while (!(uart-&gt;UTRSTAT &amp; 0x1)); return uart-&gt;URXH &amp; 0xff;&#125; 监内存映射 在smdk2410.c里的函数dram_init中设置的内存起始地址为0x3000 0000,大小为0x4000 0000:[smdk2410.c]1234567int dram_init (void)&#123; gd-&gt;bd-&gt;bi_dram[0].start = PHYS_SDRAM_1; gd-&gt;bd-&gt;bi_dram[0].size = PHYS_SDRAM_1_SIZE; return 0;&#125; 至此，U-Boot的启动过程基本分析完了，在启动U-Boot后，通过lib_arm/armlinux.c中的do_boot_linux来启动内核。这里总结画个图来记录下，中间的顺序可能有点小差异，但大致没问题：3.U-Boot移植待补充。4.U-Boot使用记录下平时使用U-Boot烧写内核/根文件系统和挂载根文件系统，这里假设如下： Ubuntu中待作为nfs挂载的路径：/work/hceng/nfs_rootfsUbuntu IP：192.168.1.141开发板 IP：192.168.1.142网关 IP：192.168.1.1 这里要提前在Ubuntu虚拟机中进行NFS配置，参考上一篇文章中的：2.3安装、 配置网络服务； 启动U-Boot后，迅速按任意键进入U-Boot的下载模式，再输入”q”退出菜单。 设置开发板ip和nfs挂载的服务ip： 123setenv serverip 192.168.1.141 //设置服务器ubuntu ipsetenv ipaddr 192.168.1.142 //设置开发板ipsaveenv 设置u-boot各分区大小（内核也要相应设置匹配，在Linux-3.4.2内核中，文件在arch/arm/mach-s3c24xx/common-smdk.c中）: 12setenv mtdparts mtdparts=nandflash0:256k@0(bootloader),128k(params),4m(kernel),-(root)saveenv 下载、擦除、烧写内核： 123nfs 30000000 192.168.1.141:/work/hceng/nfs_rootfs/uImagenand erase kernelnand write.jffs2 30000000 kernel 下载、擦除、烧写根文件系统： 123nfs 30000000 192.168.1.141:/work/hceng/nfs_rootfs/fs_mini_mdev_new.yaffs2nand erase rootnand write.yaffs 30000000 4a0000 $(filesize) 根文件系统采用nand启动： 12set bootargs noinitrd root=/dev/mtdblock3 rootfstype=yaffs2 init=/linuxrc console=ttySAC0,115200saveenv 启动后，对应的NFS挂载： 1mount -t nfs -o nolock 192.168.1.141:/work/hceng/nfs_rootfs /tmp 根文件系统采用nfs启动： 12set bootargs root=/dev/nfs nfsroot=192.168.1.141:/work/hceng/nfs_rootfs ip=192.168.1.142:192.168.1.141:192.168.1.1:255.255.255.0::eth0:off init=/linuxrc console=ttySAC0,115200 saveenv 最后启动：1boot 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/环境搭建/"}]},{"title":"搭建嵌入式Linux开发环境","date":"2017-03-23T09:19:00.000Z","path":"2017/03/23/搭建嵌入式Linux开发环境/","text":"本文主要记录在搭建嵌入式Linux开发环境过程中的. 所需材料： 虚拟机：VMware-workstation-full-12.0.0-2985596.exe Ubuntu系统镜像：ubuntu-16.04.1-desktop-amd64.iso 交叉工具链：arm-linux-gcc-4.4.3.tar.gz(根据自己需求下载) 安装脚本：install-devel-packages-for-16.sh 1.安装Ubuntu-16.04.1 打开安装好的虚拟机，选择创建新的虚拟机： 选择典型配置： 选择浏览找到ubuntu-16.04.1-desktop-amd64.iso并选中： 填入用户名、密码（本机密码：123456）： 设置虚拟机名称和保存路径： 设置虚拟机最大容量（60G差不多了）： 在弹出的向导中选择自定义硬件，设置内存、CPU、网络： 等待一会后，安装完毕，输入之前设置的密码进入系统： 点左上角的Ubuntu搜索图标，，输入t，将出现的Terminal控制台： 2.安装、配置必要软件2.1检查虚拟机网络设置 打开编辑-&gt;虚拟网络编辑器： 更改设置： 检查这三个配置： 输入ifconfig查看网络配置，再ping www.baidu.com测试： 2.2修改软件源 首先备份原来的文件：1$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup 用vi编辑器打开编辑：1$ sudo vi /etc/apt/sources.list 删掉文件中的所有内容，替换为以下文本：123456789101112131415161718# deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricteddeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse 注： 此时vi是不完全版的，很难用，编辑模式下方向键是乱的，使用gedit打开编辑，后面再更新vi：1$ sudo gedit /etc/apt/sources.list 此时Ubuntu默认装了VMware Tools，可以复制windows下的文本，然后ctrl+shift+v在Ubuntu里面粘贴文本。也支持windows里文件和Ubuntu的直接拖拽复制。 完成上面的修改后，再更新软件列表和安装完整的vim：12$ sudo apt-get update$ sudo apt-get install vim 安装过程中根据提示输入yes确认，下同。 2.3安装、 配置网络服务 执行以下命令安装 ftp、ssh、nfs服务：1$ sudo apt-get install vsftpd openssh-server nfs-kernel-server portmap 配置 FTP 服务：修改 vsftpd 的配置文件/etc/vsftpd.conf，检查下面两行前面的“#”号是否去掉。第28行，默认没有#：1local_enable=YES 第31行，默认有#，去掉#：1# write_enable=YES 注： 上面第一个表示是否允许本地用户登录，第二行个示是否允许上传文件。 在vim的命令模式输入如下命令即可显示行号：1:set nu 修改完华之后，执行以下命令重启 ftp 服务：1$ sudo /etc/init.d/vsftpd restart 配置 NFS 服务修改/etc/exports，增加以下内容，以后开发板可以通过网络文件系统访问/work 目录和专门用来作为根文件系统挂载的/work/hceng/nfs_rootfs目录： 12/work *(rw,sync,no_root_squash,no_subtree_check)/work/hceng/nfs_rootfs *(rw,sync,no_root_squash,no_subtree_check) 修改完华之后，执行以下命令重启 nfs 服务： 1$ sudo /etc/init.d/nfs-kernel-server restart 最后，关闭Ubuntu的防火墙：1$ sudo ufw disable 4.安装基本开发环境： 这里使用韦东山老师第四期安卓视频环境搭建提供的脚本，这个脚本会自动安装诸如 g++等工具、 库。但该脚本是为Ubuntu12制作的，Ubuntu16使用需要做一些修改，主要是名字变了。修改变化如下：1libgl1-mesa-glx-lts-quantal:i386 libgl1-mesa-dev-lts-quantal \\ 改为：1libgl1-mesa-glx-lts-xenial:i386 libgl1-mesa-dev-lts-xenial \\ 将修改后的脚本文件改为：install-devel-packages-for-16.sh 拖拽到自己建的/work/tool里面，加入可执行权限，然后执行：12$ sudo chmod +x install-devel-packages-for-16.sh$ sudo ./install-devel-packages-for-16.sh 然后报错,提示差mingw32： 解决：在源中加入如下部分：1deb http://cz.archive.ubuntu.com/ubuntu trusty main universe 再更新列表，再执行就没问题了：12$ sudo apt-get update$ sudo ./install-devel-packages-for-16.sh 3.安装基本开发环境 这里使用arm-linux-gcc-4.4.3.tar.gz，之前用的4.5出了问题，换成这个就好了，暂时用这个版本。把文件拖进/work/tool，解压到根目录：1$ sudo tar xzf arm-linux-gcc-4.4.3.tar.gz –C / 再修改环境变量： 1$ sudo vim /etc/ environment 把工具链目录添加到最后，内容如下： 1PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/opt/FriendlyARM/toolschain/4.4.3/bin&quot; 重启Ubuntu，输入如下命令检测是否正常： 1$ arm-linux-gcc –v 至此，开发环境以基本搭建完成。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/环境搭建/"}]},{"title":"设备驱动模型","date":"2017-03-18T15:44:00.000Z","path":"2017/03/18/设备驱动模型/","text":"最近在看设备驱动模型，记录下分析的结构。 设备驱动模型提供了硬件的抽象，内核可以使用该抽象完成很多硬件重复的工作，这样很多重复的代码就不需要重复编写和调试了。这些抽象包括：电源管理、即插即用设备的支持、与用户空间的通信。 1.sysfs文件系统 sysfs文件系统是Linux众多文件系统中的一个，在Linux中每个文件系统都要自己的特殊的用途。Liunx设备驱动模型由大量的数据结构和算法组成，数据结构之间通过指针相互关联，构成树形或者网状关系。显示这种关系最好的利用树形结构的文件系统，同时还要显示内核中一些关于设备、驱动和驱动的信息，因此内核开发者创造sysfs这种新文件系统来实现上述的要求。 sysfs是一个只存在于内存的文件系统，内核通过这个文件系统将系统信息导出到用户空间，同时用户空间的数据也能通过它传到内核中，实现设置驱动程序的状态和属性。 sysfs文件系统是内核对象（kobject）、属性（kobj_type）及它们互相关系的一种表现机制。内核与sysfs的关系如下： Linux内核中的结构 sysfs中的结构 kobject 目录 kobj_type 属性文件 对象间的关系 符号链接 2.核心数据结构 设备驱动模式由kobject、kset、subsystem这三个核心数据结构组成。 2.1 kobject 在Linux系统中，kobject结构体是组成设备驱动模型的基本结构，提供最基本的设备对象管理能力，每个在内核注册的kobject对象都对应sysfs文件系统中的一个目录。 kobject结构体：1234567891011121314struct kobject &#123; const char *name; /* 对应sysfs的目录名 */ struct list_head entry; /* kobjetct双向链表 ,指向下一个kobject结构*/ struct kobject *parent; /* 指向kset中的kobject，相当于指向父目录 */ struct kset *kset; /*指向所属的kset */ struct kobj_type *ktype; /*指向kobject的类型描述符*/ struct sysfs_dirent *sd; /*对应的sysfs文件目录*/ struct kref kref; /*kobject引用计数，为0释放*/ unsigned int state_initialized:1; /*kobject是否已初始化，1初0未*/ unsigned int state_in_sysfs:1 ; /*kobject是否注册到sysfs*/ unsigned int state_add_uevent_sent:1; unsigned int state_remove_uevent_sent:1; unsigned int uevent_suppress:1;&#125;; kobject操作函数： 2.2 kset kobject通过kset组织层次化，kest是拥有相同类型的kobject的集合。 kset结构体：123456struct kset &#123; struct list_head list; /* 连接所包含的kobject对象的链表头部 */ spinlock_t list_lock; /* 添加/删除kobject时使用的自旋锁 */ struct kobject kobj; /*所有属于该kset的kobject的parent均指向这 */ const struct kset_uevent_ops *uevent_ops; /* 热拔插事件函数集 */&#125;; kset操作函数： kest和kobject关系： 2.3 注册kobject到sysfs中的实例[kobject_test.c]link123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/* 目的：在/sys目录下添加一个名为kobject_test的目录名， 并在该目录下添加一个kobject_test_attr的文件，这个文件为属性文件； 功能：koject_test_show()函数显示属性的值； kobject_test_store()函数向属性中写入一个值；*/#include &lt;linux/device.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/sysfs.h&gt;#include &lt;linux/stat.h&gt;/*声明释放kobject结构体函数*/void kobject_test_release(struct kobject *kobject);/*读属性的函数*/ssize_t kobject_test_show(struct kobject *kobject, struct attribute *attr, char *buf);/*写属性的函数*/ssize_t kobject_test_store(struct kobject *kobject, struct attribute *attr, const char *buf, size_t count);/*定义了一个名为kobject_test，可以读写的属性*/struct attribute test_attr = &#123; .name = \"kobject_test_attr\", .mode = S_IRWXUGO,&#125;;/*该object只有一个属性*/static struct attribute *def_attrs[] = &#123; &amp;test_attr, NULL,&#125;;/*操作函数*/struct sysfs_ops obj_test_sysops = &#123; .show = kobject_test_show, .store = kobject_test_store,&#125;;/*kobject属性*/struct kobj_type ktype = &#123; .release = kobject_test_release, .sysfs_ops = &amp;obj_test_sysops, .default_attrs = def_attrs,&#125;; /*释放kobject结构体函数*/void kobject_test_release(struct kobject *kobject)&#123; printk(\"kobject_test: kobject_test_release(). \\n\");&#125;/*该函数用于读取一个属性的名字*/ssize_t kobject_test_show(struct kobject *kobject, struct attribute *attr, char *buf)&#123; printk(\"call kobject_test_show(). \\n\"); printk(\"attrname:%s.\\n\", attr-&gt;name); sprintf(buf, \"%s\\n\", attr-&gt;name); return strlen(attr-&gt;name)+2;&#125;/*该函数用于写入一个属性的值*/ssize_t kobject_test_store(struct kobject *kobject, struct attribute *attr, const char *buf, size_t count)&#123; printk(\"call kobject_test_store(). \\n\"); printk(\"write: %s\\n\", buf); strcpy(attr-&gt;name, buf); return count;&#125;/*入口函数*/struct kobject kobj;static int kobject_test_init()&#123; printk(\"kobject test_init().\\n\"); kobject_init_and_add(&amp;kobj, &amp;ktype, NULL, \"kobject_test\"); return 0;&#125;/*出口函数*/static int kobject_test_exit()&#123; printk(\"kobject test exit.\\n\"); kobject_del(&amp;kobj); return 0;&#125;module_init(kobject_test_init);module_exit(kobject_test_exit);MODULE_AUTHOR(\"hceng\");MODULE_LICENSE(\"Dual BSD/GPL\"); [kobject_app.c]link123456789101112131415161718192021222324252627#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;poll.h&gt;#include &lt;signal.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;/* kobject_test */int fd;int main(int argc, char **argv)&#123; fd = open(\"/dev/kobject_test\", O_RDWR); if (fd &lt; 0) &#123; printf(\"can't open!\\n\"); return -1; &#125; return 0;&#125; 调用关系： 3.三大组件 设备驱动模型中有三个重要的组件：总线（bus_type）、设备（device）、驱动（driver）,三者关系如下： bus_type通过扫描设备链表和驱动链表，使用mach方法查找匹配的设备和驱动，然后将struct device中的*driver设置为匹配的驱动； 将struct device_driver中的device设置为匹配的设备，这就完成了将总线、设备和驱动3者之间的关联； bus_type只有很少的成员必须提供初始化，大部分由设备模型核心控制； 内核提供许多函数实现bus_type的注册注销等操作，新注册的总线可以再/sys/bus目录下看到； 3.1总线 总线数据结构bus_type：1234567891011121314151617181920212223struct bus_type &#123; const char *name; /* 总线类型名 */ struct bus_attribute *bus_attrs; /* 总线的属性、方法 */ struct device_attribute *dev_attrs; /* 设备属性,为每个加入总线的设备建立属性链表 */ struct driver_attribute *drv_attrs; /* 驱动属性,为每个加入总线的驱动建立属性链表 */ /* 驱动与设备匹配函数:当一个新设备或者驱动被添加到这个总线时，这个方法会被调用一次或多次， 若指定的驱动程序能够处理指定的设备，则返回非零值。 必须在总线层使用这个函数, 因为那里存在正确的逻辑，核心内核不知道如何为每个总线类型匹配设备和驱动程序 */ int (*match)(struct device *dev, struct device_driver *drv); /*在为用户空间产生热插拔事件之前，这个方法允许总线添加环境变量（参数和 kset 的uevent方法相同）*/ int (*uevent)(struct device *dev, struct kobj_uevent_env *env); int (*probe)(struct device *dev); int (*remove)(struct device *dev); /* 设备移除调用操作 */ void (*shutdown)(struct device *dev); int (*suspend)(struct device *dev, pm_message_t state); int (*resume)(struct device *dev); const struct dev_pm_ops *pm; /*电源管理相关操作符*/ struct subsys_private *p; /* 一个很重要的域，包含了device链表和drivers链表 */&#125;; 相关操作函数： 3.2设备 设备数据结构device：12345678910111213141516171819202122232425262728293031323334353637struct device &#123; struct device *parent; /* 父设备，总线设备指定为NULL */ struct device_private *p; /* 包含设备链表，driver_data（驱动程序要使用数据）等信息 */ struct kobject kobj; const char *init_name; /* 初始默认的设备名,但@device_add调用之后又重新设为NULL */ struct device_type *type; struct mutex mutex; /* mutex to synchronize calls to its driver */ struct bus_type *bus; /* type of bus device is on */ struct device_driver *driver; /* which driver has allocated this device */ void *platform_data; /* Platform specific data, device core doesn't touch it */ struct dev_pm_info power; #ifdef CONFIG_NUMA int numa_node; /* NUMA node this device is close to */ #endif u64 *dma_mask; /* dma mask (if dma'able device) *///Like dma_mask, but for alloc_coherent mappings as not all hardware supports 64 bit addresses //for consistentallocations such descriptors. u64 coherent_dma_mask; struct device_dma_parameters *dma_parms; struct list_head dma_pools; /* dma pools (if dma'ble) */ struct dma_coherent_mem *dma_mem; /* internal for coherent mem override */ /* arch specific additions */ struct dev_archdata archdata; #ifdef CONFIG_OF struct device_node *of_node; #endif dev_t devt; /* dev_t, creates the sysfs \"dev\" 设备号 */ spinlock_t devres_lock; struct list_head devres_head; struct klist_node knode_class; struct class *class; const struct attribute_group **groups; /* optional groups */ void (*release)(struct device *dev); &#125;; 3.3驱动 驱动数据结构driver·：1234567891011121314151617181920struct device_driver &#123; const char *name; /* 驱动名称,在sysfs中以文件夹名出现 */ struct bus_type *bus; /* 驱动属于的总线，总线上可以有很多设备 */ struct module *owner; /* 设备驱动自身模块 */ const char *mod_name; /* 驱动模块名字 */ bool suppress_bind_attrs; /* disables bind/unbind via sysfs */ const struct of_device_id *of_match_table; /*检测设备方法，并检测设备驱动可以控制那些设备*/ int (*probe) (struct device *dev); int (*remove) (struct device *dev); /*移除设备时调用的方法*/ void (*shutdown) (struct device *dev); /*关闭设备时调用的方法*/ int (*suspend) (struct device *dev, pm_message_t state); /*处于低功耗时调用的方法*/ int (*resume) (struct device *dev); /*恢复正常状态时调用的方法*/ const struct attribute_group **groups; /*属性组*/ const struct dev_pm_ops *pm; /*用于电源管理*/ struct driver_private *p; /* 定义device_driver中的私有数据类型 */ &#125;; 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/tags/Linux驱动/"},{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"}]},{"title":"Linux常用命令","date":"2017-03-12T15:14:00.000Z","path":"2017/03/12/Linux常用命令/","text":"本文主要汇总一些常用且不太熟练的Liunx命令，不定期更新。 1. tar作用：打包（拆包）/压缩（解压）文件； 语法：tar [主选项+辅选项] 文件或目录 主选项： c ：打包文件； x ：拆包文件； t ：列出包/压缩文件里有哪些文件。辅选项： z ：具有 gzip 属性；格式为xx.tar.gz或xx. tgz； j ：具有 bzip2 属性；格式为xx.tar.bz2； v ：显示压缩文件过程； f ：在其后必须是文件名； - -exclude xxx：打包除xxx文件之外的文件；示例：1234567$ tar cf test.tar test #打包test文件/文件夹为test.tar;$ tar xf test.tar #拆包test.tar；$ tar czf test.tar.gz test #压缩test文件/文件夹为test.tar.gz；$ tar xzf test.tar.gz #解压test.tar.gz；$ tar cjf test.bzip2 test #压缩test文件/文件夹为test.bzip2；$ tar xjf test.bzip2 #解压test.bzip2；$ tar cf test.tar --exclude test.txt test #打包test文件夹里除test.txt之外的为test.tar 2. grep作用：查找字符串； 语法：grep [选项] ‘搜寻字符串’ 文件名 选项： -c ：计算找到 ‘搜寻字符串’ 的次数; -i ：忽略大小写; -n ：顺便输出行号; -v ：反向选择，即显示出没有 ‘搜寻字符串’ 内容的那一行;示例：1$ grep -n &apos;test&apos; test.txt #搜索test.txt中含test的行，且显示对应行号； 3. find作用：选项较多，这里暂仅使用name选项查找文件； 语法：find 路径 -name “文件名”示例：1$ find -name &quot;test&quot; #在当前文件下找test文件； 4. ifconfig作用：网卡配置； 语法：ifconfig [网络设备] [参数]”示例：12345678#设置网卡1的地址 192.168.1.44，掩码为255.255.255.0（即默认）；$ ifconfig eth0 192.168.1.44 netmask 255.255.255.0#捆绑网卡1的第二个地址为 192.168.1.x$ ifconfig eth0:x 192.168.1.x#打开网卡1$ ifconfig eth0 up#关闭网卡1$ ifconfig eth0 down 5. mount作用：目前只用来挂载NFS； 语法：mount -t nfs 服务器ip:挂载目录 挂载到本地哪里”示例：12#把主机(192.168.1.44)的/work/hceng/nfs_rootfs挂载到本地/tmp目录下；$ mount -t nfs 192.168.1.44:/work/hceng/nfs_rootfs /tmp 6. 查看Linux版本信息示例：1234$ uname -a #显示电脑以及操作系统的相关信；$ cat /proc/version #正在运行的内核版本；$ cat /etc/issue #显示的是发行版本信息；$ lsb_release -a #列出所有版本信息； 7. 关闭防火墙示例：12$ ufw disable #关闭ubuntu的防火墙 ；$ ufw enable #开启防火墙； 7. source作用：免重启更新环境变量；示例：1$ source /etc/environment 8. vim作用：vim里代码自动格式化；示例：123ggvG= 最后修改时间：2017/3/31 19:57:49 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux基础/"}]},{"title":"Makefile小结","date":"2017-03-11T09:44:00.000Z","path":"2017/03/11/Makefile小结/","text":"本文主要是记录一些遇到的Makefile知识。 Makefile以韦东山老师第一期裸板视频中的 第8课LCD实验的配套代码lcd_3.5_4.3 中的Makefile为例，该工程有两个Makefile,分别位于根目录和lib目录中：[根目录Makefile]123456789101112131415161718192021222324252627282930313233CC = arm-linux-gccLD = arm-linux-ldAR = arm-linux-arOBJCOPY = arm-linux-objcopyOBJDUMP = arm-linux-objdumpINCLUDEDIR := $(shell pwd)/includeCFLAGS := -Wall -O2CPPFLAGS := -nostdinc -I$(INCLUDEDIR)export CC LD AR OBJCOPY OBJDUMP INCLUDEDIR CFLAGS CPPFLAGSobjs := head.o init.o nand.o interrupt.o serial.o lcddrv.o/ framebuffer.o lcdlib.o main.o lib libc.alcd.bin: $(objs) $&#123;LD&#125; -Tlcd.lds -o lcd_elf $^ $&#123;OBJCOPY&#125; -O binary -S lcd_elf $@ $&#123;OBJDUMP&#125; -D -m arm lcd_elf &gt; lcd.dis.PHONY : lib/libc.alib/libc.a: cd lib; make; cd .. %.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;clean: make clean -C lib rm -f lcd.bin lcd_elf lcd.dis *.o 主Makefile总领全局的就这句:1lcd.bin: $(objs)要生成lcd.bin，依赖于objs列举的一堆文件：head.o init.o nand.o interrupt.o serial.o lcddrv.o framebuffer.o lcdlib.o main.o lib libc.a，所以要先找到这些文件，几个.o，还有一个.a。 .o目标文件怎么生成？%.o:%.c和%.o:%.S是生成规则，就是依赖于.c或.S文件，使用交叉编译命令生成。 .a目标文件怎么生成？.a是库文件，到lib子目录里去找，在子目录里用make命令生成。 注:链接：将多.o文件，或者.o文件和库文件链接成为可被操作系统执行的可执行程序（Linux环境下，可执行文件的格式为“ELF”格式）。链接器不检查函数所在的源文件，只检查所有.o文件中的定义的符号。将.o文件中使用的函数和其它.o或者库文件中的相关符号进行合并，对所有文件中的符号进行重新安排（重定位），并链接系统相关文件（程序启动文件等）最终生成可执行程序。链接过程使用GNU 的“ld”工具。静态库：又称为文档文件（Archive File）。它是多个.o文件的集合。Linux中静态库文件的后缀为“.a”。静态库中的各个成员（.o文件）没有特殊的存在格式，仅仅是一个.o文件的集合。使用“ar”工具维护和管理静态库。共享库：也是多个.o文件的集合，但是这些.o文件时有编译器按照一种特殊的方式生成（Linux中，共享库文件格式通常为“ELF”格式。共享库已经具备了可执行条件）。模块中各个成员的地址（变量引用和函数调用）都是相对地址。使用此共享库的程序在运行时，共享库被动态加载到内存并和主程序在内存中进行连接。多个可执行程序可共享库文件的代码段（多个程序可以共享的使用库中的某一个模块，共享代码，不共享数据）。另外共享库的成员对象可被执行（由libdl.so提供支持）。 下面进行分析： 第一至五行：12345CC = arm-linux-gccLD = arm-linux-ldAR = arm-linux-arOBJCOPY = arm-linux-objcopyOBJDUMP = arm-linux-objdump 作用：将右边工具链名赋值给左边变量，为了简化书写； 分析： arm-linux-gcc：编译.c或.s头的C文件或汇编程序； arm-linux-ld：连接器，把多个.o文件或库文件连接成一个可执行文件； arm-linux-ar：库管理器，把多个.o文件合并成一个.o文件或静态库文件（.a文件）； arm-linux-objcopy：转换可执行文件的格式； arm-linux-objdump：生成反汇编； 第七行：1INCLUDEDIR := $(shell pwd)/include 作用：将shell命令和include组成的路径立即赋值给左边变量，为了简化书写； 分析：Makefile中调用shell命令：$(shell 命令)； ‘ = ’与‘ := ’的区别注： - “ = ”：make会将整个Makefile展开后，再决定变量的值。也就是说，变量的值将会是整个,Makefile中最后被指定的值。看例子： 123x = fooy = $(x) barx = xyz 在上例中，y的值将会是 xyz bar ，而不是 foo bar 。- “ := ”表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。 123x := fooy := $(x) barx := xyz 在上例中，y的值将会是 foo bar ，而不是 xyz bar 了。 第八行：1CFLAGS := -Wall -O2 作用：将gcc的编译参数赋值给左边变量，为了简化书写； 分析：-Wall显示所有编译错误或警告；-O2优化选项，编译时使用2级优化 第九行：1CPPFLAGS := -nostdinc -I$(INCLUDEDIR) 作用：将gcc编译路径参数赋值给左边变量，为了简化书写； 分析：-nostdinc忽略系统库目录（这里我们自定义了printf等系统函数，不能再包含系统文件里的相关函数）；-I指定搜索路径； 第十一行：1export CC LD AR OBJCOPY OBJDUMP INCLUDEDIR CFLAGS CPPFLAGS 作用：将变量传递到下级Makefile，类似于宏； 分析：本文件中指的是生成lib/libc.a库文件时的Makefile； 第十三行：12objs := head.o init.o nand.o interrupt.o serial.o lcddrv.o/ framebuffer.o lcdlib.o main.o lib libc.a 作用：定义变量objs，包含了生成目标文件所需的文件，为了简化书写； 分析：一行代码写不完，使用/符号可继续在下行写； 第十六行：1lcd.bin: $(objs) 作用：定义生成目标lcd.bin，依赖于objs对象； 分析：执行这条命令时，先生成所有依赖文件，然后依次执行后面三条命令； 第十七行：1$&#123;LD&#125; -Tlcd.lds -o lcd_elf $^ 作用：根据链接脚本lcd.lds链接，输出目的文件lcd_elf,依赖全部文件； 分析：-T指定链接脚本；$^表示全部依赖文件； 第十八行：1$&#123;OBJCOPY&#125; -O binary -S lcd_elf $@ 作用：将lcd_elf文件转换成二进制文件； 分析：-O表示输出格式;-S表示不从源文件中复制重定位信息和符号信息到目标文件中；$@表示全部目标文件； 第十九行：1$&#123;OBJDUMP&#125; -D -m arm lcd_elf &gt; lcd.dis 作用：将lcd_elf文件反汇编为lcd.dis文件； 分析：-m后面跟的是cpu构架;&gt;表示将这个程序的反汇编程序写入到led.dis这个文件中,在终端中不显示出来； 第二十一行：1.PHONY : lib/libc.a 作用：.PHONY伪目标，不要管lib/libc.a文件是否存在，都执行后面的指令； 分析：通常为了避免伪目标和文件重名的这种情况，使用特殊的记“.PHONY”来显示地指明一个目标是“伪目标”； 第二十二、二十三行：12lib/libc.a: cd lib; make; cd .. 作用：执行lib文件夹的Makefile，从而生成libc.a； 分析：执行shell指令，进入lib目录，make，退出； 第二十五至二十九行：1234%.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt; 作用：依赖所有的.c和.S文件，生成所有的.o文件； 分析：%通配符；-c编译不链接;$@表示目标文件;$&lt;表示第一个依赖文件; 第三十一至三十三行：1234%.o:%.Sclean: make clean -C lib rm -f lcd.bin lcd_elf lcd.dis *.o 作用：清理所有生成文件； 分析：-C lib即清理包括lib文件夹下生成的文件; 下面是lib目录Makefile: [lib目录Makefile]123456789101112131415objs := div64.o lib1funcs.o ctype.o muldi3.o printf.o string.o/vsprintf.olibc.a: $(objs) $&#123;AR&#125; -r -o $@ $^ %.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;clean: rm -f libc.a *.o 第一、二行：12objs := div64.o lib1funcs.o ctype.o muldi3.o printf.o string.o/vsprintf.o 作用：定义变量objs，包含了生成目标文件所需的文件，为了简化书写； 分析：一行代码写不完，使用/符号可继续在下行写； 第四、五行：12libc.a: $(objs) $&#123;AR&#125; -r -o $@ $^ 作用：使用库管理器生成lib.a； 分析：$@表示目标文件;$^所有依赖文件； 第七至十一行：1234%.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt; 作用：依赖所有的.c和.S文件，生成所有的.o文件； 分析：%通配符；-c编译不链接;$@表示目标文件;$&lt;表示第一个依赖文件; 第十三、十四行：123%.o:%.Sclean: rm -f libc.a *.o 作用：清理所有生成文件； 分析：-f强制删除; 参考博文：sekon LCD实验学习笔记（一）：Makefile 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"Makefile","slug":"Makefile","permalink":"http://yoursite.com/tags/Makefile/"}]},{"title":"汇编指令小结","date":"2017-03-10T03:55:00.000Z","path":"2017/03/10/汇编指令小结/","text":"本文主要是记录一些遇到的ARM汇编知识。 汇编代码以韦东山老师的 第7章nand flash实验配套代码13th_link_4096 中的start.S为例：[start.S]12345678910111213141516171819202122232425262728293031323334353637383940414243.globl _start_start:/* 硬件相关的设置 : 把外设的基地址告诉CPU*/ /* Peri port setup */ ldr r0, =0x70000000 orr r0, r0, #0x13 mcr p15,0,r0,c15,c2,4 @ 256M(0x70000000-0x7fffffff) /* 关看门狗 *//* 往WTCON(0x7E004000)写0 */ ldr r0, =0x7E004000 mov r1, #0 str r1, [r0]/* 重定位 */ adr r0, _start /* _start当前指令地址 */ ldr r1, =_start /* _start的编译地址 */ ldr r2, =bss_start cmp r0, r1 beq clean_bsscopy_loop: ldr r3, [r0], #4 str r3, [r1], #4 cmp r1, r2 bne copy_loop /* 清BSS段 */clean_bss: ldr r0, =bss_start ldr r1, =bss_end mov r2, #0clean_loop: str r2, [r0], #4 cmp r0, r1 bne clean_loop /* 设置栈 */ ldr sp, =8*1024 ldr pc, =main /* 重定位完后, 使用位置相关的指令跳转 */ bl mainhalt: b halt 第六行：1ldr r0, =0x70000000 格式：ldr&emsp;目的寄存器&emsp;&lt;存储器地址&gt; 作用：将 存储器地址 所指地址处连续的4个字节（1个字）的数据传送到目的寄存器中。 第七行：1orr r0, r0, #0x13 格式：orr&emsp;目的寄存器，&emsp;操作数 1，&emsp;操作数 2 作用：常用于设置操作数1 的某些位，在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中。操作数1 应是一个寄存器，操作数2 可以是一个寄存器、被移位的寄存器或一个立即数。 第八行：1mcr p15,0,r0,c15,c2,4 格式：mcr&emsp;协处理器编码，&emsp;协处理器操作码1，&emsp;源寄存器，&emsp;目的寄存器1，&emsp;目的寄存器2，&emsp;协处理器操作码2 作用：将ARM处理器寄存器中的数据传送到协处理器寄存器中,若协处理器不能成功完成操作，则产生未定义指令异常。其中协处理器操作码1 和协处理器操作码2 为协处理器将要执行的操作，源寄存器为ARM处理器的寄存器，目的寄存器1和目的寄存器2均为协处理器的寄存器。 第十四行：1str r1, [r0] 格式：str&emsp;源寄存器&emsp;&lt;存储器地址&gt; 作用：用于从源寄存器中将一个32位的字数据传送到存储器中。在ARM架构下, 数据从内存到CPU之间的移动只能通过ldr/str指令来完成。而mov只能在寄存器之间移动数据,或者把立即数移动到寄存器中,并且数据的长度不能超过8位。 第十七行：1adr r0, _start 格式：adr&emsp;目的寄存器&emsp;程序相对的表达式 作用：可将一个立即值与pc值相加，并将结果写入目标寄存器。adr可生成与位置无关的代码，因为地址相对于程序或寄存器。详见ARM指令adr。 第二十行：1cmp r0, r1 格式：cmp&emsp;操作数1，&emsp;操作数2 作用：用于把一个寄存器的内容和另一个寄存器的内容或立即数进行比较，同时更新CPSR中条件标志位的值。该指令进行一次减法运算，但不存储结果，只更改条件标志位。标志位表示的是操作数1与操作数2的关系(大、小、相等)，例如，当操作数1大于操作操作数2，则此后的有GT 后缀的指令将可以执行。 CPSR注： Z标志：是否为0；如比较指令产生相等的结果、计算结果为0； N标志：是否为负；如果指令的结果被认为是有符号数，而它的第31位为1，那就会被设置为1； C标志：是否有产生进位/借位，以及进行移位操作时作移出位使用； V标志：有符号数进行运算，结果是否有溢出。 第二十一行：1beq clean_bss 格式：beq&emsp;标签 作用：数据跳转指令，标志寄存器中Z标志位等于零时, 跳转到beq后标签处。 第二十六行：1bne copy_loop 格式：bne&emsp;标签 作用：数据跳转指令，标志寄存器中Z标志位不等于零时, 跳转到bne后标签处。 第四十一行：1bl main 格式：bl&emsp;子程序名 作用：b或bl指令引起处理器转移到子程序名处开始执行。两者的不同之处在于bl指令在转移到子程序执行之前，将其下一条指令的地址拷贝到R14（LR,链接寄存器）。由于bl指令保存了下条指令的地址，因此使用指令“mov pc, lr”即可实现子程序的返回。而b指令则无法实现子程序的返回，只能实现单纯的跳转。 ARM处理器控制程序执行方式注： 流水方式执行程序：PC的值是下一条指令的地址，即每执行一条指令PC都加一个字的偏移。 通过跳转指令来控制程序执行:b-跳转到指定的指令处执行;bl-跳转执行，保存子程序地址并返回;bx-跳转执行并切换到Thumb状态;blx-三种方式组合。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/tags/汇编/"}]},{"title":"GitHub+Hexo博客搭建及优化","date":"2017-03-06T11:26:00.000Z","path":"2017/03/06/GitHub+Hexo搭建及优化/","text":"本文主要是记录本博客的搭建和优化。 为什么做独立博客？我想大概就是激励自己去持续学习和思考。 首先说下本博客搭建的大致流程:1.有一个GitHub账号，同时配置GitHub Pages；2.安装、配置Hexo；3.配置博客、Markdown写文章；4.绑定自己域名（可选）；5.优化日常操作（可选）； 1.Github Pages Github Pages是GitHub提供的免费静态站点； 创建Github Pages后，在里面存放网页源码，然后在对应网址就可看到对应网页效果； 使用GitHub账号创建一个仓库，但是这个仓库是有规则的，其格式必须为：yourusername.github.io； 注： yourusername必须是自己的GitHub账号名； 类型只能选Public； 2.安装、配置Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。1、安装 Node.js;2、下载Cmder代替Windows自带cmd;3、安装 Git;4、添加本机密钥到GitHub;5、安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，在Git上设置username和email；其中3-5步在前一篇博文Git日常使用小结中已设置过了，无需再设置。6、安装 Hexo：使用 npm 安装 Hexo。1$ npm install -g hexo-cli至此，已经安装完Hexo,后续进行相关配置。7、在电脑上选一个盘，建个文件夹存放博客数据，例我的：E:\\blog；然后打开cmder，输入:12$ e: &amp; cd blog #进入所建文件夹$ hexo init blog #初始化blog成功初始化blog后将出现：1INFO Start blogging with Hexo!8、最后再生成静态网页，即可看到网页模板：12$ hexo generate # 启动本地服务器$ hexo server # 在浏览器输入 http://localhost:4000/就可以看见网页和模板了完成后，将会看到如下提示：12INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.此时，打开浏览器，输入http://localhost:4000/就可以看见默认的网页和模板了。 3.配置博客、发表文章 在blog目录下，用Sublime Text(使用它的原因是默认是UTF-8编码，中文不会乱码)打开_config.yml文件，修改参数信息； 注：在每个参数的”：”后都要加一个空格修改网站相关信息; 3.1修改网站相关信息：1234567# Sitetitle: hceng blogsubtitle: Linux/Android驱动 description: 生命不息、折腾不止author: hcenglanguage: zh-CNtimezone: Asia/Shenzhen 3.2修改配置部署相关信息：123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: 'git@github.com:hceng/hceng.github.io.git' branch: master- type: git repo: 'git@git.coding.net:hceng/hceng.git' branch: coding-pages 这里由于我同时提交到了GitHub和Coding,用于测试百度收录，所以有两个，写一个也没事。 注:如果在执行 hexo deploy 后,出现 error deployer not found:github(git) 的错误，执行： 1$ npm install hexo-deployer-git --save 3.3修改主题： 为了让博客更加美观和符合自己需求，可以修改Hexo主题来满足自己需求。Hexo 安装主题的方式非常简单，只需要将主题文件放置于站点目录的 themes 目录下，然后修改下配置文件即可。 Hexo 有两份主要的配置文件（_config.yml），一份位于站点根目录下，另一份位于主题目录下。为了描述方便，在以下说明中，将前者称为 站点配置文件，后者称为 主题配置文件。 下载hexo-theme-yilia主题,解压放入themes文件夹下，如：E:\\blog\\blog\\themes，根据自己需求修改主题配置文件，最后再修改站点配置文件里的theme:1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-yilia 在主题配置文件里，修改头像、颜色、标签等，都有相应的注释写得非常清楚，按需修改。 3.4发表文章： 在Cmder中输入：12$ hexo new \"blog tags\"INFO Created: E:\\blog\\blog\\source\\_posts\\blog-tags.md 根据提示得路径，即可找到新建得文件，该文件使用Markdown语法，下载MarkdownPad2进行编辑。先修改相关的文章信息：123456---title: blog tagstags: - 随笔--- 本文主要是总结blog预计的标签，并不定时更新。 可修改标题、标签（本有日期的修改选项，但有日期就不能显示文章，怀疑是主题或者其它地方干扰了，文章日期就是文件创建日期）。然后简单说下Markdown语法： 3.4.1标题和引用 行首插入 1 到 6 个 # ，对应到标题 1 到 6 级标题： 123# 一级标题## 二级标题## 三标题 效果：见本文（影响目录效果，就不示例了）。 区块引用则使用 ‘&gt;’ 角括号来表示： 1&gt; 这是引用 效果： 这是引用 3.4.2列表和强调 列表分有序的1、2、3和无序的·：12- 列表1- 列表2 效果： 列表1 列表2 强调有加粗和斜体，用”*”来表示： 12**加粗***斜体* 效果：加粗斜体 3.4.3超链接和图片 在方括号”[]”写要显示标，在小括号”()”写链接：1[hceng blog](http://hceng.cn/)效果：hceng blog 在文章如果需要加入图片，先需要把图片传到床图网站，生成链接后插入使用，格式如下：1![](图片网址) 3.4.4加入代码 Markdown支持插入代码，使用单引号”`“来标注,注意是英文输入法下，左上角那个按键：1`hello`效果：hello 这种方式感觉不够醒目，而且不支持语法高亮，所以我一般使用Codeblock，语法见网站，效果如下：123456#include &lt;stdio.h&gt;int main(void)&#123; printf(\"hello,world!\"); return 0;&#125; 4.绑定自己域名（可选） 完成以上步骤后，默认域名是GitHub提供的二级域名：yoursname.github.io,下面开始绑定自己的域名： 4.1购买域名 推荐GoDaddy或万网； 我是在万网买的，首推买.com，其次.me、.top、.cn系列，根据自己喜好来，各有特色优缺点； 然后继续交实名认证、审核，还是比较快；4.2绑定域名 保证上述工作完成，域名可用； 修改DNS，分别修改为：f1g1ns1.dnspod.net和f1g1ns2.dnspod.net 本地站点目录里的source目录下添加一个CNAME文件，里面写上网址； 注:CNAME不要有任何后缀；网址不要写www或http：//,直接写hceng.cn这种； 注册DNSpod，然后添加域名，添加记录： 参考红线部分填写，一个主机纪录是@，记录类型是CNAME，线路类型填默认（图片中略有不同，是我测试百度抓取用的，暂时可不管），记录值写对应的GitHub Pages的地址；另一个主机纪录填www，其它和上面的一样。 最后把本地的Hexo生成一下，再提交到Github pages上； 5.优化日常操作（可选）5.1hexo命令简写：12345$ hexo n “新文章” == hexo new “新文章” #新建文章$ hexo c == hexo clear #清理静态文件$ hexo g == hexo generate #生成静态文件$ hexo s == hexo server #启动本地预览$ hexo d == hexo deploy #上传部署 5.2添加版权信息：1.在博客根目录下（和 source 同级），新建一个名为 scripts 的文件夹；2.在 scripts 文件夹内, 新建一个 AddTail.js 脚本文件，脚本具体内容详见下文；3.在博客根目录下，新建一个 tail.md 文件，里面写想要展示的版本说明内容;AddTail.js 脚本文件：1234567891011121314151617181920212223242526272829303132333435// Filename: AddTail.js// Author: Colin// Date: 2016/06/02// Based on the script by KUANG Qi: http://kuangqi.me/tricks/append-a-copyright-info-after-every-post/// Add a tail to every post from tail.md// Great for adding copyright infovar fs = require('fs');hexo.extend.filter.register('before_post_render', function(data)&#123; if(data.copyright == false) return data; // Add seperate line data.content += '\\n___\\n'; // Try to read tail.md try &#123; var file_content = fs.readFileSync('tail.md'); if(file_content &amp;&amp; data.content.length &gt; 50) &#123; data.content += file_content; &#125; &#125; catch (err) &#123; if (err.code !== 'ENOENT') throw err; // No process for ENOENT error &#125; // 添加具体文章链接, 不需要去掉即可 //var permalink = '\\n本文链接：' + data.permalink; //data.content += permalink; return data;&#125;);tail.md 文件：去Creative Commons根据自己需求，生成合适的许可，然后复制到tail.md 文件中； 参考博客：如何添加版权信息 5.3自动添加目录(已舍弃)： 20180105更新：舍弃本块功能；原因:更新主题后，发现主题自带目录，且比原来的更好； 修改主题的ejs文件 打开文件：themes/你的主题/layout/_partial/article.ejs 在这个文件中找到&lt;%- post.content %&gt;，并在这之前加入以下代码：1234567&lt;!-- Table of Contents --&gt;&lt;% if (!index &amp;&amp; post.toc)&#123; %&gt;&lt;div id=\"toc\" class=\"toc-article\"&gt;&lt;strong class=\"toc-title\"&gt;文章目录&lt;/strong&gt;&lt;%- toc(post.content, &#123;list_number: false&#125;) %&gt;&lt;/div&gt;&lt;% &#125; %&gt; 这里if语句中有两个条件，!index是为了不在首页的文章摘要中生成目录，post.toc确保了只在显式地标记了toc: true的文章中生成目录。若这两个条件满足，则创建一个目录的div。第五行表示不自动生成标号，不然加上自己的标号会有两个。 为需要的文章添加标记 5.4添加访问人数统计(已舍弃)： 20180105更新：舍弃本块功能；原因:底部信息太多了，访问统计在实际使用中感觉并没用，故舍弃； 安装脚本： 打开themes/你的主题/layout/_partial/footer.ejs添加下面脚本：12&lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 在需要的位置添加添加显示： 这里我用的Yilia的主题，不蒜子官方给的例子没有成功，这里自己需求是在底部中间显示统计量，于是在footer.ejs中间添加如下代码：123&lt;div class=\"footer-centre\"&gt; &amp;hearts; Total view my blog &lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt; times&lt;/div&gt; 这里我浏览量数据是+2的增加，还无解中。。（已解决）参考链接：不蒜子5.5脚本自动化：(已舍弃) 20180105更新：舍弃本块功能；原因:使用自己写的HexoBlogClient客户端，实际体验更好，其原理还是用的如下脚本。 每次发布文章大致分为清理静态文件、生成静态文件、启动本地预览或上传部署，连续这么多命令何不合成一个，于是在windows下，可新建几个批处理脚本:[make1.bat]12#生成最新本地预览hexo clean &amp; hexo g &amp;hexo s[make2.bat]12#发布生成最新博客hexo clean &amp; hexo g &amp; hexo d[make3.bat]123#发成最新博客并上传源码到Coding私有库，以便在其它电脑上编辑hexo clean &amp; hexo g &amp; hexo d &amp; git add -A &amp; git commit -m &quot;from make3&quot; &amp; \\git push origin master 在Cmder中，输入对应的makeN,即可自动完成一系列命令。 5.6提交搜索引擎（百度+谷歌+必应）：稳定测试已完成。在百度/谷歌/必应搜索“hceng”或者博客内容关键字都会有相关结果。直接在搜索引擎输入：1site:hceng.cn即可检测收录文章数量。 这块内容也不复杂，主要参考的这篇博客，感兴趣的去摸索下。 5.7添加评论模块：国内目前由不少的第三方评论系统，比如：多说、畅言、友言、网易云跟贴、disqus等。很多都陆续停止服务或者国情原因并不好用，设置也麻烦。2018年初升级主题的时候发现支持gitment了，一款基于GitHub Issues的评论系统。有如下特性： 在前端直接引入，不需要任何后端代码 使用 GitHub 账号登录 可以在页面进行查看、发送评论，点赞，@ 等操作 可以在 GitHub 进行编辑、删除评论等操作 有完整的 Markdown / GFM 支持 支持代码高亮 基于 GitHub 的通知 用Github登陆b格满满，还支持代码高亮，基于GitHub Issues也不容易挂掉，初步感觉很符合要求。设置步骤如下： a. 申请一个Github OAuth ApplicationGithub头像下拉菜单-&gt;Settings-&gt;左边Developer settings下的OAuth Application-&gt;Register a new application，填写相关信息： Application name, Homepage URL, Application description都可以随意填写，Authorization callback URL一定要写自己博客的的URL。 填写完上述信息后按Register application按钮，得到Client ID和Client Secret b. 修改配置文件然后修改主题路径下的_config.yml配置文件：123456#5、Gitmentgitment_owner: hceng gitment_repo: &apos;hceng.github.io&apos; gitment_oauth: client_id: &apos;xxxxxxxxxxxxxxxxxx&apos; client_secret: &apos;xxxxxxxxxxxxxxxxxxxxxxxxxxx&apos; gitment_owner为GitHub用户名；gitment_repo填写用来存放评论的GitHub仓库，由于评论是通过issues来存放的，建议这里直接填Github Pages个人博客所在的仓库；client_id为申请到的应用的Client ID；client_secret为申请到的应用的Client Secret； 然后重新清理，生成，上传(由于要求回调URL和当前地址一样，这里必须要上传后才能测试后续的操作，本地调试是不行的)。 c. 初始化评论系统Gitment的原理是为每一遍博文以其URL作为标识创建一个GitHub issue，对该篇博客的评论就是对这个issue的评论。因此，需要为每篇博文初始化一下评论系统，初始化后，就在Github上会创建相对应的issue。 前面重新上传后，打开博客，可以在博文页下面看到一个评论框，还有看到以下错误Error: Comments Not Initialized，提示该篇博文的评论系统还没初始化。 点击Login with GitHub后，使用自己的GitHub账号登录后，就可以在上面错误信息处看到一个Initialize Comments的按钮。 点击Initialize Comments按钮后，就可以开始对该篇博文开始评论了， 同时也可以在对应的GitHub仓库看到相应的issue。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Git日常使用小结","date":"2017-03-02T06:14:00.000Z","path":"2017/03/02/Git日常使用小结/","text":"本文主要是记录一些Git的配置和命令。关于代码托管，我目前主要使用两个： GitHub：主要用于托管公开代码和利用GitHub Pages搭建本博客； Coding：主要用于同步GitHub代码和托管私人代码；下面纪录下Git的安装、配置、使用。 1.安装GitWindows：git-for-windowsysGitMac OS:从AppStore安装Xcode,选择菜单“Xcode”-&gt;“Preferences”，找到“Downloads”，选择“Command Line Tools”，点“Install”。Linux:1$ sudo apt-get install git 2.创建本地仓库并上传2.1在本地创建仓库 第一次打开Git时,首先要在Git上设置username和email；12$ git config --global user.name &quot;hceng&quot; #与注册的账号邮箱一致；$ git config --global user.email &quot;huangcheng.job@foxmail.com&quot; 在命令行里(这里使用Cmder软件)先进入欲作为仓库的文件夹（如：E:/blog文件夹），然后初始化——创建本地仓库:12$ e: &amp; cd blog #进入E盘的blog文件夹；$ git init #初始化当前文件夹作为仓库（生成.git文件夹）； 这时生成一个”.git”目录，该目录是Git来跟踪管理版本，一般情况勿动；2.2添加文件到本地仓库12$ touch readme.txt #创建一个测试文件；$ git add readme.txt #将当前更改或者新增的文件加入到临时空间中； 注： add 命令只是把文件添加到一个临时空间里，需要执行第3 步的commit 命令才会正式提交到仓库中； 如果文件太多，可以使用以下命令一次性提交所有文件(.gitignore 文件指定的除外)；1$ git add -A 可以在当前目录下新建一个名为“.gitignore”的文件，它里面的内容用来表示某类/某个文件将不会被提交到仓库。 2.3提交文件到本地仓库执行以下命令，这会把临时空间的内容存入本地仓库，并添加注释：1$ git commit -m &quot;blog, add 1 files&quot; 可以使用以下命令查看记录：1$ git log --pretty=oneline得到类似信息，前面为版本号，后面为注释：112ewdqe2q... blog, add 1 files可以给某个版本号打上一个标签，命令如下：1$ git tag v1 12ew可以使用以下命令查看已有的标签：1$ git tag 2.4提交文件到GitHub/Coding第一次提交前，需要将本机密钥上传到GitHub/Coding；2.4.1.创建SSH Key：在用户主目录下，看看有没有.ssh 目录，如果有，再看看这个目录下有没有id_rsa 和id_rsa.pub 这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Git Bash，创建SSH Key，命令如下：1$ ssh-keygen -t rsa -C &quot;huangcheng.job@foxmail.com&quot;然后一路回车，使用默认值即可。这样在用户主目录里就会生成.ssh 目录，里面有id_rsa 和id_rsa.pub 两个文件，它们是SSH Key 的秘钥对。id_rsa 是私钥，不能泄露出去；id_rsa.pub 是公钥，可以放心地告诉任何人。 2.4.2.在GitHub 里添加SSH Key：电脑登陆GitHub,在自己账户的”Settings”-“SSH Key”中添加id_rsa.pub 文件的内容；2.4.3.创建一个仓库如:git_hexo,第一次上传需要指定GitHub/Coding仓库，如Coding的git_hexo：1$ git remote add origin https://git.coding.net/hceng/git_hexo.git然后根据提示输入账号、密码，最后执行以下指令提交至GitHub/Coding；12$ git push -u origin master$ git push origin --tags 2.5以后如果修改文件后再次提交12345$ git add –A # 添加修改文件到临时空间；$ git commit -m &quot;blog, git use&quot; # 添加本地仓库和添加备注；$ git tag v2 # 打标签；$ git push origin master # 上传到服务器的master；$ git push origin --tags # 上传标签到服务器； 3.Git 获取GitHub/Coding源码 执行以下命令，可以复制他人public代码，这称为“克隆”：1$ git clone https://github.com/hceng/hceng.github.io 当源码作者再次修改了源码后，可以进入对应目录，然后使用以下命令再次获得最新的：1$ git pull origin 查看信息纪录：1$ git log --pretty=oneline 查看标签：1$ git tag 获得指定版本的源码：123$ git checkout &lt;commit id&gt;或$ git checkout &lt;tag_name&gt; 4.分支管理4.1查看所有分支：1$ git branch --all # 本地主分支：master；远程主分支：origin/master； 4.2创建本地分支：12$ git branch bak # 创建本地分支；$ git branch # 查看本分支；&quot;*&quot;号表示当前所在分支； 4.3发布新分支：即：将本地新建的bak分支同步到远程服务器GitHub/Coding;12$ git push origin bak # 这样远程仓库也有一个bak分支了；$ git checkout bak # 切换到bak分支操作；第一种情况：bak分支开发完成，合并到主分支：12345$ git checkout master # 切换到主分支；$ git merge bak # 把bak分支的更改和master合并；$ git push # 提交主分支代码远程；$ git checkout bak # 切换到bak远程分支；$ git push # 提交bak分支到远程； 第二种情况：bak分支没开发完，推送保存，下次再开发：123$ git add -A # 添加修改文件到临时空间；$ git commit -m &quot;bak branch&quot; # 提交本地bak分支仓库；$ git push # 提交bak分支到远程； 4.4删除分支：12345# 删除远程bak分支，危险命令；$ git push origin :bak # 下面两条是删除本地分支;$ git checkout master # 切换到master分支$ git branch -d bak # 删除本地dev分支 参考： A successful Git branching model5.其它常用指令12345678910 $ git status #查看仓库状态; $ git diff XX #查看XX文件修改了那些内容;$ git log #查看历史记录;$ git reflog #查看历史记录(含回退纪录)；$ git reset –hard HEAD^ #回退到上一个版本; $ git reset –hard HEAD~ #回退到上一个版本;$ git reset –hard HEAD~100 #回退到100个版本;$ git checkout – XX #把XX文件在工作区的修改全部撤销； $ git rm XX #删除XX文件； 参考资料：韦东山Android系统视频使用手册20160303 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"SkillTree","date":"2017-03-01T00:00:00.000Z","path":"2017/03/01/SkillTree/","text":"My SkillTree. SkillTree 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]