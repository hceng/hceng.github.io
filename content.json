[{"title":"从0到Q——开发环境搭建","date":"2017-03-23T12:38:54.501Z","path":"2017/03/23/从0到Q——开发环境搭建/","text":"该系列主要是为驱动学习提供基石，从0到Qt。本文是该系列的第一篇:在Ubuntu-16.04LTS上搭建好开发环境. 所需材料： 虚拟机：VMware-workstation-full-12.0.0-2985596.exe Ubuntu系统镜像：ubuntu-16.04.1-desktop-amd64.iso 交叉工具链：arm-linux-gcc-4.4.3.tar.gz 安装脚本：install-devel-packages.sh或install-devel-packages-for-16.sh 目录： 安装虚拟机 安装、配置必要软件 安装交叉工具链 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://yoursite.com/tags/环境搭建/"}]},{"title":"Linux常用命令","date":"2017-03-11T19:05:36.506Z","path":"2017/03/12/Linux常用命令/","text":"本文主要汇总一些常用且不太熟练的Liunx命令，不定期更新。 1. tar作用：打包（拆包）/压缩（解压）文件； 语法：tar [主选项+辅选项] 文件或目录 主选项： c ：打包文件； x ：拆包文件； t ：列出包/压缩文件里有哪些文件。辅选项： z ：具有 gzip 属性；格式为xx.tar.gz或xx. tgz； j ：具有 bzip2 属性；格式为xx.tar.bz2； v ：显示压缩文件过程； f ：在其后必须是文件名； - -exclude xxx：打包除xxx文件之外的文件；示例：1234567$ tar cf test.tar test #打包test文件/文件夹为test.tar;$ tar xf test.tar #拆包test.tar；$ tar czf test.tar.gz test #压缩test文件/文件夹为test.tar.gz；$ tar xzf test.tar.gz #解压test.tar.gz；$ tar cjf test.bzip2 test #压缩test文件/文件夹为test.bzip2；$ tar xjf test.bzip2 #解压test.bzip2；$ tar cf test.tar --exclude test.txt test #打包test文件夹里除test.txt之外的为test.tar 2. grep作用：查找字符串； 语法：grep [选项] ‘搜寻字符串’ 文件名 选项： -c ：计算找到 ‘搜寻字符串’ 的次数; -i ：忽略大小写; -n ：顺便输出行号; -v ：反向选择，即显示出没有 ‘搜寻字符串’ 内容的那一行;示例：1$ grep -n &apos;test&apos; test.txt #搜索test.txt中含test的行，且显示对应行号； 3. find作用：选项较多，这里暂仅使用name选项查找文件； 语法：find 路径 -name “文件名”示例：1$ find -name &quot;test&quot; #在当前文件下找test文件； 4. ifconfig作用：网卡配置； 语法：ifconfig [网络设备] [参数]”示例：12345678#设置网卡1的地址 192.168.1.44，掩码为255.255.255.0（即默认）；$ ifconfig eth0 192.168.1.44 netmask 255.255.255.0#捆绑网卡1的第二个地址为 192.168.1.x$ ifconfig eth0:x 192.168.1.x#打开网卡1$ ifconfig eth0 up#关闭网卡1$ ifconfig eth0 down 5. mount作用：目前只用来挂载NFS； 语法：mount -t nfs 服务器ip:挂载目录 挂载到本地哪里”示例：12#把主机(192.168.1.44)的/work/hceng/nfs_rootfs挂载到本地/tmp目录下；$ mount -t nfs 192.168.1.44:/work/hceng/nfs_rootfs /tmp 6. 查看Linux版本信息示例：1234$ uname -a #显示电脑以及操作系统的相关信；$ cat /proc/version #正在运行的内核版本；$ cat /etc/issue #显示的是发行版本信息；$ lsb_release -a #列出所有版本信息； 7. 关闭防火墙示例：12$ ufw disable #关闭ubuntu的防火墙 ；$ ufw enable #开启防火墙； 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux基础/"}]},{"title":"Makefile小结","date":"2017-03-11T06:40:04.291Z","path":"2017/03/11/Makefile小结/","text":"本文主要是纪录一些遇到的Makefile知识。 Makefile以韦东山老师第一期裸板视频中的 第8课LCD实验的配套代码lcd_3.5_4.3 中的Makefile为例，该工程有两个Makefile,分别位于根目录和lib目录中：[根目录Makefile]123456789101112131415161718192021222324252627282930313233CC = arm-linux-gccLD = arm-linux-ldAR = arm-linux-arOBJCOPY = arm-linux-objcopyOBJDUMP = arm-linux-objdumpINCLUDEDIR := $(shell pwd)/includeCFLAGS := -Wall -O2CPPFLAGS := -nostdinc -I$(INCLUDEDIR)export CC LD AR OBJCOPY OBJDUMP INCLUDEDIR CFLAGS CPPFLAGSobjs := head.o init.o nand.o interrupt.o serial.o lcddrv.o/ framebuffer.o lcdlib.o main.o lib libc.alcd.bin: $(objs) $&#123;LD&#125; -Tlcd.lds -o lcd_elf $^ $&#123;OBJCOPY&#125; -O binary -S lcd_elf $@ $&#123;OBJDUMP&#125; -D -m arm lcd_elf &gt; lcd.dis.PHONY : lib/libc.alib/libc.a: cd lib; make; cd .. %.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;clean: make clean -C lib rm -f lcd.bin lcd_elf lcd.dis *.o 主Makefile总领全局的就这句:1lcd.bin: $(objs)要生成lcd.bin，依赖于objs列举的一堆文件：head.o init.o nand.o interrupt.o serial.o lcddrv.o framebuffer.o lcdlib.o main.o lib libc.a，所以要先找到这些文件，几个.o，还有一个.a。 .o目标文件怎么生成？%.o:%.c和%.o:%.S是生成规则，就是依赖于.c或.S文件，使用交叉编译命令生成。 .a目标文件怎么生成？.a是库文件，到lib子目录里去找，在子目录里用make命令生成。 注:链接：将多.o文件，或者.o文件和库文件链接成为可被操作系统执行的可执行程序（Linux环境下，可执行文件的格式为“ELF”格式）。链接器不检查函数所在的源文件，只检查所有.o文件中的定义的符号。将.o文件中使用的函数和其它.o或者库文件中的相关符号进行合并，对所有文件中的符号进行重新安排（重定位），并链接系统相关文件（程序启动文件等）最终生成可执行程序。链接过程使用GNU 的“ld”工具。静态库：又称为文档文件（Archive File）。它是多个.o文件的集合。Linux中静态库文件的后缀为“.a”。静态库中的各个成员（.o文件）没有特殊的存在格式，仅仅是一个.o文件的集合。使用“ar”工具维护和管理静态库。共享库：也是多个.o文件的集合，但是这些.o文件时有编译器按照一种特殊的方式生成（Linux中，共享库文件格式通常为“ELF”格式。共享库已经具备了可执行条件）。模块中各个成员的地址（变量引用和函数调用）都是相对地址。使用此共享库的程序在运行时，共享库被动态加载到内存并和主程序在内存中进行连接。多个可执行程序可共享库文件的代码段（多个程序可以共享的使用库中的某一个模块，共享代码，不共享数据）。另外共享库的成员对象可被执行（由libdl.so提供支持）。 下面进行分析： 第一至五行：12345CC = arm-linux-gccLD = arm-linux-ldAR = arm-linux-arOBJCOPY = arm-linux-objcopyOBJDUMP = arm-linux-objdump 作用：将右边工具链名赋值给左边变量，为了简化书写； 分析： arm-linux-gcc：编译.c或.s头的C文件或汇编程序； arm-linux-ld：连接器，把多个.o文件或库文件连接成一个可执行文件； arm-linux-ar：库管理器，把多个.o文件合并成一个.o文件或静态库文件（.a文件）； arm-linux-objcopy：转换可执行文件的格式； arm-linux-objdump：生成反汇编； 第七行：1INCLUDEDIR := $(shell pwd)/include 作用：将shell命令和include组成的路径立即赋值给左边变量，为了简化书写； 分析：Makefile中调用shell命令：$(shell 命令)； ‘ = ’与‘ := ’的区别注： - “ = ”：make会将整个Makefile展开后，再决定变量的值。也就是说，变量的值将会是整个,Makefile中最后被指定的值。看例子： 123x = fooy = $(x) barx = xyz 在上例中，y的值将会是 xyz bar ，而不是 foo bar 。- “ := ”表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。 123x := fooy := $(x) barx := xyz 在上例中，y的值将会是 foo bar ，而不是 xyz bar 了。 第八行：1CFLAGS := -Wall -O2 作用：将gcc的编译参数赋值给左边变量，为了简化书写； 分析：-Wall显示所有编译错误或警告；-O2优化选项，编译时使用2级优化 第九行：1CPPFLAGS := -nostdinc -I$(INCLUDEDIR) 作用：将gcc编译路径参数赋值给左边变量，为了简化书写； 分析：-nostdinc忽略系统库目录（这里我们自定义了printf等系统函数，不能再包含系统文件里的相关函数）；-I指定搜索路径； 第十一行：1export CC LD AR OBJCOPY OBJDUMP INCLUDEDIR CFLAGS CPPFLAGS 作用：将变量传递到下级Makefile，类似于宏； 分析：本文件中指的是生成lib/libc.a库文件时的Makefile； 第十三行：12objs := head.o init.o nand.o interrupt.o serial.o lcddrv.o/ framebuffer.o lcdlib.o main.o lib libc.a 作用：定义变量objs，包含了生成目标文件所需的文件，为了简化书写； 分析：一行代码写不完，使用/符号可继续在下行写； 第十六行：1lcd.bin: $(objs) 作用：定义生成目标lcd.bin，依赖于objs对象； 分析：执行这条命令时，先生成所有依赖文件，然后依次执行后面三条命令； 第十七行：1$&#123;LD&#125; -Tlcd.lds -o lcd_elf $^ 作用：根据链接脚本lcd.lds链接，输出目的文件lcd_elf,依赖全部文件； 分析：-T指定链接脚本；$^表示全部依赖文件； 第十八行：1$&#123;OBJCOPY&#125; -O binary -S lcd_elf $@ 作用：将lcd_elf文件转换成二进制文件； 分析：-O表示输出格式;-S表示不从源文件中复制重定位信息和符号信息到目标文件中；$@表示全部目标文件； 第十九行：1$&#123;OBJDUMP&#125; -D -m arm lcd_elf &gt; lcd.dis 作用：将lcd_elf文件反汇编为lcd.dis文件； 分析：-m后面跟的是cpu构架;&gt;表示将这个程序的反汇编程序写入到led.dis这个文件中,在终端中不显示出来； 第二十一行：1.PHONY : lib/libc.a 作用：.PHONY伪目标，不要管lib/libc.a文件是否存在，都执行后面的指令； 分析：通常为了避免伪目标和文件重名的这种情况，使用特殊的记“.PHONY”来显示地指明一个目标是“伪目标”； 第二十二、二十三行：12lib/libc.a: cd lib; make; cd .. 作用：执行lib文件夹的Makefile，从而生成libc.a； 分析：执行shell指令，进入lib目录，make，退出； 第二十五至二十九行：1234%.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt; 作用：依赖所有的.c和.S文件，生成所有的.o文件； 分析：%通配符；-c编译不链接;$@表示目标文件;$&lt;表示第一个依赖文件; 第三十一至三十三行：1234%.o:%.Sclean: make clean -C lib rm -f lcd.bin lcd_elf lcd.dis *.o 作用：清理所有生成文件； 分析：-C lib即清理包括lib文件夹下生成的文件; 下面是lib目录Makefile: [lib目录Makefile]123456789101112131415objs := div64.o lib1funcs.o ctype.o muldi3.o printf.o string.o/vsprintf.olibc.a: $(objs) $&#123;AR&#125; -r -o $@ $^ %.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;clean: rm -f libc.a *.o 第一、二行：12objs := div64.o lib1funcs.o ctype.o muldi3.o printf.o string.o/vsprintf.o 作用：定义变量objs，包含了生成目标文件所需的文件，为了简化书写； 分析：一行代码写不完，使用/符号可继续在下行写； 第四、五行：12libc.a: $(objs) $&#123;AR&#125; -r -o $@ $^ 作用：使用库管理器生成lib.a； 分析：$@表示目标文件;$^所有依赖文件； 第七至十一行：1234%.o:%.c $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt;%.o:%.S $&#123;CC&#125; $(CPPFLAGS) $(CFLAGS) -c -o $@ $&lt; 作用：依赖所有的.c和.S文件，生成所有的.o文件； 分析：%通配符；-c编译不链接;$@表示目标文件;$&lt;表示第一个依赖文件; 第十三、十四行：123%.o:%.Sclean: rm -f libc.a *.o 作用：清理所有生成文件； 分析：-f强制删除; 参考博文：sekon LCD实验学习笔记（一）：Makefile 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"Makefile","slug":"Makefile","permalink":"http://yoursite.com/tags/Makefile/"}]},{"title":"汇编指令小结","date":"2017-03-10T13:10:21.279Z","path":"2017/03/10/汇编指令小结/","text":"本文主要是纪录一些遇到的ARM汇编知识。 汇编代码以韦东山老师的 第7章nand flash实验配套代码13th_link_4096 中的start.S为例：[start.S]12345678910111213141516171819202122232425262728293031323334353637383940414243.globl _start_start:/* 硬件相关的设置 : 把外设的基地址告诉CPU*/ /* Peri port setup */ ldr r0, =0x70000000 orr r0, r0, #0x13 mcr p15,0,r0,c15,c2,4 @ 256M(0x70000000-0x7fffffff) /* 关看门狗 *//* 往WTCON(0x7E004000)写0 */ ldr r0, =0x7E004000 mov r1, #0 str r1, [r0]/* 重定位 */ adr r0, _start /* _start当前指令地址 */ ldr r1, =_start /* _start的编译地址 */ ldr r2, =bss_start cmp r0, r1 beq clean_bsscopy_loop: ldr r3, [r0], #4 str r3, [r1], #4 cmp r1, r2 bne copy_loop /* 清BSS段 */clean_bss: ldr r0, =bss_start ldr r1, =bss_end mov r2, #0clean_loop: str r2, [r0], #4 cmp r0, r1 bne clean_loop /* 设置栈 */ ldr sp, =8*1024 ldr pc, =main /* 重定位完后, 使用位置相关的指令跳转 */ bl mainhalt: b halt 第六行：1ldr r0, =0x70000000 格式：ldr&emsp;目的寄存器&emsp;&lt;存储器地址&gt; 作用：将 存储器地址 所指地址处连续的4个字节（1个字）的数据传送到目的寄存器中。 第七行：1orr r0, r0, #0x13 格式：orr&emsp;目的寄存器，&emsp;操作数 1，&emsp;操作数 2 作用：常用于设置操作数1 的某些位，在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中。操作数1 应是一个寄存器，操作数2 可以是一个寄存器、被移位的寄存器或一个立即数。 第八行：1mcr p15,0,r0,c15,c2,4 格式：mcr&emsp;协处理器编码，&emsp;协处理器操作码1，&emsp;源寄存器，&emsp;目的寄存器1，&emsp;目的寄存器2，&emsp;协处理器操作码2 作用：将ARM处理器寄存器中的数据传送到协处理器寄存器中,若协处理器不能成功完成操作，则产生未定义指令异常。其中协处理器操作码1 和协处理器操作码2 为协处理器将要执行的操作，源寄存器为ARM处理器的寄存器，目的寄存器1和目的寄存器2均为协处理器的寄存器。 第十四行：1str r1, [r0] 格式：str&emsp;源寄存器&emsp;&lt;存储器地址&gt; 作用：用于从源寄存器中将一个32位的字数据传送到存储器中。在ARM架构下, 数据从内存到CPU之间的移动只能通过ldr/str指令来完成。而mov只能在寄存器之间移动数据,或者把立即数移动到寄存器中,并且数据的长度不能超过8位。 第十七行：1adr r0, _start 格式：adr&emsp;目的寄存器&emsp;程序相对的表达式 作用：可将一个立即值与pc值相加，并将结果写入目标寄存器。adr可生成与位置无关的代码，因为地址相对于程序或寄存器。详见ARM指令adr。 第二十行：1cmp r0, r1 格式：cmp&emsp;操作数1，&emsp;操作数2 作用：用于把一个寄存器的内容和另一个寄存器的内容或立即数进行比较，同时更新CPSR中条件标志位的值。该指令进行一次减法运算，但不存储结果，只更改条件标志位。标志位表示的是操作数1与操作数2的关系(大、小、相等)，例如，当操作数1大于操作操作数2，则此后的有GT 后缀的指令将可以执行。 CPSR注： Z标志：是否为0；如比较指令产生相等的结果、计算结果为0； N标志：是否为负；如果指令的结果被认为是有符号数，而它的第31位为1，那就会被设置为1； C标志：是否有产生进位/借位，以及进行移位操作时作移出位使用； V标志：有符号数进行运算，结果是否有溢出。 第二十一行：1beq clean_bss 格式：beq&emsp;标签 作用：数据跳转指令，标志寄存器中Z标志位等于零时, 跳转到beq后标签处。 第二十六行：1bne copy_loop 格式：bne&emsp;标签 作用：数据跳转指令，标志寄存器中Z标志位不等于零时, 跳转到bne后标签处。 第四十一行：1bl main 格式：bl&emsp;子程序名 作用：b或bl指令引起处理器转移到子程序名处开始执行。两者的不同之处在于bl指令在转移到子程序执行之前，将其下一条指令的地址拷贝到R14（LR,链接寄存器）。由于bl指令保存了下条指令的地址，因此使用指令“mov pc, lr”即可实现子程序的返回。而b指令则无法实现子程序的返回，只能实现单纯的跳转。 ARM处理器控制程序执行方式注： 流水方式执行程序：PC的值是下一条指令的地址，即每执行一条指令PC都加一个字的偏移。 通过跳转指令来控制程序执行:b-跳转到指定的指令处执行;bl-跳转执行，保存子程序地址并返回;bx-跳转执行并切换到Thumb状态;blx-三种方式组合。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"驱动相关","slug":"驱动相关","permalink":"http://yoursite.com/tags/驱动相关/"},{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/tags/汇编/"}]},{"title":"GitHub+Hexo博客搭建及优化","date":"2017-03-06T07:17:58.000Z","path":"2017/03/06/GitHub+Hexo搭建及优化/","text":"本文主要是纪录本博客的搭建和优化。 为什么做独立博客？我想大概就是激励自己去持续学习和思考。 首先说下本博客搭建的大致流程:1.有一个GitHub账号，同时配置GitHub Pages；2.安装、配置Hexo；3.配置博客、Markdown写文章；4.绑定自己域名（可选）；5.优化日常操作（可选）； 1.Github PagesGithub Pages是GitHub提供的免费静态站点；创建Github Pages后，在里面存放网页源码，然后在对应网址就可看到对应网页效果；使用GitHub账号创建一个仓库，但是这个仓库是有规则的，其格式必须为：yourusername.github.io； 注： yourusername必须是自己的GitHub账号名； 类型只能选Public； 2.安装、配置HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。1、安装 Node.js;2、下载Cmder代替Windows自带cmd;3、安装 Git;4、添加本机密钥到GitHub;5、安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，在Git上设置username和email；其中3-5步在前一篇博文Git日常使用小结中已设置过了，无需再设置。6、安装 Hexo：使用 npm 安装 Hexo。1$ npm install -g hexo-cli至此，已经安装完Hexo,后续进行相关配置。7、在电脑上选一个盘，建个文件夹存放博客数据，例我的：E:\\blog；然后打开cmder，输入:12$ e: &amp; cd blog #进入所建文件夹$ hexo init blog #初始化blog成功初始化blog后将出现：1INFO Start blogging with Hexo!8、最后再生成静态网页，即可看到网页模板：12$ hexo generate # 启动本地服务器$ hexo server # 在浏览器输入 http://localhost:4000/就可以看见网页和模板了完成后，将会看到如下提示：12INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.此时，打开浏览器，输入http://localhost:4000/就可以看见默认的网页和模板了。 注:如果在执行 hexo deploy 后,出现 error deployer not found:github 的错误，执行： 12&gt; ￥ npm install hexo-deployer-git --save&gt; 3.配置博客、发表文章在blog目录下，用Sublime Text(使用它的原因是默认是UTF-8编码，中文不会乱码)打开_config.yml文件，修改参数信息； 注：在每个参数的”：”后都要加一个空格修改网站相关信息; 3.1修改网站相关信息：1234567# Sitetitle: 黄成的博客subtitle: Linux/Android驱动 description: 生命不息、折腾不止author: hcenglanguage: zh-CNtimezone: Asia/Shenzhen 3.2修改配置部署相关信息：123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: 'git@github.com:hceng/hceng.github.io.git' branch: master- type: git repo: 'git@git.coding.net:hceng/hceng.git' branch: coding-pages这里由于我同时提交到了GitHub和Coding,用于测试百度收录，所以有两个，写一个也没事。 3.3修改主题：为了让博客更加美观和符合自己需求，可以修改Hexo主题来满足自己需求。Hexo 安装主题的方式非常简单，只需要将主题文件放置于站点目录的 themes 目录下，然后修改下配置文件即可。Hexo 有两份主要的配置文件（_config.yml），一份位于站点根目录下，另一份位于主题目录下。为了描述方便，在以下说明中，将前者称为 站点配置文件，后者称为 主题配置文件。下载hexo-theme-yilia主题,解压放入themes文件夹下，如：E:\\blog\\blog\\themes，根据自己需求修改主题配置文件，最后再修改站点配置文件里的theme:1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-yilia在主题配置文件里，修改头像、颜色、标签等，都有相应的注释写得非常清楚，按需修改。 3.4发表文章：在Cmder中输入：12$ hexo new \"blog tags\"INFO Created: E:\\blog\\blog\\source\\_posts\\blog-tags.md根据提示得路径，即可找到新建得文件，该文件使用Markdown语法，下载MarkdownPad2进行编辑。先修改相关的文章信息：123456---title: blog tagstags: - 随笔---本文主要是总结blog预计的标签，并不定时更新。可修改标题、标签（本有日期的修改选项，但有日期就不能显示文章，怀疑是主题或者其它地方干扰了，文章日期就是文件创建日期）。然后简单说下Markdown语法： 3.1标题和引用 行首插入 1 到 6 个 # ，对应到标题 1 到 6 级标题： 123# 一级标题## 二级标题## 三标题 效果： 一级标题二级标题三标题 区块引用则使用 ‘&gt;’ 角括号来表示： 1&gt; 这是引用 效果： 这是引用 3.2列表和强调 列表分有序的1、2、3和无序的·：12- 列表1- 列表2 效果： 列表1 列表2 强调有加粗和斜体，用”*”来表示： 12**加粗***斜体* 效果：加粗斜体 3.3超链接和图片在方括号”[]”写要显示标，在小括号”()”写链接：1[hceng blog](http://hceng.cn/)效果：hceng blog在文章如果需要加入图片，先需要把图片传到床图网站，生成链接后插入使用，格式如下：1![](图片网址) 3.4加入代码Markdown支持插入代码，使用单引号”`“来标注,注意是英文输入法下，左上角那个按键：1`hello`效果：hello这种方式感觉不够醒目，而且不支持语法高亮，所以我一般使用Codeblock，语法见网站，效果如下：123456#include &lt;stdio.h&gt;int main(void)&#123; printf(\"hello,world!\"); return 0;&#125; 4.绑定自己域名（可选）完成以上步骤后，默认域名是GitHub提供的二级域名：yoursname.github.io,下面开始绑定自己的域名：4.1购买域名 推荐GoDaddy或万网； 我是在万网买的，首推买.com，其次.me、.top、.cn系列，根据自己喜好来，各有特色优缺点； 然后继续交实名认证、审核，还是比较快；4.2绑定域名 保证上述工作完成，域名可用； 修改DNS，分别修改为：f1g1ns1.dnspod.net和f1g1ns2.dnspod.net 本地站点目录里的source目录下添加一个CNAME文件，里面写上网址； 注:CNAME不要有任何后缀；网址不要写www或http：//,直接写hceng.cn这种； 注册DNSpod，然后添加域名，添加记录：参考红线部分填写，一个主机纪录是@，记录类型是CNAME，线路类型填默认（图片中是我测试百度抓取用的），记录值写对应的GitHub Pages的地址；另一个主机纪录填www，其它和上面的一样。 最后把本地的Hexo生成一下，再提交到Github pages上； 5.优化日常操作（可选）5.1hexo命令简写：12345$ hexo n “新文章” == hexo new “新文章” #新建文章$ hexo c == hexo clear #清理静态文件$ hexo g == hexo generate #生成静态文件$ hexo s == hexo server #启动本地预览$ hexo d == hexo deploy #上传部署 5.2添加版权信息：1.在博客根目录下（和 source 同级），新建一个名为 scripts 的文件夹；2.在 scripts 文件夹内, 新建一个 AddTail.js 脚本文件，脚本具体内容详见下文；3.在博客根目录下，新建一个 tail.md 文件，里面写想要展示的版本说明内容;AddTail.js 脚本文件：1234567891011121314151617181920212223242526272829303132333435// Filename: AddTail.js// Author: Colin// Date: 2016/06/02// Based on the script by KUANG Qi: http://kuangqi.me/tricks/append-a-copyright-info-after-every-post/// Add a tail to every post from tail.md// Great for adding copyright infovar fs = require('fs');hexo.extend.filter.register('before_post_render', function(data)&#123; if(data.copyright == false) return data; // Add seperate line data.content += '\\n___\\n'; // Try to read tail.md try &#123; var file_content = fs.readFileSync('tail.md'); if(file_content &amp;&amp; data.content.length &gt; 50) &#123; data.content += file_content; &#125; &#125; catch (err) &#123; if (err.code !== 'ENOENT') throw err; // No process for ENOENT error &#125; // 添加具体文章链接, 不需要去掉即可 //var permalink = '\\n本文链接：' + data.permalink; //data.content += permalink; return data;&#125;);tail.md 文件：去Creative Commons根据自己需求，生成合适的许可，然后复制到tail.md 文件中； 参考博客：如何添加版权信息 5.3脚本自动化：每次发布文章大致分为清理静态文件、生成静态文件、启动本地预览或上传部署，连续这么多命令何不合成一个，于是在windows下，可新建几个批处理脚本:[make1.bat]12#生成最新本地预览hexo clean &amp; hexo g &amp;hexo s [make1.bat]12#发布生成最新博客hexo clean &amp; hexo g &amp; hexo d [make1.bat]123#发生成最新博客并上传源码Coding到私有库，以便在其它电脑上编辑hexo clean &amp; hexo g &amp; hexo d &amp; git add -A &amp; git commit -m &quot;from make3&quot; &amp; \\git push origin master 在Cmder中，输入对应的maken,即可自动完成一系列命令。 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Git日常使用小结","date":"2017-03-01T19:15:17.000Z","path":"2017/03/02/Git日常使用小结/","text":"本文主要是纪录一些Git的配置和命令。关于代码托管，我目前主要使用两个： GitHub：主要用于托管公开代码和利用GitHub Pages搭建本博客； Coding：主要用于同步GitHub代码和托管私人代码；下面纪录下Git的安装、配置、使用。 1.安装GitWindows：git-for-windowsysGitMac OS:从AppStore安装Xcode,选择菜单“Xcode”-&gt;“Preferences”，找到“Downloads”，选择“Command Line Tools”，点“Install”。Linux:1$ sudo apt-get install git 2.创建本地仓库并上传2.1在本地创建仓库 第一次打开Git时,首先要在Git上设置username和email；12$ git config --global user.name &quot;hceng&quot; #与注册的账号邮箱一致；$ git config --global user.email &quot;huangcheng.job@foxmail.com&quot; 在命令行里(这里使用Cmder软件)先进入欲作为仓库的文件夹（如：E:/blog文件夹），然后初始化——创建本地仓库:12$ e: &amp; cd blog #进入E盘的blog文件夹；$ git init #初始化当前文件夹作为仓库（生成.git文件夹）； 这时生成一个”.git”目录，该目录是Git来跟踪管理版本，一般情况勿动；2.2添加文件到本地仓库12$ touch readme.txt #创建一个测试文件；$ git add readme.txt #将当前更改或者新增的文件加入到临时空间中； 注： add 命令只是把文件添加到一个临时空间里，需要执行第3 步的commit 命令才会正式提交到仓库中； 如果文件太多，可以使用以下命令一次性提交所有文件(.gitignore 文件指定的除外)；1$ git add -A 可以在当前目录下新建一个名为“.gitignore”的文件，它里面的内容用来表示某类/某个文件将不会被提交到仓库。 2.3提交文件到本地仓库执行以下命令，这会把临时空间的内容存入本地仓库，并添加注释：1$ git commit -m &quot;blog, add 1 files&quot; 可以使用以下命令查看记录：1$ git log --pretty=oneline得到类似信息，前面为版本号，后面为注释：112ewdqe2q... blog, add 1 files可以给某个版本号打上一个标签，命令如下：1$ git tag v1 12ew可以使用以下命令查看已有的标签：1$ git tag 2.4提交文件到GitHub/Coding第一次提交前，需要将本机密钥上传到GitHub/Coding；2.4.1.创建SSH Key：在用户主目录下，看看有没有.ssh 目录，如果有，再看看这个目录下有没有id_rsa 和id_rsa.pub 这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Git Bash，创建SSH Key，命令如下：1$ ssh-keygen -t rsa -C &quot;huangcheng.job@foxmail.com&quot;然后一路回车，使用默认值即可。这样在用户主目录里就会生成.ssh 目录，里面有id_rsa 和id_rsa.pub 两个文件，它们是SSH Key 的秘钥对。id_rsa 是私钥，不能泄露出去；id_rsa.pub 是公钥，可以放心地告诉任何人。 2.4.2.在GitHub 里添加SSH Key：电脑登陆GitHub,在自己账户的”Settings”-“SSH Key”中添加id_rsa.pub 文件的内容；2.4.3.创建一个仓库如:git_hexo,第一次上传需要指定GitHub/Coding仓库，如Coding的git_hexo：12$ git remote add origin https://git.coding.net/hceng/$ git_hexo.git然后根据提示输入账号、密码，最后执行以下指令提交至GitHub/Coding；12$ git push -u origin master$ git push origin --tags 2.5以后如果修改文件后再次提交12345$ git add –A # 添加修改文件到临时空间；$ git commit -m &quot;blog, git use&quot; # 添加本地仓库和添加备注；$ git tag v2 # 打标签；$ git push origin master # 上传到服务器的master；$ git push origin --tags # 上传标签到服务器； 3.Git 获取GitHub/Coding源码 执行以下命令，可以复制他人public代码，这称为“克隆”：1$ git clone https://github.com/hceng/hceng.github.io 当源码作者再次修改了源码后，可以进入对应目录，然后使用以下命令再次获得最新的：1$ git pull origin 查看信息纪录：1$ git log --pretty=oneline 查看标签：1$ git tag 获得指定版本的源码：123$ git checkout &lt;commit id&gt;或$ git checkout &lt;tag_name&gt; 4.分支管理4.1查看所有分支：1$ git branch --all # 本地主分支：master；远程主分支：origin/master；4.2创建本地分支：12$ git branch bak # 创建本地分支；$ git branch # 查看本分支；&quot;*&quot;号表示当前所在分支；4.3发布新分支：即：将本地新建的bak分支同步到远程服务器GitHub/Coding;12$ git push origin bak # 这样远程仓库也有一个bak分支了；$ git checkout bak # 切换到bak分支操作；第一种情况：bak分支开发完成，合并到主分支：12345$ git checkout master # 切换到主分支；$ git merge bak # 把bak分支的更改和master合并；$ git push # 提交主分支代码远程；$ git checkout bak # 切换到bak远程分支；$ git push # 提交bak分支到远程； 第二种情况：bak分支没开发完，推送保存，下次再开发：123$ git add -A # 添加修改文件到临时空间；$ git commit -m &quot;bak branch&quot; # 提交本地bak分支仓库；$ git push # 提交bak分支到远程；4.4删除分支：12345# 删除远程bak分支，危险命令；$ git push origin :bak # 下面两条是删除本地分支;$ git checkout master # 切换到master分支$ git branch -d bak # 删除本地dev分支参考： 5.其它常用指令12345678910 $ git status #查看仓库状态; $ git diff XX #查看XX文件修改了那些内容;$ git log #查看历史记录;$ git reflog #查看历史记录(含回退纪录)；$ git reset –hard HEAD^ #回退到上一个版本; $ git reset –hard HEAD~ #回退到上一个版本;$ git reset –hard HEAD~100 #回退到100个版本;$ git checkout – XX #把XX文件在工作区的修改全部撤销； $ git rm XX #删除XX文件； 参考资料：韦东山Android系统视频使用手册20160303 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"blog tags","date":"2017-03-01T04:31:04.299Z","path":"2017/03/01/tags/","text":"本文主要是总结blog预计的标签，并不定时更新。 驱动相关 Linux驱动 Android驱动 环境搭建 调试技巧 Linux基础 Makefile 汇编 裸机 STM32 硬件 PCB 设计 PS AE/PR PPT Git git hexo 本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自hceng’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]